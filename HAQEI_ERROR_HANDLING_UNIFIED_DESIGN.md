# HAQEI„Ç¢„Éä„É©„Ç§„Ç∂„Éº - „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Áµ±‰∏ÄÂº∑ÂåñË®≠Ë®àÊõ∏

## üìã Ë®≠Ë®àÊ¶ÇË¶Å

### „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÊÉÖÂ†±
- **‰ΩúÊàêÊó•**: 2025-08-05
- **„Éê„Éº„Ç∏„Éß„É≥**: v2.0.0 - Áµ±‰∏Ä„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
- **ÂØæË±°„Ç∑„Çπ„ÉÜ„É†**: HAQEI„Ç¢„Éä„É©„Ç§„Ç∂„ÉºÔºàÊòìÁµå„Éªbunenjin„ÉªTriple OSÔºâ
- **Ë®≠Ë®àÊñπÈáù**: HAQEIÂì≤Â≠¶Ê∫ñÊã†„ÄÅ„Ç∞„É¨„Éº„Çπ„Éï„É´„Éá„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„ÄÅÁµ±‰∏ÄÊÄß

### Ë®≠Ë®àÁõÆÊ®ô
1. **Áµ±‰∏ÄÊÄß**: ÂÖ®„Ç∑„Çπ„ÉÜ„É†Ê®™Êñ≠ÁöÑ„Å™‰∏ÄË≤´„Åó„Åü„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
2. **Âì≤Â≠¶Ê∫ñÊã†**: ÊòìÁµå„Éªbunenjin„ÉªTriple OSÂì≤Â≠¶„Å®„ÅÆÊï¥ÂêàÊÄß
3. **Âæ©ÊóßÂäõ**: „Ç∞„É¨„Éº„Çπ„Éï„É´„Éá„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Å´„Çà„ÇãÁ∂ôÁ∂öÈÅãÁî®
4. **„É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£**: Áõ¥ÊÑüÁöÑ„ÅßÂàÜ„Åã„Çä„ÇÑ„Åô„ÅÑ„Ç®„É©„Éº„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥
5. **Êã°ÂºµÊÄß**: Â∞ÜÊù•„ÅÆÊ©üËÉΩËøΩÂä†„Å´ÂØæÂøú„Åß„Åç„ÇãÊüîËªü„Å™Ë®≠Ë®à

---

## üèóÔ∏è 1. „Ç∑„Çπ„ÉÜ„É†„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ë®≠Ë®à

### 1.1 ÈöéÂ±§ÊßãÈÄ† (Layered Architecture)

```mermaid
graph TB
    subgraph "Presentation Layer"
        UI[User Interface Layer]
        Notify[Notification System]
        Recovery[Recovery Guidance]
    end
    
    subgraph "Business Logic Layer"
        EH[Unified Error Handler]
        Classifier[Error Classifier]
        Strategy[Recovery Strategy Manager]
    end
    
    subgraph "Integration Layer"
        Cache[Cache Manager Integration]
        HAQEI[HAQEI Philosophy Validator]
        Monitor[Performance Monitor]
    end
    
    subgraph "Infrastructure Layer"
        Log[Logging System]
        Storage[Persistent Storage]
        Analytics[Error Analytics]
    end
    
    UI --> EH
    Notify --> EH
    Recovery --> Strategy
    EH --> Classifier
    EH --> Strategy
    EH --> Cache
    EH --> HAQEI
    Strategy --> Monitor
    EH --> Log
    Log --> Storage
    Analytics --> Storage
```

### 1.2 „É¨„Ç§„É§„ÉºÂà•Ë≤¨ÂãôÂÆöÁæ©

#### **1.2.1 Presentation LayerÔºàË°®ÁèæÂ±§Ôºâ**
- **Ë≤¨Âãô**: „É¶„Éº„Ç∂„Éº„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„Åß„ÅÆ„Ç®„É©„ÉºË°®Á§∫„Å®Âæ©Êóß„Ç¨„Ç§„ÉÄ„É≥„Çπ
- **„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà**:
  - `ErrorDisplayManager`: „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË°®Á§∫Âà∂Âæ°
  - `NotificationSystem`: ÈùûÁ†¥Â£äÁöÑ„Å™ÈÄöÁü•Ë°®Á§∫
  - `RecoveryGuidanceUI`: „É¶„Éº„Ç∂„ÉºÂêë„ÅëÂæ©ÊóßÊâãÈ†ÜË°®Á§∫

#### **1.2.2 Business Logic LayerÔºà„Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØÂ±§Ôºâ**
- **Ë≤¨Âãô**: „Ç®„É©„ÉºÂàÜÈ°û„ÄÅÂá¶ÁêÜÊà¶Áï•Ê±∫ÂÆö„ÄÅÂæ©ÊóßÂá¶ÁêÜ„ÅÆÂÆüË°å
- **„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà**:
  - `UnifiedErrorHandler`: ‰∏≠Â§Æ„Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº
  - `ErrorClassifier`: „Ç®„É©„ÉºÁ®ÆÂà•Âà§ÂÆö„Ç®„É≥„Ç∏„É≥
  - `RecoveryStrategyManager`: Âæ©ÊóßÊà¶Áï•„ÅÆÁÆ°ÁêÜ„ÉªÂÆüË°å

#### **1.2.3 Integration LayerÔºàÁµ±ÂêàÂ±§Ôºâ**
- **Ë≤¨Âãô**: HAQEIÂõ∫Êúâ„Ç∑„Çπ„ÉÜ„É†„Å®„ÅÆÁµ±Âêà„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ
- **„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà**:
  - `HAQEIPhilosophyValidator`: Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„ÅÆÊ§úË®º
  - `CacheErrorHandler`: „Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†ÈÄ£Êê∫
  - `PerformanceErrorMonitor`: „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÈñ¢ÈÄ£„Ç®„É©„ÉºÁõ£Ë¶ñ

#### **1.2.4 Infrastructure LayerÔºàÂü∫Áõ§Â±§Ôºâ**
- **Ë≤¨Âãô**: „É≠„Ç∞Ë®òÈå≤„ÄÅÊ∞∏Á∂öÂåñ„ÄÅÂàÜÊûê„Éá„Éº„ÇøÂèéÈõÜ
- **„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà**:
  - `StructuredLogger`: ÊßãÈÄ†Âåñ„É≠„Ç∞Âá∫Âäõ
  - `ErrorAnalytics`: „Ç®„É©„ÉºÂàÜÊûê„ÉªÁµ±Ë®à
  - `PersistentErrorStorage`: „Ç®„É©„Éº„Éá„Éº„Çø„ÅÆÊ∞∏Á∂öÂåñ

### 1.3 „Ç®„É©„Éº‰ºùÊí≠„É°„Ç´„Éã„Ç∫„É†

```typescript
interface ErrorPropagation {
  source: ErrorSource;
  propagationPath: string[];
  context: ErrorContext;
  philosophyAlignment: PhilosophyCheck;
  recoveryAttempted: boolean;
  userNotified: boolean;
}

type ErrorSource = 
  | 'iching-engine'      // ÊòìÁµå„Ç®„É≥„Ç∏„É≥
  | 'bunenjin-logic'     // bunenjinÂì≤Â≠¶
  | 'triple-os'          // Triple OS
  | 'cache-system'       // „Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†
  | 'ui-interaction'     // UIÊìç‰Ωú
  | 'data-processing'    // „Éá„Éº„ÇøÂá¶ÁêÜ
  | 'network-operation'  // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÊìç‰Ωú
  | 'storage-operation'; // „Çπ„Éà„É¨„Éº„Ç∏Êìç‰Ωú
```

---

## üéØ 2. „Ç®„É©„ÉºÂàÜÈ°ûË®≠Ë®à

### 2.1 „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„ÉºÈöéÂ±§

#### **2.1.1 Critical LevelÔºàËá¥ÂëΩÁöÑÔºâ**
- **Impact**: „Ç∑„Çπ„ÉÜ„É†ÂÖ®‰Ωì„ÅÆÂÅúÊ≠¢„ÄÅ„Éá„Éº„ÇøÁ†¥Êêç„É™„Çπ„ÇØ
- **Examples**:
  - ÊòìÁµå„Ç®„É≥„Ç∏„É≥„ÅÆÂÆåÂÖ®ÂÅúÊ≠¢
  - „Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†„ÅÆÁ†¥Êêç
  - Triple OSÊï¥ÂêàÊÄß„ÅÆÂÆåÂÖ®Á†¥Á∂ª
- **Recovery**: Âç≥Â∫ß„Å´„Éï„Çß„Ç§„É´„Çª„Éº„Éï„É¢„Éº„Éâ„Å´ÁßªË°å

#### **2.1.2 High LevelÔºàÈ´òÔºâ**
- **Impact**: ‰∏ªË¶ÅÊ©üËÉΩ„ÅÆ‰∏ÄÈÉ®ÂÅúÊ≠¢„ÄÅÊ©üËÉΩÂà∂Èôê
- **Examples**:
  - Âç¶Ë®àÁÆó„Ç®„É≥„Ç∏„É≥„ÅÆ„Ç®„É©„Éº
  - bunenjinÂì≤Â≠¶„É≠„Ç∏„ÉÉ„ÇØ„ÅÆ‰∏çÊï¥Âêà
  - ÈáçË¶Å„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„ÅøÂ§±Êïó
- **Recovery**: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ„Å´„Çà„ÇãÁ∂ôÁ∂öÈÅãÁî®

#### **2.1.3 Medium LevelÔºà‰∏≠Ôºâ**
- **Impact**: ‰ªòÂä†Ê©üËÉΩ„ÅÆÂà∂Èôê„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ‰Ωé‰∏ã
- **Examples**:
  - ÈùûÈáçË¶Å„Ç≠„É£„ÉÉ„Ç∑„É•„ÅÆÂ§±Âäπ
  - ‰∏ÄÈÉ®UI„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆË°®Á§∫Áï∞Â∏∏
  - ÂàÜÊûêÁµêÊûú„ÅÆ‰∏ÄÈÉ®Ê¨†Êêç
- **Recovery**: Ê©üËÉΩÁ∏ÆÈÄÄ„É¢„Éº„Éâ„Åß„ÅÆÁ∂ôÁ∂ö

#### **2.1.4 Low LevelÔºà‰ΩéÔºâ**
- **Impact**: ËªΩÂæÆ„Å™‰∏çÂÖ∑Âêà„ÄÅ„É¶„Éº„Ç∂„Éº‰ΩìÈ®ì„Å∏„ÅÆÊúÄÂ∞èÂΩ±Èüø
- **Examples**:
  - ÈùûÈáçË¶Å„Å™„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Â§±Êïó
  - „É≠„Ç∞Âá∫Âäõ„ÅÆËªΩÂæÆ„Å™„Ç®„É©„Éº
  - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁµ±Ë®à„ÅÆ‰∏ÄÊôÇÁöÑÁï∞Â∏∏
- **Recovery**: „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„ÅÆËá™Âãï‰øÆÂæ©

### 2.2 „É¶„Éº„Ç∂„Éº„Ç®„É©„ÉºÂàÜÈ°û

#### **2.2.1 ÂÖ•Âäõ„Ç®„É©„Éº**
```typescript
interface InputError {
  type: 'validation' | 'format' | 'constraint';
  field: string;
  providedValue: any;
  expectedFormat: string;
  bunenjinGuidance: string; // bunenjinÂì≤Â≠¶„Å´„Çà„ÇãÊåáÂ∞é
}
```

#### **2.2.2 Êìç‰Ωú„Ç®„É©„Éº**
```typescript
interface OperationError {
  type: 'sequence' | 'permission' | 'state';
  operation: string;
  currentState: string;
  requiredState: string;
  tripleOSGuidance: string; // Triple OSË¶≥ÁÇπ„Åß„ÅÆÊåáÂ∞é
}
```

#### **2.2.3 Ë®≠ÂÆö„Ç®„É©„Éº**
```typescript
interface ConfigurationError {
  type: 'missing' | 'invalid' | 'conflicting';
  configKey: string;
  ichingWisdom: string; // ÊòìÁµå„ÅÆÊô∫ÊÖß„Å´„Çà„ÇãËß£Ê±∫ÊåáÂ∞é
}
```

### 2.3 Â§ñÈÉ®‰æùÂ≠ò„Ç®„É©„Éº

#### **2.3.1 „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº**
- **Connection Lost**: Êé•Á∂öÊñ≠„Å´„Çà„ÇãÊ©üËÉΩÂà∂Èôê
- **API Timeout**: Â§ñÈÉ®APIÂøúÁ≠îÈÅÖÂª∂
- **CORS Issues**: „Éñ„É©„Ç¶„Ç∂„Çª„Ç≠„É•„É™„ÉÜ„Ç£Âà∂Á¥Ñ

#### **2.3.2 „Çπ„Éà„É¨„Éº„Ç∏„Ç®„É©„Éº**
- **Quota Exceeded**: „Çπ„Éà„É¨„Éº„Ç∏ÂÆπÈáèË∂ÖÈÅé
- **Permission Denied**: „Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„Ç®„É©„Éº
- **Data Corruption**: „Éá„Éº„ÇøÊï¥ÂêàÊÄß„Ç®„É©„Éº

### 2.4 Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„Ç®„É©„Éº

#### **2.4.1 ÊòìÁµåÊï¥ÂêàÊÄß„Ç®„É©„Éº**
```typescript
interface IChingIntegrityError {
  hexagramId: number;
  violatedPrinciple: string;
  expectedBehavior: string;
  actualBehavior: string;
  sequenceLogicViolation: boolean;
}
```

#### **2.4.2 bunenjinÊï¥ÂêàÊÄß„Ç®„É©„Éº**
```typescript
interface BunenjinIntegrityError {
  personaConflict: string;
  contextMismatch: string;
  navigationInconsistency: string;
  philosophyViolation: string;
}
```

#### **2.4.3 Triple OSÊï¥ÂêàÊÄß„Ç®„É©„Éº**
```typescript
interface TripleOSIntegrityError {
  osLayerConflict: 'engine' | 'interface' | 'safe-mode';
  inconsistentState: string;
  osTransitionError: string;
  architectureViolation: string;
}
```

---

## üîÑ 3. „Ç®„É©„ÉºÂá¶ÁêÜ„Éï„É≠„ÉºË®≠Ë®à

### 3.1 Áµ±‰∏Ä„Ç®„É©„ÉºÂá¶ÁêÜ„Éë„Ç§„Éó„É©„Ç§„É≥

```mermaid
flowchart TD
    Start([Error Detected]) --> Capture[Error Capture & Context Collection]
    Capture --> Validate[Philosophy Alignment Validation]
    Validate --> Classify[Error Classification]
    Classify --> Strategy[Recovery Strategy Selection]
    Strategy --> Execute[Recovery Execution]
    Execute --> Monitor[Recovery Monitoring]
    Monitor --> Success{Recovery Successful?}
    Success -->|Yes| Notify[Success Notification]
    Success -->|No| Escalate[Error Escalation]
    Escalate --> Manual[Manual Recovery Options]
    Notify --> Log[Structured Logging]
    Manual --> Log
    Log --> Analytics[Error Analytics Update]
    Analytics --> End([Complete])
    
    subgraph "Philosophy Integration"
        Validate --> IChingCheck[ÊòìÁµåÂéüÁêÜ„ÉÅ„Çß„ÉÉ„ÇØ]
        Validate --> BunenjinCheck[bunenjinÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØ]
        Validate --> TripleOSCheck[Triple OSÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØ]
    end
```

### 3.2 ÂêÑÊÆµÈöé„ÅÆË©≥Á¥∞Ë®≠Ë®à

#### **3.2.1 Error DetectionÔºà„Ç®„É©„ÉºÊ§úÂá∫Ôºâ**
```typescript
class ErrorDetector {
  private detectionMethods = {
    globalError: this.setupGlobalErrorHandling,
    promiseRejection: this.setupUnhandledRejectionHandling,
    customError: this.setupCustomErrorTriggers,
    performanceError: this.setupPerformanceThresholdMonitoring,
    philosophyError: this.setupPhilosophyViolationDetection
  };

  setupGlobalErrorHandling(): void {
    window.addEventListener('error', (event) => {
      this.handleDetectedError({
        type: 'javascript-runtime',
        source: event.filename,
        message: event.message,
        stack: event.error?.stack,
        context: this.collectExecutionContext()
      });
    });
  }
}
```

#### **3.2.2 Error ClassificationÔºà„Ç®„É©„ÉºÂàÜÈ°ûÔºâ**
```typescript
class ErrorClassifier {
  classify(error: CapturedError): ClassifiedError {
    const classification = {
      category: this.determineCategory(error),
      severity: this.determineSeverity(error),
      source: this.determineSource(error),
      philosophyImpact: this.assessPhilosophyImpact(error),
      recoveryComplexity: this.assessRecoveryComplexity(error)
    };

    return this.enrichWithContext(error, classification);
  }

  private assessPhilosophyImpact(error: CapturedError): PhilosophyImpact {
    return {
      ichingViolation: this.checkIChingViolation(error),
      bunenjinInconsistency: this.checkBunenjinInconsistency(error),
      tripleOSDisruption: this.checkTripleOSDisruption(error)
    };
  }
}
```

#### **3.2.3 Recovery Strategy SelectionÔºàÂæ©ÊóßÊà¶Áï•ÈÅ∏ÊäûÔºâ**
```typescript
class RecoveryStrategyManager {
  private strategies = new Map<ErrorPattern, RecoveryStrategy>([
    ['iching-calculation-error', new IChingFallbackStrategy()],
    ['bunenjin-navigation-error', new BunenjinGuidanceStrategy()],
    ['triple-os-state-error', new TripleOSResetStrategy()],
    ['cache-corruption-error', new CacheRecoveryStrategy()],
    ['network-failure-error', new OfflineModeStrategy()]
  ]);

  async selectStrategy(classifiedError: ClassifiedError): Promise<RecoveryStrategy> {
    const primaryStrategy = this.strategies.get(classifiedError.pattern);
    
    if (!primaryStrategy || !(await primaryStrategy.canHandle(classifiedError))) {
      return this.selectFallbackStrategy(classifiedError);
    }

    return primaryStrategy;
  }
}
```

#### **3.2.4 Recovery ExecutionÔºàÂæ©ÊóßÂÆüË°åÔºâ**
```typescript
abstract class RecoveryStrategy {
  abstract async execute(error: ClassifiedError): Promise<RecoveryResult>;
  abstract async rollback(error: ClassifiedError): Promise<void>;
  abstract getExpectedDuration(): number;
  abstract getPhilosophyGuidance(): string;
}

class IChingFallbackStrategy extends RecoveryStrategy {
  async execute(error: ClassifiedError): Promise<RecoveryResult> {
    // 1. ÊòìÁµåÂü∫Êú¨„Éá„Éº„Çø„ÅÆÁ¢∫Ë™ç
    const basicDataAvailable = await this.checkBasicIChingData();
    
    // 2. „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂç¶„Éá„Éº„Çø„ÅÆÁîüÊàê
    const fallbackHexagrams = await this.generateFallbackHexagrams();
    
    // 3. Â∫èÂç¶‰ºù„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÁ∞°ÊòìÂÆüË£Ö
    const sequenceLogic = await this.implementBasicSequenceLogic();

    return {
      success: true,
      message: 'ÊòìÁµå„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ„Å´„Çà„ÇäÁ∂ôÁ∂öÈÅãÁî®‰∏≠„Åß„Åô',
      philosophyGuidance: 'Â§âÂåñ„ÅÆÂéüÁêÜ„Å´Âæì„ÅÑ„ÄÅÁèæÂú®„ÅÆÁä∂Ê≥Å„ÇíÂèó„ÅëÂÖ•„Çå„Å§„Å§ÂâçÈÄ≤„Åó„Åæ„Åô',
      functionalityLevel: 'reduced',
      estimatedRecoveryTime: 300000 // 5ÂàÜ
    };
  }
}
```

### 3.3 ‰æãÂ§ñÂá¶ÁêÜ„Éë„Çø„Éº„É≥

#### **3.3.1 Try-Catch Enhancement Pattern**
```typescript
async function withPhilosophyAwareErrorHandling<T>(
  operation: () => Promise<T>,
  context: PhilosophyContext
): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    const philosophyGuidance = await generatePhilosophyGuidance(error, context);
    const enrichedError = new PhilosophyAwareError(error.message, {
      originalError: error,
      philosophyGuidance,
      context,
      suggestedActions: await generateSuggestedActions(error, context)
    });
    
    throw enrichedError;
  }
}
```

#### **3.3.2 Circuit Breaker PatternÔºàÊòìÁµåÁâàÔºâ**
```typescript
class IChingCircuitBreaker {
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private failureCount = 0;
  private lastFailureTime = 0;
  private readonly threshold = 5;
  private readonly timeout = 60000; // 1ÂàÜ

  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open - ÊòìÁµå„ÅÆÊïô„Åà„Å´Âæì„ÅÑ„ÄÅÊôÇ„ÇíÂæÖ„Å°„Åæ„Åô');
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess(): void {
    this.failureCount = 0;
    this.state = 'closed';
  }

  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.threshold) {
      this.state = 'open';
    }
  }
}
```

---

## üé® 4. UI/UXË®≠Ë®à

### 4.1 „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏Ë®≠Ë®àÂéüÂâá

#### **4.1.1 HAQEIÂì≤Â≠¶„Å´Âü∫„Å•„Åè„É°„ÉÉ„Çª„Éº„Ç∏„É≥„Ç∞**
```typescript
interface HAQEIErrorMessage {
  technical: string;           // ÊäÄË°ìÁöÑË™¨Êòé
  philosophical: string;       // Âì≤Â≠¶ÁöÑËß£Èáà
  guidance: string;           // ÂÖ∑‰ΩìÁöÑÊåáÂ∞é
  metaphor: string;           // ÊòìÁµå„É°„Çø„Éï„Ç°„Éº
  bunenjinPerspective: string; // bunenjinË¶≥ÁÇπ
  tripleOSContext: string;    // Triple OSÊñáËÑà
}

const messageTemplates = {
  'cache-error': {
    technical: '„Ç≠„É£„ÉÉ„Ç∑„É•„Ç∑„Çπ„ÉÜ„É†„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü',
    philosophical: 'Ë®òÊÜ∂„Å®ÁèæÂú®„ÅÆË™øÂíå„Åå‰π±„Çå„Å¶„ÅÑ„Åæ„Åô',
    guidance: '„Éá„Éº„Çø„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶Êñ∞„Åó„ÅÑÊµÅ„Çå„Çí‰Ωú„Çä„Åæ„Åó„Çá„ÅÜ',
    metaphor: 'È¢®Èõ∑ÁõäÔºà42Áï™Ôºâ- Êêç„Åó„Å¶Áõä„ÇíÂæó„ÇãÊôÇ„Åß„Åô',
    bunenjinPerspective: 'ÁèæÂú®„ÅÆÁä∂Ê≥Å„Å´ÈÅ©Âøú„Åó„ÅüÊñ∞„Åó„ÅÑÂàÜ‰∫∫„ÅßÂØæÂøú„Åó„Åæ„Åô',
    tripleOSContext: 'Safe Mode OS„ÅåÂÆâÂÖ®„Å™Âæ©Êóß„ÇíÊîØÊè¥„Åó„Åæ„Åô'
  }
};
```

#### **4.1.2 ÊÆµÈöéÁöÑÊÉÖÂ†±ÈñãÁ§∫**
```typescript
interface ErrorDisplay {
  level1: SimpleMessage;     // ‰∏ÄËà¨„É¶„Éº„Ç∂„ÉºÂêë„Åë
  level2: DetailedMessage;   // Ë©≥Á¥∞„ÇíÁü•„Çä„Åü„ÅÑ„É¶„Éº„Ç∂„ÉºÂêë„Åë
  level3: TechnicalMessage;  // ÈñãÁô∫ËÄÖ„Éª‰∏äÁ¥öËÄÖÂêë„Åë
  level4: PhilosophyDeep;    // HAQEIÂì≤Â≠¶Ê∑±Â±§Ëß£Êûê
}
```

### 4.2 ÈÄöÁü•„Ç∑„Çπ„ÉÜ„É†Ë®≠Ë®à

#### **4.2.1 ÈùûÁ†¥Â£äÁöÑÈÄöÁü•ÔºàToast SystemÔºâ**
```typescript
class HAQEINotificationSystem {
  showPhilosophyGuidedNotification(error: ClassifiedError): void {
    const notification = {
      type: this.mapSeverityToNotificationType(error.severity),
      title: this.generatePhilosophicalTitle(error),
      message: this.generateUserFriendlyMessage(error),
      actions: this.generateContextualActions(error),
      metaphor: this.generateIChingMetaphor(error),
      duration: this.calculateDisplayDuration(error.severity),
      dismissible: true,
      persistent: error.severity === 'critical'
    };

    this.displayNotification(notification);
  }
}
```

#### **4.2.2 „Éó„É≠„Ç∞„É¨„ÉÉ„Ç∑„Éñ„Éá„Ç£„Çπ„ÇØ„É≠„Éº„Ç∏„É£„Éº**
```typescript
class ProgressiveErrorDisclosure {
  displayError(error: ClassifiedError): void {
    // „É¨„Éô„É´1: Âü∫Êú¨„É°„ÉÉ„Çª„Éº„Ç∏
    this.showBasicMessage(error);

    // „É¨„Éô„É´2: Ë©≥Á¥∞ÊÉÖÂ†±Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
    this.addDetailToggle(() => this.showDetailedInfo(error));

    // „É¨„Éô„É´3: ÊäÄË°ìÊÉÖÂ†±ÔºàÈñãÁô∫ËÄÖÂêë„ÅëÔºâ
    this.addTechnicalToggle(() => this.showTechnicalInfo(error));

    // „É¨„Éô„É´4: Âì≤Â≠¶ÁöÑËß£ÈáàÔºàHAQEIÂ∞ÇÈñÄÔºâ
    this.addPhilosophyToggle(() => this.showPhilosophyAnalysis(error));
  }
}
```

### 4.3 Âæ©ÊóßÊìç‰Ωú„Ç¨„Ç§„ÉÄ„É≥„Çπ

#### **4.3.1 „Çπ„ÉÜ„ÉÉ„Éó„Éê„Ç§„Çπ„ÉÜ„ÉÉ„Éó„Ç¨„Ç§„Éâ**
```typescript
class RecoveryGuidanceUI {
  displayRecoverySteps(strategy: RecoveryStrategy): void {
    const steps = strategy.getRecoverySteps();
    const guidanceUI = this.createStepByStepInterface(steps);

    guidanceUI.onStepComplete = (stepIndex) => {
      this.markStepComplete(stepIndex);
      this.updateProgressIndicator(stepIndex, steps.length);
      this.showPhilosophicalEncouragement(stepIndex);
    };

    guidanceUI.onAllStepsComplete = () => {
      this.showCompletionCelebration();
      this.offerPreventionTips();
    };
  }

  private showPhilosophicalEncouragement(stepIndex: number): void {
    const encouragements = [
      'ÊòìÁµå64Áï™„ÄåÁÅ´Ê∞¥Êú™Ê∏à„Äç- „Åæ„Å†ÂÆåÊàê„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åã„Çâ„Åì„ÅùÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô',
      'bunenjinÂì≤Â≠¶ - „Åì„ÅÆÂõ∞Èõ£„ÇÇÊñ∞„Åó„ÅÑÂàÜ‰∫∫„ÇíÁô∫Ë¶ã„Åô„ÇãÊ©ü‰ºö„Åß„Åô',
      'Triple OS - Interface OS„ÅåÊñ∞„Åó„ÅÑË™øÂíå„ÇíË¶ã„Å§„Åë„Å¶„ÅÑ„Åæ„Åô'
    ];

    this.showMotivationalMessage(encouragements[stepIndex % 3]);
  }
}
```

#### **4.2.2 Ëá™ÂãïÂæ©ÊóßÈÄ≤ÊçóË°®Á§∫**
```typescript
class AutoRecoveryProgress {
  displayProgress(strategy: RecoveryStrategy): void {
    const progressBar = this.createProgressBar({
      title: `${strategy.name} „Å´„Çà„ÇãËá™ÂãïÂæ©Êóß‰∏≠...`,
      subtitle: strategy.getPhilosophyGuidance(),
      estimatedDuration: strategy.getExpectedDuration(),
      showPhilosophyQuotes: true
    });

    strategy.onProgress = (percent, currentStep) => {
      progressBar.updateProgress(percent);
      progressBar.updateStep(currentStep);
      progressBar.showRandomPhilosophyQuote();
    };
  }
}
```

---

## ‚öôÔ∏è 5. ÊäÄË°ìË®≠Ë®à

### 5.1 UnifiedErrorHandler „ÇØ„É©„ÇπÊã°Âºµ

```typescript
class UnifiedErrorHandler {
  private errorClassifier: ErrorClassifier;
  private recoveryManager: RecoveryStrategyManager;
  private philosophyValidator: PhilosophyValidator;
  private analyticsCollector: ErrorAnalyticsCollector;
  private cacheManager: CacheManager;
  private performanceMonitor: PerformanceMonitor;

  constructor(options: ErrorHandlerOptions) {
    this.initializeComponents(options);
    this.setupGlobalHandlers();
    this.initializePhilosophyIntegration();
  }

  async handleError(error: Error, context: ErrorContext): Promise<ErrorHandlingResult> {
    const startTime = performance.now();
    
    try {
      // 1. Error Capture & Enrichment
      const capturedError = await this.captureError(error, context);

      // 2. Philosophy Alignment Check
      const philosophyCheck = await this.philosophyValidator.validate(capturedError);

      // 3. Error Classification
      const classifiedError = await this.errorClassifier.classify(capturedError, philosophyCheck);

      // 4. Recovery Strategy Selection
      const strategy = await this.recoveryManager.selectStrategy(classifiedError);

      // 5. Recovery Execution
      const recoveryResult = await this.executeRecovery(strategy, classifiedError);

      // 6. Analytics & Logging
      await this.recordErrorHandling(classifiedError, recoveryResult, performance.now() - startTime);

      return recoveryResult;

    } catch (handlingError) {
      // Fallback to basic error handling
      return this.executeBasicFallback(error, handlingError);
    }
  }

  private async executeRecovery(
    strategy: RecoveryStrategy, 
    error: ClassifiedError
  ): Promise<ErrorHandlingResult> {
    const recoveryTimeout = strategy.getExpectedDuration() * 1.5; // 150% buffer

    return Promise.race([
      strategy.execute(error),
      this.createRecoveryTimeout(recoveryTimeout, strategy)
    ]);
  }
}
```

### 5.2 Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†Ë®≠Ë®à

#### **5.2.1 „É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ**
```typescript
class ErrorMonitoringSystem {
  private metricsCollector: MetricsCollector;
  private alertManager: AlertManager;
  private dashboardUpdater: DashboardUpdater;

  startMonitoring(): void {
    // Error rate monitoring
    this.monitorErrorRate();
    
    // Philosophy violation monitoring
    this.monitorPhilosophyViolations();
    
    // Recovery success rate monitoring
    this.monitorRecoverySuccessRate();
    
    // Performance impact monitoring
    this.monitorPerformanceImpact();
  }

  private monitorErrorRate(): void {
    setInterval(() => {
      const errorRate = this.calculateErrorRate();
      
      if (errorRate > this.thresholds.warning) {
        this.alertManager.sendAlert({
          level: errorRate > this.thresholds.critical ? 'critical' : 'warning',
          message: `Error rate elevated: ${errorRate}/min`,
          philosophyGuidance: this.generatePhilosophyGuidance(errorRate),
          suggestedActions: this.generateSuggestedActions(errorRate)
        });
      }
    }, 60000); // Every minute
  }
}
```

#### **5.2.2 ‰∫àÊ∏¨ÁöÑÁõ£Ë¶ñ**
```typescript
class PredictiveErrorMonitoring {
  private mlModel: ErrorPredictionModel;
  private patternDetector: PatternDetector;

  async predictPotentialErrors(): Promise<ErrorPrediction[]> {
    const currentMetrics = await this.gatherCurrentMetrics();
    const historicalPatterns = await this.analyzeHistoricalPatterns();
    
    const predictions = await this.mlModel.predict(currentMetrics, historicalPatterns);
    
    return predictions.map(prediction => ({
      ...prediction,
      philosophyInterpretation: this.interpretFromPhilosophyPerspective(prediction),
      preventiveActions: this.generatePreventiveActions(prediction)
    }));
  }
}
```

### 5.3 „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁµ±Âêà

#### **5.3.1 „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ**
```typescript
class PerformanceOptimizedErrorHandler {
  private executionCache = new Map<string, CachedRecoveryResult>();
  private asyncQueue = new AsyncQueue();
  private workerPool = new WorkerPool();

  async handleErrorWithOptimization(error: Error, context: ErrorContext): Promise<ErrorHandlingResult> {
    // 1. Quick cache check for similar errors
    const cacheKey = this.generateErrorCacheKey(error, context);
    const cachedResult = this.executionCache.get(cacheKey);
    
    if (cachedResult && this.isCacheValid(cachedResult)) {
      return this.applyCachedRecovery(cachedResult, error);
    }

    // 2. Parallel processing for non-blocking operations
    const parallelTasks = [
      this.classifyErrorAsync(error, context),
      this.gatherContextAsync(context),
      this.checkPhilosophyAlignmentAsync(error)
    ];

    const [classification, enrichedContext, philosophyCheck] = await Promise.all(parallelTasks);

    // 3. Web Worker for heavy computation
    const strategy = await this.workerPool.execute('selectStrategy', {
      classification,
      enrichedContext,
      philosophyCheck
    });

    // 4. Execute recovery with performance monitoring
    return this.executeWithPerformanceTracking(strategy, error, context);
  }
}
```

### 5.4 „ÉÜ„Çπ„ÉàÂèØËÉΩÊÄßË®≠Ë®à

#### **5.4.1 Dependency Injection Container**
```typescript
class ErrorHandlingContainer {
  private dependencies = new Map<string, any>();

  register<T>(key: string, factory: () => T): void {
    this.dependencies.set(key, factory);
  }

  resolve<T>(key: string): T {
    const factory = this.dependencies.get(key);
    if (!factory) {
      throw new Error(`Dependency not found: ${key}`);
    }
    return factory();
  }

  // Test-specific registration
  registerMock<T>(key: string, mock: T): void {
    this.dependencies.set(key, () => mock);
  }
}

// Usage in tests
const container = new ErrorHandlingContainer();
container.registerMock('ErrorClassifier', mockErrorClassifier);
container.registerMock('RecoveryStrategyManager', mockRecoveryManager);
```

#### **5.4.2 Test Scenarios Generator**
```typescript
class ErrorTestScenarioGenerator {
  generateIChingErrorScenarios(): ErrorTestCase[] {
    return [
      {
        name: 'Hexagram calculation failure',
        error: new Error('Invalid hexagram binary'),
        context: { operation: 'hexagram-calculation', hexagramId: 23 },
        expectedClassification: 'iching-calculation-error',
        expectedRecoveryStrategy: 'IChingFallbackStrategy',
        philosophyExpectation: 'Should maintain I Ching integrity'
      },
      // ... more scenarios
    ];
  }

  generateBunenjinErrorScenarios(): ErrorTestCase[] {
    return [
      {
        name: 'Persona navigation conflict',
        error: new Error('Conflicting persona states'),
        context: { operation: 'persona-transition', fromPersona: 'A', toPersona: 'B' },
        expectedClassification: 'bunenjin-navigation-error',
        expectedRecoveryStrategy: 'BunenjinGuidanceStrategy',
        philosophyExpectation: 'Should provide persona guidance'
      }
    ];
  }
}
```

---

## üìä 6. APIË®≠Ë®à‰ªïÊßò

### 6.1 Core Error Handling API

```typescript
interface UnifiedErrorHandlerAPI {
  // Primary error handling
  handleError(error: Error, context?: ErrorContext): Promise<ErrorHandlingResult>;
  
  // Error classification
  classifyError(error: Error, context?: ErrorContext): Promise<ClassifiedError>;
  
  // Recovery management
  getAvailableRecoveryStrategies(error: ClassifiedError): Promise<RecoveryStrategy[]>;
  executeRecovery(strategy: RecoveryStrategy, error: ClassifiedError): Promise<RecoveryResult>;
  
  // Philosophy integration
  validatePhilosophyAlignment(error: Error, context?: ErrorContext): Promise<PhilosophyCheck>;
  getPhilosophyGuidance(error: ClassifiedError): Promise<PhilosophyGuidance>;
  
  // Monitoring and analytics
  getErrorStatistics(timeRange?: TimeRange): Promise<ErrorStatistics>;
  getRecoveryMetrics(timeRange?: TimeRange): Promise<RecoveryMetrics>;
  
  // Configuration
  updateConfiguration(config: Partial<ErrorHandlerConfig>): Promise<void>;
  getConfiguration(): Promise<ErrorHandlerConfig>;
}
```

### 6.2 Philosophy-Specific APIs

```typescript
interface IChingErrorAPI {
  validateHexagramIntegrity(hexagramId: number, context: any): Promise<IntegrityCheck>;
  generateHexagramBasedGuidance(error: ClassifiedError): Promise<HexagramGuidance>;
  checkSequenceLogicViolation(operation: string, context: any): Promise<SequenceCheck>;
}

interface BunenjinErrorAPI {
  validatePersonaConsistency(personas: PersonaState[]): Promise<ConsistencyCheck>;
  generatePersonaGuidance(error: ClassifiedError): Promise<PersonaGuidance>;
  suggestPersonaTransition(currentState: PersonaState, error: ClassifiedError): Promise<PersonaTransition>;
}

interface TripleOSErrorAPI {
  validateOSLayerIntegrity(layer: OSLayer, state: any): Promise<LayerIntegrityCheck>;
  generateOSTransitionGuidance(error: ClassifiedError): Promise<OSTransitionGuidance>;
  checkArchitectureViolation(operation: string, context: any): Promise<ArchitectureCheck>;
}
```

### 6.3 Event-Driven API

```typescript
interface ErrorEventAPI {
  // Event subscription
  onError(callback: (event: ErrorEvent) => void): UnsubscribeFunction;
  onRecoveryStart(callback: (event: RecoveryStartEvent) => void): UnsubscribeFunction;
  onRecoveryComplete(callback: (event: RecoveryCompleteEvent) => void): UnsubscribeFunction;
  onPhilosophyViolation(callback: (event: PhilosophyViolationEvent) => void): UnsubscribeFunction;
  
  // Event emission
  emitError(error: Error, context?: ErrorContext): void;
  emitRecoveryStart(strategy: RecoveryStrategy, error: ClassifiedError): void;
  emitRecoveryComplete(result: RecoveryResult): void;
  emitPhilosophyViolation(violation: PhilosophyViolation): void;
}
```

---

## üß™ 7. „ÉÜ„Çπ„ÉàË®≠Ë®à

### 7.1 „ÉÜ„Çπ„ÉàÊà¶Áï•

#### **7.1.1 „ÉÜ„Çπ„Éà„Éî„É©„Éü„ÉÉ„Éâ**
```
     /\
    /  \        E2E Tests (10%)
   /____\       - Full system error scenarios
  /      \      - Philosophy integration tests
 /        \     - User journey error handling
/__________\    
            \   Integration Tests (20%)
             \  - Component interaction tests
              \ - Recovery strategy tests
               \- Philosophy validation tests
                \________________
                                \
                                 \ Unit Tests (70%)
                                  \- Individual class tests
                                   \- Error classification tests
                                    \- Recovery strategy unit tests
```

#### **7.1.2 „ÉÜ„Çπ„Éà„Ç´„ÉÜ„Ç¥„É™**
```typescript
interface TestSuite {
  unit: {
    errorClassification: ClassificationTestSuite;
    recoveryStrategies: RecoveryStrategyTestSuite;
    philosophyValidation: PhilosophyValidationTestSuite;
  };
  
  integration: {
    errorPropagation: PropagationTestSuite;
    recoveryExecution: RecoveryExecutionTestSuite;
    philosophyIntegration: PhilosophyIntegrationTestSuite;
  };
  
  e2e: {
    userErrorJourneys: UserJourneyTestSuite;
    systemRecovery: SystemRecoveryTestSuite;
    philosophyAlignment: PhilosophyAlignmentTestSuite;
  };
  
  performance: {
    errorHandlingSpeed: PerformanceTestSuite;
    memoryUsage: MemoryTestSuite;
    concurrentErrors: ConcurrencyTestSuite;
  };
}
```

### 7.2 „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥

#### **7.2.1 Philosophy-Driven Test Cases**
```typescript
describe('I Ching Error Handling', () => {
  test('should maintain hexagram sequence logic during error recovery', async () => {
    // Arrange
    const hexagramError = new Error('Hexagram calculation failed');
    const context = { hexagramId: 23, operation: 'sequence-calculation' };
    
    // Act
    const result = await errorHandler.handleError(hexagramError, context);
    
    // Assert
    expect(result.philosophyAlignment.ichingIntegrity).toBe(true);
    expect(result.recoveryStrategy.name).toBe('IChingSequenceRecovery');
    expect(result.guidance).toContain('sequence logic');
  });

  test('should provide appropriate I Ching metaphor for technical errors', async () => {
    // Test that technical errors receive meaningful I Ching metaphors
  });
});

describe('Bunenjin Error Handling', () => {
  test('should guide persona transition during navigation errors', async () => {
    // Test persona-aware error recovery
  });
});

describe('Triple OS Error Handling', () => {
  test('should maintain OS layer integrity during errors', async () => {
    // Test OS layer consistency during error states
  });
});
```

#### **7.2.2 Property-Based Testing**
```typescript
import { property, integer, string, arbitrary } from 'fast-check';

describe('Error Handler Properties', () => {
  property('should always return a valid error result', 
    arbitrary(Error), 
    arbitrary(ErrorContext),
    async (error, context) => {
      const result = await errorHandler.handleError(error, context);
      
      expect(result).toHaveProperty('success');
      expect(result).toHaveProperty('message');
      expect(result).toHaveProperty('philosophyGuidance');
      expect(result.philosophyGuidance).toBeTruthy();
    }
  );

  property('should never violate philosophy principles during recovery',
    arbitrary(ClassifiedError),
    async (error) => {
      const result = await errorHandler.executeRecovery(error);
      
      expect(result.philosophyAlignment.violated).toBe(false);
    }
  );
});
```

### 7.3 Mock Strategies

#### **7.3.1 Philosophy Component Mocks**
```typescript
class MockIChingEngine {
  async calculateHexagram(input: any): Promise<HexagramResult> {
    // Predictable hexagram calculation for testing
    return {
      hexagramId: (input.hash % 64) + 1,
      binary: '101010',
      name: 'Test Hexagram',
      interpretation: 'Test interpretation'
    };
  }

  async validateSequenceLogic(hexagramId: number): Promise<boolean> {
    // Always pass sequence validation in tests
    return true;
  }
}

class MockBunenjinNavigator {
  async transitionPersona(from: string, to: string): Promise<PersonaTransition> {
    return {
      success: true,
      newPersona: to,
      guidance: 'Mock persona transition guidance'
    };
  }
}
```

### 7.4 Performance Testing

#### **7.4.1 Error Handling Performance Benchmarks**
```typescript
describe('Error Handling Performance', () => {
  test('should handle errors within performance thresholds', async () => {
    const startTime = performance.now();
    
    await errorHandler.handleError(new Error('Test error'));
    
    const duration = performance.now() - startTime;
    expect(duration).toBeLessThan(100); // 100ms threshold
  });

  test('should handle concurrent errors efficiently', async () => {
    const errors = Array(100).fill(null).map(() => new Error('Concurrent error'));
    
    const startTime = performance.now();
    await Promise.all(errors.map(error => errorHandler.handleError(error)));
    const duration = performance.now() - startTime;
    
    expect(duration).toBeLessThan(1000); // 1 second for 100 concurrent errors
  });
});
```

---

## üìñ 8. ÂÆüË£Ö„Ç¨„Ç§„Éâ„É©„Ç§„É≥

### 8.1 ÈñãÁô∫„Éï„Çß„Éº„Ç∫

#### **Phase 1: Core Infrastructure (Week 1-2)**
1. `UnifiedErrorHandler` Âü∫Áõ§ÂÆüË£Ö
2. `ErrorClassifier` Âü∫Êú¨ÂàÜÈ°û„É≠„Ç∏„ÉÉ„ÇØ
3. `PhilosophyValidator` Âü∫Êú¨„ÉÅ„Çß„ÉÉ„ÇØÊ©üËÉΩ
4. Âü∫Êú¨ÁöÑ„Å™„ÉÜ„Çπ„Éà„Çπ„Ç§„Éº„Éà

#### **Phase 2: Recovery Systems (Week 3-4)**
1. `RecoveryStrategyManager` ÂÆüË£Ö
2. ÂêÑÁ®Æ `RecoveryStrategy` „ÇØ„É©„ÇπÂÆüË£Ö
3. Ëá™ÂãïÂæ©Êóß„Ç∑„Çπ„ÉÜ„É†
4. Âæ©Êóß„ÉÜ„Çπ„Éà„ÅÆÂÆüË£Ö

#### **Phase 3: Philosophy Integration (Week 5-6)**
1. ÊòìÁµåÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØÂº∑Âåñ
2. bunenjin „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥Áµ±Âêà
3. Triple OS „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Áµ±Âêà
4. Âì≤Â≠¶ÁöÑ„Ç¨„Ç§„ÉÄ„É≥„ÇπÁîüÊàê

#### **Phase 4: UI/UX Implementation (Week 7-8)**
1. „Ç®„É©„ÉºË°®Á§∫„Ç∑„Çπ„ÉÜ„É†
2. ÈÄöÁü•„Ç∑„Çπ„ÉÜ„É†
3. Âæ©Êóß„Ç¨„Ç§„ÉÄ„É≥„ÇπUI
4. „É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà

#### **Phase 5: Monitoring & Analytics (Week 9-10)**
1. „É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†
2. „Ç®„É©„ÉºÂàÜÊûê„ÉªÁµ±Ë®à
3. ‰∫àÊ∏¨ÁöÑÁõ£Ë¶ñ
4. „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÂÆüË£Ö

### 8.2 ÂìÅË≥™‰øùË®º

#### **8.2.1 „Ç≥„Éº„ÉâÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà**
- [ ] TypeScript strict mode Ê∫ñÊã†
- [ ] 100% „Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπÂÆüË£Ö
- [ ] 90%+ „ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏
- [ ] ESLint/Prettier Ê∫ñÊã†
- [ ] JSDocÂÆåÂÖ®Ë®òËø∞
- [ ] Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØ

#### **8.2.2 Philosophy Alignment Checklist**
- [ ] ÊòìÁµåÂéüÁêÜ„Å®„ÅÆÊï¥ÂêàÊÄßÁ¢∫Ë™ç
- [ ] bunenjinÂì≤Â≠¶„Å®„ÅÆ‰∏ÄË≤´ÊÄß
- [ ] Triple OS „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ê∫ñÊã†
- [ ] Â∫èÂç¶‰ºùË´ñÁêÜ„ÅÆÁ∂≠ÊåÅ
- [ ] Â§âÂåñ„ÅÆÂéüÁêÜ„Å∏„ÅÆÂØæÂøú

### 8.3 „Éá„Éó„É≠„Ç§„É°„É≥„ÉàÊà¶Áï•

#### **8.3.1 ÊÆµÈöéÁöÑ„É≠„Éº„É´„Ç¢„Ç¶„Éà**
```typescript
interface DeploymentPhase {
  phase: 'canary' | 'blue-green' | 'full';
  userPercentage: number;
  features: string[];
  rollbackCriteria: RollbackCriteria;
  philosophyValidation: boolean;
}

const deploymentPlan: DeploymentPhase[] = [
  {
    phase: 'canary',
    userPercentage: 5,
    features: ['basic-error-handling'],
    rollbackCriteria: { errorRateIncrease: 10 },
    philosophyValidation: true
  },
  {
    phase: 'blue-green',
    userPercentage: 50,
    features: ['basic-error-handling', 'recovery-strategies'],
    rollbackCriteria: { errorRateIncrease: 5 },
    philosophyValidation: true
  },
  {
    phase: 'full',
    userPercentage: 100,
    features: ['all'],
    rollbackCriteria: { errorRateIncrease: 2 },
    philosophyValidation: true
  }
];
```

### 8.4 ÈÅãÁî®„Ç¨„Ç§„Éâ„É©„Ç§„É≥

#### **8.4.1 Áõ£Ë¶ñ„Ç¢„É©„Éº„ÉàË®≠ÂÆö**
```yaml
alerts:
  error_rate_high:
    condition: error_rate > 5 per minute
    severity: warning
    notification: team_slack
    philosophy_check: true
  
  recovery_failure_rate_high:
    condition: recovery_failure_rate > 20%
    severity: critical
    notification: on_call
    auto_escalation: true
  
  philosophy_violation:
    condition: philosophy_violation_detected
    severity: high
    notification: philosophy_team
    manual_review_required: true
```

#### **8.4.2 „É°„É≥„ÉÜ„Éä„É≥„ÇπÊâãÈ†Ü**
1. **ÂÆöÊúü„É°„É≥„ÉÜ„Éä„É≥„Çπ (ÈÄ±Ê¨°)**
   - „Ç®„É©„Éº„É≠„Ç∞„ÅÆÂàÜÊûê„Å®„Éë„Çø„Éº„É≥Ë≠òÂà•
   - Âæ©ÊóßÊà¶Áï•„ÅÆÂäπÊûúÊ∏¨ÂÆö
   - Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„ÅÆÁ¢∫Ë™ç

2. **Á∑äÊÄ•„É°„É≥„ÉÜ„Éä„É≥„Çπ**
   - Ëá¥ÂëΩÁöÑ„Ç®„É©„Éº„ÅÆÂç≥Â∫ßÂØæÂøú
   - Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄßÈÅïÂèç„ÅÆ‰øÆÊ≠£
   - „É¶„Éº„Ç∂„ÉºÂΩ±Èüø„ÅÆÊúÄÂ∞èÂåñ

---

## üìã 9. ÁßªË°åË®àÁîª

### 9.1 Êó¢Â≠ò„Ç∑„Çπ„ÉÜ„É†„Åã„Çâ„ÅÆÁßªË°å

#### **9.1.1 ÁßªË°åÊà¶Áï•**
```typescript
class MigrationStrategy {
  async migrateToUnifiedErrorHandling(): Promise<MigrationResult> {
    const phases = [
      this.auditExistingErrorHandlers,
      this.createCompatibilityLayer,
      this.gradualMigration,
      this.validateMigration,
      this.cleanupLegacyCode
    ];

    const results = [];
    for (const phase of phases) {
      const result = await phase();
      results.push(result);
      
      if (!result.success) {
        await this.rollbackToSafeState();
        throw new Error(`Migration failed at phase: ${phase.name}`);
      }
    }

    return { success: true, phases: results };
  }
}
```

#### **9.1.2 Êó¢Â≠ò„Ç®„É©„Éº„Éè„É≥„Éâ„É©„Éº„Å®„ÅÆ‰∫íÊèõÊÄß**
```typescript
class LegacyErrorHandlerAdapter {
  constructor(
    private unifiedHandler: UnifiedErrorHandler,
    private legacyHandler: any
  ) {}

  // Adapter pattern for gradual migration
  async handleError(error: Error, context?: any): Promise<any> {
    try {
      // Try new unified handler first
      return await this.unifiedHandler.handleError(error, context);
    } catch (newHandlerError) {
      // Fallback to legacy handler
      console.warn('Falling back to legacy error handler:', newHandlerError);
      return this.legacyHandler.handleError(error, context);
    }
  }
}
```

### 9.2 „Éá„Éº„ÇøÁßªË°å

#### **9.2.1 „Ç®„É©„Éº„É≠„Ç∞„ÅÆÁßªË°å**
```typescript
class ErrorLogMigration {
  async migrateLegacyErrorLogs(): Promise<void> {
    const legacyLogs = await this.fetchLegacyErrorLogs();
    
    for (const legacyLog of legacyLogs) {
      const modernized = await this.modernizeErrorLog(legacyLog);
      const philosophyEnhanced = await this.enhanceWithPhilosophy(modernized);
      
      await this.storeModernizedLog(philosophyEnhanced);
    }
  }

  private async enhanceWithPhilosophy(errorLog: ErrorLog): Promise<EnhancedErrorLog> {
    const philosophyGuidance = await this.generateRetroactivePhilosophyGuidance(errorLog);
    
    return {
      ...errorLog,
      philosophyGuidance,
      ichingInterpretation: await this.generateIChingInterpretation(errorLog),
      bunenjinPerspective: await this.generateBunenjinPerspective(errorLog),
      tripleOSContext: await this.generateTripleOSContext(errorLog)
    };
  }
}
```

---

## üéØ 10. ÊàêÂäüÊåáÊ®ô

### 10.1 ÊäÄË°ìÊåáÊ®ô

#### **10.1.1 „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊåáÊ®ô**
- **„Ç®„É©„ÉºÂá¶ÁêÜÊôÇÈñì**: Âπ≥Âùá < 100ms, 95%ile < 500ms
- **Âæ©ÊóßÊàêÂäüÁéá**: > 85%
- **„Ç®„É©„ÉºÁô∫ÁîüÁéáÊ∏õÂ∞ë**: ÊúàÊ¨° 5% ÊîπÂñÑ
- **„É°„É¢„É™‰ΩøÁî®Èáè**: „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Áî® < 10MB

#### **10.1.2 ÂìÅË≥™ÊåáÊ®ô**
- **„ÉÜ„Çπ„Éà„Ç´„Éê„É¨„ÉÉ„Ç∏**: > 90%
- **„Ç≥„Éº„ÉâÂìÅË≥™„Çπ„Ç≥„Ç¢**: > 8.5/10
- **„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Çπ„Ç≥„Ç¢**: > 9.0/10
- **„Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£„Çπ„Ç≥„Ç¢**: > 95%

### 10.2 „É¶„Éº„Ç∂„Éº‰ΩìÈ®ìÊåáÊ®ô

#### **10.2.1 „É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£ÊåáÊ®ô**
- **„Ç®„É©„ÉºÁêÜËß£Â∫¶**: „É¶„Éº„Ç∂„ÉºË™øÊüª > 85%
- **Âæ©ÊóßÊìç‰ΩúÊàêÂäüÁéá**: > 80%
- **„É¶„Éº„Ç∂„ÉºÊ∫ÄË∂≥Â∫¶**: > 4.2/5.0
- **„Çµ„Éù„Éº„ÉàÂïè„ÅÑÂêà„Çè„ÅõÊ∏õÂ∞ë**: ÊúàÊ¨° 15% Ê∏õÂ∞ë

#### **10.2.2 Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄßÊåáÊ®ô**
- **Âì≤Â≠¶ÁöÑ„Ç¨„Ç§„ÉÄ„É≥„ÇπÊúâÁî®ÊÄß**: > 80%
- **ÊòìÁµå„É°„Çø„Éï„Ç°„ÉºÁêÜËß£Â∫¶**: > 70%
- **bunenjin ÈÅ©Áî®ÊÄß**: > 75%
- **Triple OS ‰ΩìÊÑü**: > 85%

---

## üìö 11. ÂèÇËÄÉË≥áÊñô„Éª‰ªòÈå≤

### 11.1 ÊäÄË°ì„É™„Éï„Ç°„É¨„É≥„Çπ

#### **11.1.1 Error Handling Patterns**
- Circuit Breaker Pattern
- Retry Pattern with Exponential Backoff
- Bulkhead Pattern
- Timeout Pattern
- Graceful Degradation Pattern

#### **11.1.2 Philosophy Integration References**
- ÊòìÁµå64Âç¶„Ç∑„Çπ„ÉÜ„É†ÂÆåÂÖ®„Éû„ÉÉ„Éó
- bunenjinÂì≤Â≠¶ÂÆüË£Ö„Ç¨„Ç§„Éâ
- Triple OS „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£‰ªïÊßò
- Â∫èÂç¶‰ºùË´ñÁêÜÂÆüË£Ö„Éë„Çø„Éº„É≥

### 11.2 ÂÆüË£Ö„ÉÜ„É≥„Éó„É¨„Éº„Éà

#### **11.2.1 Error Handler Template**
```typescript
// Template for custom error handlers
abstract class CustomErrorHandler extends BaseErrorHandler {
  abstract getHandledErrorTypes(): string[];
  abstract async handle(error: ClassifiedError): Promise<RecoveryResult>;
  abstract getPhilosophyGuidance(error: ClassifiedError): string;
  
  // Common implementation
  async execute(error: Error, context: ErrorContext): Promise<ErrorHandlingResult> {
    const classified = await this.classify(error, context);
    const philosophyCheck = await this.validatePhilosophy(classified);
    const recovery = await this.handle(classified);
    
    return this.formatResult(recovery, philosophyCheck);
  }
}
```

### 11.3 Ë®≠ÂÆö„Çµ„É≥„Éó„É´

#### **11.3.1 Production Configuration**
```json
{
  "errorHandling": {
    "logLevel": "info",
    "enablePhilosophyValidation": true,
    "recoveryTimeout": 30000,
    "maxRetryAttempts": 3,
    "enableAnalytics": true,
    "philosophySettings": {
      "ichingValidation": true,
      "bunenjinGuidance": true,
      "tripleOSIntegration": true
    },
    "notifications": {
      "enableToast": true,
      "enableModal": true,
      "enableSound": false,
      "philosophy": true
    }
  }
}
```

---

## üìû „Çµ„Éù„Éº„Éà„ÉªÂïè„ÅÑÂêà„Çè„Åõ

### ÈñãÁô∫„ÉÅ„Éº„É†ÈÄ£Áµ°ÂÖà
- **„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞ÊãÖÂΩì**: error-handling-team@haqei.com
- **Âì≤Â≠¶Áµ±ÂêàÊãÖÂΩì**: philosophy-team@haqei.com
- **UI/UXÊãÖÂΩì**: ux-team@haqei.com

### „Éâ„Ç≠„É•„É°„É≥„ÉàÊõ¥Êñ∞Â±•Ê≠¥
- **v2.0.0** (2025-08-05): Áµ±‰∏Ä„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞Ë®≠Ë®àÊõ∏ÂàùÁâà
- **v2.0.1** (‰∫àÂÆö): ÂÆüË£Ö„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÂèçÊò†Áâà

---

*„Åì„ÅÆË®≠Ë®àÊõ∏„ÅØ HAQEI„Ç¢„Éä„É©„Ç§„Ç∂„Éº„ÅÆÂì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„Çí‰øù„Å°„Å™„Åå„Çâ„ÄÅ‰∏ñÁïåÊúÄÈ´òÊ∞¥Ê∫ñ„ÅÆ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÅÆÂÆüÁèæ„ÇíÁõÆÊåá„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊòìÁµå„ÅÆÂ§âÂåñ„ÅÆÂéüÁêÜ„ÄÅbunenjinÂì≤Â≠¶„ÅÆÊüîËªüÊÄß„ÄÅTriple OS „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÅÆÂÆâÂÆöÊÄß„ÇíÁµ±Âêà„Åó„Åü„ÄÅÈù©Êñ∞ÁöÑ„Å™„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„Åß„Åô„ÄÇ*