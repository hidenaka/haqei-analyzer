<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ 16åã‚Šå•é¡Œãƒ‡ãƒãƒƒã‚°</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #f5f5f5; }
        .debug-section { background: white; margin: 10px 0; padding: 15px; border-radius: 5px; border-left: 4px solid #007acc; }
        .error { border-left-color: #dc3545; }
        .warning { border-left-color: #ffc107; }
        .success { border-left-color: #28a745; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 3px; overflow-x: auto; }
        .test-result { margin: 5px 0; padding: 8px; border-radius: 3px; }
        .pass { background: #d4edda; color: #155724; }
        .fail { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ 16åã‚Šå•é¡Œãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«</h1>
    
    <div class="debug-section">
        <h2>ğŸ” å•é¡Œã®è¨ºæ–­</h2>
        <div id="diagnosis-results"></div>
    </div>

    <div class="debug-section">
        <h2>ğŸ“Š ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèª</h2>
        <div id="data-integrity-results"></div>
    </div>

    <div class="debug-section">
        <h2>ğŸ§ª è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯æ¤œè¨¼</h2>
        <div id="calculation-test-results"></div>
    </div>

    <div class="debug-section">
        <h2>ğŸ’¡ æ¨å¥¨ä¿®æ­£æ–¹æ³•</h2>
        <div id="fix-recommendations"></div>
    </div>

    <!-- ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ -->
    <script src="js/shared/data/vectors.js"></script>
    <script src="js/shared/data/questions.js"></script>
    <script src="js/shared/core/DataManager.js"></script>
    <script src="js/os-analyzer/core/Calculator.js"></script>
    <script src="js/os-analyzer/core/Engine.js"></script>

    <script>
        console.log('ğŸ”¬ ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ 16åã‚Šå•é¡Œãƒ‡ãƒãƒƒã‚°é–‹å§‹');

        class BiasDebugger {
            constructor() {
                this.results = {
                    diagnosis: [],
                    dataIntegrity: [],
                    calculationTests: [],
                    recommendations: []
                };
            }

            async runDiagnosis() {
                console.log('ğŸ” è¨ºæ–­é–‹å§‹...');
                
                try {
                    // 1. DataManagerã®å•é¡Œç¢ºèª
                    this.checkDataManagerIssues();
                    
                    // 2. ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèª
                    this.checkDataIntegrity();
                    
                    // 3. è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯æ¤œè¨¼
                    this.testCalculationLogic();
                    
                    // 4. ä¿®æ­£æ–¹æ³•ã®ææ¡ˆ
                    this.generateRecommendations();
                    
                    // çµæœè¡¨ç¤º
                    this.displayResults();
                    
                } catch (error) {
                    console.error('âŒ è¨ºæ–­ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:', error);
                    this.results.diagnosis.push({
                        type: 'error',
                        message: `è¨ºæ–­ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: ${error.message}`
                    });
                    this.displayResults();
                }
            }

            checkDataManagerIssues() {
                console.log('ğŸ” DataManagerå•é¡Œç¢ºèªä¸­...');
                
                try {
                    const dataManager = new DataManager();
                    
                    // getVectorsDataãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ç¢ºèª
                    const hasGetVectorsData = typeof dataManager.getVectorsData === 'function';
                    const hasGetVectors = typeof dataManager.getVectors === 'function';
                    
                    this.results.diagnosis.push({
                        type: hasGetVectorsData ? 'pass' : 'fail',
                        message: `getVectorsData()ãƒ¡ã‚½ãƒƒãƒ‰å­˜åœ¨ç¢ºèª: ${hasGetVectorsData ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}`
                    });
                    
                    this.results.diagnosis.push({
                        type: hasGetVectors ? 'pass' : 'fail',
                        message: `getVectors()ãƒ¡ã‚½ãƒƒãƒ‰å­˜åœ¨ç¢ºèª: ${hasGetVectors ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}`
                    });
                    
                    if (!hasGetVectorsData && hasGetVectors) {
                        this.results.diagnosis.push({
                            type: 'warning',
                            message: 'å•é¡Œç™ºè¦‹: getVectorsData()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚Engine.jsãŒgetVectorsData()ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ãŒã€DataManagerã«ã¯getVectors()ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚'
                        });
                    }
                    
                } catch (error) {
                    this.results.diagnosis.push({
                        type: 'error',
                        message: `DataManagerç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`
                    });
                }
            }

            checkDataIntegrity() {
                console.log('ğŸ“Š ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèªä¸­...');
                
                try {
                    // H64_8D_VECTORSã®ç¢ºèª
                    if (typeof H64_8D_VECTORS !== 'undefined') {
                        const vectorCount = Object.keys(H64_8D_VECTORS).length;
                        this.results.dataIntegrity.push({
                            type: vectorCount === 64 ? 'pass' : 'fail',
                            message: `ãƒ™ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿æ•°: ${vectorCount}/64`
                        });
                        
                        // ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ 16ã®ç‰¹åˆ¥ãƒã‚§ãƒƒã‚¯
                        const hex16 = H64_8D_VECTORS[16];
                        if (hex16) {
                            const hex16Values = Object.values(hex16);
                            const isAllSame = hex16Values.every(v => v === hex16Values[0]);
                            const vectorSum = hex16Values.reduce((sum, val) => sum + val, 0);
                            
                            this.results.dataIntegrity.push({
                                type: isAllSame ? 'warning' : 'pass',
                                message: `ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ 16ãƒ™ã‚¯ã‚¿ãƒ¼: ${JSON.stringify(hex16)} (åˆè¨ˆ: ${vectorSum}, å…¨ã¦åŒå€¤: ${isAllSame ? 'ã¯ã„' : 'ã„ã„ãˆ'})`
                            });
                        } else {
                            this.results.dataIntegrity.push({
                                type: 'fail',
                                message: 'ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ 16ã®ãƒ™ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ã¾ã›ã‚“'
                            });
                        }
                        
                        // å…¨ãƒ™ã‚¯ã‚¿ãƒ¼ã®åˆ†æ•£ç¢ºèª
                        this.checkVectorDistribution();
                        
                    } else {
                        this.results.dataIntegrity.push({
                            type: 'fail',
                            message: 'H64_8D_VECTORSãŒæœªå®šç¾©ã§ã™'
                        });
                    }
                    
                } catch (error) {
                    this.results.dataIntegrity.push({
                        type: 'error',
                        message: `ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`
                    });
                }
            }

            checkVectorDistribution() {
                try {
                    const allVectors = Object.values(H64_8D_VECTORS);
                    const vectorMagnitudes = allVectors.map(vector => {
                        const values = Object.values(vector);
                        return Math.sqrt(values.reduce((sum, val) => sum + val * val, 0));
                    });
                    
                    const uniqueMagnitudes = [...new Set(vectorMagnitudes.map(m => m.toFixed(2)))];
                    const magnitudeDistribution = {};
                    
                    vectorMagnitudes.forEach((mag, index) => {
                        const roundedMag = mag.toFixed(2);
                        if (!magnitudeDistribution[roundedMag]) {
                            magnitudeDistribution[roundedMag] = [];
                        }
                        magnitudeDistribution[roundedMag].push(index + 1);
                    });
                    
                    this.results.dataIntegrity.push({
                        type: 'info',
                        message: `ãƒ™ã‚¯ã‚¿ãƒ¼åˆ†å¸ƒ: ${uniqueMagnitudes.length}ç¨®ã®ç•°ãªã‚‹ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰`
                    });
                    
                    // ç•°å¸¸ã«å¤šãç¾ã‚Œã‚‹ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰ã‚’ç‰¹å®š
                    const frequentMagnitudes = Object.entries(magnitudeDistribution)
                        .filter(([mag, hexagrams]) => hexagrams.length > 3)
                        .sort((a, b) => b[1].length - a[1].length);
                    
                    if (frequentMagnitudes.length > 0) {
                        this.results.dataIntegrity.push({
                            type: 'warning',
                            message: `é »å‡ºãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰: ${frequentMagnitudes[0][0]} (${frequentMagnitudes[0][1].length}å€‹ã®ãƒ˜ã‚­ã‚µã‚°ãƒ©ãƒ : ${frequentMagnitudes[0][1].join(', ')})`
                        });
                    }
                    
                } catch (error) {
                    this.results.dataIntegrity.push({
                        type: 'error',
                        message: `ãƒ™ã‚¯ã‚¿ãƒ¼åˆ†å¸ƒç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}`
                    });
                }
            }

            testCalculationLogic() {
                console.log('ğŸ§ª è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯æ¤œè¨¼ä¸­...');
                
                try {
                    const calculator = new Calculator();
                    
                    // ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ³ãƒ—ãƒ«å›ç­”ãƒ‡ãƒ¼ã‚¿ä½œæˆ
                    const testAnswers = this.createTestAnswers();
                    
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ™ã‚¯ã‚¿ãƒ¼æ§‹ç¯‰ãƒ†ã‚¹ãƒˆ
                    const userVector = calculator.buildUserVector(testAnswers);
                    
                    this.results.calculationTests.push({
                        type: userVector ? 'pass' : 'fail',
                        message: `ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ™ã‚¯ã‚¿ãƒ¼æ§‹ç¯‰: ${userVector ? 'æˆåŠŸ' : 'å¤±æ•—'}`
                    });
                    
                    if (userVector) {
                        const vectorValues = Object.values(userVector);
                        const isAllZero = vectorValues.every(v => v === 0);
                        const hasNegative = vectorValues.some(v => v < 0);
                        
                        this.results.calculationTests.push({
                            type: isAllZero ? 'warning' : 'pass',
                            message: `ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ™ã‚¯ã‚¿ãƒ¼å€¤: å…¨ã¦0=${isAllZero}, è² ã®å€¤å«ã‚€=${hasNegative}, åˆè¨ˆ=${vectorValues.reduce((sum, val) => sum + val, 0)}`
                        });
                        
                        // OSå€™è£œåˆ†æãƒ†ã‚¹ãƒˆ
                        if (typeof H64_8D_VECTORS !== 'undefined') {
                            try {
                                const candidates = calculator.analyzeOSCandidates(userVector, H64_8D_VECTORS);
                                
                                this.results.calculationTests.push({
                                    type: candidates && candidates.length > 0 ? 'pass' : 'fail',
                                    message: `OSå€™è£œåˆ†æ: ${candidates ? candidates.length : 0}å€‹ã®å€™è£œç”Ÿæˆ`
                                });
                                
                                if (candidates && candidates.length > 0) {
                                    const topCandidate = candidates[0];
                                    const candidateIds = candidates.map(c => c.osId);
                                    const has16 = candidateIds.includes(16);
                                    const uniqueIds = [...new Set(candidateIds)];
                                    
                                    this.results.calculationTests.push({
                                        type: uniqueIds.length > 1 ? 'pass' : 'fail',
                                        message: `å€™è£œå¤šæ§˜æ€§: ãƒˆãƒƒãƒ—å€™è£œ=${topCandidate.osId}, 16å«ã‚€=${has16}, ãƒ¦ãƒ‹ãƒ¼ã‚¯æ•°=${uniqueIds.length}/4`
                                    });
                                    
                                    this.results.calculationTests.push({
                                        type: 'info',
                                        message: `å€™è£œè©³ç´°: [${candidateIds.join(', ')}], ã‚¹ã‚³ã‚¢: [${candidates.map(c => c.score.toFixed(3)).join(', ')}]`
                                    });
                                }
                                
                            } catch (analysisError) {
                                this.results.calculationTests.push({
                                    type: 'error',
                                    message: `OSå€™è£œåˆ†æã‚¨ãƒ©ãƒ¼: ${analysisError.message}`
                                });
                            }
                        }
                    }
                    
                } catch (error) {
                    this.results.calculationTests.push({
                        type: 'error',
                        message: `è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: ${error.message}`
                    });
                }
            }

            createTestAnswers() {
                // å¤šæ§˜ãªå›ç­”ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½œæˆ
                return [
                    {
                        questionId: 'q1',
                        selectedValue: 'A',
                        scoring_tags: [
                            { key: "ä¹¾_å‰µé€ æ€§", value: 3.0 },
                            { key: "é›¢_è¡¨ç¾æ€§", value: 1.5 }
                        ]
                    },
                    {
                        questionId: 'q2',
                        selectedValue: 'B',
                        scoring_tags: [
                            { key: "éœ‡_è¡Œå‹•æ€§", value: 2.5 },
                            { key: "å_æ¢æ±‚æ€§", value: 1.0 }
                        ]
                    },
                    {
                        questionId: 'q3',
                        selectedValue: 'C',
                        scoring_tags: [
                            { key: "å¤_å—å®¹æ€§", value: 2.0 },
                            { key: "å…Œ_èª¿å’Œæ€§", value: 1.5 }
                        ]
                    }
                ];
            }

            generateRecommendations() {
                console.log('ğŸ’¡ ä¿®æ­£æ–¹æ³•ç”Ÿæˆä¸­...');
                
                // DataManagerã®å•é¡ŒãŒç™ºè¦‹ã•ã‚ŒãŸå ´åˆ
                const hasDataManagerIssue = this.results.diagnosis.some(d => 
                    d.message.includes('getVectorsData()ãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“')
                );
                
                if (hasDataManagerIssue) {
                    this.results.recommendations.push({
                        priority: 'critical',
                        title: 'DataManagerã«getVectorsData()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ',
                        description: 'Engine.jsãŒå‘¼ã³å‡ºã™getVectorsData()ãƒ¡ã‚½ãƒƒãƒ‰ãŒDataManagerã«å­˜åœ¨ã—ã¾ã›ã‚“ã€‚',
                        solution: `DataManager.jsã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ï¼š
getVectorsData() {
    return this.getVectors();
}`
                    });
                }
                
                this.results.recommendations.push({
                    priority: 'high',
                    title: 'è¨ºæ–­ãƒ­ã‚¸ãƒƒã‚¯ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–',
                    description: 'undefinedãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚‹äºˆæœŸã—ãªã„å‹•ä½œã‚’é˜²ã',
                    solution: 'Engine.jsã®getVectorsDataOptimized()ã§nullãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ '
                });
                
                this.results.recommendations.push({
                    priority: 'medium', 
                    title: 'ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®è¿½åŠ ',
                    description: 'è¨ºæ–­ãƒ—ãƒ­ã‚»ã‚¹ã®å¯è¦–åŒ–ã«ã‚ˆã‚Šå•é¡Œã®æ—©æœŸç™ºè¦‹',
                    solution: 'Calculator.jsã®analyzeOSCandidatesãƒ¡ã‚½ãƒƒãƒ‰ã«è©³ç´°ãƒ­ã‚°ã‚’è¿½åŠ '
                });
            }

            displayResults() {
                document.getElementById('diagnosis-results').innerHTML = 
                    this.formatResults(this.results.diagnosis);
                document.getElementById('data-integrity-results').innerHTML = 
                    this.formatResults(this.results.dataIntegrity);
                document.getElementById('calculation-test-results').innerHTML = 
                    this.formatResults(this.results.calculationTests);
                document.getElementById('fix-recommendations').innerHTML = 
                    this.formatRecommendations(this.results.recommendations);
            }

            formatResults(results) {
                return results.map(result => 
                    `<div class="test-result ${result.type}">${result.message}</div>`
                ).join('');
            }

            formatRecommendations(recommendations) {
                return recommendations.map(rec => 
                    `<div class="debug-section">
                        <h4>ğŸ”§ ${rec.title} (å„ªå…ˆåº¦: ${rec.priority})</h4>
                        <p>${rec.description}</p>
                        <pre>${rec.solution}</pre>
                    </div>`
                ).join('');
            }
        }

        // ãƒ‡ãƒãƒƒã‚°å®Ÿè¡Œ
        window.addEventListener('DOMContentLoaded', async () => {
            const debugger = new BiasDebugger();
            await debugger.runDiagnosis();
        });
    </script>
</body>
</html>