# HAQEI„Ç¢„Éä„É©„Ç§„Ç∂„Éº - „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„ÇØ„É©„ÇπË®≠Ë®à‰ªïÊßòÊõ∏

## üèóÔ∏è „ÇØ„É©„ÇπÈöéÂ±§ÊßãÈÄ†

```mermaid
classDiagram
    class UnifiedErrorHandler {
        -static instance: UnifiedErrorHandler
        -errorClassifier: ErrorClassifier
        -recoveryManager: RecoveryStrategyManager
        -philosophyValidator: PhilosophyValidator
        -analyticsCollector: ErrorAnalyticsCollector
        -performanceMonitor: PerformanceMonitor
        +getInstance(options?: ErrorHandlerOptions): UnifiedErrorHandler
        +handleError(error: Error, context?: ErrorContext): Promise~ErrorHandlingResult~
        +classifyError(error: Error): Promise~ClassifiedError~
        +getErrorStatistics(): Promise~ErrorStatistics~
        -captureErrorWithContext(error: Error, context: ErrorContext, errorId: string): Promise~CapturedError~
        -executeRecoveryStrategy(classifiedError: ClassifiedError): Promise~RecoveryResult~
        -recordAndNotify(error: ClassifiedError, result: RecoveryResult, duration: number): Promise~void~
    }

    class ErrorClassifier {
        -classificationRules: Map~string, ClassificationRule~
        -philosophyMatcher: PhilosophyMatcher
        +classify(error: CapturedError, philosophyCheck: PhilosophyCheck): Promise~ClassifiedError~
        +registerClassificationRule(pattern: string, rule: ClassificationRule): void
        -performBaseClassification(error: CapturedError): BaseClassification
        -classifyPhilosophyImpact(error: CapturedError, check: PhilosophyCheck): Promise~PhilosophyClassification~
        -analyzeContextualFactors(error: CapturedError): ContextualClassification
    }

    class PhilosophyValidator {
        -ichingValidator: IChingValidator
        -bunenjinValidator: BunenjinValidator
        -tripleOSValidator: TripleOSValidator
        +validate(error: CapturedError): Promise~PhilosophyCheck~
        +validateIChingIntegrity(error: CapturedError): Promise~IChingIntegrityCheck~
        +validateBunenjinConsistency(error: CapturedError): Promise~BunenjinConsistencyCheck~
        +validateTripleOSArchitecture(error: CapturedError): Promise~TripleOSArchitectureCheck~
    }

    class RecoveryStrategyManager {
        -strategies: Map~string, RecoveryStrategy~
        -strategySelector: StrategySelector
        +selectStrategy(classifiedError: ClassifiedError): Promise~RecoveryStrategy~
        +executeRecovery(strategy: RecoveryStrategy, error: ClassifiedError): Promise~RecoveryResult~
        +registerStrategy(name: string, strategy: RecoveryStrategy): void
        -getCandidateStrategies(error: ClassifiedError): RecoveryStrategy[]
        -getFallbackStrategy(error: ClassifiedError): RecoveryStrategy
    }

    class RecoveryStrategy {
        <<abstract>>
        +execute(error: ClassifiedError): Promise~RecoveryResult~
        +rollback(error: ClassifiedError): Promise~void~
        +canHandle(error: ClassifiedError): Promise~boolean~
        +getExpectedDuration(): number
        +getPhilosophyGuidance(): string
        +getDetailedSteps(): Promise~RecoveryStep[]~
    }

    class IChingFallbackStrategy {
        +execute(error: ClassifiedError): Promise~RecoveryResult~
        +rollback(error: ClassifiedError): Promise~void~
        +getExpectedDuration(): number
        +getPhilosophyGuidance(): string
        -checkBasicIChingData(): Promise~boolean~
        -generateFallbackHexagrams(): Promise~HexagramData[]~
        -implementBasicSequenceLogic(): Promise~SequenceLogic~
    }

    class BunenjinGuidanceStrategy {
        +execute(error: ClassifiedError): Promise~RecoveryResult~
        +rollback(error: ClassifiedError): Promise~void~
        +getExpectedDuration(): number
        +getPhilosophyGuidance(): string
        -analyzePersonaConflict(error: ClassifiedError): Promise~PersonaConflict~
        -generatePersonaTransitionGuidance(conflict: PersonaConflict): Promise~PersonaGuidance~
    }

    class TripleOSResetStrategy {
        +execute(error: ClassifiedError): Promise~RecoveryResult~
        +rollback(error: ClassifiedError): Promise~void~
        +getExpectedDuration(): number
        +getPhilosophyGuidance(): string
        -resetToSafeMode(): Promise~OSState~
        -validateOSTransition(fromState: OSState, toState: OSState): Promise~boolean~
    }

    UnifiedErrorHandler --> ErrorClassifier
    UnifiedErrorHandler --> PhilosophyValidator
    UnifiedErrorHandler --> RecoveryStrategyManager
    RecoveryStrategyManager --> RecoveryStrategy
    RecoveryStrategy <|-- IChingFallbackStrategy
    RecoveryStrategy <|-- BunenjinGuidanceStrategy
    RecoveryStrategy <|-- TripleOSResetStrategy
```

---

## üìã Core Classes

### 1. UnifiedErrorHandler

```typescript
/**
 * Áµ±‰∏Ä„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÅÆ‰∏≠Ê†∏„ÇØ„É©„Çπ
 * Singleton „Éë„Çø„Éº„É≥„ÅßÂÆüË£Ö„Åï„Çå„ÄÅÂÖ®„Ç∑„Çπ„ÉÜ„É†„ÅÆ„Ç®„É©„ÉºÂá¶ÁêÜ„ÇíÁµ±Êã¨
 */
export class UnifiedErrorHandler {
  private static instance: UnifiedErrorHandler;
  
  // Core components
  private errorClassifier: ErrorClassifier;
  private recoveryManager: RecoveryStrategyManager;
  private philosophyValidator: PhilosophyValidator;
  private analyticsCollector: ErrorAnalyticsCollector;
  private performanceMonitor: PerformanceMonitor;
  private cacheManager: CacheManager;
  
  // Configuration and state
  private config: ErrorHandlerConfig;
  private isInitialized: boolean = false;
  private errorHistory: Map<string, CapturedError> = new Map();
  private activeRecoveries: Map<string, RecoveryOperation> = new Map();

  /**
   * Singleton instance getter
   */
  public static getInstance(options?: ErrorHandlerOptions): UnifiedErrorHandler {
    if (!UnifiedErrorHandler.instance) {
      UnifiedErrorHandler.instance = new UnifiedErrorHandler(options);
    }
    return UnifiedErrorHandler.instance;
  }

  private constructor(options: ErrorHandlerOptions = {}) {
    this.config = this.mergeWithDefaultConfig(options);
    this.initializeComponents();
    this.setupGlobalHandlers();
    this.initializePhilosophyIntegration();
  }

  /**
   * „É°„Ç§„É≥„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
   * @param error - Âá¶ÁêÜ„Åô„Çã„Ç®„É©„Éº
   * @param context - „Ç®„É©„Éº„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà
   * @returns „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞ÁµêÊûú
   */
  public async handleError(
    error: Error, 
    context: ErrorContext = {}
  ): Promise<ErrorHandlingResult> {
    const startTime = performance.now();
    const errorId = this.generateErrorId();

    try {
      // 1. Error Capture & Enrichment
      const capturedError = await this.captureErrorWithContext(error, context, errorId);
      this.errorHistory.set(errorId, capturedError);

      // 2. Philosophy Alignment Validation
      const philosophyCheck = await this.philosophyValidator.validate(capturedError);

      // 3. Error Classification
      const classifiedError = await this.errorClassifier.classify(capturedError, philosophyCheck);

      // 4. Recovery Strategy Selection & Execution
      const recoveryResult = await this.executeRecoveryStrategy(classifiedError);

      // 5. Analytics & Performance Recording
      const handlingDuration = performance.now() - startTime;
      await this.recordAndNotify(classifiedError, recoveryResult, handlingDuration);

      return {
        success: recoveryResult.success,
        errorId: errorId,
        classification: classifiedError,
        recoveryResult: recoveryResult,
        philosophyCheck: philosophyCheck,
        handlingDuration: handlingDuration,
        timestamp: new Date().toISOString()
      };

    } catch (handlingError) {
      console.error('Critical error in error handling:', handlingError);
      return await this.executeBasicFallback(error, handlingError, errorId);
    }
  }

  /**
   * „Ç®„É©„ÉºÂàÜÈ°û„ÅÆ„Åø„ÇíÂÆüË°å
   */
  public async classifyError(error: Error, context?: ErrorContext): Promise<ClassifiedError> {
    const capturedError = await this.captureErrorWithContext(error, context || {}, this.generateErrorId());
    const philosophyCheck = await this.philosophyValidator.validate(capturedError);
    return await this.errorClassifier.classify(capturedError, philosophyCheck);
  }

  /**
   * „Ç®„É©„ÉºÁµ±Ë®à„ÅÆÂèñÂæó
   */
  public async getErrorStatistics(timeRange?: TimeRange): Promise<ErrorStatistics> {
    return await this.analyticsCollector.generateStatistics(timeRange);
  }

  /**
   * „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ„ÅÆÈñãÂßã
   */
  public startPerformanceMonitoring(): void {
    this.performanceMonitor.startMonitoring();
  }

  /**
   * Ë®≠ÂÆö„ÅÆÊõ¥Êñ∞
   */
  public async updateConfiguration(config: Partial<ErrorHandlerConfig>): Promise<void> {
    this.config = { ...this.config, ...config };
    await this.reinitializeWithNewConfig();
  }

  // Private methods...
  private async captureErrorWithContext(
    error: Error, 
    context: ErrorContext, 
    errorId: string
  ): Promise<CapturedError> {
    return {
      id: errorId,
      originalError: error,
      context: {
        ...context,
        timestamp: Date.now(),
        userAgent: navigator?.userAgent,
        url: window?.location?.href,
        viewport: this.getViewportInfo(),
        stackTrace: this.parseStackTrace(error.stack),
        executionContext: this.captureExecutionContext()
      },
      captureTime: Date.now()
    };
  }

  private async executeRecoveryStrategy(classifiedError: ClassifiedError): Promise<RecoveryResult> {
    const strategy = await this.recoveryManager.selectStrategy(classifiedError);
    const recoveryId = this.generateRecoveryId();
    
    this.activeRecoveries.set(recoveryId, {
      id: recoveryId,
      strategy: strategy,
      error: classifiedError,
      startTime: Date.now(),
      status: 'in-progress'
    });

    try {
      const result = await this.recoveryManager.executeRecovery(strategy, classifiedError);
      this.activeRecoveries.get(recoveryId)!.status = result.success ? 'completed' : 'failed';
      return result;
    } catch (recoveryError) {
      this.activeRecoveries.get(recoveryId)!.status = 'failed';
      throw recoveryError;
    } finally {
      setTimeout(() => this.activeRecoveries.delete(recoveryId), 300000); // 5ÂàÜÂæå„Å´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    }
  }

  private generateErrorId(): string {
    return `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateRecoveryId(): string {
    return `recovery_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### 2. ErrorClassifier

```typescript
/**
 * „Ç®„É©„ÉºÂàÜÈ°û„Ç®„É≥„Ç∏„É≥
 * „Ç®„É©„Éº„ÇíÂ§öËßíÁöÑ„Å´ÂàÜÊûê„Åó„ÄÅÈÅ©Âàá„Å™ÂàÜÈ°û„Å®ÂÑ™ÂÖàÂ∫¶„ÇíÊ±∫ÂÆö
 */
export class ErrorClassifier {
  private classificationRules: Map<string, ClassificationRule>;
  private philosophyMatcher: PhilosophyMatcher;
  private contextAnalyzer: ContextAnalyzer;
  private severityCalculator: SeverityCalculator;

  constructor() {
    this.classificationRules = new Map();
    this.philosophyMatcher = new PhilosophyMatcher();
    this.contextAnalyzer = new ContextAnalyzer();
    this.severityCalculator = new SeverityCalculator();
    this.initializeDefaultRules();
  }

  /**
   * „Ç®„É©„Éº„ÅÆÂåÖÊã¨ÁöÑÂàÜÈ°û
   * @param error - „Ç≠„É£„Éó„ÉÅ„É£„Åï„Çå„Åü„Ç®„É©„Éº
   * @param philosophyCheck - Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØÁµêÊûú
   * @returns ÂàÜÈ°û„Åï„Çå„Åü„Ç®„É©„Éº
   */
  public async classify(
    error: CapturedError, 
    philosophyCheck: PhilosophyCheck
  ): Promise<ClassifiedError> {
    
    // ‰∏¶Âàó„ÅßÂêÑÁ®ÆÂàÜÈ°û„ÇíÂÆüË°å
    const [
      baseClassification,
      philosophyClassification,
      contextualClassification,
      severityAssessment
    ] = await Promise.all([
      this.performBaseClassification(error),
      this.classifyPhilosophyImpact(error, philosophyCheck),
      this.analyzeContextualFactors(error),
      this.assessSeverity(error, philosophyCheck)
    ]);

    return this.mergeClassifications({
      error,
      philosophyCheck,
      baseClassification,
      philosophyClassification,
      contextualClassification,
      severityAssessment,
      classificationTime: Date.now()
    });
  }

  /**
   * Êñ∞„Åó„ÅÑÂàÜÈ°û„É´„Éº„É´„ÅÆÁôªÈå≤
   */
  public registerClassificationRule(pattern: string, rule: ClassificationRule): void {
    this.classificationRules.set(pattern, rule);
  }

  /**
   * Âü∫Êú¨ÁöÑ„Å™„Ç®„É©„ÉºÂàÜÈ°û
   */
  private async performBaseClassification(error: CapturedError): Promise<BaseClassification> {
    const errorMessage = error.originalError.message.toLowerCase();
    const stackTrace = error.originalError.stack?.toLowerCase() || '';

    // JavaScript Runtime Errors
    if (this.isJavaScriptRuntimeError(error)) {
      return {
        category: 'javascript-runtime',
        subcategory: this.classifyJavaScriptError(error),
        confidence: 0.95,
        indicators: this.extractJavaScriptErrorIndicators(error)
      };
    }

    // Network Errors
    if (this.isNetworkError(error)) {
      return {
        category: 'network',
        subcategory: this.classifyNetworkError(error),
        confidence: 0.90,
        indicators: this.extractNetworkErrorIndicators(error)
      };
    }

    // Data Processing Errors
    if (this.isDataProcessingError(error)) {
      return {
        category: 'data-processing',
        subcategory: this.classifyDataError(error),
        confidence: 0.85,
        indicators: this.extractDataErrorIndicators(error)
      };
    }

    // HAQEI-specific Errors
    if (this.isHAQEISpecificError(error)) {
      return {
        category: 'haqei-specific',
        subcategory: this.classifyHAQEIError(error),
        confidence: 0.98,
        indicators: this.extractHAQEIErrorIndicators(error)
      };
    }

    // Fallback to generic classification
    return {
      category: 'generic',
      subcategory: 'unknown',
      confidence: 0.50,
      indicators: ['unknown-error-pattern']
    };
  }

  /**
   * Âì≤Â≠¶ÁöÑÂΩ±Èüø„ÅÆÂàÜÈ°û
   */
  private async classifyPhilosophyImpact(
    error: CapturedError, 
    philosophyCheck: PhilosophyCheck
  ): Promise<PhilosophyClassification> {
    const [ichingImpact, bunenjinImpact, tripleOSImpact] = await Promise.all([
      this.assessIChingImpact(error, philosophyCheck.ichingIntegrity),
      this.assessBunenjinImpact(error, philosophyCheck.bunenjinConsistency),
      this.assessTripleOSImpact(error, philosophyCheck.tripleOSArchitecture)
    ]);

    return {
      ichingImpact,
      bunenjinImpact,
      tripleOSImpact,
      overallPhilosophyImpact: this.calculateOverallPhilosophyImpact(
        ichingImpact, bunenjinImpact, tripleOSImpact
      ),
      requiresPhilosophyGuidance: this.requiresPhilosophyGuidance(
        ichingImpact, bunenjinImpact, tripleOSImpact
      )
    };
  }

  /**
   * ÊñáËÑàÁöÑË¶ÅÂõ†„ÅÆÂàÜÊûê
   */
  private analyzeContextualFactors(error: CapturedError): ContextualClassification {
    return {
      operationContext: this.analyzeOperationContext(error.context),
      userInteractionContext: this.analyzeUserInteractionContext(error.context),
      systemStateContext: this.analyzeSystemStateContext(error.context),
      timingContext: this.analyzeTimingContext(error.context),
      environmentContext: this.analyzeEnvironmentContext(error.context)
    };
  }

  /**
   * „Ç®„É©„ÉºÈáçË¶ÅÂ∫¶„ÅÆË©ï‰æ°
   */
  private async assessSeverity(
    error: CapturedError, 
    philosophyCheck: PhilosophyCheck
  ): Promise<SeverityAssessment> {
    const factors = {
      systemImpact: this.assessSystemImpact(error),
      userImpact: this.assessUserImpact(error),
      dataIntegrityRisk: this.assessDataIntegrityRisk(error),
      philosophyViolationSeverity: this.assessPhilosophyViolationSeverity(philosophyCheck),
      recoverabilityComplexity: this.assessRecoverabilityComplexity(error)
    };

    const calculatedSeverity = this.severityCalculator.calculate(factors);

    return {
      level: calculatedSeverity.level,
      score: calculatedSeverity.score,
      factors: factors,
      justification: calculatedSeverity.justification,
      escalationRequired: calculatedSeverity.level === 'critical'
    };
  }

  // Helper methods for error type detection
  private isJavaScriptRuntimeError(error: CapturedError): boolean {
    const jsErrorPatterns = [
      /reference.*error/i,
      /type.*error/i,
      /syntax.*error/i,
      /range.*error/i,
      /eval.*error/i
    ];
    
    return jsErrorPatterns.some(pattern => 
      pattern.test(error.originalError.message) || 
      pattern.test(error.originalError.name)
    );
  }

  private isNetworkError(error: CapturedError): boolean {
    const networkErrorPatterns = [
      /network/i,
      /fetch/i,
      /cors/i,
      /timeout/i,
      /connection/i,
      /offline/i
    ];
    
    return networkErrorPatterns.some(pattern => 
      pattern.test(error.originalError.message) ||
      error.context.operation?.includes('network') ||
      error.context.operation?.includes('api')
    );
  }

  private isDataProcessingError(error: CapturedError): boolean {
    const dataErrorPatterns = [
      /json.*parse/i,
      /invalid.*data/i,
      /parsing.*error/i,
      /validation.*error/i,
      /schema.*error/i
    ];
    
    return dataErrorPatterns.some(pattern => 
      pattern.test(error.originalError.message)
    ) || error.context.operation?.includes('data-processing');
  }

  private isHAQEISpecificError(error: CapturedError): boolean {
    const haqeiErrorPatterns = [
      /hexagram/i,
      /iching/i,
      /bunenjin/i,
      /triple.*os/i,
      /persona/i,
      /philosophy/i
    ];
    
    return haqeiErrorPatterns.some(pattern => 
      pattern.test(error.originalError.message) ||
      pattern.test(error.context.operation || '') ||
      error.context.hexagramId !== undefined ||
      error.context.personaState !== undefined
    );
  }
}
```

### 3. PhilosophyValidator

```typescript
/**
 * Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄßÊ§úË®º„Ç®„É≥„Ç∏„É≥
 * HAQEI‰∏âÂ§ßÂì≤Â≠¶ÔºàÊòìÁµå„Éªbunenjin„ÉªTriple OSÔºâ„Å®„ÅÆÊï¥ÂêàÊÄß„ÇíÊ§úË®º
 */
export class PhilosophyValidator {
  private ichingValidator: IChingValidator;
  private bunenjinValidator: BunenjinValidator;
  private tripleOSValidator: TripleOSValidator;
  private philosophyCache: Map<string, PhilosophyCheck>;

  constructor() {
    this.ichingValidator = new IChingValidator();
    this.bunenjinValidator = new BunenjinValidator();
    this.tripleOSValidator = new TripleOSValidator();
    this.philosophyCache = new Map();
  }

  /**
   * ÂåÖÊã¨ÁöÑÂì≤Â≠¶Êï¥ÂêàÊÄßÊ§úË®º
   * @param error - „Ç≠„É£„Éó„ÉÅ„É£„Åï„Çå„Åü„Ç®„É©„Éº
   * @returns Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØÁµêÊûú
   */
  public async validate(error: CapturedError): Promise<PhilosophyCheck> {
    const cacheKey = this.generateCacheKey(error);
    
    if (this.philosophyCache.has(cacheKey)) {
      return this.philosophyCache.get(cacheKey)!;
    }

    const [ichingCheck, bunenjinCheck, tripleOSCheck] = await Promise.all([
      this.ichingValidator.validateIntegrity(error),
      this.bunenjinValidator.validateConsistency(error),
      this.tripleOSValidator.validateArchitecture(error)
    ]);

    const overallAlignment = this.calculateOverallAlignment(
      ichingCheck, bunenjinCheck, tripleOSCheck
    );

    const philosophyCheck: PhilosophyCheck = {
      ichingIntegrity: ichingCheck,
      bunenjinConsistency: bunenjinCheck,
      tripleOSArchitecture: tripleOSCheck,
      overallAlignment,
      violatedPrinciples: this.identifyViolatedPrinciples(ichingCheck, bunenjinCheck, tripleOSCheck),
      guidanceRequired: overallAlignment < 0.8,
      validationTime: Date.now()
    };

    this.philosophyCache.set(cacheKey, philosophyCheck);
    return philosophyCheck;
  }

  /**
   * ÊòìÁµåÊï¥ÂêàÊÄß„ÅÆÂÄãÂà•Ê§úË®º
   */
  public async validateIChingIntegrity(error: CapturedError): Promise<IChingIntegrityCheck> {
    return await this.ichingValidator.validateIntegrity(error);
  }

  /**
   * bunenjinÊï¥ÂêàÊÄß„ÅÆÂÄãÂà•Ê§úË®º
   */
  public async validateBunenjinConsistency(error: CapturedError): Promise<BunenjinConsistencyCheck> {
    return await this.bunenjinValidator.validateConsistency(error);
  }

  /**
   * Triple OS„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÅÆÂÄãÂà•Ê§úË®º
   */
  public async validateTripleOSArchitecture(error: CapturedError): Promise<TripleOSArchitectureCheck> {
    return await this.tripleOSValidator.validateArchitecture(error);
  }

  /**
   * Âì≤Â≠¶ÁöÑ„Ç¨„Ç§„ÉÄ„É≥„Çπ„ÅÆÁîüÊàê
   */
  public async generatePhilosophyGuidance(philosophyCheck: PhilosophyCheck): Promise<PhilosophyGuidance> {
    const guidanceComponents = await Promise.all([
      this.ichingValidator.generateGuidance(philosophyCheck.ichingIntegrity),
      this.bunenjinValidator.generateGuidance(philosophyCheck.bunenjinConsistency),
      this.tripleOSValidator.generateGuidance(philosophyCheck.tripleOSArchitecture)
    ]);

    return {
      ichingGuidance: guidanceComponents[0],
      bunenjinGuidance: guidanceComponents[1],
      tripleOSGuidance: guidanceComponents[2],
      integratedGuidance: this.integrateGuidance(guidanceComponents),
      actionableSteps: this.generateActionableSteps(philosophyCheck),
      expectedOutcome: this.predictOutcome(philosophyCheck)
    };
  }

  private calculateOverallAlignment(
    ichingCheck: IChingIntegrityCheck,
    bunenjinCheck: BunenjinConsistencyCheck,
    tripleOSCheck: TripleOSArchitectureCheck
  ): number {
    const weights = { iching: 0.4, bunenjin: 0.3, tripleOS: 0.3 };
    
    return (
      ichingCheck.overallIntegrity * weights.iching +
      bunenjinCheck.overallConsistency * weights.bunenjin +
      tripleOSCheck.overallArchitectureHealth * weights.tripleOS
    );
  }

  private identifyViolatedPrinciples(
    ichingCheck: IChingIntegrityCheck,
    bunenjinCheck: BunenjinConsistencyCheck,
    tripleOSCheck: TripleOSArchitectureCheck
  ): string[] {
    const violations: string[] = [];

    if (ichingCheck.violatedPrinciples.length > 0) {
      violations.push(...ichingCheck.violatedPrinciples);
    }

    if (bunenjinCheck.violatedPrinciples.length > 0) {
      violations.push(...bunenjinCheck.violatedPrinciples);
    }

    if (tripleOSCheck.violatedPrinciples.length > 0) {
      violations.push(...tripleOSCheck.violatedPrinciples);
    }

    return violations;
  }

  private generateCacheKey(error: CapturedError): string {
    const keyComponents = [
      error.originalError.name,
      error.originalError.message,
      error.context.operation || 'unknown',
      error.context.hexagramId || 'none',
      error.context.personaState || 'none'
    ];
    
    return keyComponents.join('|');
  }
}
```

### 4. RecoveryStrategyManager

```typescript
/**
 * Âæ©ÊóßÊà¶Áï•ÁÆ°ÁêÜ„Ç®„É≥„Ç∏„É≥
 * „Ç®„É©„Éº„ÅÆÁâπÊÄß„Å´Âøú„Åò„Å¶ÊúÄÈÅ©„Å™Âæ©ÊóßÊà¶Áï•„ÇíÈÅ∏Êäû„ÉªÂÆüË°å
 */
export class RecoveryStrategyManager {
  private strategies: Map<string, RecoveryStrategy>;
  private strategySelector: StrategySelector;
  private executionMonitor: ExecutionMonitor;
  private recoveryHistory: RecoveryHistory;

  constructor() {
    this.strategies = new Map();
    this.strategySelector = new StrategySelector();
    this.executionMonitor = new ExecutionMonitor();
    this.recoveryHistory = new RecoveryHistory();
    this.initializeDefaultStrategies();
  }

  /**
   * ÊúÄÈÅ©Âæ©ÊóßÊà¶Áï•„ÅÆÈÅ∏Êäû
   * @param classifiedError - ÂàÜÈ°û„Åï„Çå„Åü„Ç®„É©„Éº
   * @returns ÈÅ∏Êäû„Åï„Çå„ÅüÂæ©ÊóßÊà¶Áï•
   */
  public async selectStrategy(classifiedError: ClassifiedError): Promise<RecoveryStrategy> {
    // ÈÅéÂéª„ÅÆÊàêÂäü‰æã„Åã„ÇâÂ≠¶Áøí
    const historicalSuccess = await this.recoveryHistory.getSuccessfulStrategies(classifiedError);
    
    // ÂÄôË£úÊà¶Áï•„ÅÆÂèñÂæó
    const candidateStrategies = this.getCandidateStrategies(classifiedError);
    
    // Êà¶Áï•„ÅÆË©ï‰æ°„ÉªÈÅ∏Êäû
    const bestStrategy = await this.strategySelector.selectBest(
      candidateStrategies, 
      classifiedError, 
      historicalSuccess
    );

    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊà¶Áï•„ÅÆÁ¢∫‰øù
    if (!bestStrategy || !(await bestStrategy.canHandle(classifiedError))) {
      return this.getFallbackStrategy(classifiedError);
    }

    return bestStrategy;
  }

  /**
   * Âæ©ÊóßÊà¶Áï•„ÅÆÂÆüË°å
   * @param strategy - ÂÆüË°å„Åô„ÇãÊà¶Áï•
   * @param error - ÂØæË±°„Ç®„É©„Éº
   * @returns Âæ©ÊóßÁµêÊûú
   */
  public async executeRecovery(
    strategy: RecoveryStrategy, 
    error: ClassifiedError
  ): Promise<RecoveryResult> {
    const executionId = this.generateExecutionId();
    const timeout = strategy.getExpectedDuration() * 1.5; // 50% „Éê„ÉÉ„Éï„Ç°

    try {
      // ÂÆüË°åÁõ£Ë¶ñ„ÅÆÈñãÂßã
      this.executionMonitor.startMonitoring(executionId, strategy, error);

      // „Çø„Ç§„É†„Ç¢„Ç¶„Éà‰ªò„ÅçÂÆüË°å
      const result = await Promise.race([
        this.executeWithMonitoring(strategy, error, executionId),
        this.createTimeoutPromise(timeout, strategy)
      ]);

      // ÂÆüË°åÂ±•Ê≠¥„ÅÆË®òÈå≤
      await this.recoveryHistory.recordExecution({
        strategy: strategy.constructor.name,
        error: error,
        result: result,
        duration: this.executionMonitor.getDuration(executionId),
        timestamp: Date.now()
      });

      return result;

    } catch (executionError) {
      // ÂÆüË°åÂ§±ÊïóÊôÇ„ÅÆ„É≠„Éº„É´„Éê„ÉÉ„ÇØ
      await this.performRollback(strategy, error, executionError);
      throw executionError;
    } finally {
      this.executionMonitor.stopMonitoring(executionId);
    }
  }

  /**
   * Êñ∞„Åó„ÅÑÂæ©ÊóßÊà¶Áï•„ÅÆÁôªÈå≤
   */
  public registerStrategy(name: string, strategy: RecoveryStrategy): void {
    this.strategies.set(name, strategy);
  }

  /**
   * Êà¶Áï•ÂÆüË°åÁµ±Ë®à„ÅÆÂèñÂæó
   */
  public async getExecutionStatistics(): Promise<StrategyExecutionStatistics> {
    return await this.recoveryHistory.generateStatistics();
  }

  private initializeDefaultStrategies(): void {
    // HAQEI Âõ∫ÊúâÊà¶Áï•
    this.strategies.set('iching-fallback', new IChingFallbackStrategy());
    this.strategies.set('bunenjin-guidance', new BunenjinGuidanceStrategy());
    this.strategies.set('triple-os-reset', new TripleOSResetStrategy());
    
    // Ê±éÁî®Êà¶Áï•
    this.strategies.set('cache-recovery', new CacheRecoveryStrategy());
    this.strategies.set('offline-mode', new OfflineModeStrategy());
    this.strategies.set('graceful-degradation', new GracefulDegradationStrategy());
    this.strategies.set('system-restart', new SystemRestartStrategy());
    
    // È´òÂ∫¶„Å™Êà¶Áï•
    this.strategies.set('adaptive-recovery', new AdaptiveRecoveryStrategy());
    this.strategies.set('machine-learning-recovery', new MLBasedRecoveryStrategy());
  }

  private getCandidateStrategies(classifiedError: ClassifiedError): RecoveryStrategy[] {
    const candidates: RecoveryStrategy[] = [];

    // „Ç®„É©„Éº„Ç´„ÉÜ„Ç¥„É™„Éº„Å´Âü∫„Å•„ÅèÊà¶Áï•ÈÅ∏Êäû
    switch (classifiedError.baseClassification.category) {
      case 'haqei-specific':
        candidates.push(
          this.strategies.get('iching-fallback')!,
          this.strategies.get('bunenjin-guidance')!,
          this.strategies.get('triple-os-reset')!
        );
        break;
      
      case 'network':
        candidates.push(
          this.strategies.get('offline-mode')!,
          this.strategies.get('cache-recovery')!
        );
        break;
      
      case 'data-processing':
        candidates.push(
          this.strategies.get('cache-recovery')!,
          this.strategies.get('graceful-degradation')!
        );
        break;
      
      default:
        candidates.push(
          this.strategies.get('graceful-degradation')!,
          this.strategies.get('adaptive-recovery')!
        );
    }

    // ÈáçË¶ÅÂ∫¶„Å´Âü∫„Å•„ÅèËøΩÂä†Êà¶Áï•
    if (classifiedError.severityAssessment.level === 'critical') {
      candidates.push(this.strategies.get('system-restart')!);
    }

    // Âì≤Â≠¶ÁöÑÂΩ±Èüø„Å´Âü∫„Å•„ÅèÊà¶Áï•ËøΩÂä†
    if (classifiedError.philosophyClassification.requiresPhilosophyGuidance) {
      candidates.push(
        this.strategies.get('iching-fallback')!,
        this.strategies.get('bunenjin-guidance')!
      );
    }

    return candidates.filter(Boolean); // null/undefined „ÇíÈô§Âéª
  }

  private getFallbackStrategy(classifiedError: ClassifiedError): RecoveryStrategy {
    // ÊúÄÂæå„ÅÆÊâãÊÆµ„Å®„Åó„Å¶„ÄÅÂ∏∏„Å´‰ΩøÁî®ÂèØËÉΩ„Å™Âü∫Êú¨Êà¶Áï•„ÇíËøî„Åô
    return this.strategies.get('graceful-degradation')!;
  }

  private async executeWithMonitoring(
    strategy: RecoveryStrategy, 
    error: ClassifiedError, 
    executionId: string
  ): Promise<RecoveryResult> {
    const startTime = Date.now();

    try {
      const result = await strategy.execute(error);
      
      this.executionMonitor.recordSuccess(executionId, {
        strategy: strategy.constructor.name,
        duration: Date.now() - startTime,
        result: result
      });

      return result;

    } catch (strategyError) {
      this.executionMonitor.recordFailure(executionId, {
        strategy: strategy.constructor.name,
        duration: Date.now() - startTime,
        error: strategyError
      });

      throw strategyError;
    }
  }

  private async performRollback(
    strategy: RecoveryStrategy, 
    error: ClassifiedError, 
    executionError: Error
  ): Promise<void> {
    try {
      await strategy.rollback(error);
    } catch (rollbackError) {
      console.error('Rollback failed:', {
        strategy: strategy.constructor.name,
        originalError: error,
        executionError: executionError,
        rollbackError: rollbackError
      });
    }
  }

  private createTimeoutPromise(timeout: number, strategy: RecoveryStrategy): Promise<RecoveryResult> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Recovery strategy '${strategy.constructor.name}' timed out after ${timeout}ms`));
      }, timeout);
    });
  }

  private generateExecutionId(): string {
    return `exec_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

---

## üîÑ Recovery Strategy Classes

### RecoveryStrategy (Abstract Base Class)

```typescript
/**
 * Âæ©ÊóßÊà¶Áï•„ÅÆÊäΩË±°Âü∫Â∫ï„ÇØ„É©„Çπ
 * ÂÖ®„Å¶„ÅÆÂÖ∑‰ΩìÁöÑ„Å™Âæ©ÊóßÊà¶Áï•„ÅØ„Åì„ÅÆ„ÇØ„É©„Çπ„ÇíÁ∂ôÊâø
 */
export abstract class RecoveryStrategy {
  protected strategyName: string;
  protected description: string;
  protected applicableErrorTypes: string[];

  constructor(name: string, description: string) {
    this.strategyName = name;
    this.description = description;
    this.applicableErrorTypes = [];
  }

  /**
   * Âæ©ÊóßÂá¶ÁêÜ„ÅÆÂÆüË°å
   * @param error - ÂàÜÈ°û„Åï„Çå„Åü„Ç®„É©„Éº
   * @returns Âæ©ÊóßÁµêÊûú
   */
  public abstract execute(error: ClassifiedError): Promise<RecoveryResult>;

  /**
   * Âæ©ÊóßÂá¶ÁêÜ„ÅÆ„É≠„Éº„É´„Éê„ÉÉ„ÇØ
   * @param error - ÂàÜÈ°û„Åï„Çå„Åü„Ç®„É©„Éº
   */
  public abstract rollback(error: ClassifiedError): Promise<void>;

  /**
   * „Åì„ÅÆÊà¶Áï•„Åå„Ç®„É©„Éº„ÇíÂá¶ÁêÜÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
   * @param error - ÂàÜÈ°û„Åï„Çå„Åü„Ç®„É©„Éº
   * @returns Âá¶ÁêÜÂèØËÉΩÊÄß
   */
  public abstract canHandle(error: ClassifiedError): Promise<boolean>;

  /**
   * ‰∫àÊÉ≥ÂÆüË°åÊôÇÈñì„ÅÆÂèñÂæó
   * @returns ‰∫àÊÉ≥ÂÆüË°åÊôÇÈñìÔºà„Éü„É™ÁßíÔºâ
   */
  public abstract getExpectedDuration(): number;

  /**
   * Âì≤Â≠¶ÁöÑ„Ç¨„Ç§„ÉÄ„É≥„Çπ„ÅÆÂèñÂæó
   * @returns Âì≤Â≠¶ÁöÑ„Ç¨„Ç§„ÉÄ„É≥„ÇπÊñáË®Ä
   */
  public abstract getPhilosophyGuidance(): string;

  /**
   * Ë©≥Á¥∞Âæ©Êóß„Çπ„ÉÜ„ÉÉ„Éó„ÅÆÂèñÂæó
   * @returns Âæ©Êóß„Çπ„ÉÜ„ÉÉ„ÉóÈÖçÂàó
   */
  public async getDetailedSteps(): Promise<RecoveryStep[]> {
    return [
      {
        id: 1,
        name: 'Áä∂Ê≥ÅÂàÜÊûê',
        description: '„Ç®„É©„Éº„ÅÆÁä∂Ê≥Å„ÇíË©≥Á¥∞„Å´ÂàÜÊûê„Åó„Åæ„Åô',
        estimatedDuration: this.getExpectedDuration() * 0.2
      },
      {
        id: 2,
        name: 'Âæ©ÊóßÂá¶ÁêÜÂÆüË°å',
        description: 'ÈÅ∏Êäû„Åï„Çå„ÅüÂæ©ÊóßÊà¶Áï•„ÇíÂÆüË°å„Åó„Åæ„Åô',
        estimatedDuration: this.getExpectedDuration() * 0.6
      },
      {
        id: 3,
        name: 'ÁµêÊûúÁ¢∫Ë™ç',
        description: 'Âæ©ÊóßÂá¶ÁêÜ„ÅÆÁµêÊûú„ÇíÁ¢∫Ë™ç„ÉªÊ§úË®º„Åó„Åæ„Åô',
        estimatedDuration: this.getExpectedDuration() * 0.2
      }
    ];
  }

  /**
   * Êà¶Áï•„ÅÆÈÅ©Áî®ÂèØËÉΩÊÄß„Çπ„Ç≥„Ç¢Ë®àÁÆó
   * @param error - ÂàÜÈ°û„Åï„Çå„Åü„Ç®„É©„Éº
   * @returns ÈÅ©Áî®ÂèØËÉΩÊÄß„Çπ„Ç≥„Ç¢ (0-1)
   */
  public calculateApplicabilityScore(error: ClassifiedError): number {
    let score = 0;

    // „Ç®„É©„Éº„Çø„Ç§„Éó„ÅÆ‰∏ÄËá¥Â∫¶
    if (this.applicableErrorTypes.includes(error.baseClassification.category)) {
      score += 0.4;
    }

    // ÈáçË¶ÅÂ∫¶„ÅÆÈÅ©ÂêàÊÄß
    score += this.calculateSeverityMatch(error.severityAssessment.level) * 0.3;

    // Âì≤Â≠¶ÁöÑÊï¥ÂêàÊÄß
    score += this.calculatePhilosophyMatch(error.philosophyClassification) * 0.3;

    return Math.min(score, 1.0);
  }

  protected calculateSeverityMatch(severity: string): number {
    // ÊäΩË±°„É°„ÇΩ„ÉÉ„ÉâÔºöÁ∂ôÊâø„ÇØ„É©„Çπ„Åß„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ
    return 0.5;
  }

  protected calculatePhilosophyMatch(philosophyClassification: PhilosophyClassification): number {
    // ÊäΩË±°„É°„ÇΩ„ÉÉ„ÉâÔºöÁ∂ôÊâø„ÇØ„É©„Çπ„Åß„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ
    return 0.5;
  }

  /**
   * Êà¶Áï•„É°„Çø„Éá„Éº„Çø„ÅÆÂèñÂæó
   */
  public getStrategyMetadata(): StrategyMetadata {
    return {
      name: this.strategyName,
      description: this.description,
      applicableErrorTypes: this.applicableErrorTypes,
      expectedDuration: this.getExpectedDuration(),
      philosophyAlignment: this.getPhilosophyAlignment(),
      riskLevel: this.getRiskLevel(),
      successRate: this.getHistoricalSuccessRate()
    };
  }

  protected abstract getPhilosophyAlignment(): PhilosophyAlignment;
  protected abstract getRiskLevel(): 'low' | 'medium' | 'high';
  protected abstract getHistoricalSuccessRate(): number;
}
```

### IChingFallbackStrategy

```typescript
/**
 * ÊòìÁµå„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂæ©ÊóßÊà¶Áï•
 * ÊòìÁµå„Ç®„É≥„Ç∏„É≥„ÅÆÈöúÂÆ≥ÊôÇ„Å´Âü∫Êú¨ÁöÑ„Å™Âç¶Ë®àÁÆóÊ©üËÉΩ„ÇíÊèê‰æõ
 */
export class IChingFallbackStrategy extends RecoveryStrategy {
  private fallbackHexagramDatabase: FallbackHexagramDatabase;
  private sequenceLogicEngine: BasicSequenceLogicEngine;
  private validationEngine: IChingValidationEngine;

  constructor() {
    super('I Ching Fallback Strategy', 'ÊòìÁµå„Ç®„É≥„Ç∏„É≥ÈöúÂÆ≥ÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ');
    this.applicableErrorTypes = ['haqei-specific', 'iching-engine', 'hexagram-calculation'];
    this.fallbackHexagramDatabase = new FallbackHexagramDatabase();
    this.sequenceLogicEngine = new BasicSequenceLogicEngine();
    this.validationEngine = new IChingValidationEngine();
  }

  public async execute(error: ClassifiedError): Promise<RecoveryResult> {
    const startTime = Date.now();
    const recoverySteps = await this.getDetailedSteps();
    
    try {
      // Step 1: Âü∫Êú¨ÊòìÁµå„Éá„Éº„Çø„ÅÆÁ¢∫Ë™ç
      const basicDataCheck = await this.checkBasicIChingData();
      if (!basicDataCheck.available) {
        return {
          success: false,
          message: 'Âü∫Êú¨ÊòìÁµå„Éá„Éº„Çø„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì',
          functionalityLevel: 'none',
          estimatedRecoveryTime: 0
        };
      }

      // Step 2: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂç¶„Éá„Éº„Çø„ÅÆÁîüÊàê
      const fallbackHexagrams = await this.generateFallbackHexagrams();

      // Step 3: Âü∫Êú¨Â∫èÂç¶‰ºù„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂÆüË£Ö
      const sequenceLogic = await this.implementBasicSequenceLogic();

      // Step 4: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊï¥ÂêàÊÄß„ÅÆÊ§úË®º
      const integrityCheck = await this.validateFallbackIntegrity(fallbackHexagrams, sequenceLogic);

      if (!integrityCheck.valid) {
        throw new Error(`„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊï¥ÂêàÊÄß„ÉÅ„Çß„ÉÉ„ÇØÂ§±Êïó: ${integrityCheck.reason}`);
      }

      // Step 5: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„ÅÆÊúâÂäπÂåñ
      await this.enableFallbackSystem(fallbackHexagrams, sequenceLogic);

      const duration = Date.now() - startTime;

      return {
        success: true,
        message: 'ÊòìÁµå„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ„Å´„Çà„ÇäÁ∂ôÁ∂öÈÅãÁî®‰∏≠„Åß„Åô',
        philosophyGuidance: this.generateIChingGuidance(error),
        functionalityLevel: 'reduced',
        estimatedRecoveryTime: this.calculateRecoveryTime(error),
        executionDuration: duration,
        data: {
          fallbackHexagrams: fallbackHexagrams,
          sequenceLogic: sequenceLogic,
          integrityScore: integrityCheck.score
        },
        nextSteps: [
          '‰∏ªË¶ÅÊòìÁµå„Ç®„É≥„Ç∏„É≥„ÅÆË®∫Êñ≠„ÇíÂÆüË°å',
          '„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ„ÅÆÁõ£Ë¶ñ„ÇíÁ∂ôÁ∂ö',
          'ÂÆåÂÖ®Âæ©ÊóßÂæå„ÅÆ„Éá„Éº„ÇøÊï¥ÂêàÊÄßÁ¢∫Ë™ç'
        ]
      };

    } catch (fallbackError) {
      return {
        success: false,
        message: `ÊòìÁµå„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„Å´Â§±Êïó: ${fallbackError.message}`,
        functionalityLevel: 'none',
        estimatedRecoveryTime: 0,
        executionDuration: Date.now() - startTime,
        error: fallbackError
      };
    }
  }

  public async rollback(error: ClassifiedError): Promise<void> {
    try {
      await this.disableFallbackSystem();
      await this.clearFallbackData();
      await this.restoreOriginalIChingEngine();
    } catch (rollbackError) {
      console.error('I Ching fallback rollback failed:', rollbackError);
      throw new Error(`ÊòìÁµå„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÅÆ„É≠„Éº„É´„Éê„ÉÉ„ÇØ„Å´Â§±Êïó: ${rollbackError.message}`);
    }
  }

  public async canHandle(error: ClassifiedError): boolean {
    // ÊòìÁµåÈñ¢ÈÄ£„Ç®„É©„Éº„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    const isIChingError = this.isIChingRelatedError(error);
    
    // Âü∫Êú¨„Éá„Éº„Çø„ÅÆÂà©Áî®ÂèØËÉΩÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
    const basicDataAvailable = await this.checkBasicDataAvailability();
    
    // „Ç∑„Çπ„ÉÜ„É†„É™„ÇΩ„Éº„Çπ„ÅÆÁ¢∫Ë™ç
    const resourcesAvailable = await this.checkSystemResources();

    return isIChingError && basicDataAvailable && resourcesAvailable;
  }

  public getExpectedDuration(): number {
    return 300000; // 5ÂàÜ
  }

  public getPhilosophyGuidance(): string {
    return 'ÊòìÁµå64Áï™„ÄåÁÅ´Ê∞¥Êú™Ê∏à„Äç„ÅÆÊïô„Åà„Å´Âæì„ÅÑ„ÄÅ„Åæ„Å†ÂÆåÊàê„Åó„Å¶„ÅÑ„Å™„ÅÑÁä∂ÊÖã„ÇíÂèó„ÅëÂÖ•„Çå„Å§„Å§„ÄÅ' +
           'Â§âÂåñ„ÅÆÂéüÁêÜ„Å´Âü∫„Å•„ÅÑ„Å¶ÁèæÁä∂„Åã„ÇâÊñ∞„Åó„ÅÑÈÅì„ÇíË¶ã„Å§„Åë„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ' +
           'Âõ∞Èõ£„Å™Áä∂Ê≥Å„Åì„Åù„Åå„ÄÅ„Çà„ÇäÊ∑±„ÅÑÁêÜËß£„Å®ÊàêÈï∑„ÅÆÊ©ü‰ºö„Å®„Å™„Çä„Åæ„Åô„ÄÇ';
  }

  protected getPhilosophyAlignment(): PhilosophyAlignment {
    return {
      iching: 1.0,        // ÊòìÁµå„Å´ÂÆåÂÖ®Ê∫ñÊã†
      bunenjin: 0.7,      // bunenjinÂì≤Â≠¶„Å´ÈÉ®ÂàÜÁöÑÊ∫ñÊã†
      tripleOS: 0.8       // Triple OS„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„Å´Ê∫ñÊã†
    };
  }

  protected getRiskLevel(): 'low' | 'medium' | 'high' {
    return 'low'; // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ„ÅØ‰Ωé„É™„Çπ„ÇØ
  }

  protected getHistoricalSuccessRate(): number {
    return 0.92; // ÈÅéÂéª„ÅÆÊàêÂäüÁéá92%
  }

  // Private helper methods
  private async checkBasicIChingData(): Promise<{ available: boolean; quality: number }> {
    try {
      const coreHexagrams = await this.fallbackHexagramDatabase.getCoreHexagrams();
      const sequenceData = await this.fallbackHexagramDatabase.getSequenceData();
      
      return {
        available: coreHexagrams.length >= 64 && sequenceData.length > 0,
        quality: this.assessDataQuality(coreHexagrams, sequenceData)
      };
    } catch (error) {
      return { available: false, quality: 0 };
    }
  }

  private async generateFallbackHexagrams(): Promise<HexagramData[]> {
    const coreHexagrams = await this.fallbackHexagramDatabase.getCoreHexagrams();
    
    return coreHexagrams.map(hexagram => ({
      id: hexagram.id,
      name: hexagram.name,
      binary: hexagram.binary,
      trigrams: hexagram.trigrams,
      basicInterpretation: hexagram.interpretation,
      fallbackMode: true,
      generatedAt: Date.now()
    }));
  }

  private async implementBasicSequenceLogic(): Promise<SequenceLogic> {
    return this.sequenceLogicEngine.generateBasicSequenceLogic();
  }

  private async validateFallbackIntegrity(
    hexagrams: HexagramData[], 
    sequenceLogic: SequenceLogic
  ): Promise<{ valid: boolean; score: number; reason?: string }> {
    return await this.validationEngine.validate({
      hexagrams,
      sequenceLogic,
      minimumIntegrityThreshold: 0.8
    });
  }

  private generateIChingGuidance(error: ClassifiedError): string {
    const guidance = [
      'ÁèæÂú®„ÅÆÂõ∞Èõ£„ÅØ„ÄåÂ§âÂåñ„ÅÆÊôÇ„Äç„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ',
      'ÊòìÁµå„ÅÆÊïô„Åà„Å´Âæì„ÅÑ„ÄÅÊüîËªüÊÄß„ÇíÊåÅ„Å£„Å¶Áä∂Ê≥Å„Å´ÂØæÂøú„Åó„Åæ„Åô„ÄÇ',
      '„Åì„ÅÆÁµåÈ®ì„ÇíÈÄö„Åò„Å¶„ÄÅ„Ç∑„Çπ„ÉÜ„É†„ÅØ„Çà„ÇäÂº∑Âõ∫„Å´„Å™„Çä„Åæ„Åô„ÄÇ',
      'Èô∞„Å®ÈôΩ„ÅÆ„Éê„É©„É≥„Çπ„Çí‰øù„Å°„Å™„Åå„Çâ„ÄÅÊÆµÈöéÁöÑ„Å´ÂõûÂæ©„Åó„Å¶„ÅÑ„Åç„Åæ„Åô„ÄÇ'
    ];

    // „Ç®„É©„Éº„ÅÆÁâπÊÄß„Å´Âøú„Åò„Å¶„Ç¨„Ç§„ÉÄ„É≥„Çπ„Çí„Ç´„Çπ„Çø„Éû„Ç§„Ç∫
    if (error.context.hexagramId) {
      const hexagramGuidance = this.getHexagramSpecificGuidance(error.context.hexagramId);
      guidance.unshift(hexagramGuidance);
    }

    return guidance.join(' ');
  }

  private getHexagramSpecificGuidance(hexagramId: number): string {
    // ÁâπÂÆö„ÅÆÂç¶„Å´Âü∫„Å•„ÅÑ„Åü„Ç¨„Ç§„ÉÄ„É≥„ÇπÁîüÊàê
    const guidanceMap: { [key: number]: string } = {
      1: '‰πæÁÇ∫Â§© - ÂâµÈÄ†ÁöÑ„Å™Âäõ„ÅßÂõ∞Èõ£„Çí‰πó„ÇäË∂ä„Åà„Åæ„Åô',
      2: 'Âù§ÁÇ∫Âú∞ - ÂèóÂÆπÊÄß„Å®ÂøçËÄê„ÅßÁä∂Ê≥Å„ÇíÊîπÂñÑ„Åó„Åæ„Åô',
      3: 'Ê∞¥Èõ∑Â±Ø - ÂàùÊúü„ÅÆÂõ∞Èõ£„ÅØÊàêÈï∑„ÅÆÂÖÜ„Åó„Åß„Åô',
      // ... 64Âç¶ÂÖ®„Å¶„ÅÆ guidance mapping
    };

    return guidanceMap[hexagramId] || 'ÁèæÂú®„ÅÆÁä∂Ê≥Å„Å´ÈÅ©„Åó„ÅüÂØæÂøú„ÇíÊ®°Á¥¢„Åó„Åæ„Åô';
  }
}
```

---

## üìä Interface Types

```typescript
// Core interfaces for the error handling system

export interface ErrorHandlerOptions {
  enablePhilosophyValidation?: boolean;
  enableRecovery?: boolean;
  enableAnalytics?: boolean;
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
  performanceThreshold?: number;
  maxRecoveryAttempts?: number;
  cacheEnabled?: boolean;
}

export interface ErrorContext {
  operation?: string;
  hexagramId?: number;
  personaState?: string;
  osLayer?: 'engine' | 'interface' | 'safe-mode';
  userAction?: string;
  timestamp?: number;
  sessionId?: string;
  userId?: string;
  [key: string]: any;
}

export interface CapturedError {
  id: string;
  originalError: Error;
  context: ErrorContext;
  captureTime: number;
  stackTrace?: ParsedStackTrace;
  executionContext?: ExecutionContext;
}

export interface ClassifiedError {
  error: CapturedError;
  baseClassification: BaseClassification;
  philosophyClassification: PhilosophyClassification;
  contextualClassification: ContextualClassification;
  severityAssessment: SeverityAssessment;
  classificationTime: number;
  confidence: number;
}

export interface PhilosophyCheck {
  ichingIntegrity: IChingIntegrityCheck;
  bunenjinConsistency: BunenjinConsistencyCheck;
  tripleOSArchitecture: TripleOSArchitectureCheck;
  overallAlignment: number;
  violatedPrinciples: string[];
  guidanceRequired: boolean;
  validationTime: number;
}

export interface RecoveryResult {
  success: boolean;
  message: string;
  philosophyGuidance?: string;
  functionalityLevel: 'full' | 'reduced' | 'safe-mode' | 'none';
  estimatedRecoveryTime: number;
  executionDuration?: number;
  data?: any;
  nextSteps?: string[];
  error?: Error;
}

export interface ErrorHandlingResult {
  success: boolean;
  errorId: string;
  classification: ClassifiedError;
  recoveryResult: RecoveryResult;
  philosophyCheck: PhilosophyCheck;
  handlingDuration: number;
  timestamp: string;
}

// Philosophy-specific interfaces
export interface IChingIntegrityCheck {
  hexagramConsistency: boolean;
  sequenceLogic: SequenceLogicCheck;
  transformationPrinciples: TransformationCheck;
  elementalBalance: ElementalBalanceCheck;
  overallIntegrity: number;
  violatedPrinciples: string[];
  recommendedActions: string[];
}

export interface BunenjinConsistencyCheck {
  personaState: PersonaState;
  navigationConsistency: NavigationConsistencyCheck;
  contextualAppropriateness: ContextualAppropriatenessCheck;
  adaptationPotential: AdaptationPotentialCheck;
  overallConsistency: number;
  violatedPrinciples: string[];
  recommendedPersonaShift?: PersonaTransition;
  guidanceMessage: string;
}

export interface TripleOSArchitectureCheck {
  currentState: TripleOSState;
  violations: ArchitectureViolation[];
  recommendedOSTransition?: OSTransition;
  safeModeRequired: boolean;
  recoveryPath: OSRecoveryPath;
  overallArchitectureHealth: number;
  violatedPrinciples: string[];
  architectureGuidance: string;
}

// Recovery-specific interfaces
export interface RecoveryStep {
  id: number;
  name: string;
  description: string;
  estimatedDuration: number;
  dependencies?: number[];
  optional?: boolean;
  philosophyGuidance?: string;
}

export interface StrategyMetadata {
  name: string;
  description: string;
  applicableErrorTypes: string[];
  expectedDuration: number;
  philosophyAlignment: PhilosophyAlignment;
  riskLevel: 'low' | 'medium' | 'high';
  successRate: number;
}

export interface PhilosophyAlignment {
  iching: number;
  bunenjin: number;
  tripleOS: number;
}

// Classification interfaces
export interface BaseClassification {
  category: string;
  subcategory: string;
  confidence: number;
  indicators: string[];
}

export interface PhilosophyClassification {
  ichingImpact: IChingImpact;
  bunenjinImpact: BunenjinImpact;
  tripleOSImpact: TripleOSImpact;
  overallPhilosophyImpact: number;
  requiresPhilosophyGuidance: boolean;
}

export interface SeverityAssessment {
  level: 'low' | 'medium' | 'high' | 'critical';
  score: number;
  factors: SeverityFactors;
  justification: string;
  escalationRequired: boolean;
}

// Analytics interfaces
export interface ErrorStatistics {
  totalErrors: number;
  errorsByCategory: { [key: string]: number };
  errorsByPhilosophy: PhilosophyErrorStats;
  recoverySuccessRate: number;
  averageRecoveryTime: number;
  timeRange: TimeRange;
  trends: ErrorTrends;
}

export interface TimeRange {
  start: Date;
  end: Date;
  label: string;
}

export interface ErrorTrends {
  errorRateChange: number;
  recoveryRateChange: number;
  philosophyAlignmentChange: number;
  predictedTrends: PredictedTrend[];
}
```

---

„Åì„ÅÆ„ÇØ„É©„ÇπË®≠Ë®à‰ªïÊßòÊõ∏„Å´„Çà„Çä„ÄÅHAQEI„Ç¢„Éä„É©„Ç§„Ç∂„Éº„ÅÆÁµ±‰∏Ä„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÅÆÂÆüË£Ö„Å´ÂøÖË¶Å„Å™ÂÖ®„Å¶„ÅÆ„ÇØ„É©„ÇπÊßãÈÄ†„ÄÅ„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÄÅ„Åä„Çà„Å≥Èñ¢‰øÇÊÄß„ÅåÊòéÁ¢∫„Å´ÂÆöÁæ©„Åï„Çå„Åæ„Åó„Åü„ÄÇÂêÑ„ÇØ„É©„Çπ„ÅØÂçò‰∏ÄË≤¨‰ªªÂéüÂâá„Å´Âæì„ÅÑ„ÄÅHAQEIÂì≤Â≠¶ÔºàÊòìÁµå„Éªbunenjin„ÉªTriple OSÔºâ„Å®„ÅÆÊï¥ÂêàÊÄß„Çí‰øù„Å°„Å™„Åå„Çâ„ÄÅÊã°ÂºµÊÄß„Å®‰øùÂÆàÊÄß„ÇíÁ¢∫‰øù„Åó„ÅüË®≠Ë®à„Å®„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ