# HAQEI 仮想人格生成システム実装計画書 v2.0

## 🎯 システムコンセプト

HAQEIは30問の設問を通じてユーザーの一部を切り出し、**仮想人格**として形成し、それを易経のメタファーで表現するシステムです。

### 核心設計
- 30問の回答から仮想人格を形成
- **Triple OS**として3つの側面を抽出
- **各OSは64卦のいずれか1つに対応**
- フィクションのキャラクターのような客観的視点を提供

## 🔯 Triple OS と易経マッピング

```
┌─────────────────────────────────────────────────────────┐
│                    30問の設問                            │
└──────────────────────┬──────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────┐
│               仮想人格の形成                             │
└──────────────────────┬──────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────────┐
│              Triple OS 生成                              │
├─────────────────────┼─────────────────────┼─────────────┤
│   Engine OS        │   Interface OS      │  SafeMode OS │
│   (価値観)         │   (社会的側面)      │  (防御機制)  │
│      ↓            │       ↓            │      ↓      │
│   64卦の1つ       │    64卦の1つ        │   64卦の1つ  │
│   例: ䷀ 乾       │    例: ䷁ 坤        │   例: ䷜ 坎  │
└─────────────────────┴─────────────────────┴─────────────┘
```

## 📊 OS→卦 マッピングアルゴリズム

### 1. Engine OS（価値観システム）判定
```javascript
// 内的動機・本質的価値観を表す設問群から算出
const engineQuestions = [
  // 価値観・信念・内的動機に関する設問
  q1, q5, q9, q13, q17, q21, q25, q29
];

// 8つの基本卦要素への変換
const engineTrigramScore = {
  乾: 創造性・主導性スコア,
  坤: 受容性・協調性スコア,
  震: 行動力・開拓性スコア,
  巽: 柔軟性・浸透性スコア,
  坎: 探求性・深層性スコア,
  離: 表現性・明晰性スコア,
  艮: 安定性・内省性スコア,
  兌: 喜悦性・交流性スコア
};

// 上卦・下卦の組み合わせで64卦の1つを決定
engineOS = calculate64Gua(engineTrigramScore);
```

### 2. Interface OS（社会的システム）判定
```javascript
// 対人関係・社会的振る舞いを表す設問群から算出
const interfaceQuestions = [
  // 社会的行動・対人関係に関する設問
  q2, q6, q10, q14, q18, q22, q26, q30
];

// 社会的特性の8要素スコア算出
// → 64卦の1つに変換
interfaceOS = calculate64Gua(interfaceTrigramScore);
```

### 3. SafeMode OS（防御システム）判定
```javascript
// ストレス反応・防御機制を表す設問群から算出
const safeModeQuestions = [
  // 困難時の反応・防御パターンに関する設問
  q3, q7, q11, q15, q19, q23, q27, // シナリオ設問含む
];

// 防御パターンの8要素スコア算出
// → 64卦の1つに変換
safeModeOS = calculate64Gua(safeModeTrigramScore);
```

## 🔧 実装タスクリスト

### Phase 1: OS→卦マッピングエンジン開発 (最優先)

#### Task 1.1: 設問分類システム
- [ ] 30問を3つのOS判定用に分類
- [ ] 各設問の重み付け設定
- [ ] スコアリングアルゴリズム実装

#### Task 1.2: 8卦要素スコアリング
- [ ] 各OSごとの8つの基本要素定義
- [ ] 設問回答→要素スコア変換ロジック
- [ ] スコア正規化アルゴリズム

#### Task 1.3: 64卦決定アルゴリズム
- [ ] 8要素スコア→上卦・下卦決定ロジック
- [ ] 64卦マッピングテーブル構築
- [ ] 境界値処理と安定性保証

### Phase 2: 仮想人格表現システム (高優先)

#### Task 2.1: Triple OS統合表現
- [ ] 3つの卦の相互関係分析
- [ ] 序卦伝による関係性説明生成
- [ ] 統合的な人格像の構築

#### Task 2.2: 易経メタファー生成
- [ ] 各OSの卦象による性格描写
- [ ] 爻辞を活用した詳細説明
- [ ] 変爻による成長可能性提示

### Phase 3: 高速分析エンジン (高優先)

#### Task 3.1: 並列処理実装
- [ ] 3つのOS判定の並列実行
- [ ] WebWorkerによる高速化
- [ ] プログレッシブ結果表示

#### Task 3.2: キャッシュ戦略
- [ ] 卦計算結果のキャッシュ
- [ ] 頻出パターンの事前計算
- [ ] メモリ効率的なデータ構造

### Phase 4: フィードバックUI開発 (中優先)

#### Task 4.1: Triple OS視覚化
- [ ] 3つの卦の視覚的表現
- [ ] 相互作用のアニメーション
- [ ] インタラクティブな探索

#### Task 4.2: 仮想人格プレゼンテーション
- [ ] キャラクター的な表現方法
- [ ] 客観視を促すデザイン
- [ ] 詳細情報の段階的開示

### Phase 5: HaQei哲学統合 (中優先)

#### Task 5.1: 7段階ナビゲーション実装
- [ ] OS分析を中心とした流れ
- [ ] Gap Visualizationの組み込み
- [ ] 成長への道筋提示

## 📐 技術仕様

### OS判定精度目標
- 各OS判定の一貫性: 95%以上
- 64卦マッピング精度: 98%以上
- 再現性: 同じ回答で同じ結果 100%

### パフォーマンス目標
- OS判定完了: 500ms以内
- 全体分析完了: 2秒以内
- メモリ使用量: 50MB以下

## 🚀 実装スケジュール

### Week 1-2: OS→卦マッピングエンジン
- 設問分類とスコアリングシステム
- 64卦決定アルゴリズム
- 単体テスト実装

### Week 3-4: 仮想人格表現システム
- Triple OS統合ロジック
- 易経メタファー生成
- 基本的なUI実装

### Week 5: パフォーマンス最適化
- 並列処理実装
- キャッシュシステム
- 負荷テスト

### Week 6: 統合とテスト
- HaQei哲学統合
- 総合テスト
- ドキュメント整備

## 🔄 Claude-Flow Hooks 実装パターン

```javascript
// 各フェーズでの必須フック使用
// Phase開始時
npx claude-flow@alpha hooks pre-task --description "Triple OS mapping implementation"

// ファイル作成・編集時
npx claude-flow@alpha hooks post-edit --file "TripleOSEngine.js" --memory-key "haqei/os-mapping/engine"

// 重要な判断時
npx claude-flow@alpha hooks notify --message "OS判定アルゴリズム: 8要素スコアリング方式採用"

// Phase完了時
npx claude-flow@alpha hooks post-task --task-id "os-mapping-phase1" --analyze-performance true
```

---

**作成日**: 2025-08-04  
**バージョン**: 2.0  
**重要更新**: 各OSが64卦の1つに対応する設計を明確化