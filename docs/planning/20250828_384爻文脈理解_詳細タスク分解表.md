# 384爻システム文脈理解実装 詳細タスク分解表

**文書番号**: HAQEI-TASK-003  
**作成日**: 2025年8月28日  
**担当**: 実装チーム向け  
**総工数見積**: Phase 1（2週間）、Phase 2（4週間）、Phase 3（8週間）

---

## 📋 Phase 1: 基本的文脈理解実装（2週間）

### Week 1: Kuromoji.js統合と形態素解析活用

#### Task 1-1: Kuromoji.js完全統合（2日）
**ファイル**: `/public/js/ai/TextTo384LinesBridge.js`
**行番号**: 100-150（constructor部分）

```javascript
// 実装内容
class TextTo384LinesBridge {
    async initializeKuromoji() {
        this.tokenizer = await new Promise((resolve, reject) => {
            kuromoji.builder({ dicPath: "/dict/" }).build((err, tokenizer) => {
                if (err) reject(err);
                else resolve(tokenizer);
            });
        });
        this.kuromojiReady = true;
    }
}
```

**チェックリスト**:
- [ ] Kuromoji辞書ファイルの配置確認
- [ ] 初期化エラーハンドリング実装
- [ ] フォールバック処理実装
- [ ] 初期化状態管理実装

#### Task 1-2: 形態素解析結果の構造化（1日）
**ファイル**: `/public/js/ai/MorphologicalAnalyzer.js`（新規作成）

```javascript
class MorphologicalAnalyzer {
    analyzeTokens(tokens) {
        return {
            nouns: tokens.filter(t => t.pos === '名詞'),
            verbs: tokens.filter(t => t.pos === '動詞'),
            adjectives: tokens.filter(t => t.pos === '形容詞'),
            particles: tokens.filter(t => t.pos === '助詞'),
            negations: this.findNegations(tokens)
        };
    }
    
    findNegations(tokens) {
        const negationPatterns = ['ない', 'ず', 'ぬ', 'まい'];
        return tokens.filter(t => 
            negationPatterns.includes(t.surface_form) ||
            t.pos_detail_1 === '非自立' && t.surface_form.includes('ない')
        );
    }
}
```

#### Task 1-3: 否定文検出システム（2日）
**ファイル**: `/public/js/ai/NegationDetector.js`（新規作成）

```javascript
class NegationDetector {
    detectNegation(tokens, targetIndex) {
        // 対象語句の後続5トークンをチェック
        const window = tokens.slice(targetIndex, targetIndex + 5);
        
        // 否定助動詞のチェック
        const hasNegation = window.some(t => 
            ['ない', 'ません', 'ず', 'ぬ'].includes(t.surface_form)
        );
        
        // 否定的文脈語のチェック
        const negativeContext = window.some(t =>
            ['疑問', '不安', '心配', '困難'].includes(t.surface_form)
        );
        
        return { hasNegation, negativeContext, confidence: 0.8 };
    }
}
```

**テストケース**:
```javascript
// test/negation-detection.test.js
const testCases = [
    { input: "リーダーになりたい", expected: false },
    { input: "リーダーになりたくない", expected: true },
    { input: "リーダーには向いていない", expected: true },
    { input: "リーダーシップに疑問を感じる", expected: true }
];
```

#### Task 1-4: 品詞情報活用スコアリング（2日）
**ファイル**: `/public/js/ai/TextTo384LinesBridge.js`
**行番号**: 1700-1750（スコアリング部分）

```javascript
calculateContextAwareScore(text, lineData) {
    const tokens = await this.tokenizer.tokenize(text);
    const analysis = this.morphAnalyzer.analyzeTokens(tokens);
    
    let score = 0;
    
    // 名詞の重要度スコアリング
    analysis.nouns.forEach(noun => {
        if (lineData.keywords.includes(noun.surface_form)) {
            score += 3; // 名詞は高重み
        }
    });
    
    // 動詞の意図スコアリング
    analysis.verbs.forEach(verb => {
        const baseForm = verb.basic_form;
        if (lineData.actionKeywords.includes(baseForm)) {
            score += 2;
        }
    });
    
    // 否定文の場合はスコア反転
    if (this.negationDetector.detectNegation(tokens)) {
        score *= -1;
    }
    
    return score;
}
```

### Week 2: 文脈ウィンドウと関係性理解

#### Task 1-5: 文脈ウィンドウ実装（2日）
**ファイル**: `/public/js/ai/ContextWindow.js`（新規作成）

```javascript
class ContextWindow {
    constructor(windowSize = 5) {
        this.windowSize = windowSize;
    }
    
    extractContext(tokens, targetIndex) {
        const before = tokens.slice(
            Math.max(0, targetIndex - this.windowSize),
            targetIndex
        );
        const after = tokens.slice(
            targetIndex + 1,
            Math.min(tokens.length, targetIndex + this.windowSize + 1)
        );
        
        return {
            before,
            target: tokens[targetIndex],
            after,
            hasNegationBefore: before.some(t => this.isNegation(t)),
            hasNegationAfter: after.some(t => this.isNegation(t))
        };
    }
}
```

#### Task 1-6: 係り受け基本解析（3日）
**ファイル**: `/public/js/ai/DependencyParser.js`（新規作成）

```javascript
class SimpleDependencyParser {
    parseBasicDependencies(tokens) {
        const dependencies = [];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // 主語の検出（〜は、〜が）
            if (['は', 'が'].includes(token.surface_form)) {
                if (i > 0) {
                    dependencies.push({
                        type: 'subject',
                        word: tokens[i-1].surface_form,
                        particle: token.surface_form
                    });
                }
            }
            
            // 目的語の検出（〜を）
            if (token.surface_form === 'を' && i > 0) {
                dependencies.push({
                    type: 'object',
                    word: tokens[i-1].surface_form
                });
            }
        }
        
        return dependencies;
    }
}
```

#### Task 1-7: 統合テストとバグ修正（2日）
**ファイル**: `/test/phase1-integration.test.js`（新規作成）

```javascript
describe('Phase 1 文脈理解統合テスト', () => {
    test('否定文を正しく認識する', async () => {
        const result = await analyzer.analyze("リーダーは向いていない");
        expect(result.negation).toBe(true);
        expect(result.score).toBeLessThan(0);
    });
    
    test('係り受けを基本的に理解する', async () => {
        const result = await analyzer.analyze("部下がリーダーになった");
        expect(result.subject).toBe("部下");
        expect(result.role).toBe("リーダー");
    });
});
```

---

## 📋 Phase 2: 意味理解とベクトル化（4週間）

### Week 3-4: Word2Vec簡易実装

#### Task 2-1: 日本語Word2Vecモデル準備（3日）
**ファイル**: `/public/js/ml/Word2VecLoader.js`（新規作成）

```javascript
class Word2VecLoader {
    async loadPretrainedModel() {
        // 事前学習済みモデルの読み込み
        const response = await fetch('/models/ja_word2vec_mini.json');
        this.vectors = await response.json();
        this.dimensions = 100; // 100次元ベクトル
    }
    
    getVector(word) {
        return this.vectors[word] || this.getRandomVector();
    }
    
    calculateSimilarity(word1, word2) {
        const vec1 = this.getVector(word1);
        const vec2 = this.getVector(word2);
        return this.cosineSimilarity(vec1, vec2);
    }
}
```

#### Task 2-2: 類義語辞書構築（2日）
**ファイル**: `/public/data/synonyms.json`（新規作成）
**ファイル**: `/public/js/ai/SynonymManager.js`（新規作成）

```javascript
class SynonymManager {
    constructor() {
        this.synonymGroups = {
            "リーダー": ["指導者", "統率者", "指揮官", "マネージャー", "長"],
            "チーム": ["組織", "グループ", "部署", "仲間", "メンバー"],
            "成長": ["向上", "発展", "進歩", "改善", "上達"]
        };
    }
    
    expandQuery(word) {
        for (const [key, synonyms] of Object.entries(this.synonymGroups)) {
            if (key === word || synonyms.includes(word)) {
                return [key, ...synonyms];
            }
        }
        return [word];
    }
}
```

#### Task 2-3: セマンティック類似度計算（3日）
**ファイル**: `/public/js/ai/SemanticAnalyzer.js`（新規作成）

```javascript
class SemanticAnalyzer {
    async analyzeSemanticSimilarity(text, lineData) {
        const textVectors = await this.textToVectors(text);
        const lineVectors = await this.getLineVectors(lineData);
        
        // ベクトル空間での距離計算
        const similarity = this.calculateVectorSimilarity(
            textVectors.average,
            lineVectors.average
        );
        
        // 重要語句の意味的一致度
        const keywordMatches = this.calculateKeywordSemantics(
            textVectors.keywords,
            lineVectors.keywords
        );
        
        return {
            overallSimilarity: similarity,
            keywordAlignment: keywordMatches,
            confidence: this.calculateConfidence(similarity, keywordMatches)
        };
    }
}
```

### Week 5-6: 文章構造理解

#### Task 2-4: 文章意図分類器（3日）
**ファイル**: `/public/js/ai/IntentClassifier.js`（新規作成）

```javascript
class IntentClassifier {
    classifyIntent(tokens) {
        const patterns = {
            願望: ['たい', 'ほしい', '望む', '希望'],
            疑問: ['か', 'だろう', 'かしら', 'かな'],
            否定: ['ない', 'ず', 'いけない', 'だめ'],
            過去: ['た', 'だった', 'ました'],
            未来: ['だろう', 'でしょう', 'つもり', '予定']
        };
        
        const detected = {};
        for (const [intent, keywords] of Object.entries(patterns)) {
            detected[intent] = tokens.some(t => 
                keywords.includes(t.surface_form) ||
                keywords.includes(t.basic_form)
            );
        }
        
        return detected;
    }
}
```

#### Task 2-5: 時制・モダリティ解析（2日）
**ファイル**: `/public/js/ai/TemporalAnalyzer.js`（新規作成）

```javascript
class TemporalAnalyzer {
    analyzeTense(tokens) {
        const tenseMarkers = {
            past: ['た', 'だった', 'ました', 'でした'],
            present: ['る', 'です', 'ます', 'だ', 'である'],
            future: ['だろう', 'でしょう', 'はず', 'つもり']
        };
        
        // 最後の動詞・形容詞の活用形を確認
        const predicates = tokens.filter(t => 
            ['動詞', '形容詞'].includes(t.pos)
        );
        
        if (predicates.length > 0) {
            const lastPredicate = predicates[predicates.length - 1];
            return this.detectTenseFromConjugation(lastPredicate);
        }
    }
}
```

#### Task 2-6: 感情極性の文脈判定（3日）
**ファイル**: `/public/js/ai/SentimentAnalyzer.js`（改修）

```javascript
class ContextualSentimentAnalyzer {
    analyzeSentimentWithContext(tokens, contextWindow) {
        let sentiment = 0;
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const context = contextWindow.extractContext(tokens, i);
            
            // 基本感情スコア
            let tokenSentiment = this.getBaseSentiment(token);
            
            // 否定による反転
            if (context.hasNegationAfter) {
                tokenSentiment *= -1;
            }
            
            // 強調語による増幅
            if (this.hasIntensifier(context.before)) {
                tokenSentiment *= 1.5;
            }
            
            sentiment += tokenSentiment;
        }
        
        return sentiment / tokens.length;
    }
}
```

---

## 📋 Phase 3: 高度な文脈理解（8週間）

### Week 7-10: TensorFlow.js統合

#### Task 3-1: TensorFlow.js環境構築（2日）
**ファイル**: `/public/js/ml/TFSetup.js`（新規作成）

```javascript
import * as tf from '@tensorflow/tfjs';

class TensorFlowSetup {
    async initialize() {
        // WebGLバックエンド設定
        await tf.setBackend('webgl');
        
        // モデル読み込み
        this.model = await tf.loadLayersModel('/models/ja_context_model.json');
        
        // ウォームアップ
        const dummy = tf.zeros([1, 128]);
        this.model.predict(dummy).dispose();
        dummy.dispose();
    }
}
```

#### Task 3-2: 文章埋め込みモデル（5日）
**ファイル**: `/public/js/ml/TextEmbedding.js`（新規作成）

```javascript
class TextEmbeddingModel {
    async embedText(text) {
        // トークン化
        const tokens = await this.tokenizer.encode(text);
        
        // パディング
        const padded = this.padSequence(tokens, 128);
        
        // テンソル化
        const input = tf.tensor2d([padded]);
        
        // 埋め込み取得
        const embedding = this.model.predict(input);
        
        // Float32Arrayに変換
        const vector = await embedding.array();
        
        // メモリ解放
        input.dispose();
        embedding.dispose();
        
        return vector[0];
    }
}
```

#### Task 3-3: 384爻専用ファインチューニング（5日）
**ファイル**: `/public/js/ml/FineTuning.js`（新規作成）

```javascript
class LineSpecificFineTuning {
    async fineTuneForLine(lineId, trainingData) {
        // 転移学習用レイヤー追加
        const baseModel = await tf.loadLayersModel('/models/base_model.json');
        
        const finetuneLayer = tf.layers.dense({
            units: 384,
            activation: 'softmax',
            name: 'line_classifier'
        });
        
        const input = baseModel.input;
        const output = finetuneLayer.apply(baseModel.layers[baseModel.layers.length - 2].output);
        
        const model = tf.model({ inputs: input, outputs: output });
        
        // 学習
        await model.fit(trainingData.x, trainingData.y, {
            epochs: 10,
            batchSize: 32,
            validationSplit: 0.2
        });
        
        return model;
    }
}
```

### Week 11-12: リアルタイム学習

#### Task 3-4: ユーザーフィードバック収集（3日）
**ファイル**: `/public/js/ml/FeedbackCollector.js`（新規作成）

```javascript
class FeedbackCollector {
    collectFeedback(input, prediction, userCorrection) {
        const feedback = {
            timestamp: Date.now(),
            input: input,
            predicted: prediction.lineId,
            corrected: userCorrection.lineId,
            confidence: prediction.confidence,
            features: this.extractFeatures(input)
        };
        
        // IndexedDBに保存
        this.saveFeedback(feedback);
        
        // バッチ学習キューに追加
        this.learningQueue.add(feedback);
        
        // 閾値超えたら学習開始
        if (this.learningQueue.size >= 100) {
            this.triggerBatchLearning();
        }
    }
}
```

#### Task 3-5: オンライン学習システム（4日）
**ファイル**: `/public/js/ml/OnlineLearning.js`（新規作成）

```javascript
class OnlineLearningSystem {
    async updateModel(feedbackBatch) {
        // 特徴量抽出
        const features = await this.extractBatchFeatures(feedbackBatch);
        const labels = this.extractLabels(feedbackBatch);
        
        // ミニバッチ学習
        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);
        
        // 既存モデルの更新
        await this.model.fit(xs, ys, {
            epochs: 1,
            batchSize: 32
        });
        
        // メモリ解放
        xs.dispose();
        ys.dispose();
        
        // モデル保存
        await this.saveUpdatedModel();
    }
}
```

#### Task 3-6: A/Bテストフレームワーク（3日）
**ファイル**: `/public/js/ml/ABTesting.js`（新規作成）

```javascript
class ABTestingFramework {
    async runTest(input) {
        const userId = this.getUserId();
        const variant = this.assignVariant(userId);
        
        let result;
        if (variant === 'A') {
            // 既存のキーワードマッチング
            result = await this.keywordAnalyzer.analyze(input);
        } else {
            // 新しい文脈理解
            result = await this.contextAnalyzer.analyze(input);
        }
        
        // 結果記録
        this.recordResult({
            variant,
            input,
            result,
            timestamp: Date.now()
        });
        
        return result;
    }
}
```

### Week 13-14: 最適化とデプロイ

#### Task 3-7: モデル圧縮（3日）
**ファイル**: `/public/js/ml/ModelCompression.js`（新規作成）

```javascript
class ModelCompressor {
    async compressModel(model) {
        // 量子化
        const quantized = await tf.quantization.quantize(model, {
            inputRange: [-1, 1],
            outputRange: [-1, 1]
        });
        
        // プルーニング
        const pruned = await this.pruneWeights(quantized, 0.1);
        
        // サイズ確認
        const originalSize = await this.getModelSize(model);
        const compressedSize = await this.getModelSize(pruned);
        
        console.log(`圧縮率: ${(compressedSize/originalSize * 100).toFixed(2)}%`);
        
        return pruned;
    }
}
```

#### Task 3-8: パフォーマンス最適化（2日）
**ファイル**: `/public/js/ai/PerformanceOptimizer.js`（新規作成）

```javascript
class PerformanceOptimizer {
    optimizeInference() {
        // バッチ処理
        this.batchSize = 10;
        this.batchQueue = [];
        this.batchTimeout = 50; // 50ms
        
        // キャッシュ戦略
        this.cache = new LRUCache(1000);
        
        // Web Worker活用
        this.worker = new Worker('/workers/ml-inference.js');
    }
    
    async predict(input) {
        // キャッシュチェック
        const cached = this.cache.get(input);
        if (cached) return cached;
        
        // バッチキューに追加
        return new Promise((resolve) => {
            this.batchQueue.push({ input, resolve });
            
            if (this.batchQueue.length >= this.batchSize) {
                this.processBatch();
            } else {
                this.scheduleBatch();
            }
        });
    }
}
```

#### Task 3-9: 統合テストとベンチマーク（3日）
**ファイル**: `/test/benchmark.js`（新規作成）

```javascript
class PerformanceBenchmark {
    async runBenchmark() {
        const testCases = this.loadTestCases(); // 1000件のテストケース
        
        console.log('=== ベンチマーク開始 ===');
        
        // 旧実装
        const oldStart = performance.now();
        const oldResults = await this.runOldImplementation(testCases);
        const oldTime = performance.now() - oldStart;
        
        // 新実装
        const newStart = performance.now();
        const newResults = await this.runNewImplementation(testCases);
        const newTime = performance.now() - newStart;
        
        // 精度比較
        const accuracy = this.compareAccuracy(oldResults, newResults);
        
        console.log(`旧実装: ${oldTime.toFixed(2)}ms`);
        console.log(`新実装: ${newTime.toFixed(2)}ms`);
        console.log(`速度向上: ${((oldTime/newTime - 1) * 100).toFixed(2)}%`);
        console.log(`精度向上: ${accuracy.improvement.toFixed(2)}%`);
    }
}
```

---

## 📊 進捗管理とマイルストーン

### Phase 1 マイルストーン（2週間）
- [ ] Week 1完了: Kuromoji完全統合、否定文検出
- [ ] Week 2完了: 係り受け解析、統合テスト

### Phase 2 マイルストーン（4週間）
- [ ] Week 4完了: Word2Vec統合
- [ ] Week 6完了: 文章構造理解

### Phase 3 マイルストーン（8週間）
- [ ] Week 10完了: TensorFlow.js統合
- [ ] Week 12完了: リアルタイム学習
- [ ] Week 14完了: 最適化とデプロイ

---

## 🧪 各フェーズの検証基準

### Phase 1 完了基準
```javascript
// 必須テストケース
const phase1Tests = [
    { input: "リーダーになりたくない", mustDetect: "negation" },
    { input: "部下がリーダーだ", mustDetect: "subject-not-self" },
    { accuracy: ">= 60%" }
];
```

### Phase 2 完了基準
```javascript
const phase2Tests = [
    { input: "指導者を目指す", mustMatch: "リーダー（類義語）" },
    { input: "昔はリーダーだった", mustDetect: "past-tense" },
    { accuracy: ">= 75%" }
];
```

### Phase 3 完了基準
```javascript
const phase3Tests = [
    { responseTime: "< 100ms" },
    { accuracy: ">= 85%" },
    { modelSize: "< 10MB" }
];
```

---

## 📝 実装優先順位

### 最優先（今すぐ着手）
1. Task 1-1: Kuromoji.js完全統合
2. Task 1-3: 否定文検出システム
3. Task 1-4: 品詞情報活用スコアリング

### 高優先（1週間以内）
4. Task 1-5: 文脈ウィンドウ実装
5. Task 2-2: 類義語辞書構築

### 中優先（2週間以内）
6. Task 2-3: セマンティック類似度計算
7. Task 2-4: 文章意図分類器

---

**文書完了** - 各タスクは独立して実装可能です。すぐに着手できます。