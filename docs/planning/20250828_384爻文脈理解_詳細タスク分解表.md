# 384çˆ»ã‚·ã‚¹ãƒ†ãƒ æ–‡è„ˆç†è§£å®Ÿè£… è©³ç´°ã‚¿ã‚¹ã‚¯åˆ†è§£è¡¨

**æ–‡æ›¸ç•ªå·**: HAQEI-TASK-003  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ28æ—¥  
**æ‹…å½“**: å®Ÿè£…ãƒãƒ¼ãƒ å‘ã‘  
**ç·å·¥æ•°è¦‹ç©**: Phase 1ï¼ˆ2é€±é–“ï¼‰ã€Phase 2ï¼ˆ4é€±é–“ï¼‰ã€Phase 3ï¼ˆ8é€±é–“ï¼‰

---

## ğŸ“‹ Phase 1: åŸºæœ¬çš„æ–‡è„ˆç†è§£å®Ÿè£…ï¼ˆ2é€±é–“ï¼‰

### Week 1: Kuromoji.jsçµ±åˆã¨å½¢æ…‹ç´ è§£ææ´»ç”¨

#### Task 1-1: Kuromoji.jså®Œå…¨çµ±åˆï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/TextTo384LinesBridge.js`
**è¡Œç•ªå·**: 100-150ï¼ˆconstructoréƒ¨åˆ†ï¼‰

```javascript
// å®Ÿè£…å†…å®¹
class TextTo384LinesBridge {
    async initializeKuromoji() {
        this.tokenizer = await new Promise((resolve, reject) => {
            kuromoji.builder({ dicPath: "/dict/" }).build((err, tokenizer) => {
                if (err) reject(err);
                else resolve(tokenizer);
            });
        });
        this.kuromojiReady = true;
    }
}
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] Kuromojiè¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®é…ç½®ç¢ºèª
- [ ] åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè£…
- [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å®Ÿè£…
- [ ] åˆæœŸåŒ–çŠ¶æ…‹ç®¡ç†å®Ÿè£…

#### Task 1-2: å½¢æ…‹ç´ è§£æçµæœã®æ§‹é€ åŒ–ï¼ˆ1æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/MorphologicalAnalyzer.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class MorphologicalAnalyzer {
    analyzeTokens(tokens) {
        return {
            nouns: tokens.filter(t => t.pos === 'åè©'),
            verbs: tokens.filter(t => t.pos === 'å‹•è©'),
            adjectives: tokens.filter(t => t.pos === 'å½¢å®¹è©'),
            particles: tokens.filter(t => t.pos === 'åŠ©è©'),
            negations: this.findNegations(tokens)
        };
    }
    
    findNegations(tokens) {
        const negationPatterns = ['ãªã„', 'ãš', 'ã¬', 'ã¾ã„'];
        return tokens.filter(t => 
            negationPatterns.includes(t.surface_form) ||
            t.pos_detail_1 === 'éè‡ªç«‹' && t.surface_form.includes('ãªã„')
        );
    }
}
```

#### Task 1-3: å¦å®šæ–‡æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/NegationDetector.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class NegationDetector {
    detectNegation(tokens, targetIndex) {
        // å¯¾è±¡èªå¥ã®å¾Œç¶š5ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
        const window = tokens.slice(targetIndex, targetIndex + 5);
        
        // å¦å®šåŠ©å‹•è©ã®ãƒã‚§ãƒƒã‚¯
        const hasNegation = window.some(t => 
            ['ãªã„', 'ã¾ã›ã‚“', 'ãš', 'ã¬'].includes(t.surface_form)
        );
        
        // å¦å®šçš„æ–‡è„ˆèªã®ãƒã‚§ãƒƒã‚¯
        const negativeContext = window.some(t =>
            ['ç–‘å•', 'ä¸å®‰', 'å¿ƒé…', 'å›°é›£'].includes(t.surface_form)
        );
        
        return { hasNegation, negativeContext, confidence: 0.8 };
    }
}
```

**ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹**:
```javascript
// test/negation-detection.test.js
const testCases = [
    { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„", expected: false },
    { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸããªã„", expected: true },
    { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ã¯å‘ã„ã¦ã„ãªã„", expected: true },
    { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã«ç–‘å•ã‚’æ„Ÿã˜ã‚‹", expected: true }
];
```

#### Task 1-4: å“è©æƒ…å ±æ´»ç”¨ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/TextTo384LinesBridge.js`
**è¡Œç•ªå·**: 1700-1750ï¼ˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°éƒ¨åˆ†ï¼‰

```javascript
calculateContextAwareScore(text, lineData) {
    const tokens = await this.tokenizer.tokenize(text);
    const analysis = this.morphAnalyzer.analyzeTokens(tokens);
    
    let score = 0;
    
    // åè©ã®é‡è¦åº¦ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
    analysis.nouns.forEach(noun => {
        if (lineData.keywords.includes(noun.surface_form)) {
            score += 3; // åè©ã¯é«˜é‡ã¿
        }
    });
    
    // å‹•è©ã®æ„å›³ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
    analysis.verbs.forEach(verb => {
        const baseForm = verb.basic_form;
        if (lineData.actionKeywords.includes(baseForm)) {
            score += 2;
        }
    });
    
    // å¦å®šæ–‡ã®å ´åˆã¯ã‚¹ã‚³ã‚¢åè»¢
    if (this.negationDetector.detectNegation(tokens)) {
        score *= -1;
    }
    
    return score;
}
```

### Week 2: æ–‡è„ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã¨é–¢ä¿‚æ€§ç†è§£

#### Task 1-5: æ–‡è„ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å®Ÿè£…ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/ContextWindow.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class ContextWindow {
    constructor(windowSize = 5) {
        this.windowSize = windowSize;
    }
    
    extractContext(tokens, targetIndex) {
        const before = tokens.slice(
            Math.max(0, targetIndex - this.windowSize),
            targetIndex
        );
        const after = tokens.slice(
            targetIndex + 1,
            Math.min(tokens.length, targetIndex + this.windowSize + 1)
        );
        
        return {
            before,
            target: tokens[targetIndex],
            after,
            hasNegationBefore: before.some(t => this.isNegation(t)),
            hasNegationAfter: after.some(t => this.isNegation(t))
        };
    }
}
```

#### Task 1-6: ä¿‚ã‚Šå—ã‘åŸºæœ¬è§£æï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/DependencyParser.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class SimpleDependencyParser {
    parseBasicDependencies(tokens) {
        const dependencies = [];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // ä¸»èªã®æ¤œå‡ºï¼ˆã€œã¯ã€ã€œãŒï¼‰
            if (['ã¯', 'ãŒ'].includes(token.surface_form)) {
                if (i > 0) {
                    dependencies.push({
                        type: 'subject',
                        word: tokens[i-1].surface_form,
                        particle: token.surface_form
                    });
                }
            }
            
            // ç›®çš„èªã®æ¤œå‡ºï¼ˆã€œã‚’ï¼‰
            if (token.surface_form === 'ã‚’' && i > 0) {
                dependencies.push({
                    type: 'object',
                    word: tokens[i-1].surface_form
                });
            }
        }
        
        return dependencies;
    }
}
```

#### Task 1-7: çµ±åˆãƒ†ã‚¹ãƒˆã¨ãƒã‚°ä¿®æ­£ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/test/phase1-integration.test.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
describe('Phase 1 æ–‡è„ˆç†è§£çµ±åˆãƒ†ã‚¹ãƒˆ', () => {
    test('å¦å®šæ–‡ã‚’æ­£ã—ãèªè­˜ã™ã‚‹', async () => {
        const result = await analyzer.analyze("ãƒªãƒ¼ãƒ€ãƒ¼ã¯å‘ã„ã¦ã„ãªã„");
        expect(result.negation).toBe(true);
        expect(result.score).toBeLessThan(0);
    });
    
    test('ä¿‚ã‚Šå—ã‘ã‚’åŸºæœ¬çš„ã«ç†è§£ã™ã‚‹', async () => {
        const result = await analyzer.analyze("éƒ¨ä¸‹ãŒãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã£ãŸ");
        expect(result.subject).toBe("éƒ¨ä¸‹");
        expect(result.role).toBe("ãƒªãƒ¼ãƒ€ãƒ¼");
    });
});
```

---

## ğŸ“‹ Phase 2: æ„å‘³ç†è§£ã¨ãƒ™ã‚¯ãƒˆãƒ«åŒ–ï¼ˆ4é€±é–“ï¼‰

### Week 3-4: Word2Vecç°¡æ˜“å®Ÿè£…

#### Task 2-1: æ—¥æœ¬èªWord2Vecãƒ¢ãƒ‡ãƒ«æº–å‚™ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/Word2VecLoader.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class Word2VecLoader {
    async loadPretrainedModel() {
        // äº‹å‰å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿
        const response = await fetch('/models/ja_word2vec_mini.json');
        this.vectors = await response.json();
        this.dimensions = 100; // 100æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
    }
    
    getVector(word) {
        return this.vectors[word] || this.getRandomVector();
    }
    
    calculateSimilarity(word1, word2) {
        const vec1 = this.getVector(word1);
        const vec2 = this.getVector(word2);
        return this.cosineSimilarity(vec1, vec2);
    }
}
```

#### Task 2-2: é¡ç¾©èªè¾æ›¸æ§‹ç¯‰ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/data/synonyms.json`ï¼ˆæ–°è¦ä½œæˆï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/SynonymManager.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class SynonymManager {
    constructor() {
        this.synonymGroups = {
            "ãƒªãƒ¼ãƒ€ãƒ¼": ["æŒ‡å°è€…", "çµ±ç‡è€…", "æŒ‡æ®å®˜", "ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼", "é•·"],
            "ãƒãƒ¼ãƒ ": ["çµ„ç¹”", "ã‚°ãƒ«ãƒ¼ãƒ—", "éƒ¨ç½²", "ä»²é–“", "ãƒ¡ãƒ³ãƒãƒ¼"],
            "æˆé•·": ["å‘ä¸Š", "ç™ºå±•", "é€²æ­©", "æ”¹å–„", "ä¸Šé”"]
        };
    }
    
    expandQuery(word) {
        for (const [key, synonyms] of Object.entries(this.synonymGroups)) {
            if (key === word || synonyms.includes(word)) {
                return [key, ...synonyms];
            }
        }
        return [word];
    }
}
```

#### Task 2-3: ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯é¡ä¼¼åº¦è¨ˆç®—ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/SemanticAnalyzer.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class SemanticAnalyzer {
    async analyzeSemanticSimilarity(text, lineData) {
        const textVectors = await this.textToVectors(text);
        const lineVectors = await this.getLineVectors(lineData);
        
        // ãƒ™ã‚¯ãƒˆãƒ«ç©ºé–“ã§ã®è·é›¢è¨ˆç®—
        const similarity = this.calculateVectorSimilarity(
            textVectors.average,
            lineVectors.average
        );
        
        // é‡è¦èªå¥ã®æ„å‘³çš„ä¸€è‡´åº¦
        const keywordMatches = this.calculateKeywordSemantics(
            textVectors.keywords,
            lineVectors.keywords
        );
        
        return {
            overallSimilarity: similarity,
            keywordAlignment: keywordMatches,
            confidence: this.calculateConfidence(similarity, keywordMatches)
        };
    }
}
```

### Week 5-6: æ–‡ç« æ§‹é€ ç†è§£

#### Task 2-4: æ–‡ç« æ„å›³åˆ†é¡å™¨ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/IntentClassifier.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class IntentClassifier {
    classifyIntent(tokens) {
        const patterns = {
            é¡˜æœ›: ['ãŸã„', 'ã»ã—ã„', 'æœ›ã‚€', 'å¸Œæœ›'],
            ç–‘å•: ['ã‹', 'ã ã‚ã†', 'ã‹ã—ã‚‰', 'ã‹ãª'],
            å¦å®š: ['ãªã„', 'ãš', 'ã„ã‘ãªã„', 'ã ã‚'],
            éå»: ['ãŸ', 'ã ã£ãŸ', 'ã¾ã—ãŸ'],
            æœªæ¥: ['ã ã‚ã†', 'ã§ã—ã‚‡ã†', 'ã¤ã‚‚ã‚Š', 'äºˆå®š']
        };
        
        const detected = {};
        for (const [intent, keywords] of Object.entries(patterns)) {
            detected[intent] = tokens.some(t => 
                keywords.includes(t.surface_form) ||
                keywords.includes(t.basic_form)
            );
        }
        
        return detected;
    }
}
```

#### Task 2-5: æ™‚åˆ¶ãƒ»ãƒ¢ãƒ€ãƒªãƒ†ã‚£è§£æï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/TemporalAnalyzer.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class TemporalAnalyzer {
    analyzeTense(tokens) {
        const tenseMarkers = {
            past: ['ãŸ', 'ã ã£ãŸ', 'ã¾ã—ãŸ', 'ã§ã—ãŸ'],
            present: ['ã‚‹', 'ã§ã™', 'ã¾ã™', 'ã ', 'ã§ã‚ã‚‹'],
            future: ['ã ã‚ã†', 'ã§ã—ã‚‡ã†', 'ã¯ãš', 'ã¤ã‚‚ã‚Š']
        };
        
        // æœ€å¾Œã®å‹•è©ãƒ»å½¢å®¹è©ã®æ´»ç”¨å½¢ã‚’ç¢ºèª
        const predicates = tokens.filter(t => 
            ['å‹•è©', 'å½¢å®¹è©'].includes(t.pos)
        );
        
        if (predicates.length > 0) {
            const lastPredicate = predicates[predicates.length - 1];
            return this.detectTenseFromConjugation(lastPredicate);
        }
    }
}
```

#### Task 2-6: æ„Ÿæƒ…æ¥µæ€§ã®æ–‡è„ˆåˆ¤å®šï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/SentimentAnalyzer.js`ï¼ˆæ”¹ä¿®ï¼‰

```javascript
class ContextualSentimentAnalyzer {
    analyzeSentimentWithContext(tokens, contextWindow) {
        let sentiment = 0;
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            const context = contextWindow.extractContext(tokens, i);
            
            // åŸºæœ¬æ„Ÿæƒ…ã‚¹ã‚³ã‚¢
            let tokenSentiment = this.getBaseSentiment(token);
            
            // å¦å®šã«ã‚ˆã‚‹åè»¢
            if (context.hasNegationAfter) {
                tokenSentiment *= -1;
            }
            
            // å¼·èª¿èªã«ã‚ˆã‚‹å¢—å¹…
            if (this.hasIntensifier(context.before)) {
                tokenSentiment *= 1.5;
            }
            
            sentiment += tokenSentiment;
        }
        
        return sentiment / tokens.length;
    }
}
```

---

## ğŸ“‹ Phase 3: é«˜åº¦ãªæ–‡è„ˆç†è§£ï¼ˆ8é€±é–“ï¼‰

### Week 7-10: TensorFlow.jsçµ±åˆ

#### Task 3-1: TensorFlow.jsç’°å¢ƒæ§‹ç¯‰ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/TFSetup.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
import * as tf from '@tensorflow/tfjs';

class TensorFlowSetup {
    async initialize() {
        // WebGLãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰è¨­å®š
        await tf.setBackend('webgl');
        
        // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
        this.model = await tf.loadLayersModel('/models/ja_context_model.json');
        
        // ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—
        const dummy = tf.zeros([1, 128]);
        this.model.predict(dummy).dispose();
        dummy.dispose();
    }
}
```

#### Task 3-2: æ–‡ç« åŸ‹ã‚è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ï¼ˆ5æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/TextEmbedding.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class TextEmbeddingModel {
    async embedText(text) {
        // ãƒˆãƒ¼ã‚¯ãƒ³åŒ–
        const tokens = await this.tokenizer.encode(text);
        
        // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
        const padded = this.padSequence(tokens, 128);
        
        // ãƒ†ãƒ³ã‚½ãƒ«åŒ–
        const input = tf.tensor2d([padded]);
        
        // åŸ‹ã‚è¾¼ã¿å–å¾—
        const embedding = this.model.predict(input);
        
        // Float32Arrayã«å¤‰æ›
        const vector = await embedding.array();
        
        // ãƒ¡ãƒ¢ãƒªè§£æ”¾
        input.dispose();
        embedding.dispose();
        
        return vector[0];
    }
}
```

#### Task 3-3: 384çˆ»å°‚ç”¨ãƒ•ã‚¡ã‚¤ãƒ³ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ï¼ˆ5æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/FineTuning.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class LineSpecificFineTuning {
    async fineTuneForLine(lineId, trainingData) {
        // è»¢ç§»å­¦ç¿’ç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ 
        const baseModel = await tf.loadLayersModel('/models/base_model.json');
        
        const finetuneLayer = tf.layers.dense({
            units: 384,
            activation: 'softmax',
            name: 'line_classifier'
        });
        
        const input = baseModel.input;
        const output = finetuneLayer.apply(baseModel.layers[baseModel.layers.length - 2].output);
        
        const model = tf.model({ inputs: input, outputs: output });
        
        // å­¦ç¿’
        await model.fit(trainingData.x, trainingData.y, {
            epochs: 10,
            batchSize: 32,
            validationSplit: 0.2
        });
        
        return model;
    }
}
```

### Week 11-12: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å­¦ç¿’

#### Task 3-4: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/FeedbackCollector.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class FeedbackCollector {
    collectFeedback(input, prediction, userCorrection) {
        const feedback = {
            timestamp: Date.now(),
            input: input,
            predicted: prediction.lineId,
            corrected: userCorrection.lineId,
            confidence: prediction.confidence,
            features: this.extractFeatures(input)
        };
        
        // IndexedDBã«ä¿å­˜
        this.saveFeedback(feedback);
        
        // ãƒãƒƒãƒå­¦ç¿’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
        this.learningQueue.add(feedback);
        
        // é–¾å€¤è¶…ãˆãŸã‚‰å­¦ç¿’é–‹å§‹
        if (this.learningQueue.size >= 100) {
            this.triggerBatchLearning();
        }
    }
}
```

#### Task 3-5: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ4æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/OnlineLearning.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class OnlineLearningSystem {
    async updateModel(feedbackBatch) {
        // ç‰¹å¾´é‡æŠ½å‡º
        const features = await this.extractBatchFeatures(feedbackBatch);
        const labels = this.extractLabels(feedbackBatch);
        
        // ãƒŸãƒ‹ãƒãƒƒãƒå­¦ç¿’
        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);
        
        // æ—¢å­˜ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
        await this.model.fit(xs, ys, {
            epochs: 1,
            batchSize: 32
        });
        
        // ãƒ¡ãƒ¢ãƒªè§£æ”¾
        xs.dispose();
        ys.dispose();
        
        // ãƒ¢ãƒ‡ãƒ«ä¿å­˜
        await this.saveUpdatedModel();
    }
}
```

#### Task 3-6: A/Bãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/ABTesting.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class ABTestingFramework {
    async runTest(input) {
        const userId = this.getUserId();
        const variant = this.assignVariant(userId);
        
        let result;
        if (variant === 'A') {
            // æ—¢å­˜ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°
            result = await this.keywordAnalyzer.analyze(input);
        } else {
            // æ–°ã—ã„æ–‡è„ˆç†è§£
            result = await this.contextAnalyzer.analyze(input);
        }
        
        // çµæœè¨˜éŒ²
        this.recordResult({
            variant,
            input,
            result,
            timestamp: Date.now()
        });
        
        return result;
    }
}
```

### Week 13-14: æœ€é©åŒ–ã¨ãƒ‡ãƒ—ãƒ­ã‚¤

#### Task 3-7: ãƒ¢ãƒ‡ãƒ«åœ§ç¸®ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/ModelCompression.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class ModelCompressor {
    async compressModel(model) {
        // é‡å­åŒ–
        const quantized = await tf.quantization.quantize(model, {
            inputRange: [-1, 1],
            outputRange: [-1, 1]
        });
        
        // ãƒ—ãƒ«ãƒ¼ãƒ‹ãƒ³ã‚°
        const pruned = await this.pruneWeights(quantized, 0.1);
        
        // ã‚µã‚¤ã‚ºç¢ºèª
        const originalSize = await this.getModelSize(model);
        const compressedSize = await this.getModelSize(pruned);
        
        console.log(`åœ§ç¸®ç‡: ${(compressedSize/originalSize * 100).toFixed(2)}%`);
        
        return pruned;
    }
}
```

#### Task 3-8: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/PerformanceOptimizer.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class PerformanceOptimizer {
    optimizeInference() {
        // ãƒãƒƒãƒå‡¦ç†
        this.batchSize = 10;
        this.batchQueue = [];
        this.batchTimeout = 50; // 50ms
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
        this.cache = new LRUCache(1000);
        
        // Web Workeræ´»ç”¨
        this.worker = new Worker('/workers/ml-inference.js');
    }
    
    async predict(input) {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        const cached = this.cache.get(input);
        if (cached) return cached;
        
        // ãƒãƒƒãƒã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
        return new Promise((resolve) => {
            this.batchQueue.push({ input, resolve });
            
            if (this.batchQueue.length >= this.batchSize) {
                this.processBatch();
            } else {
                this.scheduleBatch();
            }
        });
    }
}
```

#### Task 3-9: çµ±åˆãƒ†ã‚¹ãƒˆã¨ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/test/benchmark.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class PerformanceBenchmark {
    async runBenchmark() {
        const testCases = this.loadTestCases(); // 1000ä»¶ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        
        console.log('=== ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹ ===');
        
        // æ—§å®Ÿè£…
        const oldStart = performance.now();
        const oldResults = await this.runOldImplementation(testCases);
        const oldTime = performance.now() - oldStart;
        
        // æ–°å®Ÿè£…
        const newStart = performance.now();
        const newResults = await this.runNewImplementation(testCases);
        const newTime = performance.now() - newStart;
        
        // ç²¾åº¦æ¯”è¼ƒ
        const accuracy = this.compareAccuracy(oldResults, newResults);
        
        console.log(`æ—§å®Ÿè£…: ${oldTime.toFixed(2)}ms`);
        console.log(`æ–°å®Ÿè£…: ${newTime.toFixed(2)}ms`);
        console.log(`é€Ÿåº¦å‘ä¸Š: ${((oldTime/newTime - 1) * 100).toFixed(2)}%`);
        console.log(`ç²¾åº¦å‘ä¸Š: ${accuracy.improvement.toFixed(2)}%`);
    }
}
```

---

## ğŸ“Š é€²æ—ç®¡ç†ã¨ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³

### Phase 1 ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ï¼ˆ2é€±é–“ï¼‰
- [ ] Week 1å®Œäº†: Kuromojiå®Œå…¨çµ±åˆã€å¦å®šæ–‡æ¤œå‡º
- [ ] Week 2å®Œäº†: ä¿‚ã‚Šå—ã‘è§£æã€çµ±åˆãƒ†ã‚¹ãƒˆ

### Phase 2 ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ï¼ˆ4é€±é–“ï¼‰
- [ ] Week 4å®Œäº†: Word2Vecçµ±åˆ
- [ ] Week 6å®Œäº†: æ–‡ç« æ§‹é€ ç†è§£

### Phase 3 ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ï¼ˆ8é€±é–“ï¼‰
- [ ] Week 10å®Œäº†: TensorFlow.jsçµ±åˆ
- [ ] Week 12å®Œäº†: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å­¦ç¿’
- [ ] Week 14å®Œäº†: æœ€é©åŒ–ã¨ãƒ‡ãƒ—ãƒ­ã‚¤

---

## ğŸ§ª å„ãƒ•ã‚§ãƒ¼ã‚ºã®æ¤œè¨¼åŸºæº–

### Phase 1 å®Œäº†åŸºæº–
```javascript
// å¿…é ˆãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
const phase1Tests = [
    { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸããªã„", mustDetect: "negation" },
    { input: "éƒ¨ä¸‹ãŒãƒªãƒ¼ãƒ€ãƒ¼ã ", mustDetect: "subject-not-self" },
    { accuracy: ">= 60%" }
];
```

### Phase 2 å®Œäº†åŸºæº–
```javascript
const phase2Tests = [
    { input: "æŒ‡å°è€…ã‚’ç›®æŒ‡ã™", mustMatch: "ãƒªãƒ¼ãƒ€ãƒ¼ï¼ˆé¡ç¾©èªï¼‰" },
    { input: "æ˜”ã¯ãƒªãƒ¼ãƒ€ãƒ¼ã ã£ãŸ", mustDetect: "past-tense" },
    { accuracy: ">= 75%" }
];
```

### Phase 3 å®Œäº†åŸºæº–
```javascript
const phase3Tests = [
    { responseTime: "< 100ms" },
    { accuracy: ">= 85%" },
    { modelSize: "< 10MB" }
];
```

---

## ğŸ“ å®Ÿè£…å„ªå…ˆé †ä½

### æœ€å„ªå…ˆï¼ˆä»Šã™ãç€æ‰‹ï¼‰
1. Task 1-1: Kuromoji.jså®Œå…¨çµ±åˆ
2. Task 1-3: å¦å®šæ–‡æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ 
3. Task 1-4: å“è©æƒ…å ±æ´»ç”¨ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°

### é«˜å„ªå…ˆï¼ˆ1é€±é–“ä»¥å†…ï¼‰
4. Task 1-5: æ–‡è„ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å®Ÿè£…
5. Task 2-2: é¡ç¾©èªè¾æ›¸æ§‹ç¯‰

### ä¸­å„ªå…ˆï¼ˆ2é€±é–“ä»¥å†…ï¼‰
6. Task 2-3: ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯é¡ä¼¼åº¦è¨ˆç®—
7. Task 2-4: æ–‡ç« æ„å›³åˆ†é¡å™¨

---

**æ–‡æ›¸å®Œäº†** - å„ã‚¿ã‚¹ã‚¯ã¯ç‹¬ç«‹ã—ã¦å®Ÿè£…å¯èƒ½ã§ã™ã€‚ã™ãã«ç€æ‰‹ã§ãã¾ã™ã€‚