# 384çˆ»ã‚·ã‚¹ãƒ†ãƒ æ–‡è„ˆç†è§£å®Ÿè£… è©³ç´°ã‚¿ã‚¹ã‚¯åˆ†è§£è¡¨ v2ï¼ˆä¿®æ­£ç‰ˆï¼‰

**æ–‡æ›¸ç•ªå·**: HAQEI-TASK-003-v2  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ28æ—¥  
**æ”¹è¨‚**: ãƒ¬ãƒ“ãƒ¥ãƒ¼æŒ‡æ‘˜äº‹é …åæ˜ ç‰ˆ  
**æ‹…å½“**: å®Ÿè£…ãƒãƒ¼ãƒ å‘ã‘  
**ç·å·¥æ•°è¦‹ç©**: Phase 0ï¼ˆ1é€±é–“ï¼‰ã€Phase 1ï¼ˆ2é€±é–“ï¼‰ã€Phase 2ï¼ˆ4é€±é–“ï¼‰ã€Phase 3ï¼ˆ8é€±é–“ï¼‰

---

## ğŸš¨ é‡è¦ãªå‰ææ¡ä»¶ã¨åˆ¶ç´„

### æ€§èƒ½ç›®æ¨™ï¼ˆç¾å®Ÿçš„ãªå€¤ã«ä¿®æ­£ï¼‰
```javascript
// âŒ æ—§: éç¾å®Ÿçš„ãªç›®æ¨™
// expect(avg).toBeLessThan(5);  

// âœ… æ–°: Edgeç’°å¢ƒã§å®Ÿç¾å¯èƒ½ãªç›®æ¨™
const performanceTargets = {
    e2e_average: 40,    // 40msä»¥ä¸‹ï¼ˆEdgeåˆ¶ç´„è€ƒæ…®ï¼‰
    e2e_p50: 35,        // ä¸­å¤®å€¤35ms
    e2e_p95: 45,        // 95ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«45ms
    e2e_p99: 50,        // 99ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«50ms
    memory_usage: 120   // 120MBä»¥ä¸‹ï¼ˆEdgeåˆ¶ç´„128MBï¼‰
};
```

### å…±é€šDoDï¼ˆDefinition of Doneï¼‰
```javascript
const commonDoD = {
    unitTest: {
        coverage: 80,           // åˆ†å²ç¶²ç¾…80%ä»¥ä¸Š
        allTestsPass: true      // å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼
    },
    performance: {
        p95_latency: 45,        // p95ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·45msä»¥å†…
        memory: 120             // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡120MBä»¥å†…
    },
    determinism: {
        sameInputSameOutput: 100,  // åŒä¸€å…¥åŠ›=åŒä¸€å‡ºåŠ›100%
        fixedSeedReproducibility: true
    },
    distribution: {
        maxPositionBias: 30,    // ã©ã®çˆ»ä½ç½®ã‚‚30%ã‚’è¶…ãˆãªã„
        chiSquareTest: true     // Ï‡Â²æ¤œå®šåˆæ ¼
    },
    monitoring: {
        metricsLogged: true,    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²å®Ÿè£…
        alertsConfigured: true  // ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šæ¸ˆã¿
    }
};
```

---

## ğŸ“‹ Phase 0: Pre-flight ãƒã‚§ãƒƒã‚¯ï¼ˆæ–°è¨­ãƒ»1é€±é–“ï¼‰

### Week 0: ãƒ‡ãƒ¼ã‚¿å‰ææ¡ä»¶ã®æ¤œè¨¼ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æº–å‚™

#### Task 0-1: ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèªã¨ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/scripts/data-preflight-check.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ æœ€å„ªå…ˆï¼ˆå…¨ä½œæ¥­ã®å‰æï¼‰

```javascript
class DataPreflightCheck {
    async validateDataDependencies() {
        const requiredFiles = [
            {
                path: '/data/enhanced_hexagrams_complete.json',
                schema: {
                    type: 'array',
                    items: {
                        hexagram_id: 'number',
                        name_ja: 'string',
                        yao_lines: 'array'
                    }
                },
                fallback: '/data/basic_hexagrams.json'
            },
            {
                path: '/data/yaoci_31-63.json',
                schema: {
                    type: 'array',
                    items: {
                        line_id: 'number',
                        text: 'string',
                        interpretation: 'string'
                    }
                },
                fallback: null  // å¿…é ˆãƒ‡ãƒ¼ã‚¿
            },
            {
                path: '/data/h384.json',
                schema: {
                    type: 'array',
                    length: 384,
                    items: {
                        id: 'number',
                        hexagram: 'number',
                        line: 'number',
                        keywords: 'array'
                    }
                },
                fallback: 'generate_from_hexagrams()'  // å‹•çš„ç”Ÿæˆ
            }
        ];
        
        const validation = {
            valid: [],
            missing: [],
            invalid: [],
            fallbacks: []
        };
        
        for (const file of requiredFiles) {
            try {
                const data = await fetch(file.path);
                if (!data.ok) throw new Error('File not found');
                
                const json = await data.json();
                if (this.validateSchema(json, file.schema)) {
                    validation.valid.push(file.path);
                } else {
                    validation.invalid.push(file.path);
                    if (file.fallback) {
                        validation.fallbacks.push(file.fallback);
                    }
                }
            } catch (error) {
                validation.missing.push(file.path);
                if (file.fallback) {
                    validation.fallbacks.push(file.fallback);
                }
            }
        }
        
        return validation;
    }
}
```

**DoD**:
- [ ] å…¨å¿…é ˆãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèªã‚¹ã‚¯ãƒªãƒ—ãƒˆä½œæˆ
- [ ] ã‚¹ã‚­ãƒ¼ãƒãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…
- [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½å®Ÿè£…
- [ ] ç¸®é€€é‹è»¢ãƒ¢ãƒ¼ãƒ‰ã®å®šç¾©ï¼ˆæœ€å°æ©Ÿèƒ½ã‚»ãƒƒãƒˆï¼‰

#### Task 0-2: ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ç¢ºèªã¨ä»£æ›¿ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼ˆ1æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/docs/data-license.md`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ æ³•çš„ãƒªã‚¹ã‚¯å›é¿

```javascript
class LicenseValidator {
    checkDataLicense() {
        const licenses = {
            'enhanced_hexagrams_complete.json': {
                source: 'public_domain',
                attribution_required: false,
                commercial_use: true
            },
            'yaoci_31-63.json': {
                source: 'traditional_text',
                attribution_required: true,
                commercial_use: true
            },
            'h384.json': {
                source: 'generated',
                attribution_required: false,
                commercial_use: true
            }
        };
        
        // ãƒ©ã‚¤ã‚»ãƒ³ã‚¹é•åãƒã‚§ãƒƒã‚¯
        for (const [file, license] of Object.entries(licenses)) {
            if (!license.commercial_use && this.isCommercialProject()) {
                throw new Error(`License violation: ${file} cannot be used commercially`);
            }
        }
        
        return licenses;
    }
}
```

#### Task 0-3: DBç§»è¡Œæº–å‚™ã¨ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨ˆç”»ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/migrations/001_initial_schema.sql`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºä¿

```sql
-- Migration UP
CREATE TABLE IF NOT EXISTS lines_384 (
    id INTEGER PRIMARY KEY,
    hexagram_id INTEGER NOT NULL,
    line_number INTEGER NOT NULL,
    keywords TEXT NOT NULL,
    interpretation TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CHECK (line_number BETWEEN 1 AND 6),
    CHECK (hexagram_id BETWEEN 1 AND 64)
);

-- Migration DOWN (ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯)
DROP TABLE IF EXISTS lines_384;
```

```javascript
class MigrationManager {
    async migrate() {
        const migrationDoD = {
            preChecks: {
                backupCreated: false,
                schemaValidated: false,
                testDataPrepared: false
            },
            migration: {
                rowCountBefore: 0,
                rowCountAfter: 0,
                integrityCheck: false,
                performanceCheck: false  // ä¸»è¦ã‚¯ã‚¨ãƒª p95 < 10ms
            },
            rollback: {
                tested: false,
                automated: false,
                timeLimit: 60  // 60ç§’ä»¥å†…ã«ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œäº†
            }
        };
        
        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
        await this.createBackup();
        migrationDoD.preChecks.backupCreated = true;
        
        // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        try {
            migrationDoD.migration.rowCountBefore = await this.countRows();
            await this.runMigration();
            migrationDoD.migration.rowCountAfter = await this.countRows();
            
            // æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
            if (migrationDoD.migration.rowCountBefore !== migrationDoD.migration.rowCountAfter) {
                throw new Error('Row count mismatch');
            }
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
            const p95 = await this.testQueryPerformance();
            if (p95 > 10) {
                throw new Error(`Query p95 ${p95}ms exceeds 10ms limit`);
            }
            
        } catch (error) {
            // è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
            await this.rollback();
            throw error;
        }
        
        return migrationDoD;
    }
}
```

#### Task 0-4: é‹ç”¨ç›£è¦–åŸºç›¤ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/monitoring/metrics-collector.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸŸ¡ é‹ç”¨å“è³ªç¢ºä¿

```javascript
class MetricsCollector {
    constructor() {
        this.metrics = {
            performance: {
                e2e_times: [],
                cache_hits: 0,
                cache_misses: 0
            },
            accuracy: {
                predictions: [],
                feedback: []
            },
            distribution: {
                linePositions: new Array(6).fill(0),
                hexagrams: new Array(64).fill(0)
            },
            errors: {
                count: 0,
                types: {}
            }
        };
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆé–¾å€¤
        this.alertThresholds = {
            e2e_p95: 45,           // 45msè¶…ãˆãŸã‚‰ã‚¢ãƒ©ãƒ¼ãƒˆ
            error_rate: 0.01,      // ã‚¨ãƒ©ãƒ¼ç‡1%è¶…ãˆãŸã‚‰ã‚¢ãƒ©ãƒ¼ãƒˆ
            position_bias: 0.30,   // ä½ç½®åã‚Š30%è¶…ãˆãŸã‚‰ã‚¢ãƒ©ãƒ¼ãƒˆ
            cache_hit_rate: 0.70   // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡70%æœªæº€ã§ã‚¢ãƒ©ãƒ¼ãƒˆ
        };
    }
    
    checkAlerts() {
        const alerts = [];
        
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯
        const p95 = this.calculateP95(this.metrics.performance.e2e_times);
        if (p95 > this.alertThresholds.e2e_p95) {
            alerts.push({
                type: 'PERFORMANCE',
                message: `E2E P95 ${p95}ms exceeds ${this.alertThresholds.e2e_p95}ms`,
                severity: 'HIGH'
            });
        }
        
        // åˆ†å¸ƒåã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆÏ‡Â²æ¤œå®šï¼‰
        const chiSquare = this.calculateChiSquare(this.metrics.distribution.linePositions);
        if (chiSquare.pValue < 0.05) {
            alerts.push({
                type: 'DISTRIBUTION_BIAS',
                message: `Position distribution bias detected (p=${chiSquare.pValue})`,
                severity: 'MEDIUM'
            });
        }
        
        return alerts;
    }
}
```

---

## ğŸ“‹ Phase 1: åŸºæœ¬çš„æ–‡è„ˆç†è§£å®Ÿè£…ï¼ˆ2é€±é–“ï¼‰

### Week 1: Kuromoji.jsçµ±åˆã¨å½¢æ…‹ç´ è§£ææ´»ç”¨

#### Task 1-1: Kuromoji.jså®Œå…¨çµ±åˆï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/TextTo384LinesBridge.js`
**è¡Œç•ªå·**: 100-150ï¼ˆconstructoréƒ¨åˆ†ï¼‰
**ä¾å­˜**: Task 0-1å®Œäº†

```javascript
class TextTo384LinesBridge {
    async initializeKuromoji() {
        // æ±ºå®šè«–æ€§ç¢ºä¿ã®ãŸã‚ã®è¨­å®š
        this.config = {
            deterministic: true,
            randomSeed: 42,
            cacheEnabled: true,
            maxCacheSize: 1000
        };
        
        try {
            this.tokenizer = await new Promise((resolve, reject) => {
                kuromoji.builder({ 
                    dicPath: "/dict/",
                    // æ±ºå®šè«–æ€§ã®ãŸã‚ã®è¾æ›¸é †åºå›ºå®š
                    randomize: false
                }).build((err, tokenizer) => {
                    if (err) reject(err);
                    else resolve(tokenizer);
                });
            });
            this.kuromojiReady = true;
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šé–‹å§‹
            this.performanceMonitor = new PerformanceMonitor();
            
        } catch (error) {
            console.error('Kuromoji initialization failed:', error);
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èµ·å‹•
            this.tokenizer = new SimpleTokenizer();
            this.kuromojiReady = false;
        }
    }
    
    // æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆ
    async testDeterminism() {
        const testInputs = [
            "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„",
            "ãƒãƒ¼ãƒ ã‚’å¼•ã£å¼µã‚‹",
            "æˆé•·ã—ãŸã„"
        ];
        
        const results = [];
        for (let i = 0; i < 10; i++) {
            const run = [];
            for (const input of testInputs) {
                const result = await this.analyze(input);
                run.push(result.lineId);
            }
            results.push(run.join(','));
        }
        
        // å…¨å®Ÿè¡ŒãŒåŒä¸€çµæœã‹ç¢ºèª
        const allSame = results.every(r => r === results[0]);
        console.assert(allSame, 'Determinism check failed!');
        return allSame;
    }
}
```

**DoD**:
- [ ] KuromojiåˆæœŸåŒ–æˆåŠŸç‡100%
- [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹•ä½œç¢ºèª
- [ ] æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆåˆæ ¼ï¼ˆ10å›å®Ÿè¡ŒåŒä¸€çµæœï¼‰
- [ ] åˆæœŸåŒ–æ™‚é–“ < 500ms
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ < 20MB

#### Task 1-2: å½¢æ…‹ç´ è§£æçµæœã®æ§‹é€ åŒ–ï¼ˆ1æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/MorphologicalAnalyzer.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**ä¾å­˜**: Task 1-1å®Œäº†

```javascript
class MorphologicalAnalyzer {
    analyzeTokens(tokens) {
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
        const startTime = performance.now();
        
        const analysis = {
            nouns: tokens.filter(t => t.pos === 'åè©'),
            verbs: tokens.filter(t => t.pos === 'å‹•è©'),
            adjectives: tokens.filter(t => t.pos === 'å½¢å®¹è©'),
            particles: tokens.filter(t => t.pos === 'åŠ©è©'),
            negations: this.findNegations(tokens),
            // ãƒ¡ã‚¿æƒ…å ±
            processingTime: 0,
            tokenCount: tokens.length
        };
        
        analysis.processingTime = performance.now() - startTime;
        
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
        if (analysis.processingTime > 10) {
            console.warn(`Slow morphological analysis: ${analysis.processingTime}ms`);
        }
        
        return analysis;
    }
    
    findNegations(tokens) {
        const negationPatterns = ['ãªã„', 'ãš', 'ã¬', 'ã¾ã„', 'ã„ã‘ãªã„', 'ã ã‚'];
        const negations = [];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // å¦å®šåŠ©å‹•è©
            if (negationPatterns.includes(token.surface_form)) {
                negations.push({
                    index: i,
                    type: 'auxiliary',
                    form: token.surface_form,
                    affecting: tokens[i - 1]  // å½±éŸ¿ã‚’å—ã‘ã‚‹å‰ã®èª
                });
            }
            
            // å¦å®šå½¢å®¹è©
            if (token.pos === 'å½¢å®¹è©' && token.surface_form.endsWith('ãªã„')) {
                negations.push({
                    index: i,
                    type: 'adjective',
                    form: token.surface_form
                });
            }
        }
        
        return negations;
    }
}
```

**DoD**:
- [ ] å“è©åˆ†é¡ç²¾åº¦95%ä»¥ä¸Š
- [ ] å‡¦ç†æ™‚é–“ < 10msï¼ˆ100ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰
- [ ] ãƒ¡ãƒ¢ãƒªåŠ¹ç‡çš„ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥æ´»ç”¨ï¼‰
- [ ] å¦å®šè¡¨ç¾æ¤œå‡ºç‡90%ä»¥ä¸Š

#### Task 1-3: å¦å®šæ–‡æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆ2æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/NegationDetector.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**ä¾å­˜**: Task 1-2å®Œäº†

```javascript
class NegationDetector {
    detectNegation(tokens, targetIndex) {
        // æ–‡è„ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼ˆå‰å¾Œ5ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰
        const windowSize = 5;
        const window = tokens.slice(
            Math.max(0, targetIndex - windowSize),
            Math.min(tokens.length, targetIndex + windowSize + 1)
        );
        
        // å¦å®šãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        const negationResult = {
            hasNegation: false,
            negationType: null,
            confidence: 0,
            position: null,
            scope: null
        };
        
        // å¦å®šåŠ©å‹•è©ã®ãƒã‚§ãƒƒã‚¯
        const negationAux = ['ãªã„', 'ã¾ã›ã‚“', 'ãš', 'ã¬', 'ãªã‹ã£ãŸ'];
        for (let i = targetIndex + 1; i < Math.min(targetIndex + 4, tokens.length); i++) {
            if (negationAux.includes(tokens[i].surface_form)) {
                negationResult.hasNegation = true;
                negationResult.negationType = 'auxiliary';
                negationResult.confidence = 0.9;
                negationResult.position = i - targetIndex;
                negationResult.scope = [targetIndex, i];
                break;
            }
        }
        
        // å¦å®šçš„æ–‡è„ˆèªã®ãƒã‚§ãƒƒã‚¯
        const negativeContext = ['ç–‘å•', 'ä¸å®‰', 'å¿ƒé…', 'å›°é›£', 'ç„¡ç†', 'è‹¦æ‰‹'];
        const contextWords = window.map(t => t.surface_form);
        const hasNegativeContext = negativeContext.some(word => 
            contextWords.includes(word)
        );
        
        if (hasNegativeContext && !negationResult.hasNegation) {
            negationResult.hasNegation = true;
            negationResult.negationType = 'contextual';
            negationResult.confidence = 0.7;
        }
        
        return negationResult;
    }
    
    // å¦å®šã‚¹ã‚³ãƒ¼ãƒ—ã®åˆ¤å®š
    determineNegationScope(tokens, negationIndex) {
        // å¦å®šã®å½±éŸ¿ç¯„å›²ã‚’ç‰¹å®š
        const scope = {
            start: negationIndex,
            end: negationIndex,
            affectedTokens: []
        };
        
        // å‰æ–¹æ¢ç´¢ï¼ˆä¿‚ã‚Šå…ˆã‚’æ¢ã™ï¼‰
        for (let i = negationIndex - 1; i >= Math.max(0, negationIndex - 5); i--) {
            const token = tokens[i];
            if (token.pos === 'å‹•è©' || token.pos === 'å½¢å®¹è©') {
                scope.start = i;
                scope.affectedTokens.push(i);
                break;
            }
        }
        
        return scope;
    }
}
```

**ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹**:
```javascript
// test/negation-detection.test.js
describe('å¦å®šæ–‡æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ', () => {
    const detector = new NegationDetector();
    
    test('åŸºæœ¬çš„ãªå¦å®šæ–‡ã‚’æ¤œå‡º', async () => {
        const cases = [
            { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„", expected: false },
            { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸããªã„", expected: true },
            { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ã¯å‘ã„ã¦ã„ãªã„", expected: true },
            { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã«ç–‘å•ã‚’æ„Ÿã˜ã‚‹", expected: true }
        ];
        
        for (const testCase of cases) {
            const tokens = await tokenizer.tokenize(testCase.input);
            const result = detector.detectNegation(tokens, 0);
            expect(result.hasNegation).toBe(testCase.expected);
        }
    });
    
    test('å¦å®šã‚¹ã‚³ãƒ¼ãƒ—ã‚’æ­£ã—ãåˆ¤å®š', async () => {
        const input = "ã“ã‚Œã¯è‰¯ããªã„ã¨æ€ã†";
        const tokens = await tokenizer.tokenize(input);
        const negIndex = tokens.findIndex(t => t.surface_form === 'ãªã„');
        const scope = detector.determineNegationScope(tokens, negIndex);
        
        expect(scope.affectedTokens).toContain(
            tokens.findIndex(t => t.surface_form === 'è‰¯ã')
        );
    });
});
```

**DoD**:
- [ ] å¦å®šæ–‡æ¤œå‡ºç²¾åº¦90%ä»¥ä¸Š
- [ ] å‡¦ç†æ™‚é–“ < 5ms
- [ ] ã‚¹ã‚³ãƒ¼ãƒ—åˆ¤å®šç²¾åº¦85%ä»¥ä¸Š
- [ ] æ±ºå®šè«–çš„å‹•ä½œï¼ˆåŒä¸€å…¥åŠ›=åŒä¸€å‡ºåŠ›ï¼‰

#### Task 1-4: åã‚Šæ¤œå‡ºã¨è‡ªå‹•è£œæ­£ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ3æ—¥ï¼‰ğŸ”´æ–°è¦è¿½åŠ 
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/BiasDetector.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ å¿…é ˆï¼ˆåã‚Šé˜²æ­¢ï¼‰

```javascript
class BiasDetector {
    constructor() {
        this.history = {
            linePositions: new Array(6).fill(0),  // çˆ»ä½ç½® (1-6)
            hexagrams: new Array(64).fill(0),     // å¦ (1-64)
            total: 0
        };
        
        // é–¾å€¤è¨­å®š
        this.thresholds = {
            maxPositionBias: 0.30,  // 30%ã‚’è¶…ãˆãªã„
            minPositionUsage: 0.10, // 10%ã‚’ä¸‹å›ã‚‰ãªã„
            chiSquareAlpha: 0.05   // Ï‡Â²æ¤œå®šã®æœ‰æ„æ°´æº–
        };
    }
    
    recordSelection(hexagramId, linePosition) {
        this.history.hexagrams[hexagramId - 1]++;
        this.history.linePositions[linePosition - 1]++;
        this.history.total++;
        
        // å®šæœŸçš„ãªåã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆ100ä»¶ã”ã¨ï¼‰
        if (this.history.total % 100 === 0) {
            this.checkAndAlertBias();
        }
    }
    
    checkAndAlertBias() {
        const positionDistribution = this.history.linePositions.map(
            count => count / this.history.total
        );
        
        // Ï‡Â²æ¤œå®š
        const expected = this.history.total / 6;  // å‡ç­‰åˆ†å¸ƒã®æœŸå¾…å€¤
        let chiSquare = 0;
        
        for (let i = 0; i < 6; i++) {
            const observed = this.history.linePositions[i];
            chiSquare += Math.pow(observed - expected, 2) / expected;
        }
        
        // è‡ªç”±åº¦5ã®Ï‡Â²åˆ†å¸ƒã®è‡¨ç•Œå€¤ï¼ˆÎ±=0.05ï¼‰
        const criticalValue = 11.070;
        
        if (chiSquare > criticalValue) {
            // åã‚Šæ¤œå‡ºã‚¢ãƒ©ãƒ¼ãƒˆ
            const alert = {
                type: 'DISTRIBUTION_BIAS',
                severity: 'HIGH',
                chiSquare: chiSquare,
                distribution: positionDistribution,
                maxBias: Math.max(...positionDistribution),
                minUsage: Math.min(...positionDistribution),
                recommendation: this.generateCorrection(positionDistribution)
            };
            
            console.error('âš ï¸ åã‚Šæ¤œå‡º:', alert);
            this.applyCorrection(alert.recommendation);
        }
        
        return { chiSquare, biased: chiSquare > criticalValue };
    }
    
    generateCorrection(distribution) {
        // è£œæ­£é‡ã¿ã®è¨ˆç®—
        const targetProb = 1 / 6;  // ç›®æ¨™: å‡ç­‰åˆ†å¸ƒ
        const corrections = distribution.map((prob, index) => ({
            position: index + 1,
            currentProb: prob,
            targetProb: targetProb,
            weight: targetProb / Math.max(prob, 0.01)  // ã‚¼ãƒ­é™¤ç®—é˜²æ­¢
        }));
        
        return corrections;
    }
    
    applyCorrection(corrections) {
        // ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°æ™‚ã®è£œæ­£é‡ã¿é©ç”¨
        window.biasCorrection = corrections;
        console.log('ğŸ“Š åã‚Šè£œæ­£é©ç”¨:', corrections);
    }
}
```

**DoD**:
- [ ] Ï‡Â²æ¤œå®šå®Ÿè£…ãƒ»å‹•ä½œç¢ºèª
- [ ] è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç«ç¢ºèª
- [ ] è£œæ­£é‡ã¿è¨ˆç®—ã®å¦¥å½“æ€§æ¤œè¨¼
- [ ] è£œæ­£å¾Œã®åˆ†å¸ƒæ”¹å–„ç¢ºèªï¼ˆ30%ä»¥å†…ï¼‰

---

## ğŸ“‹ Phase 2: æ„å‘³ç†è§£ã¨ãƒ™ã‚¯ãƒˆãƒ«åŒ–ï¼ˆ4é€±é–“ï¼‰

### Week 3-4: Word2Vecç°¡æ˜“å®Ÿè£…

#### Task 2-1: æ—¥æœ¬èªWord2Vecãƒ¢ãƒ‡ãƒ«æº–å‚™ï¼ˆ3æ—¥ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ml/Word2VecLoader.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**ä¾å­˜**: Phase 1å®Œäº†
**ãƒ¡ãƒ¢ãƒªåˆ¶ç´„**: < 50MBï¼ˆEdgeç’°å¢ƒï¼‰

```javascript
class Word2VecLoader {
    async loadPretrainedModel() {
        try {
            // è»½é‡åŒ–ãƒ¢ãƒ‡ãƒ«ï¼ˆ100æ¬¡å…ƒã€é »å‡º5000èªã®ã¿ï¼‰
            const response = await fetch('/models/ja_word2vec_mini.json');
            if (!response.ok) {
                throw new Error('Model not found');
            }
            
            this.vectors = await response.json();
            this.dimensions = 100;
            this.vocabSize = Object.keys(this.vectors).length;
            
            // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯
            const estimatedSize = this.vocabSize * this.dimensions * 4 / 1024 / 1024; // MB
            if (estimatedSize > 50) {
                console.warn(`Model size ${estimatedSize}MB exceeds 50MB limit`);
                // é »åº¦é †ã«å‰Šæ¸›
                this.reduceVocabulary(3000);
            }
            
        } catch (error) {
            console.error('Word2Vec model loading failed:', error);
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰
            this.useRandomVectors = true;
        }
    }
    
    getVector(word) {
        if (this.useRandomVectors) {
            // æ±ºå®šè«–çš„ãªç–‘ä¼¼ãƒ©ãƒ³ãƒ€ãƒ ãƒ™ã‚¯ãƒˆãƒ«
            return this.generateDeterministicVector(word);
        }
        return this.vectors[word] || this.getOOVVector(word);
    }
    
    generateDeterministicVector(word) {
        // æ–‡å­—åˆ—ã‹ã‚‰æ±ºå®šè«–çš„ã«ãƒ™ã‚¯ãƒˆãƒ«ç”Ÿæˆ
        const vector = new Float32Array(this.dimensions);
        let seed = 0;
        for (let i = 0; i < word.length; i++) {
            seed = ((seed << 5) - seed) + word.charCodeAt(i);
            seed = seed & seed;
        }
        
        for (let i = 0; i < this.dimensions; i++) {
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            vector[i] = (seed / 0x7fffffff) * 2 - 1;  // -1 to 1
        }
        
        return vector;
    }
}
```

**DoD**:
- [ ] ãƒ¢ãƒ‡ãƒ«ã‚µã‚¤ã‚º < 50MB
- [ ] ãƒ­ãƒ¼ãƒ‰æ™‚é–“ < 1000ms
- [ ] OOVï¼ˆæœªçŸ¥èªï¼‰å‡¦ç†å®Ÿè£…
- [ ] æ±ºå®šè«–çš„ãƒ™ã‚¯ãƒˆãƒ«ç”Ÿæˆç¢ºèª

---

## ğŸ“Š æ¤œè¨¼ãƒ»ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚¿ã‚¹ã‚¯

### æœ€å°æ¤œè¨¼3æœ¬ï¼ˆPhase 1å®Œäº†æ™‚ç‚¹ã§å®Ÿæ–½ï¼‰

```javascript
describe('æœ€å°æ¤œè¨¼ã‚»ãƒƒãƒˆ', () => {
    test('æ±ºå®šè«–æ€§ã‚¹ãƒ¢ãƒ¼ã‚¯', async () => {
        const inputs = [
            "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„",
            "ãƒãƒ¼ãƒ ã‚’æˆé•·ã•ã›ã‚‹",
            "å›°é›£ã‚’ä¹—ã‚Šè¶Šãˆã‚‹",
            // ... 10ä»¶
        ];
        
        const results = [];
        for (let run = 0; run < 10; run++) {
            const runResults = [];
            for (const input of inputs) {
                const result = await analyzer.analyze(input);
                runResults.push(result.lineId);
            }
            results.push(runResults.join(','));
        }
        
        // ä¸€è‡´ç‡100%ç¢ºèª
        const firstRun = results[0];
        const allSame = results.every(r => r === firstRun);
        expect(allSame).toBe(true);
    });
    
    test('5çˆ»å›å¾©ãƒã‚§ãƒƒã‚¯', async () => {
        const leadershipSamples = [
            "å¼·ã„ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã‚’ç™ºæ®ã—ãŸã„",
            "ãƒãƒ¼ãƒ ã‚’çµ±ç‡ã™ã‚‹åŠ›ãŒæ¬²ã—ã„",
            "çµ„ç¹”ã‚’å°ãå­˜åœ¨ã«ãªã‚ŠãŸã„",
            // ... 10ä»¶
        ];
        
        let line5Count = 0;
        for (const sample of leadershipSamples) {
            const result = await analyzer.analyze(sample);
            if (result.linePosition === 5) {
                line5Count++;
            }
        }
        
        const line5Ratio = line5Count / leadershipSamples.length;
        expect(line5Ratio).toBeGreaterThanOrEqual(0.60);  // 60%ä»¥ä¸Š
    });
    
    test('æ€§èƒ½ã—ãã„å€¤', async () => {
        const times = [];
        
        for (let i = 0; i < 100; i++) {
            const start = performance.now();
            await analyzer.analyze("ãƒ†ã‚¹ãƒˆãƒ†ã‚­ã‚¹ãƒˆ" + i);
            const time = performance.now() - start;
            times.push(time);
        }
        
        const avg = times.reduce((a, b) => a + b) / times.length;
        const sorted = times.sort((a, b) => a - b);
        const p95 = sorted[Math.floor(times.length * 0.95)];
        
        expect(avg).toBeLessThan(40);   // å¹³å‡40msæœªæº€
        expect(p95).toBeLessThan(45);   // p95ãŒ45msæœªæº€
    });
});
```

---

## ğŸ“ é‹ç”¨ç›£è¦–ã‚¿ã‚¹ã‚¯ï¼ˆå„Phaseçµ‚äº†æ™‚ã«å¿…é ˆï¼‰

### ç¶™ç¶šçš„ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°è¨­å®š
```javascript
class ContinuousMonitoring {
    constructor() {
        // ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†é–“éš”
        this.intervals = {
            performance: 60000,     // 1åˆ†ã”ã¨
            accuracy: 3600000,      // 1æ™‚é–“ã”ã¨
            distribution: 600000    // 10åˆ†ã”ã¨
        };
        
        this.startMonitoring();
    }
    
    startMonitoring() {
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
        setInterval(() => {
            const metrics = this.collectPerformanceMetrics();
            if (metrics.p95 > 45) {
                this.sendAlert('PERFORMANCE_DEGRADATION', metrics);
            }
        }, this.intervals.performance);
        
        // åˆ†å¸ƒç›£è¦–
        setInterval(() => {
            const bias = this.checkDistributionBias();
            if (bias.detected) {
                this.sendAlert('DISTRIBUTION_BIAS', bias);
            }
        }, this.intervals.distribution);
    }
}
```

---

## ğŸ¯ ãƒªã‚¹ã‚¯ç®¡ç†ã¨è»½æ¸›ç­–

| ãƒªã‚¹ã‚¯ | å½±éŸ¿åº¦ | è»½æ¸›ç­– |
|--------|--------|--------|
| ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«æ¬ æ | é«˜ | Phase 0ã§äº‹å‰æ¤œè¨¼ãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æº–å‚™ |
| æ€§èƒ½ç›®æ¨™æœªé” | ä¸­ | æ®µéšçš„æœ€é©åŒ–ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¼·åŒ– |
| åã‚Šç™ºç”Ÿ | é«˜ | Ï‡Â²æ¤œå®šã«ã‚ˆã‚‹è‡ªå‹•æ¤œå‡ºãƒ»è£œæ­£ |
| ãƒ¡ãƒ¢ãƒªè¶…é | é«˜ | ãƒ¢ãƒ‡ãƒ«åœ§ç¸®ãƒ»æ®µéšçš„ãƒ­ãƒ¼ãƒ‰ |

---

## âœ… Go/No-Goåˆ¤å®šåŸºæº–

### Phase 0çµ‚äº†æ™‚ç‚¹
- [ ] å…¨å¿…é ˆãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«åˆ©ç”¨å¯èƒ½
- [ ] DBç§»è¡Œãƒ†ã‚¹ãƒˆæˆåŠŸ
- [ ] ç›£è¦–åŸºç›¤ç¨¼åƒ

### Phase 1çµ‚äº†æ™‚ç‚¹  
- [ ] æ±ºå®šè«–æ€§100%é”æˆ
- [ ] E2Eå¹³å‡ < 40ms
- [ ] åã‚Šæ¤œå‡ºãƒ»è£œæ­£æ©Ÿèƒ½ç¨¼åƒ

### æœ€çµ‚ãƒªãƒªãƒ¼ã‚¹åŸºæº–
- [ ] å…¨DoDé …ç›®ã‚¯ãƒªã‚¢
- [ ] 3ã¤ã®æœ€å°æ¤œè¨¼åˆæ ¼
- [ ] é‹ç”¨ç›£è¦–ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šå®Œäº†

---

**æ–‡æ›¸å®Œäº†** - æŒ‡æ‘˜äº‹é …ã‚’åæ˜ ã—ã€å®Ÿè£…å¯èƒ½ãªè©³ç´°åº¦ã¾ã§è½ã¨ã—è¾¼ã¿ã¾ã—ãŸ