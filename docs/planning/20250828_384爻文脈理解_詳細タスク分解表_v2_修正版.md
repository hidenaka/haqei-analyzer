# 384爻システム文脈理解実装 詳細タスク分解表 v2（修正版）

**文書番号**: HAQEI-TASK-003-v2  
**作成日**: 2025年8月28日  
**改訂**: レビュー指摘事項反映版  
**担当**: 実装チーム向け  
**総工数見積**: Phase 0（1週間）、Phase 1（2週間）、Phase 2（4週間）、Phase 3（8週間）

---

## 🚨 重要な前提条件と制約

### 性能目標（現実的な値に修正）
```javascript
// ❌ 旧: 非現実的な目標
// expect(avg).toBeLessThan(5);  

// ✅ 新: Edge環境で実現可能な目標
const performanceTargets = {
    e2e_average: 40,    // 40ms以下（Edge制約考慮）
    e2e_p50: 35,        // 中央値35ms
    e2e_p95: 45,        // 95パーセンタイル45ms
    e2e_p99: 50,        // 99パーセンタイル50ms
    memory_usage: 120   // 120MB以下（Edge制約128MB）
};
```

### 共通DoD（Definition of Done）
```javascript
const commonDoD = {
    unitTest: {
        coverage: 80,           // 分岐網羅80%以上
        allTestsPass: true      // 全テスト合格
    },
    performance: {
        p95_latency: 45,        // p95レイテンシ45ms以内
        memory: 120             // メモリ使用量120MB以内
    },
    determinism: {
        sameInputSameOutput: 100,  // 同一入力=同一出力100%
        fixedSeedReproducibility: true
    },
    distribution: {
        maxPositionBias: 30,    // どの爻位置も30%を超えない
        chiSquareTest: true     // χ²検定合格
    },
    monitoring: {
        metricsLogged: true,    // メトリクス記録実装
        alertsConfigured: true  // アラート設定済み
    }
};
```

---

## 📋 Phase 0: Pre-flight チェック（新設・1週間）

### Week 0: データ前提条件の検証とフォールバック準備

#### Task 0-1: データファイル存在確認とスキーマ検証（2日）
**ファイル**: `/scripts/data-preflight-check.js`（新規作成）
**優先度**: 🔴 最優先（全作業の前提）

```javascript
class DataPreflightCheck {
    async validateDataDependencies() {
        const requiredFiles = [
            {
                path: '/data/enhanced_hexagrams_complete.json',
                schema: {
                    type: 'array',
                    items: {
                        hexagram_id: 'number',
                        name_ja: 'string',
                        yao_lines: 'array'
                    }
                },
                fallback: '/data/basic_hexagrams.json'
            },
            {
                path: '/data/yaoci_31-63.json',
                schema: {
                    type: 'array',
                    items: {
                        line_id: 'number',
                        text: 'string',
                        interpretation: 'string'
                    }
                },
                fallback: null  // 必須データ
            },
            {
                path: '/data/h384.json',
                schema: {
                    type: 'array',
                    length: 384,
                    items: {
                        id: 'number',
                        hexagram: 'number',
                        line: 'number',
                        keywords: 'array'
                    }
                },
                fallback: 'generate_from_hexagrams()'  // 動的生成
            }
        ];
        
        const validation = {
            valid: [],
            missing: [],
            invalid: [],
            fallbacks: []
        };
        
        for (const file of requiredFiles) {
            try {
                const data = await fetch(file.path);
                if (!data.ok) throw new Error('File not found');
                
                const json = await data.json();
                if (this.validateSchema(json, file.schema)) {
                    validation.valid.push(file.path);
                } else {
                    validation.invalid.push(file.path);
                    if (file.fallback) {
                        validation.fallbacks.push(file.fallback);
                    }
                }
            } catch (error) {
                validation.missing.push(file.path);
                if (file.fallback) {
                    validation.fallbacks.push(file.fallback);
                }
            }
        }
        
        return validation;
    }
}
```

**DoD**:
- [ ] 全必須ファイルの存在確認スクリプト作成
- [ ] スキーマバリデーション実装
- [ ] フォールバック機能実装
- [ ] 縮退運転モードの定義（最小機能セット）

#### Task 0-2: ライセンス確認と代替データ準備（1日）
**ファイル**: `/docs/data-license.md`（新規作成）
**優先度**: 🔴 法的リスク回避

```javascript
class LicenseValidator {
    checkDataLicense() {
        const licenses = {
            'enhanced_hexagrams_complete.json': {
                source: 'public_domain',
                attribution_required: false,
                commercial_use: true
            },
            'yaoci_31-63.json': {
                source: 'traditional_text',
                attribution_required: true,
                commercial_use: true
            },
            'h384.json': {
                source: 'generated',
                attribution_required: false,
                commercial_use: true
            }
        };
        
        // ライセンス違反チェック
        for (const [file, license] of Object.entries(licenses)) {
            if (!license.commercial_use && this.isCommercialProject()) {
                throw new Error(`License violation: ${file} cannot be used commercially`);
            }
        }
        
        return licenses;
    }
}
```

#### Task 0-3: DB移行準備とロールバック計画（2日）
**ファイル**: `/migrations/001_initial_schema.sql`（新規作成）
**優先度**: 🔴 データ整合性確保

```sql
-- Migration UP
CREATE TABLE IF NOT EXISTS lines_384 (
    id INTEGER PRIMARY KEY,
    hexagram_id INTEGER NOT NULL,
    line_number INTEGER NOT NULL,
    keywords TEXT NOT NULL,
    interpretation TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CHECK (line_number BETWEEN 1 AND 6),
    CHECK (hexagram_id BETWEEN 1 AND 64)
);

-- Migration DOWN (ロールバック)
DROP TABLE IF EXISTS lines_384;
```

```javascript
class MigrationManager {
    async migrate() {
        const migrationDoD = {
            preChecks: {
                backupCreated: false,
                schemaValidated: false,
                testDataPrepared: false
            },
            migration: {
                rowCountBefore: 0,
                rowCountAfter: 0,
                integrityCheck: false,
                performanceCheck: false  // 主要クエリ p95 < 10ms
            },
            rollback: {
                tested: false,
                automated: false,
                timeLimit: 60  // 60秒以内にロールバック完了
            }
        };
        
        // バックアップ
        await this.createBackup();
        migrationDoD.preChecks.backupCreated = true;
        
        // マイグレーション実行
        try {
            migrationDoD.migration.rowCountBefore = await this.countRows();
            await this.runMigration();
            migrationDoD.migration.rowCountAfter = await this.countRows();
            
            // 整合性チェック
            if (migrationDoD.migration.rowCountBefore !== migrationDoD.migration.rowCountAfter) {
                throw new Error('Row count mismatch');
            }
            
            // パフォーマンステスト
            const p95 = await this.testQueryPerformance();
            if (p95 > 10) {
                throw new Error(`Query p95 ${p95}ms exceeds 10ms limit`);
            }
            
        } catch (error) {
            // 自動ロールバック
            await this.rollback();
            throw error;
        }
        
        return migrationDoD;
    }
}
```

#### Task 0-4: 運用監視基盤セットアップ（2日）
**ファイル**: `/monitoring/metrics-collector.js`（新規作成）
**優先度**: 🟡 運用品質確保

```javascript
class MetricsCollector {
    constructor() {
        this.metrics = {
            performance: {
                e2e_times: [],
                cache_hits: 0,
                cache_misses: 0
            },
            accuracy: {
                predictions: [],
                feedback: []
            },
            distribution: {
                linePositions: new Array(6).fill(0),
                hexagrams: new Array(64).fill(0)
            },
            errors: {
                count: 0,
                types: {}
            }
        };
        
        // アラート閾値
        this.alertThresholds = {
            e2e_p95: 45,           // 45ms超えたらアラート
            error_rate: 0.01,      // エラー率1%超えたらアラート
            position_bias: 0.30,   // 位置偏り30%超えたらアラート
            cache_hit_rate: 0.70   // キャッシュヒット率70%未満でアラート
        };
    }
    
    checkAlerts() {
        const alerts = [];
        
        // パフォーマンスチェック
        const p95 = this.calculateP95(this.metrics.performance.e2e_times);
        if (p95 > this.alertThresholds.e2e_p95) {
            alerts.push({
                type: 'PERFORMANCE',
                message: `E2E P95 ${p95}ms exceeds ${this.alertThresholds.e2e_p95}ms`,
                severity: 'HIGH'
            });
        }
        
        // 分布偏りチェック（χ²検定）
        const chiSquare = this.calculateChiSquare(this.metrics.distribution.linePositions);
        if (chiSquare.pValue < 0.05) {
            alerts.push({
                type: 'DISTRIBUTION_BIAS',
                message: `Position distribution bias detected (p=${chiSquare.pValue})`,
                severity: 'MEDIUM'
            });
        }
        
        return alerts;
    }
}
```

---

## 📋 Phase 1: 基本的文脈理解実装（2週間）

### Week 1: Kuromoji.js統合と形態素解析活用

#### Task 1-1: Kuromoji.js完全統合（2日）
**ファイル**: `/public/js/ai/TextTo384LinesBridge.js`
**行番号**: 100-150（constructor部分）
**依存**: Task 0-1完了

```javascript
class TextTo384LinesBridge {
    async initializeKuromoji() {
        // 決定論性確保のための設定
        this.config = {
            deterministic: true,
            randomSeed: 42,
            cacheEnabled: true,
            maxCacheSize: 1000
        };
        
        try {
            this.tokenizer = await new Promise((resolve, reject) => {
                kuromoji.builder({ 
                    dicPath: "/dict/",
                    // 決定論性のための辞書順序固定
                    randomize: false
                }).build((err, tokenizer) => {
                    if (err) reject(err);
                    else resolve(tokenizer);
                });
            });
            this.kuromojiReady = true;
            
            // パフォーマンス測定開始
            this.performanceMonitor = new PerformanceMonitor();
            
        } catch (error) {
            console.error('Kuromoji initialization failed:', error);
            // フォールバック起動
            this.tokenizer = new SimpleTokenizer();
            this.kuromojiReady = false;
        }
    }
    
    // 決定論性テスト
    async testDeterminism() {
        const testInputs = [
            "リーダーになりたい",
            "チームを引っ張る",
            "成長したい"
        ];
        
        const results = [];
        for (let i = 0; i < 10; i++) {
            const run = [];
            for (const input of testInputs) {
                const result = await this.analyze(input);
                run.push(result.lineId);
            }
            results.push(run.join(','));
        }
        
        // 全実行が同一結果か確認
        const allSame = results.every(r => r === results[0]);
        console.assert(allSame, 'Determinism check failed!');
        return allSame;
    }
}
```

**DoD**:
- [ ] Kuromoji初期化成功率100%
- [ ] フォールバック動作確認
- [ ] 決定論性テスト合格（10回実行同一結果）
- [ ] 初期化時間 < 500ms
- [ ] メモリ使用量 < 20MB

#### Task 1-2: 形態素解析結果の構造化（1日）
**ファイル**: `/public/js/ai/MorphologicalAnalyzer.js`（新規作成）
**依存**: Task 1-1完了

```javascript
class MorphologicalAnalyzer {
    analyzeTokens(tokens) {
        // パフォーマンス計測
        const startTime = performance.now();
        
        const analysis = {
            nouns: tokens.filter(t => t.pos === '名詞'),
            verbs: tokens.filter(t => t.pos === '動詞'),
            adjectives: tokens.filter(t => t.pos === '形容詞'),
            particles: tokens.filter(t => t.pos === '助詞'),
            negations: this.findNegations(tokens),
            // メタ情報
            processingTime: 0,
            tokenCount: tokens.length
        };
        
        analysis.processingTime = performance.now() - startTime;
        
        // パフォーマンス監視
        if (analysis.processingTime > 10) {
            console.warn(`Slow morphological analysis: ${analysis.processingTime}ms`);
        }
        
        return analysis;
    }
    
    findNegations(tokens) {
        const negationPatterns = ['ない', 'ず', 'ぬ', 'まい', 'いけない', 'だめ'];
        const negations = [];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // 否定助動詞
            if (negationPatterns.includes(token.surface_form)) {
                negations.push({
                    index: i,
                    type: 'auxiliary',
                    form: token.surface_form,
                    affecting: tokens[i - 1]  // 影響を受ける前の語
                });
            }
            
            // 否定形容詞
            if (token.pos === '形容詞' && token.surface_form.endsWith('ない')) {
                negations.push({
                    index: i,
                    type: 'adjective',
                    form: token.surface_form
                });
            }
        }
        
        return negations;
    }
}
```

**DoD**:
- [ ] 品詞分類精度95%以上
- [ ] 処理時間 < 10ms（100トークン）
- [ ] メモリ効率的（キャッシュ活用）
- [ ] 否定表現検出率90%以上

#### Task 1-3: 否定文検出システム（2日）
**ファイル**: `/public/js/ai/NegationDetector.js`（新規作成）
**依存**: Task 1-2完了

```javascript
class NegationDetector {
    detectNegation(tokens, targetIndex) {
        // 文脈ウィンドウ（前後5トークン）
        const windowSize = 5;
        const window = tokens.slice(
            Math.max(0, targetIndex - windowSize),
            Math.min(tokens.length, targetIndex + windowSize + 1)
        );
        
        // 否定パターンマッチング
        const negationResult = {
            hasNegation: false,
            negationType: null,
            confidence: 0,
            position: null,
            scope: null
        };
        
        // 否定助動詞のチェック
        const negationAux = ['ない', 'ません', 'ず', 'ぬ', 'なかった'];
        for (let i = targetIndex + 1; i < Math.min(targetIndex + 4, tokens.length); i++) {
            if (negationAux.includes(tokens[i].surface_form)) {
                negationResult.hasNegation = true;
                negationResult.negationType = 'auxiliary';
                negationResult.confidence = 0.9;
                negationResult.position = i - targetIndex;
                negationResult.scope = [targetIndex, i];
                break;
            }
        }
        
        // 否定的文脈語のチェック
        const negativeContext = ['疑問', '不安', '心配', '困難', '無理', '苦手'];
        const contextWords = window.map(t => t.surface_form);
        const hasNegativeContext = negativeContext.some(word => 
            contextWords.includes(word)
        );
        
        if (hasNegativeContext && !negationResult.hasNegation) {
            negationResult.hasNegation = true;
            negationResult.negationType = 'contextual';
            negationResult.confidence = 0.7;
        }
        
        return negationResult;
    }
    
    // 否定スコープの判定
    determineNegationScope(tokens, negationIndex) {
        // 否定の影響範囲を特定
        const scope = {
            start: negationIndex,
            end: negationIndex,
            affectedTokens: []
        };
        
        // 前方探索（係り先を探す）
        for (let i = negationIndex - 1; i >= Math.max(0, negationIndex - 5); i--) {
            const token = tokens[i];
            if (token.pos === '動詞' || token.pos === '形容詞') {
                scope.start = i;
                scope.affectedTokens.push(i);
                break;
            }
        }
        
        return scope;
    }
}
```

**テストケース**:
```javascript
// test/negation-detection.test.js
describe('否定文検出システム', () => {
    const detector = new NegationDetector();
    
    test('基本的な否定文を検出', async () => {
        const cases = [
            { input: "リーダーになりたい", expected: false },
            { input: "リーダーになりたくない", expected: true },
            { input: "リーダーには向いていない", expected: true },
            { input: "リーダーシップに疑問を感じる", expected: true }
        ];
        
        for (const testCase of cases) {
            const tokens = await tokenizer.tokenize(testCase.input);
            const result = detector.detectNegation(tokens, 0);
            expect(result.hasNegation).toBe(testCase.expected);
        }
    });
    
    test('否定スコープを正しく判定', async () => {
        const input = "これは良くないと思う";
        const tokens = await tokenizer.tokenize(input);
        const negIndex = tokens.findIndex(t => t.surface_form === 'ない');
        const scope = detector.determineNegationScope(tokens, negIndex);
        
        expect(scope.affectedTokens).toContain(
            tokens.findIndex(t => t.surface_form === '良く')
        );
    });
});
```

**DoD**:
- [ ] 否定文検出精度90%以上
- [ ] 処理時間 < 5ms
- [ ] スコープ判定精度85%以上
- [ ] 決定論的動作（同一入力=同一出力）

#### Task 1-4: 偏り検出と自動補正システム（3日）🔴新規追加
**ファイル**: `/public/js/ai/BiasDetector.js`（新規作成）
**優先度**: 🔴 必須（偏り防止）

```javascript
class BiasDetector {
    constructor() {
        this.history = {
            linePositions: new Array(6).fill(0),  // 爻位置 (1-6)
            hexagrams: new Array(64).fill(0),     // 卦 (1-64)
            total: 0
        };
        
        // 閾値設定
        this.thresholds = {
            maxPositionBias: 0.30,  // 30%を超えない
            minPositionUsage: 0.10, // 10%を下回らない
            chiSquareAlpha: 0.05   // χ²検定の有意水準
        };
    }
    
    recordSelection(hexagramId, linePosition) {
        this.history.hexagrams[hexagramId - 1]++;
        this.history.linePositions[linePosition - 1]++;
        this.history.total++;
        
        // 定期的な偏りチェック（100件ごと）
        if (this.history.total % 100 === 0) {
            this.checkAndAlertBias();
        }
    }
    
    checkAndAlertBias() {
        const positionDistribution = this.history.linePositions.map(
            count => count / this.history.total
        );
        
        // χ²検定
        const expected = this.history.total / 6;  // 均等分布の期待値
        let chiSquare = 0;
        
        for (let i = 0; i < 6; i++) {
            const observed = this.history.linePositions[i];
            chiSquare += Math.pow(observed - expected, 2) / expected;
        }
        
        // 自由度5のχ²分布の臨界値（α=0.05）
        const criticalValue = 11.070;
        
        if (chiSquare > criticalValue) {
            // 偏り検出アラート
            const alert = {
                type: 'DISTRIBUTION_BIAS',
                severity: 'HIGH',
                chiSquare: chiSquare,
                distribution: positionDistribution,
                maxBias: Math.max(...positionDistribution),
                minUsage: Math.min(...positionDistribution),
                recommendation: this.generateCorrection(positionDistribution)
            };
            
            console.error('⚠️ 偏り検出:', alert);
            this.applyCorrection(alert.recommendation);
        }
        
        return { chiSquare, biased: chiSquare > criticalValue };
    }
    
    generateCorrection(distribution) {
        // 補正重みの計算
        const targetProb = 1 / 6;  // 目標: 均等分布
        const corrections = distribution.map((prob, index) => ({
            position: index + 1,
            currentProb: prob,
            targetProb: targetProb,
            weight: targetProb / Math.max(prob, 0.01)  // ゼロ除算防止
        }));
        
        return corrections;
    }
    
    applyCorrection(corrections) {
        // スコアリング時の補正重み適用
        window.biasCorrection = corrections;
        console.log('📊 偏り補正適用:', corrections);
    }
}
```

**DoD**:
- [ ] χ²検定実装・動作確認
- [ ] 自動アラート発火確認
- [ ] 補正重み計算の妥当性検証
- [ ] 補正後の分布改善確認（30%以内）

---

## 📋 Phase 2: 意味理解とベクトル化（4週間）

### Week 3-4: Word2Vec簡易実装

#### Task 2-1: 日本語Word2Vecモデル準備（3日）
**ファイル**: `/public/js/ml/Word2VecLoader.js`（新規作成）
**依存**: Phase 1完了
**メモリ制約**: < 50MB（Edge環境）

```javascript
class Word2VecLoader {
    async loadPretrainedModel() {
        try {
            // 軽量化モデル（100次元、頻出5000語のみ）
            const response = await fetch('/models/ja_word2vec_mini.json');
            if (!response.ok) {
                throw new Error('Model not found');
            }
            
            this.vectors = await response.json();
            this.dimensions = 100;
            this.vocabSize = Object.keys(this.vectors).length;
            
            // メモリ使用量チェック
            const estimatedSize = this.vocabSize * this.dimensions * 4 / 1024 / 1024; // MB
            if (estimatedSize > 50) {
                console.warn(`Model size ${estimatedSize}MB exceeds 50MB limit`);
                // 頻度順に削減
                this.reduceVocabulary(3000);
            }
            
        } catch (error) {
            console.error('Word2Vec model loading failed:', error);
            // フォールバックモード
            this.useRandomVectors = true;
        }
    }
    
    getVector(word) {
        if (this.useRandomVectors) {
            // 決定論的な疑似ランダムベクトル
            return this.generateDeterministicVector(word);
        }
        return this.vectors[word] || this.getOOVVector(word);
    }
    
    generateDeterministicVector(word) {
        // 文字列から決定論的にベクトル生成
        const vector = new Float32Array(this.dimensions);
        let seed = 0;
        for (let i = 0; i < word.length; i++) {
            seed = ((seed << 5) - seed) + word.charCodeAt(i);
            seed = seed & seed;
        }
        
        for (let i = 0; i < this.dimensions; i++) {
            seed = (seed * 1103515245 + 12345) & 0x7fffffff;
            vector[i] = (seed / 0x7fffffff) * 2 - 1;  // -1 to 1
        }
        
        return vector;
    }
}
```

**DoD**:
- [ ] モデルサイズ < 50MB
- [ ] ロード時間 < 1000ms
- [ ] OOV（未知語）処理実装
- [ ] 決定論的ベクトル生成確認

---

## 📊 検証・モニタリングタスク

### 最小検証3本（Phase 1完了時点で実施）

```javascript
describe('最小検証セット', () => {
    test('決定論性スモーク', async () => {
        const inputs = [
            "リーダーになりたい",
            "チームを成長させる",
            "困難を乗り越える",
            // ... 10件
        ];
        
        const results = [];
        for (let run = 0; run < 10; run++) {
            const runResults = [];
            for (const input of inputs) {
                const result = await analyzer.analyze(input);
                runResults.push(result.lineId);
            }
            results.push(runResults.join(','));
        }
        
        // 一致率100%確認
        const firstRun = results[0];
        const allSame = results.every(r => r === firstRun);
        expect(allSame).toBe(true);
    });
    
    test('5爻回復チェック', async () => {
        const leadershipSamples = [
            "強いリーダーシップを発揮したい",
            "チームを統率する力が欲しい",
            "組織を導く存在になりたい",
            // ... 10件
        ];
        
        let line5Count = 0;
        for (const sample of leadershipSamples) {
            const result = await analyzer.analyze(sample);
            if (result.linePosition === 5) {
                line5Count++;
            }
        }
        
        const line5Ratio = line5Count / leadershipSamples.length;
        expect(line5Ratio).toBeGreaterThanOrEqual(0.60);  // 60%以上
    });
    
    test('性能しきい値', async () => {
        const times = [];
        
        for (let i = 0; i < 100; i++) {
            const start = performance.now();
            await analyzer.analyze("テストテキスト" + i);
            const time = performance.now() - start;
            times.push(time);
        }
        
        const avg = times.reduce((a, b) => a + b) / times.length;
        const sorted = times.sort((a, b) => a - b);
        const p95 = sorted[Math.floor(times.length * 0.95)];
        
        expect(avg).toBeLessThan(40);   // 平均40ms未満
        expect(p95).toBeLessThan(45);   // p95が45ms未満
    });
});
```

---

## 📝 運用監視タスク（各Phase終了時に必須）

### 継続的モニタリング設定
```javascript
class ContinuousMonitoring {
    constructor() {
        // メトリクス収集間隔
        this.intervals = {
            performance: 60000,     // 1分ごと
            accuracy: 3600000,      // 1時間ごと
            distribution: 600000    // 10分ごと
        };
        
        this.startMonitoring();
    }
    
    startMonitoring() {
        // パフォーマンス監視
        setInterval(() => {
            const metrics = this.collectPerformanceMetrics();
            if (metrics.p95 > 45) {
                this.sendAlert('PERFORMANCE_DEGRADATION', metrics);
            }
        }, this.intervals.performance);
        
        // 分布監視
        setInterval(() => {
            const bias = this.checkDistributionBias();
            if (bias.detected) {
                this.sendAlert('DISTRIBUTION_BIAS', bias);
            }
        }, this.intervals.distribution);
    }
}
```

---

## 🎯 リスク管理と軽減策

| リスク | 影響度 | 軽減策 |
|--------|--------|--------|
| データファイル欠損 | 高 | Phase 0で事前検証・フォールバック準備 |
| 性能目標未達 | 中 | 段階的最適化・キャッシュ強化 |
| 偏り発生 | 高 | χ²検定による自動検出・補正 |
| メモリ超過 | 高 | モデル圧縮・段階的ロード |

---

## ✅ Go/No-Go判定基準

### Phase 0終了時点
- [ ] 全必須データファイル利用可能
- [ ] DB移行テスト成功
- [ ] 監視基盤稼働

### Phase 1終了時点  
- [ ] 決定論性100%達成
- [ ] E2E平均 < 40ms
- [ ] 偏り検出・補正機能稼働

### 最終リリース基準
- [ ] 全DoD項目クリア
- [ ] 3つの最小検証合格
- [ ] 運用監視アラート設定完了

---

**文書完了** - 指摘事項を反映し、実装可能な詳細度まで落とし込みました