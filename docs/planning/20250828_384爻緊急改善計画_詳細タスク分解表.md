# 384çˆ»ã‚·ã‚¹ãƒ†ãƒ ç·Šæ€¥æ”¹å–„è¨ˆç”» è©³ç´°ã‚¿ã‚¹ã‚¯åˆ†è§£è¡¨

**æ–‡æ›¸ç•ªå·**: HAQEI-URGENT-005  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ28æ—¥  
**ç·Šæ€¥åº¦**: ğŸ”´ æœ€å„ªå…ˆ  
**ç·å·¥æ•°è¦‹ç©**: 4é€±é–“ï¼ˆ160æ™‚é–“ï¼‰
**å‰æ**: ç¾åœ¨ã®å®Ÿè£…å®Œäº†åº¦5%ã‹ã‚‰ã®æ”¹å–„

---

## ğŸš¦ çµè«–ï¼ˆGo/No-Goï¼‰

**çµè«–**: æ¡ä»¶ä»˜ãGoï¼ˆä¿®æ­£å¿…é ˆã®èµ¤å­—ãƒã‚¤ãƒ³ãƒˆã‚ã‚Šï¼‰

ç€æ‰‹å¯èƒ½ãªãƒ¬ãƒ™ãƒ«ã¾ã§WBSãƒ»ä¾å­˜é–¢ä¿‚ãƒ»å®Ÿè£…æ–­ç‰‡ã¯æƒã£ã¦ã„ã‚‹ãŒã€ä»¥ä¸‹4ç‚¹ã‚’é–‹å§‹å‰ã«ä¿®æ­£ã—ãªã„ã¨è©°ã¾ã‚‹ã€‚

1. éç¾å®Ÿãªæ€§èƒ½ç›®æ¨™: 5msç´šã¯Edgeåˆ¶ç´„ã¨çŸ›ç›¾ã€‚E2Eã®åˆå¦ã¯å¹³å‡<40msã€p95<45msã€p99<50msã«çµ±ä¸€ã—ã€ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã¯p50/95/99ã‚’è¨˜éŒ²ã€‚
2. ãƒ‡ãƒ¼ã‚¿ä¾å­˜ã®æ˜è¨˜ä¸è¶³: `enhanced_hexagrams_complete.json` / `yaoci_31-63.json` / `h384.json` ã®å­˜åœ¨ãƒ»ã‚¹ã‚­ãƒ¼ãƒæ•´åˆãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹å¯å¦ã‚’ä½œæ¥­å‰æã¨ã—ã¦æ¤œè¨¼ã—ã€æœªå…¥æ‰‹æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯/ç¸®é€€é‹è»¢ã‚’æ˜æ–‡åŒ–ã€‚
3. DBçµ±åˆã®DoDä¸è¶³: D1/SQLiteã®ç§»è¡Œãƒ†ã‚¹ãƒˆï¼ˆup/downï¼‰ã€æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã€ä¸»è¦ã‚¯ã‚¨ãƒªp95<10msã€ç ´ææ™‚ã®è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’æˆåŠŸæ¡ä»¶ã¨ã—ã¦å®šç¾©ã€‚
4. æ±ºå®šè«–æ€§ã¨é‡ã¿å¤‰æ›´ã®å‰¯ä½œç”¨ç›£è¦–: å›ºå®šã‚·ãƒ¼ãƒ‰å†å®Ÿè¡Œã®ä¸€è‡´ç‡=100%ã‚’æ˜ç¤ºã€‚ä½ç½®åˆ†å¸ƒã®Ï‡Â²ãƒ†ã‚¹ãƒˆãƒ»ã—ãã„å€¤ãƒ»é€¸è„±æ™‚ã®è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆ/æ‰‹é †ã‚’æ•°å€¤ã§è¦å®šã€‚

è‰¯ã„ç‚¹ï¼ˆå®Ÿè£…ã«è¶³ã‚‹æ ¹æ‹ ï¼‰
- WBSã¨ä¾å­˜é–¢ä¿‚ãŒæ˜ç¢ºã§ã€å…·ä½“çš„ãªã‚³ãƒ¼ãƒ‰å¤‰æ›´ç‚¹ãŒè¨˜è¼‰ã€‚
- è©•ä¾¡ç”¨ãƒ†ã‚¹ãƒˆé››å½¢ã¨æœŸå¾…åˆ†å¸ƒï¼ˆToleranceï¼‰ãŒæç¤ºæ¸ˆã¿ã€‚
- Edgeç¾å®Ÿè«–ã¨å…¨ä½“ã‚¬ãƒãƒŠãƒ³ã‚¹ã®æ•´åˆãŒå–ã‚Œã¦ã„ã‚‹ã€‚

å°ã•ãªã‚ºãƒ¬/æ°—ã«ãªã‚‹ç‚¹ï¼ˆé‹ç”¨å®‰å®šåŒ–ã®ãŸã‚ã®è£œæ­£ï¼‰
- å·¥æ•°è¦‹ç©ã‚Šã®æŒ¯ã‚Œå¹…ã‚’è§£æ¶ˆï¼ˆæœ¬æ›¸ã®æ­£ã¯ã€Œ4é€±é–“=160æ™‚é–“ã€ï¼‰ã€‚
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™ã‚’æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ã§çµ±ä¸€ï¼ˆå¹³å‡<40msã€p95<45msã€p99<50msï¼‰ã€‚

ã“ã®çµè«–ã‚’åæ˜ ã™ã‚‹ãŸã‚ã€ä»¥ä¸‹ã®ã€ŒPhase 0: Pre-flightã€ã€ŒDBçµ±åˆDoDã€ã€ŒDoDãƒ†ãƒ³ãƒ—ãƒ¬ã€ã€Œæœ€å°æ¤œè¨¼3æœ¬ã€ã‚’è¿½è¨˜ã™ã‚‹ã€‚

---

## ğŸ›« Phase 0: Pre-flightï¼ˆãƒ‡ãƒ¼ã‚¿&ãƒ©ã‚¤ã‚»ãƒ³ã‚¹&ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ï¼‰

é–‹å§‹ã‚²ãƒ¼ãƒˆã€‚ã“ã“ã‚’æº€ãŸã•ãªã„å ´åˆã¯å®Ÿè£…ã«é€²ã¾ãªã„ã€‚

### Task P0-1: ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ãƒ»ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼ï¼ˆ4æ™‚é–“ï¼‰
å¯¾è±¡: `/data/h384.json`, `/data/enhanced_hexagrams_complete.json`, `/data/yaoci_31-63.json`

- ä»•æ§˜: Zod/JSON Schemaã§å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ»å‹ãƒ»ä»¶æ•°ï¼ˆä¾‹: h384=384ä»¶ã€hexagrams=64ä»¶ï¼‰ã‚’æ¤œè¨¼ã€‚
- å¤±æ•—æ™‚: `DataValidator`ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å¼·åˆ¶é©ç”¨ã—ç¸®é€€é‹è»¢ã«åˆ‡æ›¿ã€‚
- DoD: 3ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨/æ•´åˆãƒ­ã‚°ã€æ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆJSONï¼ˆä¿å­˜: `localStorage:dataValidation`ï¼‰ã€‚

### Task P0-2: ãƒ©ã‚¤ã‚»ãƒ³ã‚¹/å‡ºå…¸ç¢ºèªï¼ˆ2æ™‚é–“ï¼‰
- ä»•æ§˜: 3ãƒ‡ãƒ¼ã‚¿ã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹å¯å¦ãƒ»å‡ºå…¸ãƒ»å¸°å±è¡¨è¨˜ã®è¦å¦ã‚’ç¢ºèªã—ã€`docs/licenses/data-sources.md`ã«è¨˜éŒ²ã€‚
- DoD: ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®OK/NGãƒãƒˆãƒªã‚¯ã‚¹ã€NGæ™‚ã®ä»£æ›¿ãƒ‡ãƒ¼ã‚¿å–å¾—è¨ˆç”»ï¼ˆæœŸé™/è²¬ä»»è€…ï¼‰ã‚’æ˜è¨˜ã€‚

### Task P0-3: ç¸®é€€é‹è»¢ã®æœ€å°æ©Ÿèƒ½å®šç¾©ï¼ˆ2æ™‚é–“ï¼‰
- ä»•æ§˜: ãƒ‡ãƒ¼ã‚¿æ¬ ææ™‚ã®æ©Ÿèƒ½åˆ¶é™ç¯„å›²ã‚’å®šç¾©ï¼ˆä¾‹: æ–‡è„ˆè§£æ=ONã€è©³ç´°è§£èª¬=OFFã€UIè­¦å‘Š=ONï¼‰ã€‚
- DoD: 3ã‚·ãƒŠãƒªã‚ªï¼ˆå®Œå…¨ã€éƒ¨åˆ†ã€æ¬ æï¼‰ã®æ‰‹å‹•/è‡ªå‹•ãƒ†ã‚¹ãƒˆé€šéã€UIè­¦å‘Šè¡¨ç¤ºã®ç¢ºèªã€‚

ã‚²ãƒ¼ãƒˆï¼ˆGo/No-Goï¼‰
- Go: P0-1ã€œP0-3ã®DoDã‚’å…¨ã¦æº€ãŸã™ã€‚
- No-Go: ã„ãšã‚Œã‹æœªé”ã€‚Week 1ã®å®Ÿè£…é–‹å§‹ã‚’ä¿ç•™ã€‚

## ğŸš¨ ç¾çŠ¶ã®é‡å¤§å•é¡Œã¨ç·Šæ€¥å¯¾å¿œã®å¿…è¦æ€§

### è‡´å‘½çš„ãƒªã‚¹ã‚¯ï¼ˆå³åº§å¯¾å¿œå¿…é ˆï¼‰
1. **ãƒ‡ãƒ¼ã‚¿æ¬ æã§ã®ã‚¯ãƒ©ãƒƒã‚·ãƒ¥**: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æœªå®Ÿè£…ã§ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢ãƒªã‚¹ã‚¯
2. **çµ±è¨ˆçš„å¦¥å½“æ€§ã®æ¬ å¦‚**: Ï‡Â²æ¤œå®šãªã—ã§åã‚Šæ¤œå‡ºãŒæ©Ÿèƒ½ã—ãªã„
3. **æ±ºå®šè«–æ€§ã®æœªä¿è¨¼**: åŒä¸€å…¥åŠ›ã§ç•°ãªã‚‹çµæœï¼ä¿¡é ¼æ€§ã‚¼ãƒ­
4. **ç›£è¦–ä¸èƒ½**: ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãªã—ã§å•é¡Œç™ºè¦‹ãŒé…å»¶

---

## ğŸ“‹ Week 1: ç·Šæ€¥å¯¾å¿œï¼ˆåŸºç›¤å®‰å®šåŒ–ï¼‰

### Day 1-2: ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…

#### Task W1-1: ç·Šæ€¥ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰ï¼ˆ8æ™‚é–“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/core/DataValidator.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ æœ€å„ªå…ˆï¼ˆã‚¯ãƒ©ãƒƒã‚·ãƒ¥é˜²æ­¢ï¼‰

```javascript
// å®Ÿè£…è¦ä»¶: å³åº§ã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚’é˜²ãæœ€å°å®Ÿè£…
class DataValidator {
    constructor() {
        this.criticalFiles = [
            {
                path: '/data/h384.json',
                fallback: this.generateMinimalH384Data,
                validate: (data) => Array.isArray(data) && data.length === 384
            },
            {
                path: '/data/enhanced_hexagrams_complete.json',
                fallback: this.generateBasicHexagrams,
                validate: (data) => Array.isArray(data) && data.length === 64
            },
            {
                path: '/data/yaoci_31-63.json',
                fallback: null,  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸å¯ï¼ˆå¿…é ˆï¼‰
                validate: (data) => Array.isArray(data)
            }
        ];
        
        this.validationResults = {
            timestamp: null,
            files: {},
            isValid: false,
            fallbacksUsed: []
        };
    }
    
    async validateAll() {
        console.log('ğŸ” ç·Šæ€¥ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼é–‹å§‹...');
        this.validationResults.timestamp = Date.now();
        let allValid = true;
        
        for (const file of this.criticalFiles) {
            try {
                const response = await fetch(file.path);
                if (!response.ok) throw new Error(`404: ${file.path}`);
                
                const data = await response.json();
                const isValid = file.validate(data);
                
                this.validationResults.files[file.path] = {
                    exists: true,
                    valid: isValid,
                    size: JSON.stringify(data).length,
                    records: Array.isArray(data) ? data.length : 0
                };
                
                if (!isValid) {
                    console.error(`âŒ ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿: ${file.path}`);
                    if (file.fallback) {
                        const fallbackData = file.fallback();
                        this.validationResults.fallbacksUsed.push(file.path);
                        console.warn(`âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨: ${file.path}`);
                        window[`fallback_${file.path.split('/').pop().split('.')[0]}`] = fallbackData;
                    } else {
                        allValid = false;
                    }
                }
            } catch (error) {
                console.error(`âŒ ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—: ${file.path}`, error);
                this.validationResults.files[file.path] = {
                    exists: false,
                    error: error.message
                };
                
                if (file.fallback) {
                    const fallbackData = file.fallback();
                    this.validationResults.fallbacksUsed.push(file.path);
                    window[`fallback_${file.path.split('/').pop().split('.')[0]}`] = fallbackData;
                } else {
                    allValid = false;
                }
            }
        }
        
        this.validationResults.isValid = allValid;
        
        // çµæœã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¨LocalStorageã«è¨˜éŒ²
        console.table(this.validationResults.files);
        localStorage.setItem('dataValidation', JSON.stringify(this.validationResults));
        
        return allValid;
    }
    
    generateMinimalH384Data() {
        // æœ€å°é™ã®384çˆ»ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
        const data = [];
        for (let hex = 1; hex <= 64; hex++) {
            for (let line = 1; line <= 6; line++) {
                data.push({
                    id: (hex - 1) * 6 + line,
                    hexagram: hex,
                    line: line,
                    keywords: [`å¦${hex}`, `çˆ»${line}`],
                    interpretation: `å¦${hex}ã®ç¬¬${line}çˆ»`
                });
            }
        }
        return data;
    }
    
    generateBasicHexagrams() {
        // åŸºæœ¬çš„ãª64å¦ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
        const names = ['ä¹¾', 'å¤', 'å±¯', 'è’™', 'éœ€', 'è¨Ÿ', 'å¸«', 'æ¯”'];  // ... çœç•¥
        return Array.from({length: 64}, (_, i) => ({
            id: i + 1,
            name: names[i] || `å¦${i + 1}`,
            lines: Array.from({length: 6}, (_, j) => ({
                position: j + 1,
                text: `ç¬¬${j + 1}çˆ»`
            }))
        }));
    }
}

// èµ·å‹•æ™‚ã®è‡ªå‹•å®Ÿè¡Œ
window.addEventListener('DOMContentLoaded', async () => {
    const validator = new DataValidator();
    const isValid = await validator.validateAll();
    
    if (!isValid) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è­¦å‘Šè¡¨ç¤º
        const warning = document.createElement('div');
        warning.className = 'data-warning';
        warning.innerHTML = `
            <div style="background: #ff6b6b; color: white; padding: 10px; position: fixed; top: 0; width: 100%; z-index: 9999;">
                âš ï¸ ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ä¸€éƒ¨æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™
                <button onclick="this.parentElement.remove()">Ã—</button>
            </div>
        `;
        document.body.appendChild(warning);
    }
});
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] å…¨ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
- [ ] ã‚¹ã‚­ãƒ¼ãƒæ¤œè¨¼å®Ÿè£…
- [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
- [ ] ã‚¨ãƒ©ãƒ¼æ™‚ã®UIè­¦å‘Šè¡¨ç¤º
- [ ] LocalStorageè¨˜éŒ²

#### Task W1-2: æ±ºå®šè«–æ€§ä¿è¨¼ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ8æ™‚é–“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/core/DeterministicEngine.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ æœ€å„ªå…ˆï¼ˆä¿¡é ¼æ€§ç¢ºä¿ï¼‰

```javascript
class DeterministicEngine {
    constructor(seed = 42) {
        this.seed = seed;
        this.originalSeed = seed;
        this.callCount = 0;
        this.history = [];
        
        // Math.randomã‚’ä¸Šæ›¸ãï¼ˆé–‹ç™ºç’°å¢ƒã®ã¿ï¼‰
        if (window.location.hostname === 'localhost') {
            this.overrideMathRandom();
        }
    }
    
    // æ±ºå®šè«–çš„ãªç–‘ä¼¼ä¹±æ•°ç”Ÿæˆå™¨ï¼ˆXorshiftï¼‰
    random() {
        this.callCount++;
        let x = this.seed;
        x ^= x << 13;
        x ^= x >> 17;
        x ^= x << 5;
        this.seed = x >>> 0;
        
        const value = (x >>> 0) / 0xFFFFFFFF;
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨å±¥æ­´è¨˜éŒ²
        if (this.history.length < 1000) {
            this.history.push({
                call: this.callCount,
                value: value,
                seed: this.seed
            });
        }
        
        return value;
    }
    
    // ç¯„å›²æŒ‡å®šä¹±æ•°
    randomInt(min, max) {
        return Math.floor(this.random() * (max - min + 1)) + min;
    }
    
    // é…åˆ—ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆFisher-Yatesï¼‰
    shuffle(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i--) {
            const j = this.randomInt(0, i);
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }
    
    // é‡ã¿ä»˜ãé¸æŠ
    weightedChoice(items, weights) {
        const total = weights.reduce((a, b) => a + b, 0);
        let random = this.random() * total;
        
        for (let i = 0; i < items.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return items[i];
            }
        }
        return items[items.length - 1];
    }
    
    // ã‚·ãƒ¼ãƒ‰å¾©å…ƒ
    reset() {
        this.seed = this.originalSeed;
        this.callCount = 0;
        this.history = [];
    }
    
    // æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆ
    testDeterminism(iterations = 100) {
        const results = [];
        
        for (let run = 0; run < 3; run++) {
            this.reset();
            const runResults = [];
            
            for (let i = 0; i < iterations; i++) {
                runResults.push(this.random());
            }
            results.push(runResults);
        }
        
        // å…¨å®Ÿè¡ŒãŒåŒä¸€ã‹ç¢ºèª
        const firstRun = JSON.stringify(results[0]);
        const allSame = results.every(run => JSON.stringify(run) === firstRun);
        
        console.log(`æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆ: ${allSame ? 'âœ… åˆæ ¼' : 'âŒ å¤±æ•—'}`);
        return allSame;
    }
    
    // Math.randomä¸Šæ›¸ãï¼ˆé–‹ç™ºç’°å¢ƒç”¨ï¼‰
    overrideMathRandom() {
        const original = Math.random;
        Math.random = () => {
            const value = this.random();
            console.debug(`Math.random() â†’ ${value}`);
            return value;
        };
        
        // å¾©å…ƒç”¨
        Math.random.restore = () => {
            Math.random = original;
        };
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š
window.deterministicEngine = new DeterministicEngine(42);
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] ç–‘ä¼¼ä¹±æ•°ç”Ÿæˆå™¨å®Ÿè£…
- [ ] ã‚·ãƒ¼ãƒ‰ç®¡ç†æ©Ÿèƒ½
- [ ] æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
- [ ] ç¯„å›²æŒ‡å®šãƒ»é‡ã¿ä»˜ãé¸æŠ
- [ ] ãƒ‡ãƒãƒƒã‚°ç”¨å±¥æ­´è¨˜éŒ²

### Day 3-4: Ï‡Â²æ¤œå®šã¨åã‚Šæ¤œå‡ºå®Ÿè£…

#### Task W1-3: çµ±è¨ˆçš„åã‚Šæ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ ï¼ˆ12æ™‚é–“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/StatisticalBiasDetector.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ æœ€å„ªå…ˆï¼ˆå“è³ªä¿è¨¼ï¼‰

```javascript
class StatisticalBiasDetector {
    constructor() {
        this.observations = {
            linePositions: new Array(6).fill(0),    // 1-6çˆ»ã®é¸æŠå›æ•°
            hexagrams: new Array(64).fill(0),       // 1-64å¦ã®é¸æŠå›æ•°
            total: 0,
            history: []  // æœ€æ–°1000ä»¶ã®å±¥æ­´
        };
        
        // Ï‡Â²åˆ†å¸ƒã®è‡¨ç•Œå€¤ï¼ˆè‡ªç”±åº¦ã¨æœ‰æ„æ°´æº–åˆ¥ï¼‰
        this.criticalValues = {
            5: { 0.05: 11.070, 0.01: 15.086 },    // è‡ªç”±åº¦5ï¼ˆ6çˆ»-1ï¼‰
            63: { 0.05: 82.529, 0.01: 92.010 }    // è‡ªç”±åº¦63ï¼ˆ64å¦-1ï¼‰
        };
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š
        this.alertThresholds = {
            maxPositionBias: 0.30,      // 30%è¶…ãˆãŸã‚‰ã‚¢ãƒ©ãƒ¼ãƒˆ
            minPositionUsage: 0.10,     // 10%æœªæº€ã§ã‚¢ãƒ©ãƒ¼ãƒˆ
            consecutiveBias: 5,         // 5å›é€£ç¶šã§åŒã˜çˆ»/å¦
            sampleSizeMinimum: 30       // æœ€å°ã‚µãƒ³ãƒ—ãƒ«æ•°
        };
        
        this.alerts = [];
        this.correctionWeights = null;
    }
    
    // é¸æŠã‚’è¨˜éŒ²
    recordSelection(hexagramId, linePosition) {
        // ç¯„å›²ãƒã‚§ãƒƒã‚¯
        if (hexagramId < 1 || hexagramId > 64 || linePosition < 1 || linePosition > 6) {
            console.error('Invalid selection:', { hexagramId, linePosition });
            return;
        }
        
        this.observations.hexagrams[hexagramId - 1]++;
        this.observations.linePositions[linePosition - 1]++;
        this.observations.total++;
        
        // å±¥æ­´æ›´æ–°ï¼ˆæœ€æ–°1000ä»¶ä¿æŒï¼‰
        this.observations.history.push({ hexagramId, linePosition, timestamp: Date.now() });
        if (this.observations.history.length > 1000) {
            this.observations.history.shift();
        }
        
        // å®šæœŸãƒã‚§ãƒƒã‚¯ï¼ˆ30ä»¶ã”ã¨ï¼‰
        if (this.observations.total >= this.alertThresholds.sampleSizeMinimum && 
            this.observations.total % 30 === 0) {
            this.performStatisticalTests();
        }
    }
    
    // Ï‡Â²æ¤œå®šå®Ÿè¡Œ
    performChiSquareTest(observed, expected) {
        let chiSquare = 0;
        
        for (let i = 0; i < observed.length; i++) {
            if (expected[i] > 0) {
                chiSquare += Math.pow(observed[i] - expected[i], 2) / expected[i];
            }
        }
        
        return chiSquare;
    }
    
    // çµ±è¨ˆçš„æ¤œå®šã‚’å®Ÿè¡Œ
    performStatisticalTests() {
        const results = {
            linePosition: this.testLinePositionBias(),
            hexagram: this.testHexagramBias(),
            consecutive: this.testConsecutiveBias(),
            timestamp: Date.now()
        };
        
        // ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
        this.generateAlerts(results);
        
        // è£œæ­£é‡ã¿è¨ˆç®—
        if (results.linePosition.significant || results.hexagram.significant) {
            this.calculateCorrectionWeights(results);
        }
        
        return results;
    }
    
    // çˆ»ä½ç½®ã®åã‚Šæ¤œå®š
    testLinePositionBias() {
        const observed = this.observations.linePositions;
        const total = observed.reduce((a, b) => a + b, 0);
        
        if (total < this.alertThresholds.sampleSizeMinimum) {
            return { significant: false, reason: 'insufficient_data' };
        }
        
        const expected = Array(6).fill(total / 6);
        const chiSquare = this.performChiSquareTest(observed, expected);
        const criticalValue = this.criticalValues[5][0.05];
        
        // å„ä½ç½®ã®ä½¿ç”¨ç‡è¨ˆç®—
        const usage = observed.map(count => count / total);
        const maxUsage = Math.max(...usage);
        const minUsage = Math.min(...usage);
        
        return {
            chiSquare,
            criticalValue,
            significant: chiSquare > criticalValue,
            pValue: this.calculatePValue(chiSquare, 5),
            usage,
            maxUsage,
            minUsage,
            maxPosition: usage.indexOf(maxUsage) + 1,
            minPosition: usage.indexOf(minUsage) + 1
        };
    }
    
    // å¦ã®åã‚Šæ¤œå®š
    testHexagramBias() {
        const observed = this.observations.hexagrams;
        const total = observed.reduce((a, b) => a + b, 0);
        
        if (total < this.alertThresholds.sampleSizeMinimum * 2) {
            return { significant: false, reason: 'insufficient_data' };
        }
        
        const expected = Array(64).fill(total / 64);
        const chiSquare = this.performChiSquareTest(observed, expected);
        const criticalValue = this.criticalValues[63][0.05];
        
        // ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„å¦ã®æ•°
        const unusedCount = observed.filter(count => count === 0).length;
        
        return {
            chiSquare,
            criticalValue,
            significant: chiSquare > criticalValue,
            pValue: this.calculatePValue(chiSquare, 63),
            unusedCount,
            unusedPercentage: (unusedCount / 64) * 100
        };
    }
    
    // é€£ç¶šæ€§ã®æ¤œå‡º
    testConsecutiveBias() {
        const history = this.observations.history.slice(-20);  // æœ€æ–°20ä»¶
        
        if (history.length < 5) {
            return { significant: false, reason: 'insufficient_data' };
        }
        
        let maxConsecutive = 1;
        let currentConsecutive = 1;
        let consecutiveType = null;
        
        for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            
            if (prev.hexagramId === curr.hexagramId && prev.linePosition === curr.linePosition) {
                currentConsecutive++;
                if (currentConsecutive > maxConsecutive) {
                    maxConsecutive = currentConsecutive;
                    consecutiveType = `${curr.hexagramId}-${curr.linePosition}`;
                }
            } else {
                currentConsecutive = 1;
            }
        }
        
        return {
            maxConsecutive,
            consecutiveType,
            significant: maxConsecutive >= this.alertThresholds.consecutiveBias
        };
    }
    
    // på€¤ã®è¿‘ä¼¼è¨ˆç®—
    calculatePValue(chiSquare, df) {
        // ç°¡æ˜“çš„ãªpå€¤è¿‘ä¼¼ï¼ˆå®Ÿéš›ã¯ã‚¬ãƒ³ãƒé–¢æ•°ä½¿ç”¨ï¼‰
        if (df === 5) {
            if (chiSquare < 1.145) return 0.95;
            if (chiSquare < 3.357) return 0.50;
            if (chiSquare < 5.385) return 0.25;
            if (chiSquare < 7.289) return 0.10;
            if (chiSquare < 11.070) return 0.05;
            if (chiSquare < 15.086) return 0.01;
            return 0.001;
        }
        // df=63ã®å ´åˆã¯çœç•¥
        return 0.05;
    }
    
    // ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
    generateAlerts(results) {
        this.alerts = [];
        
        // çˆ»ä½ç½®åã‚Šã‚¢ãƒ©ãƒ¼ãƒˆ
        if (results.linePosition.significant) {
            this.alerts.push({
                type: 'LINE_POSITION_BIAS',
                severity: 'HIGH',
                message: `çˆ»ä½ç½®ã«æœ‰æ„ãªåã‚Šã‚’æ¤œå‡º (Ï‡Â²=${results.linePosition.chiSquare.toFixed(2)}, p<0.05)`,
                data: results.linePosition,
                timestamp: Date.now()
            });
        }
        
        // æœ€å¤§ä½¿ç”¨ç‡ã‚¢ãƒ©ãƒ¼ãƒˆ
        if (results.linePosition.maxUsage > this.alertThresholds.maxPositionBias) {
            this.alerts.push({
                type: 'EXCESSIVE_POSITION_USAGE',
                severity: 'MEDIUM',
                message: `ç¬¬${results.linePosition.maxPosition}çˆ»ã®ä½¿ç”¨ç‡ãŒ${(results.linePosition.maxUsage * 100).toFixed(1)}%`,
                data: results.linePosition,
                timestamp: Date.now()
            });
        }
        
        // é€£ç¶šæ€§ã‚¢ãƒ©ãƒ¼ãƒˆ
        if (results.consecutive.significant) {
            this.alerts.push({
                type: 'CONSECUTIVE_SELECTION',
                severity: 'MEDIUM',
                message: `${results.consecutive.consecutiveType}ãŒ${results.consecutive.maxConsecutive}å›é€£ç¶š`,
                data: results.consecutive,
                timestamp: Date.now()
            });
        }
        
        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        if (this.alerts.length > 0) {
            console.group('âš ï¸ çµ±è¨ˆçš„åã‚Šã‚¢ãƒ©ãƒ¼ãƒˆ');
            this.alerts.forEach(alert => {
                console.warn(`[${alert.severity}] ${alert.message}`);
            });
            console.groupEnd();
        }
    }
    
    // è£œæ­£é‡ã¿è¨ˆç®—
    calculateCorrectionWeights(results) {
        const weights = {
            linePositions: new Array(6).fill(1.0),
            hexagrams: new Array(64).fill(1.0),
            timestamp: Date.now()
        };
        
        // çˆ»ä½ç½®ã®è£œæ­£é‡ã¿
        if (results.linePosition.significant) {
            const targetProb = 1 / 6;
            results.linePosition.usage.forEach((usage, index) => {
                if (usage > 0) {
                    // ä½¿ç”¨ç‡ã®é€†æ•°ã§é‡ã¿ä»˜ã‘
                    weights.linePositions[index] = targetProb / usage;
                    // æ¥µç«¯ãªè£œæ­£ã‚’é˜²ãï¼ˆ0.5-2.0ã®ç¯„å›²ï¼‰
                    weights.linePositions[index] = Math.max(0.5, Math.min(2.0, weights.linePositions[index]));
                }
            });
        }
        
        this.correctionWeights = weights;
        console.log('ğŸ“Š è£œæ­£é‡ã¿æ›´æ–°:', weights);
        
        return weights;
    }
    
    // è£œæ­£ã‚’é©ç”¨ã—ãŸé¸æŠ
    applyCorrection(candidates) {
        if (!this.correctionWeights) {
            return candidates[Math.floor(Math.random() * candidates.length)];
        }
        
        // é‡ã¿ä»˜ãé¸æŠ
        const weights = candidates.map(c => {
            const lineWeight = this.correctionWeights.linePositions[c.linePosition - 1];
            const hexWeight = this.correctionWeights.hexagrams[c.hexagramId - 1];
            return lineWeight * hexWeight * c.baseScore;
        });
        
        // é‡ã¿ã®æ­£è¦åŒ–
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        const normalizedWeights = weights.map(w => w / totalWeight);
        
        // ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆé¸æŠ
        const random = Math.random();
        let cumulative = 0;
        
        for (let i = 0; i < candidates.length; i++) {
            cumulative += normalizedWeights[i];
            if (random <= cumulative) {
                return candidates[i];
            }
        }
        
        return candidates[candidates.length - 1];
    }
    
    // çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    generateReport() {
        const report = {
            summary: {
                totalSelections: this.observations.total,
                testResults: this.performStatisticalTests(),
                alerts: this.alerts.length,
                correctionActive: !!this.correctionWeights
            },
            linePositions: {
                counts: this.observations.linePositions,
                percentages: this.observations.linePositions.map(
                    c => ((c / this.observations.total) * 100).toFixed(2) + '%'
                ),
                chiSquare: null
            },
            hexagrams: {
                used: this.observations.hexagrams.filter(c => c > 0).length,
                unused: this.observations.hexagrams.filter(c => c === 0).length,
                top5: this.getTop5Hexagrams()
            }
        };
        
        return report;
    }
    
    // ä¸Šä½5å¦ã‚’å–å¾—
    getTop5Hexagrams() {
        return this.observations.hexagrams
            .map((count, index) => ({ id: index + 1, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5)
            .map(h => `å¦${h.id} (${h.count}å›)`);
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š
window.biasDetector = new StatisticalBiasDetector();
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] Ï‡Â²æ¤œå®šã®æ­£ç¢ºãªå®Ÿè£…
- [ ] på€¤è¨ˆç®—
- [ ] è¤‡æ•°ã®åã‚ŠæŒ‡æ¨™ï¼ˆä½ç½®ã€å¦ã€é€£ç¶šæ€§ï¼‰
- [ ] è‡ªå‹•ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
- [ ] è£œæ­£é‡ã¿è¨ˆç®—ã¨é©ç”¨

### Day 5: æ€§èƒ½æ¸¬å®šã¨ç›£è¦–åŸºç›¤

#### Task W1-4: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ8æ™‚é–“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/monitoring/PerformanceMonitor.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**å„ªå…ˆåº¦**: ğŸ”´ æœ€å„ªå…ˆï¼ˆæ€§èƒ½ä¿è¨¼ï¼‰

```javascript
class PerformanceMonitor {
    constructor() {
        this.metrics = {
            e2e: [],           // End-to-Endå‡¦ç†æ™‚é–“
            analysis: [],      // åˆ†æå‡¦ç†æ™‚é–“
            rendering: [],     // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚é–“
            memory: [],        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡
            cache: {
                hits: 0,
                misses: 0
            }
        };
        
        // ç›®æ¨™å€¤ï¼ˆSLAï¼‰
        this.targets = {
            e2e_average: 40,    // ms
            e2e_p50: 35,
            e2e_p95: 45,
            e2e_p99: 50,
            memory_max: 120     // MB
        };
        
        // è‡ªå‹•ç›£è¦–è¨­å®š
        this.monitoringInterval = null;
        this.reportInterval = 60000;  // 1åˆ†ã”ã¨ã«ãƒ¬ãƒãƒ¼ãƒˆ
    }
    
    // å‡¦ç†æ™‚é–“æ¸¬å®š
    measurePerformance(operation) {
        const startMark = `${operation}-start-${Date.now()}`;
        const endMark = `${operation}-end-${Date.now()}`;
        
        performance.mark(startMark);
        
        return {
            end: () => {
                performance.mark(endMark);
                performance.measure(operation, startMark, endMark);
                
                const measure = performance.getEntriesByName(operation)[0];
                const duration = measure.duration;
                
                // è¨˜éŒ²
                this.recordMetric('e2e', duration);
                
                // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                performance.clearMarks(startMark);
                performance.clearMarks(endMark);
                performance.clearMeasures(operation);
                
                // SLAé•åãƒã‚§ãƒƒã‚¯
                if (duration > this.targets.e2e_p95) {
                    console.warn(`âš ï¸ SLAé•å: ${operation} took ${duration.toFixed(2)}ms (target: <${this.targets.e2e_p95}ms)`);
                }
                
                return duration;
            }
        };
    }
    
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
    recordMetric(type, value) {
        if (!this.metrics[type]) {
            this.metrics[type] = [];
        }
        
        this.metrics[type].push({
            value,
            timestamp: Date.now()
        });
        
        // ç›´è¿‘1000ä»¶ã®ã¿ä¿æŒ
        if (this.metrics[type].length > 1000) {
            this.metrics[type].shift();
        }
    }
    
    // ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«è¨ˆç®—
    calculatePercentile(values, percentile) {
        if (values.length === 0) return 0;
        
        const sorted = values.sort((a, b) => a - b);
        const index = Math.ceil((percentile / 100) * sorted.length) - 1;
        return sorted[Math.max(0, index)];
    }
    
    // çµ±è¨ˆæƒ…å ±è¨ˆç®—
    calculateStatistics(metricType) {
        const values = this.metrics[metricType].map(m => m.value);
        
        if (values.length === 0) {
            return null;
        }
        
        return {
            count: values.length,
            average: values.reduce((a, b) => a + b, 0) / values.length,
            min: Math.min(...values),
            max: Math.max(...values),
            p50: this.calculatePercentile(values, 50),
            p95: this.calculatePercentile(values, 95),
            p99: this.calculatePercentile(values, 99)
        };
    }
    
    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
    monitorMemory() {
        if (performance.memory) {
            const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
            this.recordMetric('memory', memoryMB);
            
            if (memoryMB > this.targets.memory_max) {
                console.error(`âŒ ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡è¶…é: ${memoryMB.toFixed(2)}MB (max: ${this.targets.memory_max}MB)`);
                this.triggerMemoryCleanup();
            }
        }
    }
    
    // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    triggerMemoryCleanup() {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
        if (window.caches) {
            caches.keys().then(names => {
                names.forEach(name => caches.delete(name));
            });
        }
        
        // å¼·åˆ¶ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆChrome DevToolså¿…è¦ï¼‰
        if (window.gc) {
            window.gc();
            console.log('ğŸ§¹ ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ');
        }
    }
    
    // è‡ªå‹•ç›£è¦–é–‹å§‹
    startMonitoring() {
        if (this.monitoringInterval) {
            return;
        }
        
        this.monitoringInterval = setInterval(() => {
            this.monitorMemory();
            this.generateReport();
        }, this.reportInterval);
        
        console.log('ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–é–‹å§‹');
    }
    
    // ç›£è¦–åœæ­¢
    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
            console.log('ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–åœæ­¢');
        }
    }
    
    // ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            e2e: this.calculateStatistics('e2e'),
            memory: this.calculateStatistics('memory'),
            cache: {
                hitRate: this.metrics.cache.hits / 
                        (this.metrics.cache.hits + this.metrics.cache.misses) * 100
            },
            slaViolations: this.checkSLAViolations()
        };
        
        // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        console.group('ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆ');
        if (report.e2e) {
            console.log(`E2Eå¹³å‡: ${report.e2e.average.toFixed(2)}ms (ç›®æ¨™: <${this.targets.e2e_average}ms)`);
            console.log(`E2E P95: ${report.e2e.p95.toFixed(2)}ms (ç›®æ¨™: <${this.targets.e2e_p95}ms)`);
        }
        if (report.memory) {
            console.log(`ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: ${report.memory.average.toFixed(2)}MB (æœ€å¤§: ${this.targets.memory_max}MB)`);
        }
        console.log(`ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡: ${report.cache.hitRate.toFixed(1)}%`);
        console.groupEnd();
        
        // LocalStorageä¿å­˜
        localStorage.setItem('performanceReport', JSON.stringify(report));
        
        return report;
    }
    
    // SLAé•åãƒã‚§ãƒƒã‚¯
    checkSLAViolations() {
        const violations = [];
        const e2eStats = this.calculateStatistics('e2e');
        
        if (e2eStats) {
            if (e2eStats.average > this.targets.e2e_average) {
                violations.push({
                    metric: 'e2e_average',
                    current: e2eStats.average,
                    target: this.targets.e2e_average,
                    severity: 'HIGH'
                });
            }
            
            if (e2eStats.p95 > this.targets.e2e_p95) {
                violations.push({
                    metric: 'e2e_p95',
                    current: e2eStats.p95,
                    target: this.targets.e2e_p95,
                    severity: 'MEDIUM'
                });
            }
        }
        
        return violations;
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã¨è‡ªå‹•é–‹å§‹
window.performanceMonitor = new PerformanceMonitor();
window.performanceMonitor.startMonitoring();
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] E2Eå‡¦ç†æ™‚é–“æ¸¬å®š
- [ ] ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«è¨ˆç®—ï¼ˆp50/p95/p99ï¼‰
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
- [ ] SLAé•åæ¤œå‡º
- [ ] è‡ªå‹•ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ

---

## ğŸ“‹ Week 2: æ ¸å¿ƒæ©Ÿèƒ½å®Ÿè£…

### Day 6-7: å½¢æ…‹ç´ è§£æã®å®Œå…¨æ´»ç”¨

#### Task W2-1: MorphologicalAnalyzerå®Ÿè£…ï¼ˆ12æ™‚é–“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/public/js/ai/MorphologicalAnalyzer.js`ï¼ˆæ–°è¦ä½œæˆï¼‰
**ä¾å­˜**: KuromojiåˆæœŸåŒ–å®Œäº†

```javascript
class MorphologicalAnalyzer {
    constructor() {
        this.tokenizer = null;
        this.ready = false;
        this.cache = new Map();  // è§£æçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥
        this.maxCacheSize = 1000;
    }
    
    async initialize() {
        if (this.ready) return;
        
        try {
            // Kuromojiãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼åˆæœŸåŒ–
            this.tokenizer = await new Promise((resolve, reject) => {
                kuromoji.builder({
                    dicPath: "/dict/",
                    disableCache: false  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹åŒ–
                }).build((err, tokenizer) => {
                    if (err) reject(err);
                    else resolve(tokenizer);
                });
            });
            
            this.ready = true;
            console.log('âœ… MorphologicalAnalyzeråˆæœŸåŒ–å®Œäº†');
            
        } catch (error) {
            console.error('âŒ KuromojiåˆæœŸåŒ–å¤±æ•—:', error);
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç°¡æ˜“ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼
            this.tokenizer = new SimpleFallbackTokenizer();
            this.ready = true;
        }
    }
    
    // ãƒ†ã‚­ã‚¹ãƒˆè§£æï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰
    async analyze(text) {
        if (!this.ready) {
            await this.initialize();
        }
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        if (this.cache.has(text)) {
            return this.cache.get(text);
        }
        
        const startTime = performance.now();
        
        // ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚º
        const tokens = this.tokenizer.tokenize(text);
        
        // æ§‹é€ åŒ–è§£æ
        const analysis = {
            tokens,
            structured: this.structureTokens(tokens),
            features: this.extractFeatures(tokens),
            negations: this.findNegations(tokens),
            dependencies: this.analyzeDependencies(tokens),
            processingTime: performance.now() - startTime
        };
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
        this.addToCache(text, analysis);
        
        return analysis;
    }
    
    // ãƒˆãƒ¼ã‚¯ãƒ³æ§‹é€ åŒ–
    structureTokens(tokens) {
        return {
            nouns: tokens.filter(t => t.pos === 'åè©'),
            verbs: tokens.filter(t => t.pos === 'å‹•è©'),
            adjectives: tokens.filter(t => t.pos === 'å½¢å®¹è©'),
            particles: tokens.filter(t => t.pos === 'åŠ©è©'),
            adverbs: tokens.filter(t => t.pos === 'å‰¯è©'),
            auxiliaries: tokens.filter(t => t.pos === 'åŠ©å‹•è©')
        };
    }
    
    // ç‰¹å¾´æŠ½å‡º
    extractFeatures(tokens) {
        const features = {
            // åŸºæœ¬çµ±è¨ˆ
            tokenCount: tokens.length,
            charCount: tokens.reduce((sum, t) => sum + t.surface_form.length, 0),
            
            // å“è©åˆ†å¸ƒ
            posDistribution: this.calculatePOSDistribution(tokens),
            
            // æ„å‘³çš„ç‰¹å¾´
            hasQuestion: tokens.some(t => ['ã‹', 'ï¼Ÿ'].includes(t.surface_form)),
            hasNegation: this.hasNegation(tokens),
            hasDesire: tokens.some(t => ['ãŸã„', 'ã»ã—ã„', 'æ¬²ã—ã„'].includes(t.surface_form)),
            hasPast: tokens.some(t => ['ãŸ', 'ã ã£ãŸ'].includes(t.surface_form)),
            hasFuture: tokens.some(t => ['ã ã‚ã†', 'ã§ã—ã‚‡ã†', 'ã¤ã‚‚ã‚Š'].includes(t.surface_form)),
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¯†åº¦
            keywordDensity: this.calculateKeywordDensity(tokens)
        };
        
        return features;
    }
    
    // å¦å®šè¡¨ç¾ã®è©³ç´°æ¤œå‡º
    findNegations(tokens) {
        const negations = [];
        const negPatterns = ['ãªã„', 'ãš', 'ã¬', 'ã¾ã„', 'ã„ã‘ãªã„', 'ã ã‚', 'ç„¡', 'ä¸', 'é', 'å¦'];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // å¦å®šåŠ©å‹•è©
            if (negPatterns.includes(token.surface_form) || 
                (token.pos === 'åŠ©å‹•è©' && token.surface_form.includes('ãªã„'))) {
                
                const negation = {
                    index: i,
                    type: 'auxiliary',
                    form: token.surface_form,
                    scope: this.determineNegationScope(tokens, i),
                    affectedWord: null
                };
                
                // å½±éŸ¿ã‚’å—ã‘ã‚‹èªã‚’ç‰¹å®š
                if (i > 0 && ['å‹•è©', 'å½¢å®¹è©', 'åè©'].includes(tokens[i - 1].pos)) {
                    negation.affectedWord = tokens[i - 1];
                }
                
                negations.push(negation);
            }
            
            // å¦å®šæ¥é ­è¾
            if (token.pos === 'æ¥é ­è©' && ['ä¸', 'é', 'ç„¡', 'æœª'].includes(token.surface_form)) {
                negations.push({
                    index: i,
                    type: 'prefix',
                    form: token.surface_form,
                    scope: [i, Math.min(i + 2, tokens.length - 1)]
                });
            }
        }
        
        return negations;
    }
    
    // å¦å®šã‚¹ã‚³ãƒ¼ãƒ—åˆ¤å®š
    determineNegationScope(tokens, negIndex) {
        let start = negIndex;
        let end = negIndex;
        
        // å‰æ–¹æ¢ç´¢ï¼ˆå¦å®šã•ã‚Œã‚‹å¯¾è±¡ï¼‰
        for (let i = negIndex - 1; i >= Math.max(0, negIndex - 5); i--) {
            if (['å‹•è©', 'å½¢å®¹è©', 'åè©'].includes(tokens[i].pos)) {
                start = i;
                break;
            }
            if (tokens[i].pos === 'åŠ©è©' && ['ã¯', 'ãŒ', 'ã‚’'].includes(tokens[i].surface_form)) {
                break;
            }
        }
        
        // å¾Œæ–¹æ¢ç´¢ï¼ˆå¦å®šã®ç¯„å›²ï¼‰
        for (let i = negIndex + 1; i < Math.min(tokens.length, negIndex + 3); i++) {
            if (tokens[i].pos === 'åŠ©è©' && ['ã€‚', 'ã€'].includes(tokens[i].surface_form)) {
                end = i;
                break;
            }
        }
        
        return [start, end];
    }
    
    // ä¿‚ã‚Šå—ã‘è§£æï¼ˆç°¡æ˜“ç‰ˆï¼‰
    analyzeDependencies(tokens) {
        const dependencies = [];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // ä¸»èªã®æ¤œå‡º
            if (['ã¯', 'ãŒ'].includes(token.surface_form) && i > 0) {
                dependencies.push({
                    type: 'subject',
                    head: tokens[i - 1].surface_form,
                    particle: token.surface_form,
                    index: i - 1
                });
            }
            
            // ç›®çš„èªã®æ¤œå‡º
            if (token.surface_form === 'ã‚’' && i > 0) {
                dependencies.push({
                    type: 'object',
                    head: tokens[i - 1].surface_form,
                    particle: token.surface_form,
                    index: i - 1
                });
            }
            
            // ä¿®é£¾é–¢ä¿‚
            if (token.pos === 'é€£ä½“è©' || 
                (token.pos === 'å½¢å®¹è©' && i < tokens.length - 1 && tokens[i + 1].pos === 'åè©')) {
                dependencies.push({
                    type: 'modifier',
                    modifier: token.surface_form,
                    modified: tokens[i + 1]?.surface_form,
                    index: i
                });
            }
        }
        
        return dependencies;
    }
    
    // POSãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³è¨ˆç®—
    calculatePOSDistribution(tokens) {
        const distribution = {};
        
        tokens.forEach(token => {
            distribution[token.pos] = (distribution[token.pos] || 0) + 1;
        });
        
        // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸ã«å¤‰æ›
        const total = tokens.length;
        Object.keys(distribution).forEach(pos => {
            distribution[pos] = (distribution[pos] / total) * 100;
        });
        
        return distribution;
    }
    
    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¯†åº¦è¨ˆç®—
    calculateKeywordDensity(tokens) {
        const keywords = tokens.filter(t => 
            t.pos === 'åè©' && t.pos_detail_1 !== 'éè‡ªç«‹'
        );
        
        return keywords.length / tokens.length;
    }
    
    // å¦å®šãƒã‚§ãƒƒã‚¯
    hasNegation(tokens) {
        return tokens.some(t => 
            ['ãªã„', 'ãš', 'ã¬', 'ç„¡', 'ä¸', 'é'].includes(t.surface_form) ||
            (t.pos === 'åŠ©å‹•è©' && t.surface_form.includes('ãªã„'))
        );
    }
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
    addToCache(text, analysis) {
        if (this.cache.size >= this.maxCacheSize) {
            // LRU: æœ€åˆã®è¦ç´ ã‚’å‰Šé™¤
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(text, analysis);
    }
}

// ç°¡æ˜“ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼
class SimpleFallbackTokenizer {
    tokenize(text) {
        // å˜ç´”ãªæ–‡å­—ç¨®åˆ¥åˆ†å‰²
        const tokens = [];
        const patterns = [
            /[ä¸€-é¾ ã€…]+/g,  // æ¼¢å­—
            /[ã-ã‚“]+/g,    // ã²ã‚‰ãŒãª
            /[ã‚¡-ãƒ´ãƒ¼]+/g,  // ã‚«ã‚¿ã‚«ãƒŠ
            /[a-zA-Z]+/g,   // è‹±å­—
            /[0-9]+/g       // æ•°å­—
        ];
        
        let position = 0;
        patterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                tokens.push({
                    surface_form: match[0],
                    pos: this.guessPOS(match[0]),
                    pos_detail_1: '*',
                    position: match.index
                });
            }
        });
        
        // ä½ç½®é †ã«ã‚½ãƒ¼ãƒˆ
        return tokens.sort((a, b) => a.position - b.position);
    }
    
    guessPOS(word) {
        // ç°¡æ˜“çš„ãªå“è©æ¨å®š
        if (/[ä¸€-é¾ ã€…]+/.test(word)) return 'åè©';
        if (/[ã-ã‚“]+/.test(word)) {
            if (['ã™ã‚‹', 'ã‚ã‚‹', 'ã„ã‚‹', 'ãªã‚‹'].includes(word)) return 'å‹•è©';
            if (['ãªã„', 'ãŸã„', 'ã‚‰ã—ã„'].includes(word)) return 'åŠ©å‹•è©';
            return 'åŠ©è©';
        }
        if (/[ã‚¡-ãƒ´ãƒ¼]+/.test(word)) return 'åè©';
        return 'è¨˜å·';
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®š
window.morphAnalyzer = new MorphologicalAnalyzer();
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] Kuromojiå®Œå…¨çµ±åˆ
- [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚¶ãƒ¼
- [ ] å¦å®šã‚¹ã‚³ãƒ¼ãƒ—åˆ¤å®š
- [ ] ä¿‚ã‚Šå—ã‘è§£æ
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½

### Day 8-9: çµ±åˆãƒ†ã‚¹ãƒˆã¨ãƒã‚°ä¿®æ­£

#### Task W2-2: çµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆï¼ˆ12æ™‚é–“ï¼‰
**ãƒ•ã‚¡ã‚¤ãƒ«**: `/test/integration-test.js`ï¼ˆæ–°è¦ä½œæˆï¼‰

```javascript
class IntegrationTestSuite {
    constructor() {
        this.tests = [];
        this.results = [];
    }
    
    async runAll() {
        console.group('ğŸ§ª çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ');
        
        // ãƒ†ã‚¹ãƒˆå®šç¾©
        this.tests = [
            this.testDeterminism(),
            this.testNegationDetection(),
            this.testBiasDetection(),
            this.testPerformance(),
            this.testDataValidation()
        ];
        
        // å®Ÿè¡Œ
        for (const test of this.tests) {
            const result = await test;
            this.results.push(result);
            
            if (result.passed) {
                console.log(`âœ… ${result.name}`);
            } else {
                console.error(`âŒ ${result.name}:`, result.error);
            }
        }
        
        console.groupEnd();
        
        // ã‚µãƒãƒªãƒ¼
        const passed = this.results.filter(r => r.passed).length;
        const total = this.results.length;
        
        console.log(`\nğŸ“Š ãƒ†ã‚¹ãƒˆçµæœ: ${passed}/${total} åˆæ ¼`);
        
        return {
            passed: passed === total,
            summary: `${passed}/${total}`,
            details: this.results
        };
    }
    
    // æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆ
    async testDeterminism() {
        const testName = 'æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆ';
        
        try {
            const inputs = [
                "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„",
                "ãƒãƒ¼ãƒ ã‚’æˆé•·ã•ã›ã‚‹",
                "å›°é›£ã‚’ä¹—ã‚Šè¶Šãˆã‚‹"
            ];
            
            const results = [];
            
            // 10å›å®Ÿè¡Œ
            for (let run = 0; run < 10; run++) {
                window.deterministicEngine.reset();
                const runResults = [];
                
                for (const input of inputs) {
                    const analyzer = new TextTo384LinesBridge();
                    const result = await analyzer.analyzeTextToSpecificLine(input);
                    runResults.push(result.lineId);
                }
                
                results.push(runResults.join(','));
            }
            
            // å…¨çµæœãŒåŒä¸€ã‹ç¢ºèª
            const firstRun = results[0];
            const allSame = results.every(r => r === firstRun);
            
            return {
                name: testName,
                passed: allSame,
                error: allSame ? null : 'Results differ across runs'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // å¦å®šæ–‡æ¤œå‡ºãƒ†ã‚¹ãƒˆ
    async testNegationDetection() {
        const testName = 'å¦å®šæ–‡æ¤œå‡ºãƒ†ã‚¹ãƒˆ';
        
        try {
            const testCases = [
                { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸã„", hasNegation: false },
                { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚ŠãŸããªã„", hasNegation: true },
                { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã«ã¯å‘ã„ã¦ã„ãªã„", hasNegation: true },
                { input: "ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã«ç–‘å•ã‚’æ„Ÿã˜ã‚‹", hasNegation: false }
            ];
            
            const analyzer = window.morphAnalyzer;
            await analyzer.initialize();
            
            let allCorrect = true;
            
            for (const testCase of testCases) {
                const analysis = await analyzer.analyze(testCase.input);
                const detected = analysis.negations.length > 0;
                
                if (detected !== testCase.hasNegation) {
                    allCorrect = false;
                    console.error(`Failed: "${testCase.input}" - Expected: ${testCase.hasNegation}, Got: ${detected}`);
                }
            }
            
            return {
                name: testName,
                passed: allCorrect,
                error: allCorrect ? null : 'Some negation detections failed'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // åã‚Šæ¤œå‡ºãƒ†ã‚¹ãƒˆ
    async testBiasDetection() {
        const testName = 'åã‚Šæ¤œå‡ºãƒ†ã‚¹ãƒˆ';
        
        try {
            const detector = window.biasDetector;
            
            // åã£ãŸãƒ‡ãƒ¼ã‚¿ã‚’æ„å›³çš„ã«ä½œæˆ
            for (let i = 0; i < 100; i++) {
                // ç¬¬5çˆ»ã«åã‚‰ã›ã‚‹
                const hexagram = Math.floor(Math.random() * 64) + 1;
                const line = i < 70 ? 5 : Math.floor(Math.random() * 6) + 1;
                detector.recordSelection(hexagram, line);
            }
            
            const results = detector.performStatisticalTests();
            
            // Ï‡Â²æ¤œå®šã§æœ‰æ„å·®ãŒæ¤œå‡ºã•ã‚Œã‚‹ã¯ãš
            const biasDetected = results.linePosition.significant;
            
            return {
                name: testName,
                passed: biasDetected,
                error: biasDetected ? null : 'Failed to detect intentional bias'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
    async testPerformance() {
        const testName = 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ';
        
        try {
            const monitor = window.performanceMonitor;
            const times = [];
            
            // 100å›ã®å‡¦ç†ã‚’æ¸¬å®š
            for (let i = 0; i < 100; i++) {
                const measure = monitor.measurePerformance('test-analysis');
                
                // ãƒ€ãƒŸãƒ¼å‡¦ç†
                await new Promise(resolve => setTimeout(resolve, Math.random() * 20 + 10));
                
                const duration = measure.end();
                times.push(duration);
            }
            
            // çµ±è¨ˆè¨ˆç®—
            const average = times.reduce((a, b) => a + b, 0) / times.length;
            const sorted = times.sort((a, b) => a - b);
            const p95 = sorted[Math.floor(times.length * 0.95)];
            
            // ç›®æ¨™å€¤ãƒã‚§ãƒƒã‚¯
            const meetsTarget = average < 40 && p95 < 45;
            
            return {
                name: testName,
                passed: meetsTarget,
                error: meetsTarget ? null : `Average: ${average.toFixed(2)}ms, P95: ${p95.toFixed(2)}ms`
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ†ã‚¹ãƒˆ
    async testDataValidation() {
        const testName = 'ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ†ã‚¹ãƒˆ';
        
        try {
            const validator = new DataValidator();
            const isValid = await validator.validateAll();
            
            return {
                name: testName,
                passed: isValid || validator.validationResults.fallbacksUsed.length > 0,
                error: isValid ? null : 'Critical data missing without fallback'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
}

// å®Ÿè¡Œãƒ˜ãƒ«ãƒ‘ãƒ¼
async function runIntegrationTests() {
    const suite = new IntegrationTestSuite();
    const results = await suite.runAll();
    
    // çµæœã‚’HTMLã§è¡¨ç¤º
    if (document.getElementById('test-results')) {
        const html = `
            <div class="${results.passed ? 'success' : 'failure'}">
                <h3>çµ±åˆãƒ†ã‚¹ãƒˆçµæœ: ${results.summary}</h3>
                <ul>
                    ${results.details.map(r => `
                        <li class="${r.passed ? 'passed' : 'failed'}">
                            ${r.passed ? 'âœ…' : 'âŒ'} ${r.name}
                            ${r.error ? `<br><small>${r.error}</small>` : ''}
                        </li>
                    `).join('')}
                </ul>
            </div>
        `;
        document.getElementById('test-results').innerHTML = html;
    }
    
    return results;
}
```

**ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**:
- [ ] æ±ºå®šè«–æ€§ãƒ†ã‚¹ãƒˆå®Ÿè£…
- [ ] å¦å®šæ–‡æ¤œå‡ºãƒ†ã‚¹ãƒˆå®Ÿè£…
- [ ] åã‚Šæ¤œå‡ºãƒ†ã‚¹ãƒˆå®Ÿè£…
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè£…
- [ ] ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ†ã‚¹ãƒˆå®Ÿè£…

---

## ğŸ—„ï¸ DBçµ±åˆï¼ˆD1/SQLiteï¼‰

ã‚¢ãƒ¼ã‚­æ–¹é‡: ãƒ­ãƒ¼ã‚«ãƒ«ã¯SQLiteã€Edge/æœ¬ç•ªã¯Cloudflare D1ã€‚ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯å…±é€šã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ç®¡ç†ã€‚

### ã‚¹ã‚­ãƒ¼ãƒéª¨å­ï¼ˆä¾‹ï¼‰
```sql
-- hexagrams
CREATE TABLE hexagrams (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

-- lines (384)
CREATE TABLE lines (
  id INTEGER PRIMARY KEY,
  hexagram_id INTEGER NOT NULL,
  position INTEGER NOT NULL CHECK(position BETWEEN 1 AND 6),
  keywords TEXT,
  interpretation TEXT,
  FOREIGN KEY(hexagram_id) REFERENCES hexagrams(id)
);

-- selections (ãƒ­ã‚°)
CREATE TABLE selections (
  id INTEGER PRIMARY KEY,
  hexagram_id INTEGER NOT NULL,
  line_position INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY(hexagram_id) REFERENCES hexagrams(id)
);
```

### ä¸»è¦ã‚¿ã‚¹ã‚¯
- Task DB-1: ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆup/downï¼‰ã¨è‡ªå‹•æ¤œè¨¼ï¼ˆ6æ™‚é–“ï¼‰
- Task DB-2: ãƒ‡ãƒ¼ã‚¿æŠ•å…¥ï¼ˆJSONâ†’DBï¼‰ã¨æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ï¼ˆ6æ™‚é–“ï¼‰
- Task DB-3: ä¸»è¦ã‚¯ã‚¨ãƒªæœ€é©åŒ–ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆï¼ˆ4æ™‚é–“ï¼‰
- Task DB-4: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯/å¾©æ—§æ‰‹é †ã®è‡ªå‹•åŒ–ï¼ˆ4æ™‚é–“ï¼‰

### DoDï¼ˆå®Œäº†ã®å®šç¾©ï¼‰
- ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¾€å¾©ï¼ˆupâ†’downâ†’upï¼‰ãŒç„¡åœæ­¢ã§æˆåŠŸã€‚
- JSONâ†’DBæŠ•å…¥å¾Œã€ä»¶æ•°æ•´åˆï¼ˆhexagrams=64ã€lines=384ï¼‰ã‚’è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã€‚
- ä¸»è¦ã‚¯ã‚¨ãƒªï¼ˆæœ€æ–°Nä»¶ã€é›†è¨ˆã€è¡ŒæŠ½å‡ºï¼‰ã®p95<10msï¼ˆãƒ­ãƒ¼ã‚«ãƒ«/Edgeç›¸å½“ï¼‰ã‚’è¨ˆæ¸¬ã—è¨˜éŒ²ã€‚
- ç ´æ/å¤±æ•—æ™‚ã«è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã€æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ãŒå†åº¦æˆåŠŸã™ã‚‹ã“ã¨ã€‚

## ğŸ“‹ Week 3-4: æ®µéšçš„æ”¹å–„ã¨æœ€é©åŒ–

### Week 3: æ„å‘³ç†è§£ã®åŸºç¤å®Ÿè£…

#### Task W3-1: ç°¡æ˜“Word2Vecçµ±åˆï¼ˆ3æ—¥ï¼‰
#### Task W3-2: é¡ç¾©èªè¾æ›¸æ§‹ç¯‰ï¼ˆ2æ—¥ï¼‰

### Week 4: æœ€çµ‚èª¿æ•´ã¨æœ¬ç•ªæº–å‚™

#### Task W4-1: å…¨ä½“æœ€é©åŒ–ï¼ˆ2æ—¥ï¼‰
#### Task W4-2: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™ï¼ˆ1æ—¥ï¼‰
#### Task W4-3: æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™ï¼ˆ2æ—¥ï¼‰
#### Task W4-4: é‹ç”¨ç›£è¦–ã‚¿ã‚¹ã‚¯ã®å¿…é ˆåŒ–ï¼ˆ1æ—¥ï¼‰
- ãƒ¡ãƒˆãƒªã‚¯ã‚¹é€å‡ºï¼ˆE2E/analysis/rendering/memory/cacheï¼‰ã¨ã‚¢ãƒ©ãƒ¼ãƒˆé–¾å€¤ã‚’æœ¬ç•ªè¨­å®šã«åæ˜ ã€‚
- åã‚Šã‚¢ãƒ©ãƒ¼ãƒˆï¼ˆÏ‡Â²ã€æœ€å¤§ä½¿ç”¨ç‡ã€é€£ç¶šæ€§ï¼‰ã‚’ç›£è¦–é¢ã«éœ²å‡ºï¼ˆãƒ­ã‚°/é€šçŸ¥ï¼‰ã€‚
- å¯è¦³æ¸¬æ€§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆï¼ˆè¨ˆæ¸¬é …ç›®ã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã€ã‚¢ãƒ©ãƒ¼ãƒˆé–¾å€¤ã€Runbookï¼‰ã‚’æ•´å‚™ã€‚

---

## âœ… DoDãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå„Taskå…±é€šï¼‰

1. å˜ä½“ãƒ†ã‚¹ãƒˆåˆæ ¼ï¼ˆåˆ†å²ç¶²ç¾…80%+ï¼‰
2. p50/95/99ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãŒåŸºæº–å†…ï¼ˆEdgeæƒ³å®šï¼‰
3. æ±ºå®šè«–æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆåŒå…¥åŠ›ï¼åŒå‡ºåŠ›ã€ä¸€è‡´ç‡=100%ï¼‰
4. ä½ç½®åˆ†å¸ƒã®é–¾å€¤é€¸è„±ãªã—ï¼ˆã©ã®çˆ»ä½ç½®ã‚‚30%è¶…ãˆãªã„ï¼‰
5. ãƒ­ã‚°/ãƒ¡ãƒˆãƒªã‚¯ã‚¹é …ç›®è¿½åŠ æ¸ˆï¼ˆç²¾åº¦ãƒ»é€Ÿåº¦ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥/ã‚¢ãƒ©ãƒ¼ãƒˆï¼‰

## ğŸ”¬ ã€Œã™ãå‹•ã‹ã™ã€ãŸã‚ã®æœ€å°æ¤œè¨¼3æœ¬

1. æ±ºå®šè«–æ€§ã‚¹ãƒ¢ãƒ¼ã‚¯: å›ºå®š10å…¥åŠ›Ã—10å›ï¼ä¸€è‡´ç‡100%
2. 5çˆ»å›å¾©ãƒã‚§ãƒƒã‚¯: ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ç³»ã‚µãƒ³ãƒ—ãƒ«ã§5çˆ»é¸æŠâ‰¥60%ï¼ˆToleranceæº–æ‹ ï¼‰
3. æ€§èƒ½ã—ãã„å€¤: å¹³å‡<40msï¼ˆE2Eï¼‰ã€p95<45msã€p99<50ms

## ğŸ“Š æˆåŠŸåŸºæº–ã¨æ¤œè¨¼æ–¹æ³•

### Goåˆ¤å®šåŸºæº–ï¼ˆå¿…é ˆé”æˆé …ç›®ï¼‰

| é …ç›® | ç›®æ¨™ | æ¤œè¨¼æ–¹æ³• |
|------|------|----------|
| ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ | 100%æˆåŠŸ or ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹•ä½œ | `DataValidator.validateAll()` |
| æ±ºå®šè«–æ€§ | 100%ï¼ˆ10å›åŒä¸€çµæœï¼‰ | çµ±åˆãƒ†ã‚¹ãƒˆ |
| E2Eå¹³å‡ | < 40ms | `PerformanceMonitor.generateReport()` |
| E2E P95 | < 45ms | åŒä¸Š |
| åã‚Šæ¤œå‡º | Ï‡Â²æ¤œå®šå®Ÿè£…ãƒ»å‹•ä½œ | `StatisticalBiasDetector.performStatisticalTests()` |
| å¦å®šæ–‡æ¤œå‡º | ç²¾åº¦90%ä»¥ä¸Š | ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ |

### æ—¥æ¬¡é€²æ—ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

```javascript
// æ¯æ—¥å®Ÿè¡Œã™ã‚‹æ¤œè¨¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
async function dailyHealthCheck() {
    const checks = {
        dataValid: await new DataValidator().validateAll(),
        determinism: await testDeterminism(),
        performance: performanceMonitor.generateReport(),
        bias: biasDetector.generateReport(),
        memory: performance.memory?.usedJSHeapSize / 1024 / 1024
    };
    
    console.table(checks);
    return checks;
}
```

---

## ğŸš¨ ãƒªã‚¹ã‚¯ã¨è»½æ¸›ç­–

| ãƒªã‚¹ã‚¯ | ç™ºç”Ÿç¢ºç‡ | å½±éŸ¿ | è»½æ¸›ç­– |
|--------|----------|------|--------|
| KuromojiåˆæœŸåŒ–å¤±æ•— | ä¸­ | é«˜ | SimpleFallbackTokenizerå®Ÿè£…æ¸ˆã¿ |
| ãƒ¡ãƒ¢ãƒªä¸è¶³ | ä¸­ | é«˜ | ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ãƒ»GCå¼·åˆ¶å®Ÿè¡Œ |
| æ€§èƒ½ç›®æ¨™æœªé” | ä½ | ä¸­ | æ®µéšçš„æœ€é©åŒ–ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¼·åŒ– |
| ãƒ‡ãƒ¼ã‚¿æ¬ æ | é«˜ | é«˜ | ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ |

---

## âœ… å®Œäº†åˆ¤å®šãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Week 1å®Œäº†æ¡ä»¶
- [ ] DataValidatorå®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆåˆæ ¼
- [ ] DeterministicEngineå®Ÿè£…ãƒ»100%æ±ºå®šè«–æ€§
- [ ] StatisticalBiasDetectorå®Ÿè£…ãƒ»Ï‡Â²æ¤œå®šå‹•ä½œ
- [ ] PerformanceMonitorå®Ÿè£…ãƒ»40msé”æˆ

### Week 2å®Œäº†æ¡ä»¶
- [ ] MorphologicalAnalyzerå®Œå…¨å®Ÿè£…
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆå…¨é …ç›®åˆæ ¼
- [ ] å¦å®šæ–‡æ¤œå‡ºç²¾åº¦90%ä»¥ä¸Š

### Week 3-4å®Œäº†æ¡ä»¶
- [ ] Word2VecåŸºç¤å®Ÿè£…
- [ ] å…¨æœ€é©åŒ–å®Œäº†
- [ ] æœ¬ç•ªç’°å¢ƒæº–å‚™å®Œäº†

---

**æ–‡æ›¸å®Œäº†** - ã“ã®è©³ç´°ã‚¿ã‚¹ã‚¯åˆ†è§£ã«å¾“ã£ã¦å³åº§ã«å®Ÿè£…ã‚’é–‹å§‹ã§ãã¾ã™ã€‚Week 1ã®ç·Šæ€¥å¯¾å¿œã‚’æœ€å„ªå…ˆã§å®Ÿæ–½ã—ã¦ãã ã•ã„ã€‚
