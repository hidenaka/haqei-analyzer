# 384爻システム緊急改善計画 詳細タスク分解表

**文書番号**: HAQEI-URGENT-005  
**作成日**: 2025年8月28日  
**緊急度**: 🔴 最優先  
**総工数見積**: 4週間（160時間）
**前提**: 現在の実装完了度5%からの改善

---

## 🚦 結論（Go/No-Go）

**結論**: 条件付きGo（修正必須の赤字ポイントあり）

着手可能なレベルまでWBS・依存関係・実装断片は揃っているが、以下4点を開始前に修正しないと詰まる。

1. 非現実な性能目標: 5ms級はEdge制約と矛盾。E2Eの合否は平均<40ms、p95<45ms、p99<50msに統一し、メトリクスはp50/95/99を記録。
2. データ依存の明記不足: `enhanced_hexagrams_complete.json` / `yaoci_31-63.json` / `h384.json` の存在・スキーマ整合・ライセンス可否を作業前提として検証し、未入手時のフォールバック/縮退運転を明文化。
3. DB統合のDoD不足: D1/SQLiteの移行テスト（up/down）、整合性チェック、主要クエリp95<10ms、破損時の自動ロールバックを成功条件として定義。
4. 決定論性と重み変更の副作用監視: 固定シード再実行の一致率=100%を明示。位置分布のχ²テスト・しきい値・逸脱時の自動アラート/手順を数値で規定。

良い点（実装に足る根拠）
- WBSと依存関係が明確で、具体的なコード変更点が記載。
- 評価用テスト雛形と期待分布（Tolerance）が提示済み。
- Edge現実論と全体ガバナンスの整合が取れている。

小さなズレ/気になる点（運用安定化のための補正）
- 工数見積りの振れ幅を解消（本書の正は「4週間=160時間」）。
- パフォーマンス目標を本ドキュメント全体で統一（平均<40ms、p95<45ms、p99<50ms）。

この結論を反映するため、以下の「Phase 0: Pre-flight」「DB統合DoD」「DoDテンプレ」「最小検証3本」を追記する。

---

## 🛫 Phase 0: Pre-flight（データ&ライセンス&スキーマ検証）

開始ゲート。ここを満たさない場合は実装に進まない。

### Task P0-1: データ存在・スキーマ検証（4時間）
対象: `/data/h384.json`, `/data/enhanced_hexagrams_complete.json`, `/data/yaoci_31-63.json`

- 仕様: Zod/JSON Schemaで必須フィールド・型・件数（例: h384=384件、hexagrams=64件）を検証。
- 失敗時: `DataValidator`のフォールバックを強制適用し縮退運転に切替。
- DoD: 3ファイルの存在/整合ログ、検証レポートJSON（保存: `localStorage:dataValidation`）。

### Task P0-2: ライセンス/出典確認（2時間）
- 仕様: 3データのライセンス可否・出典・帰属表記の要否を確認し、`docs/licenses/data-sources.md`に記録。
- DoD: ライセンスのOK/NGマトリクス、NG時の代替データ取得計画（期限/責任者）を明記。

### Task P0-3: 縮退運転の最小機能定義（2時間）
- 仕様: データ欠損時の機能制限範囲を定義（例: 文脈解析=ON、詳細解説=OFF、UI警告=ON）。
- DoD: 3シナリオ（完全、部分、欠損）の手動/自動テスト通過、UI警告表示の確認。

ゲート（Go/No-Go）
- Go: P0-1〜P0-3のDoDを全て満たす。
- No-Go: いずれか未達。Week 1の実装開始を保留。

## 🚨 現状の重大問題と緊急対応の必要性

### 致命的リスク（即座対応必須）
1. **データ欠損でのクラッシュ**: フォールバック未実装でサービス停止リスク
2. **統計的妥当性の欠如**: χ²検定なしで偏り検出が機能しない
3. **決定論性の未保証**: 同一入力で異なる結果＝信頼性ゼロ
4. **監視不能**: メトリクスなしで問題発見が遅延

---

## 📋 Week 1: 緊急対応（基盤安定化）

### Day 1-2: データ検証とフォールバック実装

#### Task W1-1: 緊急データ検証システム構築（8時間）
**ファイル**: `/public/js/core/DataValidator.js`（新規作成）
**優先度**: 🔴 最優先（クラッシュ防止）

```javascript
// 実装要件: 即座にクラッシュを防ぐ最小実装
class DataValidator {
    constructor() {
        this.criticalFiles = [
            {
                path: '/data/h384.json',
                fallback: this.generateMinimalH384Data,
                validate: (data) => Array.isArray(data) && data.length === 384
            },
            {
                path: '/data/enhanced_hexagrams_complete.json',
                fallback: this.generateBasicHexagrams,
                validate: (data) => Array.isArray(data) && data.length === 64
            },
            {
                path: '/data/yaoci_31-63.json',
                fallback: null,  // フォールバック不可（必須）
                validate: (data) => Array.isArray(data)
            }
        ];
        
        this.validationResults = {
            timestamp: null,
            files: {},
            isValid: false,
            fallbacksUsed: []
        };
    }
    
    async validateAll() {
        console.log('🔍 緊急データ検証開始...');
        this.validationResults.timestamp = Date.now();
        let allValid = true;
        
        for (const file of this.criticalFiles) {
            try {
                const response = await fetch(file.path);
                if (!response.ok) throw new Error(`404: ${file.path}`);
                
                const data = await response.json();
                const isValid = file.validate(data);
                
                this.validationResults.files[file.path] = {
                    exists: true,
                    valid: isValid,
                    size: JSON.stringify(data).length,
                    records: Array.isArray(data) ? data.length : 0
                };
                
                if (!isValid) {
                    console.error(`❌ 無効なデータ: ${file.path}`);
                    if (file.fallback) {
                        const fallbackData = file.fallback();
                        this.validationResults.fallbacksUsed.push(file.path);
                        console.warn(`⚠️ フォールバック使用: ${file.path}`);
                        window[`fallback_${file.path.split('/').pop().split('.')[0]}`] = fallbackData;
                    } else {
                        allValid = false;
                    }
                }
            } catch (error) {
                console.error(`❌ データ読み込み失敗: ${file.path}`, error);
                this.validationResults.files[file.path] = {
                    exists: false,
                    error: error.message
                };
                
                if (file.fallback) {
                    const fallbackData = file.fallback();
                    this.validationResults.fallbacksUsed.push(file.path);
                    window[`fallback_${file.path.split('/').pop().split('.')[0]}`] = fallbackData;
                } else {
                    allValid = false;
                }
            }
        }
        
        this.validationResults.isValid = allValid;
        
        // 結果をコンソールとLocalStorageに記録
        console.table(this.validationResults.files);
        localStorage.setItem('dataValidation', JSON.stringify(this.validationResults));
        
        return allValid;
    }
    
    generateMinimalH384Data() {
        // 最小限の384爻データ生成
        const data = [];
        for (let hex = 1; hex <= 64; hex++) {
            for (let line = 1; line <= 6; line++) {
                data.push({
                    id: (hex - 1) * 6 + line,
                    hexagram: hex,
                    line: line,
                    keywords: [`卦${hex}`, `爻${line}`],
                    interpretation: `卦${hex}の第${line}爻`
                });
            }
        }
        return data;
    }
    
    generateBasicHexagrams() {
        // 基本的な64卦データ生成
        const names = ['乾', '坤', '屯', '蒙', '需', '訟', '師', '比'];  // ... 省略
        return Array.from({length: 64}, (_, i) => ({
            id: i + 1,
            name: names[i] || `卦${i + 1}`,
            lines: Array.from({length: 6}, (_, j) => ({
                position: j + 1,
                text: `第${j + 1}爻`
            }))
        }));
    }
}

// 起動時の自動実行
window.addEventListener('DOMContentLoaded', async () => {
    const validator = new DataValidator();
    const isValid = await validator.validateAll();
    
    if (!isValid) {
        // ユーザーに警告表示
        const warning = document.createElement('div');
        warning.className = 'data-warning';
        warning.innerHTML = `
            <div style="background: #ff6b6b; color: white; padding: 10px; position: fixed; top: 0; width: 100%; z-index: 9999;">
                ⚠️ データ読み込みエラー: 一部機能が制限されています
                <button onclick="this.parentElement.remove()">×</button>
            </div>
        `;
        document.body.appendChild(warning);
    }
});
```

**チェックリスト**:
- [ ] 全データファイルの存在確認
- [ ] スキーマ検証実装
- [ ] フォールバックデータ生成
- [ ] エラー時のUI警告表示
- [ ] LocalStorage記録

#### Task W1-2: 決定論性保証システム（8時間）
**ファイル**: `/public/js/core/DeterministicEngine.js`（新規作成）
**優先度**: 🔴 最優先（信頼性確保）

```javascript
class DeterministicEngine {
    constructor(seed = 42) {
        this.seed = seed;
        this.originalSeed = seed;
        this.callCount = 0;
        this.history = [];
        
        // Math.randomを上書き（開発環境のみ）
        if (window.location.hostname === 'localhost') {
            this.overrideMathRandom();
        }
    }
    
    // 決定論的な疑似乱数生成器（Xorshift）
    random() {
        this.callCount++;
        let x = this.seed;
        x ^= x << 13;
        x ^= x >> 17;
        x ^= x << 5;
        this.seed = x >>> 0;
        
        const value = (x >>> 0) / 0xFFFFFFFF;
        
        // デバッグ用履歴記録
        if (this.history.length < 1000) {
            this.history.push({
                call: this.callCount,
                value: value,
                seed: this.seed
            });
        }
        
        return value;
    }
    
    // 範囲指定乱数
    randomInt(min, max) {
        return Math.floor(this.random() * (max - min + 1)) + min;
    }
    
    // 配列シャッフル（Fisher-Yates）
    shuffle(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i--) {
            const j = this.randomInt(0, i);
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }
    
    // 重み付き選択
    weightedChoice(items, weights) {
        const total = weights.reduce((a, b) => a + b, 0);
        let random = this.random() * total;
        
        for (let i = 0; i < items.length; i++) {
            random -= weights[i];
            if (random <= 0) {
                return items[i];
            }
        }
        return items[items.length - 1];
    }
    
    // シード復元
    reset() {
        this.seed = this.originalSeed;
        this.callCount = 0;
        this.history = [];
    }
    
    // 決定論性テスト
    testDeterminism(iterations = 100) {
        const results = [];
        
        for (let run = 0; run < 3; run++) {
            this.reset();
            const runResults = [];
            
            for (let i = 0; i < iterations; i++) {
                runResults.push(this.random());
            }
            results.push(runResults);
        }
        
        // 全実行が同一か確認
        const firstRun = JSON.stringify(results[0]);
        const allSame = results.every(run => JSON.stringify(run) === firstRun);
        
        console.log(`決定論性テスト: ${allSame ? '✅ 合格' : '❌ 失敗'}`);
        return allSame;
    }
    
    // Math.random上書き（開発環境用）
    overrideMathRandom() {
        const original = Math.random;
        Math.random = () => {
            const value = this.random();
            console.debug(`Math.random() → ${value}`);
            return value;
        };
        
        // 復元用
        Math.random.restore = () => {
            Math.random = original;
        };
    }
}

// グローバル設定
window.deterministicEngine = new DeterministicEngine(42);
```

**チェックリスト**:
- [ ] 疑似乱数生成器実装
- [ ] シード管理機能
- [ ] 決定論性テスト機能
- [ ] 範囲指定・重み付き選択
- [ ] デバッグ用履歴記録

### Day 3-4: χ²検定と偏り検出実装

#### Task W1-3: 統計的偏り検出システム（12時間）
**ファイル**: `/public/js/ai/StatisticalBiasDetector.js`（新規作成）
**優先度**: 🔴 最優先（品質保証）

```javascript
class StatisticalBiasDetector {
    constructor() {
        this.observations = {
            linePositions: new Array(6).fill(0),    // 1-6爻の選択回数
            hexagrams: new Array(64).fill(0),       // 1-64卦の選択回数
            total: 0,
            history: []  // 最新1000件の履歴
        };
        
        // χ²分布の臨界値（自由度と有意水準別）
        this.criticalValues = {
            5: { 0.05: 11.070, 0.01: 15.086 },    // 自由度5（6爻-1）
            63: { 0.05: 82.529, 0.01: 92.010 }    // 自由度63（64卦-1）
        };
        
        // アラート設定
        this.alertThresholds = {
            maxPositionBias: 0.30,      // 30%超えたらアラート
            minPositionUsage: 0.10,     // 10%未満でアラート
            consecutiveBias: 5,         // 5回連続で同じ爻/卦
            sampleSizeMinimum: 30       // 最小サンプル数
        };
        
        this.alerts = [];
        this.correctionWeights = null;
    }
    
    // 選択を記録
    recordSelection(hexagramId, linePosition) {
        // 範囲チェック
        if (hexagramId < 1 || hexagramId > 64 || linePosition < 1 || linePosition > 6) {
            console.error('Invalid selection:', { hexagramId, linePosition });
            return;
        }
        
        this.observations.hexagrams[hexagramId - 1]++;
        this.observations.linePositions[linePosition - 1]++;
        this.observations.total++;
        
        // 履歴更新（最新1000件保持）
        this.observations.history.push({ hexagramId, linePosition, timestamp: Date.now() });
        if (this.observations.history.length > 1000) {
            this.observations.history.shift();
        }
        
        // 定期チェック（30件ごと）
        if (this.observations.total >= this.alertThresholds.sampleSizeMinimum && 
            this.observations.total % 30 === 0) {
            this.performStatisticalTests();
        }
    }
    
    // χ²検定実行
    performChiSquareTest(observed, expected) {
        let chiSquare = 0;
        
        for (let i = 0; i < observed.length; i++) {
            if (expected[i] > 0) {
                chiSquare += Math.pow(observed[i] - expected[i], 2) / expected[i];
            }
        }
        
        return chiSquare;
    }
    
    // 統計的検定を実行
    performStatisticalTests() {
        const results = {
            linePosition: this.testLinePositionBias(),
            hexagram: this.testHexagramBias(),
            consecutive: this.testConsecutiveBias(),
            timestamp: Date.now()
        };
        
        // アラート生成
        this.generateAlerts(results);
        
        // 補正重み計算
        if (results.linePosition.significant || results.hexagram.significant) {
            this.calculateCorrectionWeights(results);
        }
        
        return results;
    }
    
    // 爻位置の偏り検定
    testLinePositionBias() {
        const observed = this.observations.linePositions;
        const total = observed.reduce((a, b) => a + b, 0);
        
        if (total < this.alertThresholds.sampleSizeMinimum) {
            return { significant: false, reason: 'insufficient_data' };
        }
        
        const expected = Array(6).fill(total / 6);
        const chiSquare = this.performChiSquareTest(observed, expected);
        const criticalValue = this.criticalValues[5][0.05];
        
        // 各位置の使用率計算
        const usage = observed.map(count => count / total);
        const maxUsage = Math.max(...usage);
        const minUsage = Math.min(...usage);
        
        return {
            chiSquare,
            criticalValue,
            significant: chiSquare > criticalValue,
            pValue: this.calculatePValue(chiSquare, 5),
            usage,
            maxUsage,
            minUsage,
            maxPosition: usage.indexOf(maxUsage) + 1,
            minPosition: usage.indexOf(minUsage) + 1
        };
    }
    
    // 卦の偏り検定
    testHexagramBias() {
        const observed = this.observations.hexagrams;
        const total = observed.reduce((a, b) => a + b, 0);
        
        if (total < this.alertThresholds.sampleSizeMinimum * 2) {
            return { significant: false, reason: 'insufficient_data' };
        }
        
        const expected = Array(64).fill(total / 64);
        const chiSquare = this.performChiSquareTest(observed, expected);
        const criticalValue = this.criticalValues[63][0.05];
        
        // 使用されていない卦の数
        const unusedCount = observed.filter(count => count === 0).length;
        
        return {
            chiSquare,
            criticalValue,
            significant: chiSquare > criticalValue,
            pValue: this.calculatePValue(chiSquare, 63),
            unusedCount,
            unusedPercentage: (unusedCount / 64) * 100
        };
    }
    
    // 連続性の検出
    testConsecutiveBias() {
        const history = this.observations.history.slice(-20);  // 最新20件
        
        if (history.length < 5) {
            return { significant: false, reason: 'insufficient_data' };
        }
        
        let maxConsecutive = 1;
        let currentConsecutive = 1;
        let consecutiveType = null;
        
        for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            
            if (prev.hexagramId === curr.hexagramId && prev.linePosition === curr.linePosition) {
                currentConsecutive++;
                if (currentConsecutive > maxConsecutive) {
                    maxConsecutive = currentConsecutive;
                    consecutiveType = `${curr.hexagramId}-${curr.linePosition}`;
                }
            } else {
                currentConsecutive = 1;
            }
        }
        
        return {
            maxConsecutive,
            consecutiveType,
            significant: maxConsecutive >= this.alertThresholds.consecutiveBias
        };
    }
    
    // p値の近似計算
    calculatePValue(chiSquare, df) {
        // 簡易的なp値近似（実際はガンマ関数使用）
        if (df === 5) {
            if (chiSquare < 1.145) return 0.95;
            if (chiSquare < 3.357) return 0.50;
            if (chiSquare < 5.385) return 0.25;
            if (chiSquare < 7.289) return 0.10;
            if (chiSquare < 11.070) return 0.05;
            if (chiSquare < 15.086) return 0.01;
            return 0.001;
        }
        // df=63の場合は省略
        return 0.05;
    }
    
    // アラート生成
    generateAlerts(results) {
        this.alerts = [];
        
        // 爻位置偏りアラート
        if (results.linePosition.significant) {
            this.alerts.push({
                type: 'LINE_POSITION_BIAS',
                severity: 'HIGH',
                message: `爻位置に有意な偏りを検出 (χ²=${results.linePosition.chiSquare.toFixed(2)}, p<0.05)`,
                data: results.linePosition,
                timestamp: Date.now()
            });
        }
        
        // 最大使用率アラート
        if (results.linePosition.maxUsage > this.alertThresholds.maxPositionBias) {
            this.alerts.push({
                type: 'EXCESSIVE_POSITION_USAGE',
                severity: 'MEDIUM',
                message: `第${results.linePosition.maxPosition}爻の使用率が${(results.linePosition.maxUsage * 100).toFixed(1)}%`,
                data: results.linePosition,
                timestamp: Date.now()
            });
        }
        
        // 連続性アラート
        if (results.consecutive.significant) {
            this.alerts.push({
                type: 'CONSECUTIVE_SELECTION',
                severity: 'MEDIUM',
                message: `${results.consecutive.consecutiveType}が${results.consecutive.maxConsecutive}回連続`,
                data: results.consecutive,
                timestamp: Date.now()
            });
        }
        
        // コンソール出力
        if (this.alerts.length > 0) {
            console.group('⚠️ 統計的偏りアラート');
            this.alerts.forEach(alert => {
                console.warn(`[${alert.severity}] ${alert.message}`);
            });
            console.groupEnd();
        }
    }
    
    // 補正重み計算
    calculateCorrectionWeights(results) {
        const weights = {
            linePositions: new Array(6).fill(1.0),
            hexagrams: new Array(64).fill(1.0),
            timestamp: Date.now()
        };
        
        // 爻位置の補正重み
        if (results.linePosition.significant) {
            const targetProb = 1 / 6;
            results.linePosition.usage.forEach((usage, index) => {
                if (usage > 0) {
                    // 使用率の逆数で重み付け
                    weights.linePositions[index] = targetProb / usage;
                    // 極端な補正を防ぐ（0.5-2.0の範囲）
                    weights.linePositions[index] = Math.max(0.5, Math.min(2.0, weights.linePositions[index]));
                }
            });
        }
        
        this.correctionWeights = weights;
        console.log('📊 補正重み更新:', weights);
        
        return weights;
    }
    
    // 補正を適用した選択
    applyCorrection(candidates) {
        if (!this.correctionWeights) {
            return candidates[Math.floor(Math.random() * candidates.length)];
        }
        
        // 重み付き選択
        const weights = candidates.map(c => {
            const lineWeight = this.correctionWeights.linePositions[c.linePosition - 1];
            const hexWeight = this.correctionWeights.hexagrams[c.hexagramId - 1];
            return lineWeight * hexWeight * c.baseScore;
        });
        
        // 重みの正規化
        const totalWeight = weights.reduce((a, b) => a + b, 0);
        const normalizedWeights = weights.map(w => w / totalWeight);
        
        // ルーレット選択
        const random = Math.random();
        let cumulative = 0;
        
        for (let i = 0; i < candidates.length; i++) {
            cumulative += normalizedWeights[i];
            if (random <= cumulative) {
                return candidates[i];
            }
        }
        
        return candidates[candidates.length - 1];
    }
    
    // 統計レポート生成
    generateReport() {
        const report = {
            summary: {
                totalSelections: this.observations.total,
                testResults: this.performStatisticalTests(),
                alerts: this.alerts.length,
                correctionActive: !!this.correctionWeights
            },
            linePositions: {
                counts: this.observations.linePositions,
                percentages: this.observations.linePositions.map(
                    c => ((c / this.observations.total) * 100).toFixed(2) + '%'
                ),
                chiSquare: null
            },
            hexagrams: {
                used: this.observations.hexagrams.filter(c => c > 0).length,
                unused: this.observations.hexagrams.filter(c => c === 0).length,
                top5: this.getTop5Hexagrams()
            }
        };
        
        return report;
    }
    
    // 上位5卦を取得
    getTop5Hexagrams() {
        return this.observations.hexagrams
            .map((count, index) => ({ id: index + 1, count }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5)
            .map(h => `卦${h.id} (${h.count}回)`);
    }
}

// グローバル設定
window.biasDetector = new StatisticalBiasDetector();
```

**チェックリスト**:
- [ ] χ²検定の正確な実装
- [ ] p値計算
- [ ] 複数の偏り指標（位置、卦、連続性）
- [ ] 自動アラート生成
- [ ] 補正重み計算と適用

### Day 5: 性能測定と監視基盤

#### Task W1-4: パフォーマンス監視システム（8時間）
**ファイル**: `/public/js/monitoring/PerformanceMonitor.js`（新規作成）
**優先度**: 🔴 最優先（性能保証）

```javascript
class PerformanceMonitor {
    constructor() {
        this.metrics = {
            e2e: [],           // End-to-End処理時間
            analysis: [],      // 分析処理時間
            rendering: [],     // レンダリング時間
            memory: [],        // メモリ使用量
            cache: {
                hits: 0,
                misses: 0
            }
        };
        
        // 目標値（SLA）
        this.targets = {
            e2e_average: 40,    // ms
            e2e_p50: 35,
            e2e_p95: 45,
            e2e_p99: 50,
            memory_max: 120     // MB
        };
        
        // 自動監視設定
        this.monitoringInterval = null;
        this.reportInterval = 60000;  // 1分ごとにレポート
    }
    
    // 処理時間測定
    measurePerformance(operation) {
        const startMark = `${operation}-start-${Date.now()}`;
        const endMark = `${operation}-end-${Date.now()}`;
        
        performance.mark(startMark);
        
        return {
            end: () => {
                performance.mark(endMark);
                performance.measure(operation, startMark, endMark);
                
                const measure = performance.getEntriesByName(operation)[0];
                const duration = measure.duration;
                
                // 記録
                this.recordMetric('e2e', duration);
                
                // クリーンアップ
                performance.clearMarks(startMark);
                performance.clearMarks(endMark);
                performance.clearMeasures(operation);
                
                // SLA違反チェック
                if (duration > this.targets.e2e_p95) {
                    console.warn(`⚠️ SLA違反: ${operation} took ${duration.toFixed(2)}ms (target: <${this.targets.e2e_p95}ms)`);
                }
                
                return duration;
            }
        };
    }
    
    // メトリクス記録
    recordMetric(type, value) {
        if (!this.metrics[type]) {
            this.metrics[type] = [];
        }
        
        this.metrics[type].push({
            value,
            timestamp: Date.now()
        });
        
        // 直近1000件のみ保持
        if (this.metrics[type].length > 1000) {
            this.metrics[type].shift();
        }
    }
    
    // パーセンタイル計算
    calculatePercentile(values, percentile) {
        if (values.length === 0) return 0;
        
        const sorted = values.sort((a, b) => a - b);
        const index = Math.ceil((percentile / 100) * sorted.length) - 1;
        return sorted[Math.max(0, index)];
    }
    
    // 統計情報計算
    calculateStatistics(metricType) {
        const values = this.metrics[metricType].map(m => m.value);
        
        if (values.length === 0) {
            return null;
        }
        
        return {
            count: values.length,
            average: values.reduce((a, b) => a + b, 0) / values.length,
            min: Math.min(...values),
            max: Math.max(...values),
            p50: this.calculatePercentile(values, 50),
            p95: this.calculatePercentile(values, 95),
            p99: this.calculatePercentile(values, 99)
        };
    }
    
    // メモリ使用量監視
    monitorMemory() {
        if (performance.memory) {
            const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
            this.recordMetric('memory', memoryMB);
            
            if (memoryMB > this.targets.memory_max) {
                console.error(`❌ メモリ使用量超過: ${memoryMB.toFixed(2)}MB (max: ${this.targets.memory_max}MB)`);
                this.triggerMemoryCleanup();
            }
        }
    }
    
    // メモリクリーンアップ
    triggerMemoryCleanup() {
        // キャッシュクリア
        if (window.caches) {
            caches.keys().then(names => {
                names.forEach(name => caches.delete(name));
            });
        }
        
        // 強制ガベージコレクション（Chrome DevTools必要）
        if (window.gc) {
            window.gc();
            console.log('🧹 ガベージコレクション実行');
        }
    }
    
    // 自動監視開始
    startMonitoring() {
        if (this.monitoringInterval) {
            return;
        }
        
        this.monitoringInterval = setInterval(() => {
            this.monitorMemory();
            this.generateReport();
        }, this.reportInterval);
        
        console.log('📊 パフォーマンス監視開始');
    }
    
    // 監視停止
    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
            console.log('📊 パフォーマンス監視停止');
        }
    }
    
    // レポート生成
    generateReport() {
        const report = {
            timestamp: new Date().toISOString(),
            e2e: this.calculateStatistics('e2e'),
            memory: this.calculateStatistics('memory'),
            cache: {
                hitRate: this.metrics.cache.hits / 
                        (this.metrics.cache.hits + this.metrics.cache.misses) * 100
            },
            slaViolations: this.checkSLAViolations()
        };
        
        // コンソール出力
        console.group('📊 パフォーマンスレポート');
        if (report.e2e) {
            console.log(`E2E平均: ${report.e2e.average.toFixed(2)}ms (目標: <${this.targets.e2e_average}ms)`);
            console.log(`E2E P95: ${report.e2e.p95.toFixed(2)}ms (目標: <${this.targets.e2e_p95}ms)`);
        }
        if (report.memory) {
            console.log(`メモリ使用量: ${report.memory.average.toFixed(2)}MB (最大: ${this.targets.memory_max}MB)`);
        }
        console.log(`キャッシュヒット率: ${report.cache.hitRate.toFixed(1)}%`);
        console.groupEnd();
        
        // LocalStorage保存
        localStorage.setItem('performanceReport', JSON.stringify(report));
        
        return report;
    }
    
    // SLA違反チェック
    checkSLAViolations() {
        const violations = [];
        const e2eStats = this.calculateStatistics('e2e');
        
        if (e2eStats) {
            if (e2eStats.average > this.targets.e2e_average) {
                violations.push({
                    metric: 'e2e_average',
                    current: e2eStats.average,
                    target: this.targets.e2e_average,
                    severity: 'HIGH'
                });
            }
            
            if (e2eStats.p95 > this.targets.e2e_p95) {
                violations.push({
                    metric: 'e2e_p95',
                    current: e2eStats.p95,
                    target: this.targets.e2e_p95,
                    severity: 'MEDIUM'
                });
            }
        }
        
        return violations;
    }
}

// グローバル設定と自動開始
window.performanceMonitor = new PerformanceMonitor();
window.performanceMonitor.startMonitoring();
```

**チェックリスト**:
- [ ] E2E処理時間測定
- [ ] パーセンタイル計算（p50/p95/p99）
- [ ] メモリ使用量監視
- [ ] SLA違反検出
- [ ] 自動レポート生成

---

## 📋 Week 2: 核心機能実装

### Day 6-7: 形態素解析の完全活用

#### Task W2-1: MorphologicalAnalyzer実装（12時間）
**ファイル**: `/public/js/ai/MorphologicalAnalyzer.js`（新規作成）
**依存**: Kuromoji初期化完了

```javascript
class MorphologicalAnalyzer {
    constructor() {
        this.tokenizer = null;
        this.ready = false;
        this.cache = new Map();  // 解析結果キャッシュ
        this.maxCacheSize = 1000;
    }
    
    async initialize() {
        if (this.ready) return;
        
        try {
            // Kuromojiトークナイザー初期化
            this.tokenizer = await new Promise((resolve, reject) => {
                kuromoji.builder({
                    dicPath: "/dict/",
                    disableCache: false  // キャッシュ有効化
                }).build((err, tokenizer) => {
                    if (err) reject(err);
                    else resolve(tokenizer);
                });
            });
            
            this.ready = true;
            console.log('✅ MorphologicalAnalyzer初期化完了');
            
        } catch (error) {
            console.error('❌ Kuromoji初期化失敗:', error);
            // フォールバック: 簡易トークナイザー
            this.tokenizer = new SimpleFallbackTokenizer();
            this.ready = true;
        }
    }
    
    // テキスト解析（キャッシュ付き）
    async analyze(text) {
        if (!this.ready) {
            await this.initialize();
        }
        
        // キャッシュチェック
        if (this.cache.has(text)) {
            return this.cache.get(text);
        }
        
        const startTime = performance.now();
        
        // トークナイズ
        const tokens = this.tokenizer.tokenize(text);
        
        // 構造化解析
        const analysis = {
            tokens,
            structured: this.structureTokens(tokens),
            features: this.extractFeatures(tokens),
            negations: this.findNegations(tokens),
            dependencies: this.analyzeDependencies(tokens),
            processingTime: performance.now() - startTime
        };
        
        // キャッシュ保存
        this.addToCache(text, analysis);
        
        return analysis;
    }
    
    // トークン構造化
    structureTokens(tokens) {
        return {
            nouns: tokens.filter(t => t.pos === '名詞'),
            verbs: tokens.filter(t => t.pos === '動詞'),
            adjectives: tokens.filter(t => t.pos === '形容詞'),
            particles: tokens.filter(t => t.pos === '助詞'),
            adverbs: tokens.filter(t => t.pos === '副詞'),
            auxiliaries: tokens.filter(t => t.pos === '助動詞')
        };
    }
    
    // 特徴抽出
    extractFeatures(tokens) {
        const features = {
            // 基本統計
            tokenCount: tokens.length,
            charCount: tokens.reduce((sum, t) => sum + t.surface_form.length, 0),
            
            // 品詞分布
            posDistribution: this.calculatePOSDistribution(tokens),
            
            // 意味的特徴
            hasQuestion: tokens.some(t => ['か', '？'].includes(t.surface_form)),
            hasNegation: this.hasNegation(tokens),
            hasDesire: tokens.some(t => ['たい', 'ほしい', '欲しい'].includes(t.surface_form)),
            hasPast: tokens.some(t => ['た', 'だった'].includes(t.surface_form)),
            hasFuture: tokens.some(t => ['だろう', 'でしょう', 'つもり'].includes(t.surface_form)),
            
            // キーワード密度
            keywordDensity: this.calculateKeywordDensity(tokens)
        };
        
        return features;
    }
    
    // 否定表現の詳細検出
    findNegations(tokens) {
        const negations = [];
        const negPatterns = ['ない', 'ず', 'ぬ', 'まい', 'いけない', 'だめ', '無', '不', '非', '否'];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // 否定助動詞
            if (negPatterns.includes(token.surface_form) || 
                (token.pos === '助動詞' && token.surface_form.includes('ない'))) {
                
                const negation = {
                    index: i,
                    type: 'auxiliary',
                    form: token.surface_form,
                    scope: this.determineNegationScope(tokens, i),
                    affectedWord: null
                };
                
                // 影響を受ける語を特定
                if (i > 0 && ['動詞', '形容詞', '名詞'].includes(tokens[i - 1].pos)) {
                    negation.affectedWord = tokens[i - 1];
                }
                
                negations.push(negation);
            }
            
            // 否定接頭辞
            if (token.pos === '接頭詞' && ['不', '非', '無', '未'].includes(token.surface_form)) {
                negations.push({
                    index: i,
                    type: 'prefix',
                    form: token.surface_form,
                    scope: [i, Math.min(i + 2, tokens.length - 1)]
                });
            }
        }
        
        return negations;
    }
    
    // 否定スコープ判定
    determineNegationScope(tokens, negIndex) {
        let start = negIndex;
        let end = negIndex;
        
        // 前方探索（否定される対象）
        for (let i = negIndex - 1; i >= Math.max(0, negIndex - 5); i--) {
            if (['動詞', '形容詞', '名詞'].includes(tokens[i].pos)) {
                start = i;
                break;
            }
            if (tokens[i].pos === '助詞' && ['は', 'が', 'を'].includes(tokens[i].surface_form)) {
                break;
            }
        }
        
        // 後方探索（否定の範囲）
        for (let i = negIndex + 1; i < Math.min(tokens.length, negIndex + 3); i++) {
            if (tokens[i].pos === '助詞' && ['。', '、'].includes(tokens[i].surface_form)) {
                end = i;
                break;
            }
        }
        
        return [start, end];
    }
    
    // 係り受け解析（簡易版）
    analyzeDependencies(tokens) {
        const dependencies = [];
        
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            
            // 主語の検出
            if (['は', 'が'].includes(token.surface_form) && i > 0) {
                dependencies.push({
                    type: 'subject',
                    head: tokens[i - 1].surface_form,
                    particle: token.surface_form,
                    index: i - 1
                });
            }
            
            // 目的語の検出
            if (token.surface_form === 'を' && i > 0) {
                dependencies.push({
                    type: 'object',
                    head: tokens[i - 1].surface_form,
                    particle: token.surface_form,
                    index: i - 1
                });
            }
            
            // 修飾関係
            if (token.pos === '連体詞' || 
                (token.pos === '形容詞' && i < tokens.length - 1 && tokens[i + 1].pos === '名詞')) {
                dependencies.push({
                    type: 'modifier',
                    modifier: token.surface_form,
                    modified: tokens[i + 1]?.surface_form,
                    index: i
                });
            }
        }
        
        return dependencies;
    }
    
    // POSディストリビューション計算
    calculatePOSDistribution(tokens) {
        const distribution = {};
        
        tokens.forEach(token => {
            distribution[token.pos] = (distribution[token.pos] || 0) + 1;
        });
        
        // パーセンテージに変換
        const total = tokens.length;
        Object.keys(distribution).forEach(pos => {
            distribution[pos] = (distribution[pos] / total) * 100;
        });
        
        return distribution;
    }
    
    // キーワード密度計算
    calculateKeywordDensity(tokens) {
        const keywords = tokens.filter(t => 
            t.pos === '名詞' && t.pos_detail_1 !== '非自立'
        );
        
        return keywords.length / tokens.length;
    }
    
    // 否定チェック
    hasNegation(tokens) {
        return tokens.some(t => 
            ['ない', 'ず', 'ぬ', '無', '不', '非'].includes(t.surface_form) ||
            (t.pos === '助動詞' && t.surface_form.includes('ない'))
        );
    }
    
    // キャッシュ管理
    addToCache(text, analysis) {
        if (this.cache.size >= this.maxCacheSize) {
            // LRU: 最初の要素を削除
            const firstKey = this.cache.keys().next().value;
            this.cache.delete(firstKey);
        }
        
        this.cache.set(text, analysis);
    }
}

// 簡易フォールバックトークナイザー
class SimpleFallbackTokenizer {
    tokenize(text) {
        // 単純な文字種別分割
        const tokens = [];
        const patterns = [
            /[一-龠々]+/g,  // 漢字
            /[ぁ-ん]+/g,    // ひらがな
            /[ァ-ヴー]+/g,  // カタカナ
            /[a-zA-Z]+/g,   // 英字
            /[0-9]+/g       // 数字
        ];
        
        let position = 0;
        patterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                tokens.push({
                    surface_form: match[0],
                    pos: this.guessPOS(match[0]),
                    pos_detail_1: '*',
                    position: match.index
                });
            }
        });
        
        // 位置順にソート
        return tokens.sort((a, b) => a.position - b.position);
    }
    
    guessPOS(word) {
        // 簡易的な品詞推定
        if (/[一-龠々]+/.test(word)) return '名詞';
        if (/[ぁ-ん]+/.test(word)) {
            if (['する', 'ある', 'いる', 'なる'].includes(word)) return '動詞';
            if (['ない', 'たい', 'らしい'].includes(word)) return '助動詞';
            return '助詞';
        }
        if (/[ァ-ヴー]+/.test(word)) return '名詞';
        return '記号';
    }
}

// グローバル設定
window.morphAnalyzer = new MorphologicalAnalyzer();
```

**チェックリスト**:
- [ ] Kuromoji完全統合
- [ ] フォールバックトークナイザー
- [ ] 否定スコープ判定
- [ ] 係り受け解析
- [ ] キャッシュ機能

### Day 8-9: 統合テストとバグ修正

#### Task W2-2: 統合テストスイート（12時間）
**ファイル**: `/test/integration-test.js`（新規作成）

```javascript
class IntegrationTestSuite {
    constructor() {
        this.tests = [];
        this.results = [];
    }
    
    async runAll() {
        console.group('🧪 統合テスト実行');
        
        // テスト定義
        this.tests = [
            this.testDeterminism(),
            this.testNegationDetection(),
            this.testBiasDetection(),
            this.testPerformance(),
            this.testDataValidation()
        ];
        
        // 実行
        for (const test of this.tests) {
            const result = await test;
            this.results.push(result);
            
            if (result.passed) {
                console.log(`✅ ${result.name}`);
            } else {
                console.error(`❌ ${result.name}:`, result.error);
            }
        }
        
        console.groupEnd();
        
        // サマリー
        const passed = this.results.filter(r => r.passed).length;
        const total = this.results.length;
        
        console.log(`\n📊 テスト結果: ${passed}/${total} 合格`);
        
        return {
            passed: passed === total,
            summary: `${passed}/${total}`,
            details: this.results
        };
    }
    
    // 決定論性テスト
    async testDeterminism() {
        const testName = '決定論性テスト';
        
        try {
            const inputs = [
                "リーダーになりたい",
                "チームを成長させる",
                "困難を乗り越える"
            ];
            
            const results = [];
            
            // 10回実行
            for (let run = 0; run < 10; run++) {
                window.deterministicEngine.reset();
                const runResults = [];
                
                for (const input of inputs) {
                    const analyzer = new TextTo384LinesBridge();
                    const result = await analyzer.analyzeTextToSpecificLine(input);
                    runResults.push(result.lineId);
                }
                
                results.push(runResults.join(','));
            }
            
            // 全結果が同一か確認
            const firstRun = results[0];
            const allSame = results.every(r => r === firstRun);
            
            return {
                name: testName,
                passed: allSame,
                error: allSame ? null : 'Results differ across runs'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // 否定文検出テスト
    async testNegationDetection() {
        const testName = '否定文検出テスト';
        
        try {
            const testCases = [
                { input: "リーダーになりたい", hasNegation: false },
                { input: "リーダーになりたくない", hasNegation: true },
                { input: "リーダーには向いていない", hasNegation: true },
                { input: "リーダーシップに疑問を感じる", hasNegation: false }
            ];
            
            const analyzer = window.morphAnalyzer;
            await analyzer.initialize();
            
            let allCorrect = true;
            
            for (const testCase of testCases) {
                const analysis = await analyzer.analyze(testCase.input);
                const detected = analysis.negations.length > 0;
                
                if (detected !== testCase.hasNegation) {
                    allCorrect = false;
                    console.error(`Failed: "${testCase.input}" - Expected: ${testCase.hasNegation}, Got: ${detected}`);
                }
            }
            
            return {
                name: testName,
                passed: allCorrect,
                error: allCorrect ? null : 'Some negation detections failed'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // 偏り検出テスト
    async testBiasDetection() {
        const testName = '偏り検出テスト';
        
        try {
            const detector = window.biasDetector;
            
            // 偏ったデータを意図的に作成
            for (let i = 0; i < 100; i++) {
                // 第5爻に偏らせる
                const hexagram = Math.floor(Math.random() * 64) + 1;
                const line = i < 70 ? 5 : Math.floor(Math.random() * 6) + 1;
                detector.recordSelection(hexagram, line);
            }
            
            const results = detector.performStatisticalTests();
            
            // χ²検定で有意差が検出されるはず
            const biasDetected = results.linePosition.significant;
            
            return {
                name: testName,
                passed: biasDetected,
                error: biasDetected ? null : 'Failed to detect intentional bias'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // パフォーマンステスト
    async testPerformance() {
        const testName = 'パフォーマンステスト';
        
        try {
            const monitor = window.performanceMonitor;
            const times = [];
            
            // 100回の処理を測定
            for (let i = 0; i < 100; i++) {
                const measure = monitor.measurePerformance('test-analysis');
                
                // ダミー処理
                await new Promise(resolve => setTimeout(resolve, Math.random() * 20 + 10));
                
                const duration = measure.end();
                times.push(duration);
            }
            
            // 統計計算
            const average = times.reduce((a, b) => a + b, 0) / times.length;
            const sorted = times.sort((a, b) => a - b);
            const p95 = sorted[Math.floor(times.length * 0.95)];
            
            // 目標値チェック
            const meetsTarget = average < 40 && p95 < 45;
            
            return {
                name: testName,
                passed: meetsTarget,
                error: meetsTarget ? null : `Average: ${average.toFixed(2)}ms, P95: ${p95.toFixed(2)}ms`
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
    
    // データ検証テスト
    async testDataValidation() {
        const testName = 'データ検証テスト';
        
        try {
            const validator = new DataValidator();
            const isValid = await validator.validateAll();
            
            return {
                name: testName,
                passed: isValid || validator.validationResults.fallbacksUsed.length > 0,
                error: isValid ? null : 'Critical data missing without fallback'
            };
            
        } catch (error) {
            return {
                name: testName,
                passed: false,
                error: error.message
            };
        }
    }
}

// 実行ヘルパー
async function runIntegrationTests() {
    const suite = new IntegrationTestSuite();
    const results = await suite.runAll();
    
    // 結果をHTMLで表示
    if (document.getElementById('test-results')) {
        const html = `
            <div class="${results.passed ? 'success' : 'failure'}">
                <h3>統合テスト結果: ${results.summary}</h3>
                <ul>
                    ${results.details.map(r => `
                        <li class="${r.passed ? 'passed' : 'failed'}">
                            ${r.passed ? '✅' : '❌'} ${r.name}
                            ${r.error ? `<br><small>${r.error}</small>` : ''}
                        </li>
                    `).join('')}
                </ul>
            </div>
        `;
        document.getElementById('test-results').innerHTML = html;
    }
    
    return results;
}
```

**チェックリスト**:
- [ ] 決定論性テスト実装
- [ ] 否定文検出テスト実装
- [ ] 偏り検出テスト実装
- [ ] パフォーマンステスト実装
- [ ] データ検証テスト実装

---

## 🗄️ DB統合（D1/SQLite）

アーキ方針: ローカルはSQLite、Edge/本番はCloudflare D1。マイグレーションは共通スクリプトで管理。

### スキーマ骨子（例）
```sql
-- hexagrams
CREATE TABLE hexagrams (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

-- lines (384)
CREATE TABLE lines (
  id INTEGER PRIMARY KEY,
  hexagram_id INTEGER NOT NULL,
  position INTEGER NOT NULL CHECK(position BETWEEN 1 AND 6),
  keywords TEXT,
  interpretation TEXT,
  FOREIGN KEY(hexagram_id) REFERENCES hexagrams(id)
);

-- selections (ログ)
CREATE TABLE selections (
  id INTEGER PRIMARY KEY,
  hexagram_id INTEGER NOT NULL,
  line_position INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  FOREIGN KEY(hexagram_id) REFERENCES hexagrams(id)
);
```

### 主要タスク
- Task DB-1: マイグレーション作成（up/down）と自動検証（6時間）
- Task DB-2: データ投入（JSON→DB）と整合性チェック（6時間）
- Task DB-3: 主要クエリ最適化・インデックス設計（4時間）
- Task DB-4: ロールバック/復旧手順の自動化（4時間）

### DoD（完了の定義）
- マイグレーション往復（up→down→up）が無停止で成功。
- JSON→DB投入後、件数整合（hexagrams=64、lines=384）を自動チェック。
- 主要クエリ（最新N件、集計、行抽出）のp95<10ms（ローカル/Edge相当）を計測し記録。
- 破損/失敗時に自動ロールバックし、整合性チェックが再度成功すること。

## 📋 Week 3-4: 段階的改善と最適化

### Week 3: 意味理解の基礎実装

#### Task W3-1: 簡易Word2Vec統合（3日）
#### Task W3-2: 類義語辞書構築（2日）

### Week 4: 最終調整と本番準備

#### Task W4-1: 全体最適化（2日）
#### Task W4-2: ドキュメント整備（1日）
#### Task W4-3: 本番デプロイ準備（2日）
#### Task W4-4: 運用監視タスクの必須化（1日）
- メトリクス送出（E2E/analysis/rendering/memory/cache）とアラート閾値を本番設定に反映。
- 偏りアラート（χ²、最大使用率、連続性）を監視面に露出（ログ/通知）。
- 可観測性ドキュメント（計測項目、ダッシュボード、アラート閾値、Runbook）を整備。

---

## ✅ DoDテンプレート（各Task共通）

1. 単体テスト合格（分岐網羅80%+）
2. p50/95/99レイテンシが基準内（Edge想定）
3. 決定論性チェック（同入力＝同出力、一致率=100%）
4. 位置分布の閾値逸脱なし（どの爻位置も30%超えない）
5. ログ/メトリクス項目追加済（精度・速度・キャッシュ/アラート）

## 🔬 「すぐ動かす」ための最小検証3本

1. 決定論性スモーク: 固定10入力×10回＝一致率100%
2. 5爻回復チェック: リーダーシップ系サンプルで5爻選択≥60%（Tolerance準拠）
3. 性能しきい値: 平均<40ms（E2E）、p95<45ms、p99<50ms

## 📊 成功基準と検証方法

### Go判定基準（必須達成項目）

| 項目 | 目標 | 検証方法 |
|------|------|----------|
| データ検証 | 100%成功 or フォールバック動作 | `DataValidator.validateAll()` |
| 決定論性 | 100%（10回同一結果） | 統合テスト |
| E2E平均 | < 40ms | `PerformanceMonitor.generateReport()` |
| E2E P95 | < 45ms | 同上 |
| 偏り検出 | χ²検定実装・動作 | `StatisticalBiasDetector.performStatisticalTests()` |
| 否定文検出 | 精度90%以上 | テストスイート |

### 日次進捗チェックリスト

```javascript
// 毎日実行する検証スクリプト
async function dailyHealthCheck() {
    const checks = {
        dataValid: await new DataValidator().validateAll(),
        determinism: await testDeterminism(),
        performance: performanceMonitor.generateReport(),
        bias: biasDetector.generateReport(),
        memory: performance.memory?.usedJSHeapSize / 1024 / 1024
    };
    
    console.table(checks);
    return checks;
}
```

---

## 🚨 リスクと軽減策

| リスク | 発生確率 | 影響 | 軽減策 |
|--------|----------|------|--------|
| Kuromoji初期化失敗 | 中 | 高 | SimpleFallbackTokenizer実装済み |
| メモリ不足 | 中 | 高 | キャッシュサイズ制限・GC強制実行 |
| 性能目標未達 | 低 | 中 | 段階的最適化・キャッシュ強化 |
| データ欠損 | 高 | 高 | フォールバックデータ生成 |

---

## ✅ 完了判定チェックリスト

### Week 1完了条件
- [ ] DataValidator実装・テスト合格
- [ ] DeterministicEngine実装・100%決定論性
- [ ] StatisticalBiasDetector実装・χ²検定動作
- [ ] PerformanceMonitor実装・40ms達成

### Week 2完了条件
- [ ] MorphologicalAnalyzer完全実装
- [ ] 統合テスト全項目合格
- [ ] 否定文検出精度90%以上

### Week 3-4完了条件
- [ ] Word2Vec基礎実装
- [ ] 全最適化完了
- [ ] 本番環境準備完了

---

**文書完了** - この詳細タスク分解に従って即座に実装を開始できます。Week 1の緊急対応を最優先で実施してください。
