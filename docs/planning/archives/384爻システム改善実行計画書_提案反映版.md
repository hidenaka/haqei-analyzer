# 384爻システム改善実行計画書 - 提案反映版

**作成日**: 2025年8月26日  
**目標**: 本来の目的達成（達成度40%→90%以上）  
**期間**: 2週間（2025年8月27日〜9月9日）  

---

## 📊 現状認識と改善目標

### 現状の問題点
- **カバー率**: 5.7%（22個/384個）→ **目標: 30%以上（115個以上）**
- **5爻選択率**: 0% → **目標: 15-20%**
- **偏り**: 2爻29%、6爻28% → **目標: 全位置10-20%**
- **テストサンプル**: 100件 → **目標: 500件以上**

### 改善の優先順位
1. 🔴 **最優先**: 5爻選択問題の解決
2. 🟠 **高優先**: カバー率の大幅向上
3. 🟡 **中優先**: 全体的な偏りの是正
4. 🟢 **将来**: 機械学習導入の検討

---

## 🚀 Phase 1: 5爻選択問題の早急な対応（Day 1-3）

### 1.1 五爻キーワードの根本的見直し

#### Day 1: キーワード分析と再収集
```javascript
// 現在の5爻キーワード（効果なし）
現行: ['リーダー', '責任', '統率', '指導', '管理', '権限', '中心']

// 改善案: 実際のユーザー入力に基づく拡張
新規: [
  // 君位・中正の象徴
  '君位', '中正', '君主', '王者', '天子',
  
  // リーダーシップ関連（より具体的に）
  'CEO', '社長', '部長', '課長', 'マネージャー', 'リーダー',
  '経営', '統括', '指揮', '采配', '舵取り',
  
  // 意思決定・判断
  '決定', '決断', '判断', '方針', '戦略', '政策',
  '裁定', '裁量', '決済', '承認', '許可',
  
  // 権威・影響力
  '権威', '威厳', '影響力', '発言力', '主導権',
  '支配', '統治', '統制', 'コントロール',
  
  // 成功・達成
  '成功', '達成', '実現', '成就', '完遂',
  '勝利', '優勝', '制覇', 'トップ', '頂点'
]
```

#### Day 2: 重み付けの大幅調整
```javascript
// タスク1: encodePositionVectorの修正
encodePositionVector(vector, offset, position) {
    // 5爻を最優先に設定
    const positionWeights = [
        0.45,  // 1爻
        0.35,  // 2爻（下げる）
        0.40,  // 3爻
        0.45,  // 4爻
        0.95,  // 5爻（大幅強化）
        0.35   // 6爻（下げる）
    ];
}

// タスク2: 特別処理の追加
getEnhancedPositionAdjustment(position, text) {
    // 5爻の特別ブースト
    if (position === 5) {
        // 君位関連語があれば大幅加点
        const leadershipTerms = ['決定', '判断', 'CEO', '社長', '経営'];
        for (const term of leadershipTerms) {
            if (text.includes(term)) {
                return 0.3; // 通常の3倍のボーナス
            }
        }
    }
}
```

#### Day 3: 検証と微調整
- 200サンプルでテスト実行
- 5爻選択率の確認（目標: 15%以上）
- 他の爻への影響評価

### 成果物
- [ ] 5爻キーワード辞書（50語以上）
- [ ] 重み調整済みコード
- [ ] 検証レポート

---

## 🎯 Phase 2: カバー率向上のためのベクトル・語彙拡張（Day 4-7）

### 2.1 語彙の大幅拡張

#### Day 4: 爻辞からのキーワード抽出
```javascript
// 各爻の爻辞から意味的キーワードを抽出
async function extractKeywordsFromYaoCi() {
    const koudo_shishin = await loadKoudoShishin();
    
    for (let lineId = 1; lineId <= 384; lineId++) {
        const lineData = koudo_shishin[lineId];
        
        // 爻名から抽出
        const yaoName = lineData.name; // 例: "初九", "九二"
        
        // 爻辞から重要語抽出
        const yaoCi = lineData.yao_ci;
        const keywords = extractImportantWords(yaoCi);
        
        // 象意から抽出
        const xiangYi = lineData.xiang_yi;
        const xiangKeywords = extractXiangKeywords(xiangYi);
        
        // 統合してキーワードリストを拡張
        lineData.extended_keywords = [
            ...lineData.keywords,
            ...keywords,
            ...xiangKeywords
        ];
    }
}
```

#### Day 5: セマンティックベクトルの差別化強化
```javascript
generateSemanticVectors(lineId) {
    const vector = new Float32Array(656);
    
    // 1. 基本ベクトル（既存）
    this.encodeHexagramVector(vector, 0, hexagramId);
    this.encodePositionVector(vector, 100, position);
    
    // 2. 爻固有の特徴を強化（新規）
    this.encodeUniquePattern(vector, 200, lineId);
    
    // 3. ノイズ追加で多様性確保（新規）
    this.addDeterministicNoise(vector, 300, lineId);
    
    // 4. 正規化
    this.normalizeVector(vector);
    
    return vector;
}

// 爻固有パターンの生成
encodeUniquePattern(vector, offset, lineId) {
    // 黄金比を使った一意なパターン生成
    const phi = 1.618033988749;
    const theta = lineId * phi * Math.PI / 192;
    
    for (let i = 0; i < 100; i++) {
        // 各爻に固有のサイン波パターン
        vector[offset + i] = Math.sin(theta * i) * 0.5 + 
                            Math.cos(theta * i * 0.7) * 0.3;
    }
}
```

#### Day 6: キーワードマッチング改善
```javascript
// より柔軟なマッチングアルゴリズム
calculateKeywordMatch(lineKeywords, textKeywords) {
    let score = 0;
    
    // 完全一致
    const exactMatches = this.countExactMatches(lineKeywords, textKeywords);
    score += exactMatches * 0.3;
    
    // 部分一致（新規）
    const partialMatches = this.countPartialMatches(lineKeywords, textKeywords);
    score += partialMatches * 0.2;
    
    // 意味的類似度（新規）
    const semanticSimilarity = this.calculateSemanticSimilarity(lineKeywords, textKeywords);
    score += semanticSimilarity * 0.5;
    
    return Math.min(1, score);
}
```

#### Day 7: 統合テストと調整
- 300サンプルでカバー率測定
- 未使用爻の分析
- 追加調整

### 成果物
- [ ] 拡張キーワード辞書（各爻10語以上）
- [ ] 改良セマンティックベクトル生成器
- [ ] カバー率15%以上の達成

---

## ⚖️ Phase 3: 偏り監視と重み調整（Day 8-10）

### 3.1 リアルタイム監視システムの実装

#### Day 8: 監視ダッシュボード構築
```javascript
class BiasMonitor {
    constructor() {
        this.positionCounts = new Array(6).fill(0);
        this.lineCounts = new Map();
        this.sampleCount = 0;
    }
    
    // リアルタイムで偏りを監視
    monitor(result) {
        const position = ((result.exact_line - 1) % 6) + 1;
        this.positionCounts[position - 1]++;
        
        const count = this.lineCounts.get(result.exact_line) || 0;
        this.lineCounts.set(result.exact_line, count + 1);
        
        this.sampleCount++;
        
        // 偏りアラート
        if (this.sampleCount % 50 === 0) {
            this.checkBias();
        }
    }
    
    checkBias() {
        const distribution = this.getDistribution();
        
        // 30%を超える位置があればアラート
        for (let i = 0; i < 6; i++) {
            if (distribution[i] > 30) {
                console.warn(`⚠️ 位置${i+1}が${distribution[i]}%で偏り発生`);
                this.suggestAdjustment(i + 1);
            }
        }
    }
}
```

#### Day 9: 動的重み調整システム
```javascript
class DynamicWeightAdjuster {
    constructor() {
        this.adjustmentHistory = [];
    }
    
    // 偏りに基づいて自動調整
    adjustWeights(biasData) {
        const newWeights = this.calculateOptimalWeights(biasData);
        
        // 段階的に調整（急激な変更を避ける）
        this.applyGradualAdjustment(newWeights);
        
        // 調整履歴を記録
        this.adjustmentHistory.push({
            timestamp: Date.now(),
            before: this.currentWeights,
            after: newWeights,
            bias: biasData
        });
    }
    
    calculateOptimalWeights(biasData) {
        const targetDistribution = 1/6; // 16.67%
        const weights = new Array(6);
        
        for (let i = 0; i < 6; i++) {
            const currentRatio = biasData.distribution[i];
            const adjustment = targetDistribution / currentRatio;
            weights[i] = this.currentWeights[i] * adjustment;
        }
        
        return weights;
    }
}
```

#### Day 10: A/Bテストシステム
```javascript
// 複数の重み設定を比較テスト
async function runABTest() {
    const configs = [
        { name: 'Config A', weights: [0.5, 0.4, 0.4, 0.5, 0.9, 0.4] },
        { name: 'Config B', weights: [0.45, 0.35, 0.45, 0.45, 0.95, 0.35] },
        { name: 'Config C', weights: [0.4, 0.3, 0.5, 0.5, 1.0, 0.3] }
    ];
    
    const results = [];
    
    for (const config of configs) {
        const testResult = await testConfiguration(config, 200);
        results.push({
            config: config.name,
            coverage: testResult.coverage,
            distribution: testResult.distribution,
            fiveYaoRate: testResult.positionRates[4]
        });
    }
    
    // 最適な設定を選択
    return selectBestConfiguration(results);
}
```

### 成果物
- [ ] リアルタイム監視システム
- [ ] 動的調整機能
- [ ] 最適重み設定の特定

---

## 📈 Phase 4: 大規模テストと検証（Day 11-12）

### 4.1 500サンプルテストの実施

#### Day 11: テストデータセット作成
```javascript
// 多様なカテゴリーからサンプル生成
function generate500TestSamples() {
    const categories = [
        { name: 'リーダーシップ', count: 50, keywords: ['決定', '経営', '統率'] },
        { name: '人間関係', count: 50, keywords: ['協力', '相談', '関係'] },
        { name: '困難・試練', count: 50, keywords: ['問題', '困難', '挑戦'] },
        { name: '変化・転換', count: 50, keywords: ['変化', '転換', '移行'] },
        { name: '始まり', count: 50, keywords: ['開始', '新規', '初'] },
        { name: '完成・終了', count: 50, keywords: ['完了', '終了', '完成'] },
        { name: '成長・発展', count: 50, keywords: ['成長', '発展', '向上'] },
        { name: '内省・精神', count: 50, keywords: ['内面', '精神', '心'] },
        { name: 'ビジネス', count: 50, keywords: ['事業', 'ビジネス', '仕事'] },
        { name: '一般質問', count: 50, keywords: [] } // ランダムテキスト
    ];
    
    const samples = [];
    for (const category of categories) {
        samples.push(...generateCategorySamples(category));
    }
    
    return samples;
}
```

#### Day 12: 統計的検証
```javascript
// χ²検定による分布の検証
function chiSquareTest(observed, expected) {
    let chiSquare = 0;
    
    for (let i = 0; i < observed.length; i++) {
        const diff = observed[i] - expected[i];
        chiSquare += (diff * diff) / expected[i];
    }
    
    const df = observed.length - 1;
    const pValue = calculatePValue(chiSquare, df);
    
    return {
        chiSquare,
        pValue,
        significant: pValue < 0.05,
        interpretation: pValue < 0.05 ? '偏りあり' : '均等分布'
    };
}

// コルモゴロフ・スミルノフ検定
function ksTest(distribution) {
    // 一様分布との比較
    const uniform = new Array(6).fill(1/6);
    const ksStatistic = calculateKSStatistic(distribution, uniform);
    
    return {
        statistic: ksStatistic,
        significant: ksStatistic > 0.05
    };
}
```

### 成果物
- [ ] 500件のテストサンプル
- [ ] 統計検証レポート
- [ ] カバー率20%以上の確認

---

## 🤖 Phase 5: 長期的改善 - 機械学習導入検討（Day 13-14）

### 5.1 プロトタイプ実装

#### Day 13: BERTベースの意味ベクトル
```javascript
// 事前学習モデルを使った高度な意味理解
class BERTSemanticAnalyzer {
    async initialize() {
        // TensorFlow.jsでBERT-base-japaneseを読み込み
        this.model = await tf.loadLayersModel('/models/bert-base-japanese/model.json');
        this.tokenizer = new BertTokenizer();
    }
    
    async analyzeText(text) {
        // テキストをトークン化
        const tokens = this.tokenizer.tokenize(text);
        const input = this.tokenizer.convertToTensor(tokens);
        
        // BERTで意味ベクトル生成
        const embeddings = await this.model.predict(input);
        
        // 768次元のベクトルを656次元に変換
        return this.projectTo656Dim(embeddings);
    }
    
    projectTo656Dim(embeddings) {
        // PCAで次元削減
        const pca = new PCA(embeddings);
        return pca.project(656);
    }
}
```

#### Day 14: 自己学習機構の設計
```javascript
// ユーザーフィードバックに基づく継続的改善
class SelfLearningSystem {
    constructor() {
        this.feedbackHistory = [];
        this.weightUpdates = [];
    }
    
    // ユーザーフィードバックの収集
    collectFeedback(input, selectedLine, isGood) {
        this.feedbackHistory.push({
            timestamp: Date.now(),
            input,
            selectedLine,
            rating: isGood ? 1 : -1
        });
        
        // 100件ごとに学習
        if (this.feedbackHistory.length % 100 === 0) {
            this.learn();
        }
    }
    
    // 重みの自動調整
    learn() {
        const positiveExamples = this.feedbackHistory.filter(f => f.rating > 0);
        const negativeExamples = this.feedbackHistory.filter(f => f.rating < 0);
        
        // 勾配降下法で最適化
        const gradients = this.calculateGradients(positiveExamples, negativeExamples);
        this.updateWeights(gradients);
    }
}
```

### 成果物
- [ ] 機械学習プロトタイプ
- [ ] 実装可能性評価レポート
- [ ] 導入計画書

---

## 📊 成功指標とマイルストーン

### 週次目標

| 週 | 期間 | 主要目標 | 成功基準 |
|----|------|----------|----------|
| 第1週 | 8/27-9/2 | 5爻問題解決とカバー率向上 | 5爻15%以上、カバー率15% |
| 第2週 | 9/3-9/9 | 大規模検証と最適化 | カバー率30%、全位置10-20% |

### 最終目標（9月9日）

| 指標 | 現在値 | 目標値 | 必須/推奨 |
|------|--------|--------|-----------|
| カバー率 | 5.7% | 30%以上 | 必須 |
| 5爻選択率 | 0% | 15-20% | 必須 |
| 各位置分布 | 0-29% | 10-20% | 必須 |
| ユニーク爻数 | 22個 | 115個以上 | 必須 |
| テストサンプル | 100件 | 500件以上 | 必須 |
| 処理速度 | - | 1000回/秒 | 推奨 |
| 機械学習導入 | なし | プロトタイプ | 推奨 |

---

## ⚠️ リスクと対策

### 技術的リスク
1. **5爻強化による新たな偏り**
   - 対策: 段階的調整と常時監視
   
2. **処理速度の低下**
   - 対策: キャッシュ機構の実装
   
3. **決定論性の破壊**
   - 対策: シード値管理の徹底

### プロジェクトリスク
1. **スケジュール遅延**
   - 対策: 日次進捗確認
   
2. **品質低下**
   - 対策: 自動テストの充実

---

## 📝 実行体制

### 役割分担
- **開発リード**: 実装全般
- **データサイエンティスト**: 統計検証、機械学習
- **QAエンジニア**: テスト設計・実行
- **プロダクトマネージャー**: 進捗管理

### コミュニケーション
- 日次スタンドアップ: 10:00
- 週次レビュー: 金曜 16:00
- 緊急連絡: Slack #384-improvement

---

## ✅ 開始チェックリスト

- [ ] 現在のコードのバックアップ
- [ ] 開発環境の準備
- [ ] テストデータの準備
- [ ] チーム体制の確認
- [ ] スケジュールの合意
- [ ] 成功基準の承認

---

**承認**: _________________ 日付: _______  
**備考**: 本計画は提案内容を全て反映し、具体的な実装方法を含む