# 📋 TRAE実装指示書 - 高度分析機能の画面実装

## 🎯 実装目的

HAQEIを単なる診断ツールから「**深層心理の可視化システム**」へ進化させる。回答の相関、時系列変化、爻位の段階的発展を、ユーザーが直感的に理解できる形で画面に表示する。

## 🖼️ 画面表示の全体像

### 新しいタブ構成
```
[基本結果] [詳細分析] [相関マップ🆕] [成長軌跡🆕] [発展段階🆕] [洞察] [シナリオ] [エクスポート]
```

## 📊 機能1: 回答相関分析システム

### 1.1 画面表示イメージ

```html
<!-- 相関マップタブの表示 -->
<div class="correlation-map-container">
    <!-- ヒートマップ表示 -->
    <div class="correlation-heatmap">
        <canvas id="correlationCanvas"></canvas>
        <div class="correlation-legend">
            <span class="strong-positive">強い正の相関</span>
            <span class="weak-positive">弱い正の相関</span>
            <span class="neutral">相関なし</span>
            <span class="weak-negative">弱い負の相関</span>
            <span class="strong-negative">強い負の相関</span>
        </div>
    </div>
    
    <!-- 発見されたパターン -->
    <div class="discovered-patterns">
        <h3>あなたの回答から見つかった特徴的なパターン</h3>
        <div class="pattern-cards">
            <div class="pattern-card highlight">
                <span class="pattern-icon">🔄</span>
                <h4>内外一致型</h4>
                <p>内的動機（Q1-8）と外的表現（Q9-16）が強く連動</p>
                <div class="correlation-strength">相関係数: 0.85</div>
            </div>
        </div>
    </div>
    
    <!-- インタラクティブな詳細表示 -->
    <div class="correlation-details" id="correlationDetails">
        <!-- クリックした質問ペアの詳細がここに表示される -->
    </div>
</div>
```

### 1.2 実装ロジック

**新規ファイル**: `/public/js/components/tabs/CorrelationMapTab.js`

```javascript
/**
 * 相関マップタブ - 質問間の関連性を可視化
 */
class CorrelationMapTab extends BaseTabView {
    constructor(tabId) {
        super(tabId);
        this.correlationMatrix = null;
        this.patterns = [];
        this.heatmapChart = null;
    }

    /**
     * 相関行列を計算
     */
    calculateCorrelationMatrix(answers) {
        const n = answers.length;
        const matrix = Array(n).fill(null).map(() => Array(n).fill(0));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i === j) {
                    matrix[i][j] = 1; // 自己相関は1
                } else {
                    matrix[i][j] = this.pearsonCorrelation(
                        answers.slice(0, 24).map(a => a[i]),
                        answers.slice(0, 24).map(a => a[j])
                    );
                }
            }
        }
        
        return matrix;
    }

    /**
     * ピアソン相関係数の計算
     */
    pearsonCorrelation(x, y) {
        const n = x.length;
        const sumX = x.reduce((a, b) => a + b, 0);
        const sumY = y.reduce((a, b) => a + b, 0);
        const sumXY = x.reduce((total, xi, i) => total + xi * y[i], 0);
        const sumX2 = x.reduce((total, xi) => total + xi * xi, 0);
        const sumY2 = y.reduce((total, yi) => total + yi * yi, 0);
        
        const correlation = (n * sumXY - sumX * sumY) / 
            Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        
        return isNaN(correlation) ? 0 : correlation;
    }

    /**
     * 特徴的なパターンを検出
     */
    detectPatterns(matrix, answers) {
        const patterns = [];
        
        // パターン1: 内外一致性
        const innerOuter = this.calculateGroupCorrelation(
            matrix, 
            [0, 1, 2, 3, 4, 5, 6, 7],    // Q1-8: 内的動機
            [8, 9, 10, 11, 12, 13, 14, 15] // Q9-16: 外的表現
        );
        
        if (Math.abs(innerOuter) > 0.6) {
            patterns.push({
                type: 'inner-outer-consistency',
                name: innerOuter > 0 ? '内外一致型' : '内外分離型',
                description: innerOuter > 0 
                    ? '内面の思いと外での振る舞いが一致しています'
                    : '内面と外面で異なる自分を使い分けています',
                strength: Math.abs(innerOuter),
                icon: innerOuter > 0 ? '🔄' : '🔀',
                details: this.generateConsistencyDetails(answers, innerOuter)
            });
        }
        
        // パターン2: リスク-安定バランス
        const riskStability = this.calculateGroupCorrelation(
            matrix,
            [4, 5, 6, 7],      // Q5-8: リスク志向
            [19, 20, 21, 22, 23] // Q20-24: 安定志向
        );
        
        if (Math.abs(riskStability) > 0.5) {
            patterns.push({
                type: 'risk-stability',
                name: riskStability < -0.5 ? '冒険家型' : '安定重視型',
                description: riskStability < -0.5
                    ? 'リスクを恐れず新しい挑戦を求めます'
                    : '安定と確実性を重視して行動します',
                strength: Math.abs(riskStability),
                icon: riskStability < -0.5 ? '🚀' : '⚖️',
                details: this.generateRiskDetails(answers, riskStability)
            });
        }
        
        // パターン3: 論理-感情バランス
        const logicEmotion = this.detectLogicEmotionBalance(matrix, answers);
        if (logicEmotion) {
            patterns.push(logicEmotion);
        }
        
        // パターン4: リーダーシップ傾向
        const leadership = this.detectLeadershipPattern(matrix, answers);
        if (leadership) {
            patterns.push(leadership);
        }
        
        return patterns.sort((a, b) => b.strength - a.strength);
    }

    /**
     * ヒートマップを描画
     */
    renderHeatmap(container) {
        const canvas = document.getElementById('correlationCanvas');
        const ctx = canvas.getContext('2d');
        
        // キャンバスサイズ設定
        const size = Math.min(container.clientWidth - 100, 600);
        canvas.width = size;
        canvas.height = size;
        
        const cellSize = size / 24;
        
        // ヒートマップ描画
        for (let i = 0; i < 24; i++) {
            for (let j = 0; j < 24; j++) {
                const correlation = this.correlationMatrix[i][j];
                ctx.fillStyle = this.getHeatmapColor(correlation);
                ctx.fillRect(i * cellSize, j * cellSize, cellSize - 1, cellSize - 1);
            }
        }
        
        // インタラクティブ機能を追加
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const i = Math.floor(x / cellSize);
            const j = Math.floor(y / cellSize);
            
            if (i >= 0 && i < 24 && j >= 0 && j < 24) {
                this.showCorrelationDetail(i, j);
            }
        });
        
        // ツールチップ表示
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const i = Math.floor(x / cellSize);
            const j = Math.floor(y / cellSize);
            
            if (i >= 0 && i < 24 && j >= 0 && j < 24) {
                this.showTooltip(e.pageX, e.pageY, i, j);
            }
        });
    }

    /**
     * 相関の強さに応じた色を取得
     */
    getHeatmapColor(correlation) {
        if (correlation > 0.7) return '#22C55E';      // 強い正の相関：緑
        if (correlation > 0.3) return '#86EFAC';      // 弱い正の相関：薄緑
        if (correlation > -0.3) return '#F3F4F6';     // 相関なし：グレー
        if (correlation > -0.7) return '#FCA5A5';     // 弱い負の相関：薄赤
        return '#EF4444';                             // 強い負の相関：赤
    }

    /**
     * パターンカードを表示
     */
    renderPatternCards() {
        const container = document.querySelector('.pattern-cards');
        
        const cardsHTML = this.patterns.map((pattern, index) => `
            <div class="pattern-card ${index === 0 ? 'highlight' : ''}" 
                 data-pattern-type="${pattern.type}">
                <span class="pattern-icon">${pattern.icon}</span>
                <h4>${pattern.name}</h4>
                <p class="pattern-description">${pattern.description}</p>
                <div class="correlation-strength">
                    <div class="strength-bar">
                        <div class="strength-fill" style="width: ${pattern.strength * 100}%"></div>
                    </div>
                    <span class="strength-value">相関の強さ: ${(pattern.strength * 100).toFixed(0)}%</span>
                </div>
                <button class="detail-btn" onclick="showPatternDetail('${pattern.type}')">
                    詳細を見る
                </button>
            </div>
        `).join('');
        
        container.innerHTML = cardsHTML;
    }

    /**
     * クリックされた相関の詳細を表示
     */
    showCorrelationDetail(i, j) {
        const detailContainer = document.getElementById('correlationDetails');
        const correlation = this.correlationMatrix[i][j];
        const questions = this.getQuestions();
        
        const detailHTML = `
            <div class="correlation-detail-card">
                <h4>質問${i + 1}と質問${j + 1}の関係</h4>
                <div class="question-pair">
                    <div class="question-item">
                        <span class="question-number">Q${i + 1}</span>
                        <p class="question-text">${questions[i].text}</p>
                        <span class="answer-value">あなたの回答: ${this.userAnswers[i]}</span>
                    </div>
                    <div class="correlation-indicator">
                        <span class="correlation-value" style="color: ${this.getHeatmapColor(correlation)}">
                            ${correlation > 0 ? '正' : '負'}の相関
                            ${Math.abs(correlation * 100).toFixed(0)}%
                        </span>
                    </div>
                    <div class="question-item">
                        <span class="question-number">Q${j + 1}</span>
                        <p class="question-text">${questions[j].text}</p>
                        <span class="answer-value">あなたの回答: ${this.userAnswers[j]}</span>
                    </div>
                </div>
                <div class="correlation-interpretation">
                    <h5>この相関が意味すること</h5>
                    <p>${this.interpretCorrelation(i, j, correlation)}</p>
                </div>
            </div>
        `;
        
        detailContainer.innerHTML = detailHTML;
        detailContainer.scrollIntoView({ behavior: 'smooth' });
    }

    /**
     * 相関の解釈を生成
     */
    interpretCorrelation(i, j, correlation) {
        const strength = Math.abs(correlation);
        const direction = correlation > 0 ? 'positive' : 'negative';
        
        // 質問のカテゴリを判定
        const categoryI = this.getQuestionCategory(i);
        const categoryJ = this.getQuestionCategory(j);
        
        if (strength > 0.7) {
            if (direction === 'positive') {
                return `${categoryI}と${categoryJ}が強く連動しています。一方が高まると、もう一方も高まる傾向があります。これはあなたの思考と行動に一貫性があることを示しています。`;
            } else {
                return `${categoryI}と${categoryJ}が相反する関係にあります。一方を重視すると、もう一方が抑制される傾向があります。これはバランスを取ろうとする心理的メカニズムの現れです。`;
            }
        } else if (strength > 0.3) {
            return `${categoryI}と${categoryJ}には緩やかな関連性があります。状況によって影響し合う可能性があります。`;
        } else {
            return `${categoryI}と${categoryJ}は独立して機能しています。それぞれが異なる側面を表しています。`;
        }
    }
}
```

## 📈 機能2: 時系列分析機能

### 2.1 画面表示イメージ

```html
<!-- 成長軌跡タブの表示 -->
<div class="temporal-analysis-container">
    <!-- タイムライン表示 -->
    <div class="timeline-view">
        <div class="timeline-header">
            <h3>あなたの成長と変化の軌跡</h3>
            <div class="time-range-selector">
                <button class="range-btn active" data-range="1month">1ヶ月</button>
                <button class="range-btn" data-range="3months">3ヶ月</button>
                <button class="range-btn" data-range="6months">6ヶ月</button>
                <button class="range-btn" data-range="1year">1年</button>
            </div>
        </div>
        
        <!-- OSスコアの推移グラフ -->
        <div class="score-evolution-chart">
            <canvas id="evolutionChart"></canvas>
        </div>
        
        <!-- 卦の変化パターン -->
        <div class="hexagram-transitions">
            <h4>易卦の変遷</h4>
            <div class="transition-flow">
                <div class="hexagram-node past">
                    <span class="date">2024/10/19</span>
                    <span class="hexagram">乾为天</span>
                    <span class="score">75</span>
                </div>
                <div class="transition-arrow">→</div>
                <div class="hexagram-node current">
                    <span class="date">2025/01/19</span>
                    <span class="hexagram">天火同人</span>
                    <span class="score">82</span>
                </div>
            </div>
        </div>
        
        <!-- 安定vs変化の分析 -->
        <div class="stability-analysis">
            <div class="stable-traits">
                <h4>💎 安定している特性</h4>
                <ul>
                    <li>創造性への志向（一貫して高い）</li>
                    <li>協調性（安定して中程度）</li>
                </ul>
            </div>
            <div class="changing-traits">
                <h4>🌊 変化している特性</h4>
                <ul>
                    <li>リーダーシップ（上昇傾向）↑</li>
                    <li>リスク回避（減少傾向）↓</li>
                </ul>
            </div>
        </div>
    </div>
</div>
```

### 2.2 実装ロジック

**新規ファイル**: `/public/js/components/tabs/TemporalAnalysisTab.js`

```javascript
/**
 * 時系列分析タブ - 成長と変化を可視化
 */
class TemporalAnalysisTab extends BaseTabView {
    constructor(tabId) {
        super(tabId);
        this.analysisHistory = [];
        this.evolutionChart = null;
        this.timeRange = '3months';
    }

    /**
     * 分析履歴を読み込み
     */
    loadAnalysisHistory() {
        const history = this.storageManager.getItem('analysisHistory') || [];
        
        // 現在の分析を追加
        const currentAnalysis = {
            timestamp: Date.now(),
            engineOS: this.analysisData.engineOS,
            interfaceOS: this.analysisData.interfaceOS,
            safeModeOS: this.analysisData.safeModeOS,
            answers: this.storageManager.getAnswers()
        };
        
        // 重複を避けて追加
        if (!this.isDuplicateAnalysis(history, currentAnalysis)) {
            history.push(currentAnalysis);
            this.storageManager.setItem('analysisHistory', history);
        }
        
        return history;
    }

    /**
     * スコアの変化を分析
     */
    analyzeScoreEvolution(history) {
        const evolution = {
            engineOS: [],
            interfaceOS: [],
            safeModeOS: []
        };
        
        history.forEach(record => {
            evolution.engineOS.push({
                x: new Date(record.timestamp),
                y: record.engineOS.score,
                hexagram: record.engineOS.hexagram.name
            });
            evolution.interfaceOS.push({
                x: new Date(record.timestamp),
                y: record.interfaceOS.score,
                hexagram: record.interfaceOS.hexagram.name
            });
            evolution.safeModeOS.push({
                x: new Date(record.timestamp),
                y: record.safeModeOS.score,
                hexagram: record.safeModeOS.hexagram.name
            });
        });
        
        return evolution;
    }

    /**
     * 推移グラフを描画
     */
    renderEvolutionChart() {
        const canvas = document.getElementById('evolutionChart');
        const ctx = canvas.getContext('2d');
        
        if (this.evolutionChart) {
            this.evolutionChart.destroy();
        }
        
        this.evolutionChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Engine OS（内的動機）',
                        data: this.evolution.engineOS,
                        borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        tension: 0.4,
                        fill: true
                    },
                    {
                        label: 'Interface OS（社会性）',
                        data: this.evolution.interfaceOS,
                        borderColor: '#10B981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: true
                    },
                    {
                        label: 'SafeMode OS（安定性）',
                        data: this.evolution.safeModeOS,
                        borderColor: '#F59E0B',
                        backgroundColor: 'rgba(245, 158, 11, 0.1)',
                        tension: 0.4,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'day',
                            displayFormats: {
                                day: 'MM/DD'
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        max: 100,
                        title: {
                            display: true,
                            text: 'スコア'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            afterLabel: function(context) {
                                const point = context.raw;
                                return `易卦: ${point.hexagram}`;
                            }
                        }
                    },
                    annotation: {
                        annotations: this.generateMilestoneAnnotations()
                    }
                },
                interaction: {
                    mode: 'index',
                    intersect: false
                }
            }
        });
    }

    /**
     * 卦の変化パターンを分析
     */
    analyzeHexagramTransitions(history) {
        const transitions = {
            engineOS: [],
            interfaceOS: [],
            safeModeOS: []
        };
        
        for (let i = 1; i < history.length; i++) {
            const prev = history[i - 1];
            const curr = history[i];
            
            // Engine OSの変化
            if (prev.engineOS.hexagram.name !== curr.engineOS.hexagram.name) {
                transitions.engineOS.push({
                    from: prev.engineOS.hexagram.name,
                    to: curr.engineOS.hexagram.name,
                    date: new Date(curr.timestamp),
                    interpretation: this.interpretTransition(
                        prev.engineOS.hexagram.name,
                        curr.engineOS.hexagram.name
                    )
                });
            }
        }
        
        return transitions;
    }

    /**
     * 変化の解釈を生成
     */
    interpretTransition(fromHexagram, toHexagram) {
        // 易経の変爻理論に基づく解釈
        const transitionMap = {
            '乾为天→天火同人': '個人の力から協働の力へ。リーダーシップが成熟し、他者との協力を重視するようになりました。',
            '坤为地→地天泰': '受容から調和へ。受け身だった姿勢が、積極的な調和創造へと発展しました。',
            // ... 他の組み合わせ
        };
        
        const key = `${fromHexagram}→${toHexagram}`;
        return transitionMap[key] || this.generateGenericTransition(fromHexagram, toHexagram);
    }

    /**
     * 安定特性と変化特性を識別
     */
    identifyStabilityPatterns(history) {
        if (history.length < 2) {
            return { stable: [], changing: [] };
        }
        
        const traits = this.extractTraits(history);
        const stable = [];
        const changing = [];
        
        Object.entries(traits).forEach(([trait, values]) => {
            const variance = this.calculateVariance(values);
            const trend = this.calculateTrend(values);
            
            if (variance < 0.1) {
                stable.push({
                    name: trait,
                    averageValue: this.average(values),
                    consistency: (1 - variance) * 100
                });
            } else {
                changing.push({
                    name: trait,
                    direction: trend > 0 ? 'up' : 'down',
                    changeRate: Math.abs(trend),
                    currentValue: values[values.length - 1]
                });
            }
        });
        
        return { stable, changing };
    }

    /**
     * マイルストーンアノテーションを生成
     */
    generateMilestoneAnnotations() {
        const annotations = [];
        
        // 重要な変化点にマーカーを追加
        this.analysisHistory.forEach((record, index) => {
            if (this.isSignificantChange(record, index)) {
                annotations.push({
                    type: 'line',
                    xMin: record.timestamp,
                    xMax: record.timestamp,
                    borderColor: 'rgba(255, 99, 132, 0.5)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    label: {
                        content: '重要な変化',
                        enabled: true,
                        position: 'top'
                    }
                });
            }
        });
        
        return annotations;
    }

    /**
     * 重要な変化かどうかを判定
     */
    isSignificantChange(record, index) {
        if (index === 0) return false;
        
        const prev = this.analysisHistory[index - 1];
        const scoreDiff = Math.abs(record.engineOS.score - prev.engineOS.score) +
                         Math.abs(record.interfaceOS.score - prev.interfaceOS.score) +
                         Math.abs(record.safeModeOS.score - prev.safeModeOS.score);
        
        return scoreDiff > 15; // 合計15ポイント以上の変化
    }
}
```

## 🎭 機能3: 爻位による深層分析

### 3.1 画面表示イメージ

```html
<!-- 発展段階タブの表示 -->
<div class="yao-analysis-container">
    <!-- 6段階の発展段階 -->
    <div class="development-stages">
        <h3>あなたの発展段階</h3>
        
        <!-- ビジュアルな段階表示 -->
        <div class="stage-pyramid">
            <div class="stage level-6 ${activeStage === 6 ? 'active' : ''}" data-stage="6">
                <div class="stage-content">
                    <span class="stage-number">第六爻</span>
                    <span class="stage-name">究極</span>
                    <span class="stage-score">${stages[5].score}%</span>
                </div>
                <div class="stage-tooltip">
                    完成された状態、マスターレベル
                </div>
            </div>
            
            <div class="stage level-5 ${activeStage === 5 ? 'active' : ''}" data-stage="5">
                <div class="stage-content">
                    <span class="stage-number">第五爻</span>
                    <span class="stage-name">統率</span>
                    <span class="stage-score">${stages[4].score}%</span>
                </div>
            </div>
            
            <div class="stage level-4 ${activeStage === 4 ? 'active' : ''}" data-stage="4">
                <div class="stage-content">
                    <span class="stage-number">第四爻</span>
                    <span class="stage-name">社会</span>
                    <span class="stage-score">${stages[3].score}%</span>
                </div>
            </div>
            
            <div class="stage level-3 ${activeStage === 3 ? 'active' : ''}" data-stage="3">
                <div class="stage-content">
                    <span class="stage-number">第三爻</span>
                    <span class="stage-name">移行</span>
                    <span class="stage-score">${stages[2].score}%</span>
                </div>
            </div>
            
            <div class="stage level-2 ${activeStage === 2 ? 'active' : ''}" data-stage="2">
                <div class="stage-content">
                    <span class="stage-number">第二爻</span>
                    <span class="stage-name">内的</span>
                    <span class="stage-score">${stages[1].score}%</span>
                </div>
            </div>
            
            <div class="stage level-1 ${activeStage === 1 ? 'active' : ''}" data-stage="1">
                <div class="stage-content">
                    <span class="stage-number">初爻</span>
                    <span class="stage-name">潜在</span>
                    <span class="stage-score">${stages[0].score}%</span>
                </div>
            </div>
        </div>
        
        <!-- 現在の段階の詳細 -->
        <div class="current-stage-detail">
            <h4>現在あなたは「${currentStage.name}」の段階にいます</h4>
            <p class="stage-description">${currentStage.description}</p>
            
            <div class="stage-characteristics">
                <div class="characteristic-card">
                    <h5>この段階の特徴</h5>
                    <ul>
                        ${currentStage.characteristics.map(c => `<li>${c}</li>`).join('')}
                    </ul>
                </div>
                
                <div class="characteristic-card">
                    <h5>次の段階へ進むには</h5>
                    <ul>
                        ${currentStage.nextStepHints.map(h => `<li>${h}</li>`).join('')}
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- 各OSごとの爻分析 -->
        <div class="os-yao-analysis">
            <div class="os-yao-card">
                <h4>Engine OS - 内的動機の発展</h4>
                <div class="yao-distribution">
                    ${this.renderYaoDistribution('engineOS')}
                </div>
            </div>
            
            <div class="os-yao-card">
                <h4>Interface OS - 社会性の発展</h4>
                <div class="yao-distribution">
                    ${this.renderYaoDistribution('interfaceOS')}
                </div>
            </div>
            
            <div class="os-yao-card">
                <h4>SafeMode OS - 安定性の発展</h4>
                <div class="yao-distribution">
                    ${this.renderYaoDistribution('safeModeOS')}
                </div>
            </div>
        </div>
    </div>
</div>
```

### 3.2 実装ロジック

**新規ファイル**: `/public/js/components/tabs/YaoAnalysisTab.js`

```javascript
/**
 * 爻位分析タブ - 6段階の発展段階を可視化
 */
class YaoAnalysisTab extends BaseTabView {
    constructor(tabId) {
        super(tabId);
        this.stages = [];
        this.currentStage = null;
        this.hexagramExtractor = new HexagramExtractor();
    }

    /**
     * 爻位による段階分析
     */
    analyzeYaoStages(osData) {
        const stages = [];
        
        // 各OSのH384データを取得
        const engineData = this.hexagramExtractor.getHexagramDataByName(
            osData.engineOS.hexagram.name
        );
        const interfaceData = this.hexagramExtractor.getHexagramDataByName(
            osData.interfaceOS.hexagram.name
        );
        const safeModeData = this.hexagramExtractor.getHexagramDataByName(
            osData.safeModeOS.hexagram.name
        );
        
        // 6つの爻それぞれを分析
        for (let i = 0; i < 6; i++) {
            const stage = {
                position: i + 1,
                name: this.getStageName(i),
                engineScore: this.extractYaoScore(engineData, i),
                interfaceScore: this.extractYaoScore(interfaceData, i),
                safeModeScore: this.extractYaoScore(safeModeData, i),
                keywords: this.extractYaoKeywords(engineData, interfaceData, safeModeData, i),
                interpretation: this.generateStageInterpretation(i)
            };
            
            // 総合スコアを計算
            stage.totalScore = (stage.engineScore + stage.interfaceScore + stage.safeModeScore) / 3;
            stages.push(stage);
        }
        
        return stages;
    }

    /**
     * 段階の名前を取得
     */
    getStageName(position) {
        const names = [
            '潜在的資質',  // 初爻
            '内的活動',    // 二爻
            '移行期',      // 三爻
            '社会的位置',  // 四爻
            '統率力',      // 五爻
            '究極の境地'   // 上爻
        ];
        return names[position];
    }

    /**
     * 爻のスコアを抽出
     */
    extractYaoScore(hexagramData, position) {
        if (!hexagramData || hexagramData.length <= position) {
            return 50; // デフォルト値
        }
        
        const yao = hexagramData[position];
        // スコアフィールドがある場合はそれを使用
        if (yao['スコア']) {
            return yao['スコア'];
        }
        
        // なければキーワードの数や重要度から推定
        const keywords = (yao['キーワード'] || '').split('・');
        return Math.min(100, 40 + keywords.length * 10);
    }

    /**
     * 現在の発展段階を特定
     */
    identifyCurrentStage(stages, userAnswers) {
        // ユーザーの回答パターンから最も活性化している段階を特定
        let maxScore = 0;
        let currentStage = null;
        
        stages.forEach((stage, index) => {
            // 回答パターンとの相関を計算
            const correlation = this.calculateStageCorrelation(stage, userAnswers);
            const weightedScore = stage.totalScore * correlation;
            
            if (weightedScore > maxScore) {
                maxScore = weightedScore;
                currentStage = {
                    ...stage,
                    index: index,
                    dominance: weightedScore
                };
            }
        });
        
        return currentStage;
    }

    /**
     * ピラミッド型の段階表示を生成
     */
    renderStagePyramid() {
        const container = document.querySelector('.stage-pyramid');
        
        const pyramidHTML = this.stages.reverse().map((stage, index) => {
            const level = 6 - index;
            const isActive = this.currentStage && this.currentStage.position === stage.position;
            const width = 50 + (index * 15); // 上に行くほど狭く
            
            return `
                <div class="stage level-${level} ${isActive ? 'active' : ''}" 
                     data-stage="${stage.position}"
                     style="width: ${width}%">
                    <div class="stage-content">
                        <span class="stage-number">第${this.toChineseNumber(stage.position)}爻</span>
                        <span class="stage-name">${stage.name}</span>
                        <div class="stage-score-bar">
                            <div class="score-fill" style="width: ${stage.totalScore}%"></div>
                            <span class="score-text">${Math.round(stage.totalScore)}%</span>
                        </div>
                    </div>
                    <div class="stage-hover-detail">
                        <h5>${stage.name}の詳細</h5>
                        <p>${stage.interpretation}</p>
                        <div class="stage-keywords">
                            ${stage.keywords.map(kw => `<span class="keyword">${kw}</span>`).join('')}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        container.innerHTML = pyramidHTML;
        
        // インタラクティブ機能を追加
        this.addPyramidInteractions();
    }

    /**
     * 各OSの爻分布を可視化
     */
    renderYaoDistribution(osType) {
        const osData = this.analysisData[osType];
        const hexagramData = this.hexagramExtractor.getHexagramDataByName(
            osData.hexagram.name
        );
        
        // 横棒グラフ形式で爻ごとのエネルギー分布を表示
        const distributionHTML = `
            <div class="yao-bars">
                ${hexagramData.map((yao, index) => {
                    const score = this.extractYaoScore([yao], 0);
                    const isYang = this.isYangYao(osData.hexagram.binary, index);
                    
                    return `
                        <div class="yao-bar-container">
                            <span class="yao-label">
                                ${this.toChineseNumber(index + 1)}爻
                                <span class="yao-type">${isYang ? '陽' : '陰'}</span>
                            </span>
                            <div class="yao-bar">
                                <div class="yao-fill ${isYang ? 'yang' : 'yin'}" 
                                     style="width: ${score}%"></div>
                            </div>
                            <span class="yao-score">${score}%</span>
                            <div class="yao-keywords">
                                ${(yao['キーワード'] || '').split('・').slice(0, 2).join('・')}
                            </div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
        
        return distributionHTML;
    }

    /**
     * 段階の解釈を生成
     */
    generateStageInterpretation(position) {
        const interpretations = [
            // 初爻
            'あなたの最も基礎的な資質。まだ表面化していない潜在能力を表します。この段階では、内なる可能性が眠っています。',
            // 二爻
            '内面で活発に働いている要素。自己認識と内的な成長が起きている段階です。',
            // 三爻
            '内から外へ向かう移行期。内面の資質が外界との接触を始める重要な転換点です。',
            // 四爻
            '社会的な立場や役割。他者との関係性の中で自分の位置を確立する段階です。',
            // 五爻
            'リーダーシップと影響力。成熟した能力を発揮し、周囲を導く段階です。',
            // 上爻
            '究極の到達点。その領域における完成形であり、次の循環への準備段階でもあります。'
        ];
        
        return interpretations[position];
    }

    /**
     * 次の段階への発展ヒントを生成
     */
    generateDevelopmentPath(currentStage, stages) {
        const current = currentStage.position;
        const next = Math.min(current + 1, 6);
        
        if (current === 6) {
            return {
                message: 'あなたは既に最高段階に到達しています',
                hints: ['この境地を維持し、深めていく', '他の領域での成長に目を向ける', '得た知恵を他者と共有する']
            };
        }
        
        const nextStage = stages[next - 1];
        const gap = nextStage.totalScore - currentStage.totalScore;
        
        return {
            message: `次は「${nextStage.name}」の段階です`,
            hints: this.generateTransitionHints(current, next, gap),
            requiredGrowth: Math.max(0, gap),
            estimatedTime: this.estimateGrowthTime(gap)
        };
    }

    /**
     * 数字を漢数字に変換
     */
    toChineseNumber(num) {
        const numbers = ['初', '二', '三', '四', '五', '上'];
        return numbers[num - 1] || num;
    }

    /**
     * 陽爻か陰爻かを判定
     */
    isYangYao(binary, position) {
        // binaryは6桁の2進数文字列（例: "111111"）
        return binary && binary[5 - position] === '1';
    }

    /**
     * インタラクティブ機能を追加
     */
    addPyramidInteractions() {
        document.querySelectorAll('.stage').forEach(stage => {
            stage.addEventListener('click', (e) => {
                const stageNum = parseInt(e.currentTarget.dataset.stage);
                this.showStageDetail(stageNum);
            });
            
            stage.addEventListener('mouseenter', (e) => {
                this.highlightRelatedElements(e.currentTarget.dataset.stage);
            });
            
            stage.addEventListener('mouseleave', () => {
                this.clearHighlights();
            });
        });
    }

    /**
     * 段階の詳細を表示
     */
    showStageDetail(stageNumber) {
        const stage = this.stages.find(s => s.position === stageNumber);
        const detailContainer = document.querySelector('.current-stage-detail');
        
        const detailHTML = `
            <h4>${stage.name}の詳細分析</h4>
            <div class="stage-detail-content">
                <div class="detail-section">
                    <h5>この段階の意味</h5>
                    <p>${stage.interpretation}</p>
                </div>
                
                <div class="detail-section">
                    <h5>3つのOSでの現れ方</h5>
                    <ul>
                        <li>Engine OS: ${stage.engineScore}% - 内的な${stage.name}のエネルギー</li>
                        <li>Interface OS: ${stage.interfaceScore}% - 社会的な${stage.name}の表現</li>
                        <li>SafeMode OS: ${stage.safeModeScore}% - 安定面での${stage.name}の働き</li>
                    </ul>
                </div>
                
                <div class="detail-section">
                    <h5>関連キーワード</h5>
                    <div class="keyword-cloud">
                        ${stage.keywords.map(kw => 
                            `<span class="keyword-tag">${kw}</span>`
                        ).join('')}
                    </div>
                </div>
            </div>
        `;
        
        detailContainer.innerHTML = detailHTML;
        detailContainer.scrollIntoView({ behavior: 'smooth' });
    }
}
```

## 🎨 CSS追加

**ファイル**: `/public/css/advanced-analysis.css`

```css
/* 相関マップのスタイル */
.correlation-map-container {
    padding: 20px;
}

.correlation-heatmap {
    position: relative;
    margin: 20px 0;
}

#correlationCanvas {
    border: 1px solid #E5E7EB;
    border-radius: 8px;
    cursor: crosshair;
}

.correlation-legend {
    display: flex;
    justify-content: space-around;
    margin-top: 10px;
    font-size: 12px;
}

.strong-positive { color: #22C55E; }
.weak-positive { color: #86EFAC; }
.neutral { color: #9CA3AF; }
.weak-negative { color: #FCA5A5; }
.strong-negative { color: #EF4444; }

.pattern-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.pattern-card {
    background: white;
    border: 1px solid #E5E7EB;
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s;
}

.pattern-card.highlight {
    border-color: #3B82F6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.pattern-icon {
    font-size: 32px;
    display: block;
    margin-bottom: 10px;
}

.correlation-strength {
    margin-top: 15px;
}

.strength-bar {
    height: 8px;
    background: #F3F4F6;
    border-radius: 4px;
    overflow: hidden;
}

.strength-fill {
    height: 100%;
    background: linear-gradient(90deg, #3B82F6, #8B5CF6);
    transition: width 0.3s;
}

/* 時系列分析のスタイル */
.timeline-view {
    padding: 20px;
}

.time-range-selector {
    display: flex;
    gap: 10px;
    margin: 20px 0;
}

.range-btn {
    padding: 8px 16px;
    background: white;
    border: 1px solid #E5E7EB;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
}

.range-btn.active {
    background: #3B82F6;
    color: white;
    border-color: #3B82F6;
}

.score-evolution-chart {
    height: 400px;
    margin: 30px 0;
}

.hexagram-transitions {
    margin: 30px 0;
}

.transition-flow {
    display: flex;
    align-items: center;
    gap: 20px;
    padding: 20px;
    background: #F9FAFB;
    border-radius: 12px;
}

.hexagram-node {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    background: white;
    border: 2px solid #E5E7EB;
    border-radius: 8px;
}

.hexagram-node.current {
    border-color: #3B82F6;
    background: #EFF6FF;
}

.transition-arrow {
    font-size: 24px;
    color: #6B7280;
}

.stability-analysis {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 30px 0;
}

.stable-traits,
.changing-traits {
    padding: 20px;
    background: white;
    border: 1px solid #E5E7EB;
    border-radius: 12px;
}

.stable-traits h4 {
    color: #059669;
}

.changing-traits h4 {
    color: #DC2626;
}

/* 爻位分析のスタイル */
.stage-pyramid {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 40px 0;
    position: relative;
}

.stage {
    margin: 5px 0;
    padding: 20px;
    background: linear-gradient(135deg, #F3F4F6, #E5E7EB);
    border: 2px solid #D1D5DB;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
}

.stage.active {
    background: linear-gradient(135deg, #DBEAFE, #BFDBFE);
    border-color: #3B82F6;
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(59, 130, 246, 0.2);
}

.stage:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.stage-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 20px;
}

.stage-number {
    font-weight: 600;
    color: #374151;
}

.stage-name {
    font-size: 18px;
    font-weight: 500;
    color: #1F2937;
}

.stage-score-bar {
    width: 100px;
    height: 20px;
    background: white;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
}

.score-fill {
    height: 100%;
    background: linear-gradient(90deg, #3B82F6, #8B5CF6);
}

.score-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    font-weight: 600;
}

.stage-hover-detail {
    display: none;
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: white;
    border: 1px solid #D1D5DB;
    border-radius: 8px;
    padding: 15px;
    margin-top: 10px;
    width: 300px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.stage:hover .stage-hover-detail {
    display: block;
}

.yao-distribution {
    margin: 20px 0;
}

.yao-bar-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
}

.yao-label {
    width: 80px;
    font-size: 14px;
    font-weight: 500;
}

.yao-type {
    font-size: 12px;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 5px;
}

.yao-type:contains('陽') {
    background: #FEF3C7;
    color: #92400E;
}

.yao-type:contains('陰') {
    background: #E0E7FF;
    color: #3730A3;
}

.yao-bar {
    flex: 1;
    height: 24px;
    background: #F3F4F6;
    border-radius: 12px;
    overflow: hidden;
}

.yao-fill {
    height: 100%;
    transition: width 0.5s ease;
}

.yao-fill.yang {
    background: linear-gradient(90deg, #FCD34D, #F59E0B);
}

.yao-fill.yin {
    background: linear-gradient(90deg, #93C5FD, #3B82F6);
}

.yao-score {
    width: 50px;
    text-align: right;
    font-weight: 600;
}

.yao-keywords {
    font-size: 12px;
    color: #6B7280;
    margin-left: 10px;
}

/* レスポンシブ対応 */
@media (max-width: 768px) {
    .pattern-cards {
        grid-template-columns: 1fr;
    }
    
    .stability-analysis {
        grid-template-columns: 1fr;
    }
    
    .stage-pyramid {
        padding: 0 10px;
    }
    
    .stage {
        width: 100% !important;
    }
}
```

## 📝 実装手順

### Step 1: タブナビゲーションの更新
**ファイル**: `/public/results.html`

```html
<!-- 既存のタブに新しいタブを追加 -->
<div class="tab-navigation">
    <button class="tab-btn active" data-tab="basic">基本結果</button>
    <button class="tab-btn" data-tab="detailed">詳細分析</button>
    <button class="tab-btn" data-tab="correlation">相関マップ</button> <!-- 新規 -->
    <button class="tab-btn" data-tab="temporal">成長軌跡</button> <!-- 新規 -->
    <button class="tab-btn" data-tab="yao">発展段階</button> <!-- 新規 -->
    <button class="tab-btn" data-tab="insights">洞察</button>
    <button class="tab-btn" data-tab="scenarios">シナリオ</button>
    <button class="tab-btn" data-tab="export">エクスポート</button>
</div>
```

### Step 2: タブクラスの登録
**ファイル**: `/public/js/pages/results.js`

```javascript
// 新しいタブクラスをインポート
import CorrelationMapTab from '../components/tabs/CorrelationMapTab.js';
import TemporalAnalysisTab from '../components/tabs/TemporalAnalysisTab.js';
import YaoAnalysisTab from '../components/tabs/YaoAnalysisTab.js';

// タブマネージャーに登録
this.tabs = {
    basic: new BasicResultsTab('basic'),
    detailed: new DetailedAnalysisTab('detailed'),
    correlation: new CorrelationMapTab('correlation'), // 新規
    temporal: new TemporalAnalysisTab('temporal'),     // 新規
    yao: new YaoAnalysisTab('yao'),                    // 新規
    insights: new InsightsTab('insights'),
    scenarios: new ScenariosTab('scenarios'),
    export: new ExportTab('export')
};
```

## 📋 実装チェックリスト

### 必須実装
- [ ] CorrelationMapTab.jsの作成
- [ ] TemporalAnalysisTab.jsの作成
- [ ] YaoAnalysisTab.jsの作成
- [ ] advanced-analysis.cssの作成
- [ ] results.htmlのタブナビゲーション更新
- [ ] results.jsでのタブ登録

### 機能確認
- [ ] 相関ヒートマップが正しく描画される
- [ ] パターンカードが表示される
- [ ] 時系列グラフが動作する
- [ ] 爻位ピラミッドが表示される
- [ ] インタラクティブ機能が動作する

### データ連携
- [ ] H384データベースとの連携
- [ ] StorageManagerからの履歴取得
- [ ] Chart.jsの動作確認

## 🎯 期待される効果

### ユーザー体験の向上
1. **深い自己理解** - 回答の相関から隠れた傾向を発見
2. **成長の可視化** - 時系列で自分の変化を確認
3. **発展段階の把握** - 現在位置と次の目標が明確に

### 差別化要因
- 単なる診断から「**深層心理の可視化システム**」へ
- データドリブンで科学的な分析
- インタラクティブで探索的な体験

これにより、HAQEIは「**あなたの心理を多角的に解明する最先端の分析ツール**」として完成します。