# ğŸ§ª 384çˆ»ã‚·ã‚¹ãƒ†ãƒ æ–‡è„ˆç†è§£æ©Ÿèƒ½ ãƒ†ã‚¹ãƒˆè¨ˆç”»æ›¸ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆç‰ˆï¼‰

**æ–‡æ›¸ç•ªå·**: TP-384-003  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 3.0  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ28æ—¥  
**ä½œæˆè€…**: HAQEIé–‹ç™ºãƒãƒ¼ãƒ   
**æ‰¿èªè€…**: [æœªæ‰¿èª]  

---

## 1. ãƒ†ã‚¹ãƒˆæ¦‚è¦

### 1.1 ãƒ†ã‚¹ãƒˆç›®çš„
SQLiteã€MongoDBã€Redisã€InfluxDBã‚’çµ±åˆã—ãŸåŒ…æ‹¬çš„ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚‹çœŸã®æ–‡è„ˆç†è§£æ©Ÿèƒ½ã®å“è³ªä¿è¨¼ã€‚MeCabå½¢æ…‹ç´ è§£æã€WordNeté¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°ã€å­¦ç¿’æ©Ÿèƒ½ã‚’å«ã‚€é«˜åº¦AIåˆ†æã‚·ã‚¹ãƒ†ãƒ ã®å…¨é¢æ¤œè¨¼ã€‚

### 1.2 ãƒ†ã‚¹ãƒˆç¯„å›²
| ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª | æ¤œè¨¼å†…å®¹ | å„ªå…ˆåº¦ | DBå¯¾è±¡ |
|-------------|---------|--------|--------|
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ | 4DBæ¥ç¶šãƒ»ã‚¯ã‚¨ãƒªãƒ»æ•´åˆæ€§ | å¿…é ˆ | SQLite/MongoDB/Redis/InfluxDB |
| å½¢æ…‹ç´ è§£æã‚·ã‚¹ãƒ†ãƒ  | MeCab + IPADicè§£æç²¾åº¦ | å¿…é ˆ | SQLite |
| é¡ç¾©èªãƒãƒƒãƒãƒ³ã‚° | WordNet-jpé¡ä¼¼åº¦è¨ˆç®— | å¿…é ˆ | SQLite |
| ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚° | è¤‡åˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç²¾åº¦ | å¿…é ˆ | å…¨DB |
| å­¦ç¿’ãƒ»ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ | å‹•çš„é‡ã¿èª¿æ•´æ©Ÿèƒ½ | å¿…é ˆ | MongoDB |
| ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ€§èƒ½ | Redisã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ | å¿…é ˆ | Redis |
| æ€§èƒ½ç›£è¦– | ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ãƒ»åˆ†æ | æ¨å¥¨ | InfluxDB |
| ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ | æš—å·åŒ–ãƒ»ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ | å¿…é ˆ | å…¨DB |

### 1.3 ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç’°å¢ƒ
```yaml
database_environment:
  sqlite:
    path: "./dbs/main.db"
    version: "3.40+"
    encryption: "SQLCipher AES-256"
  
  mongodb:
    uri: "mongodb://localhost:27017/haqei"
    version: "6.0+"
    collections: ["feedback", "learning_stats", "analysis_logs"]
  
  redis:
    uri: "redis://localhost:6379"
    version: "7.0+"
    memory: "50MB"
  
  influxdb:
    uri: "http://localhost:8086"
    version: "2.6+"
    bucket: "haqei_metrics"

natural_language_processing:
  mecab:
    dictionary: "./data/ipadic"
    custom_dict: "./data/yijing_terms.csv"
  
  wordnet:
    version: "WordNet-jp 1.1"
    database: "./dbs/synonyms.db"
```

---

## 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆãƒ†ã‚¹ãƒˆ

### 2.1 SQLiteçµ±åˆãƒ†ã‚¹ãƒˆ

#### TC-DB-001: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ
```javascript
describe('SQLite Database Initialization', () => {
    let dbManager;
    
    beforeAll(async () => {
        dbManager = new SQLiteManager('./dbs/test_main.db');
    });
    
    test('å½¢æ…‹ç´ è§£æè¾æ›¸ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ', async () => {
        const result = await dbManager.execute(`
            CREATE TABLE IF NOT EXISTS morphology_dict (
                id INTEGER PRIMARY KEY,
                word TEXT NOT NULL,
                reading TEXT,
                part_of_speech TEXT,
                semantic_category TEXT,
                INDEX idx_word (word)
            )
        `);
        
        expect(result).toBeDefined();
        
        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¢ºèª
        const indexes = await dbManager.getIndexes('morphology_dict');
        expect(indexes.some(idx => idx.name === 'idx_word')).toBe(true);
    });
    
    test('é¡ç¾©èªè¾æ›¸ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ', async () => {
        const result = await dbManager.execute(`
            CREATE TABLE IF NOT EXISTS synonym_dict (
                id INTEGER PRIMARY KEY,
                word TEXT NOT NULL,
                synonym TEXT NOT NULL,
                similarity_score REAL,
                INDEX idx_word_synonym (word, synonym)
            )
        `);
        
        expect(result).toBeDefined();
    });
    
    test('384çˆ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è¾æ›¸ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ', async () => {
        const result = await dbManager.execute(`
            CREATE TABLE IF NOT EXISTS line_keywords (
                line_id INTEGER,
                keyword TEXT,
                weight REAL DEFAULT 1.0,
                category TEXT,
                PRIMARY KEY (line_id, keyword)
            )
        `);
        
        expect(result).toBeDefined();
    });
});
```

#### TC-DB-002: ãƒ‡ãƒ¼ã‚¿å°å…¥ãƒ»æ•´åˆæ€§ãƒ†ã‚¹ãƒˆ
```javascript
test('IPADicè¾æ›¸ãƒ‡ãƒ¼ã‚¿å°å…¥', async () => {
    // IPADic CSVèª­ã¿è¾¼ã¿
    const ipadicData = await fs.readFile('./data/ipadic/mecab-ipadic.csv', 'utf-8');
    const lines = ipadicData.split('\n').filter(line => line.trim());
    
    // ãƒãƒƒãƒæŒ¿å…¥ãƒ†ã‚¹ãƒˆ
    const batchSize = 1000;
    let insertedCount = 0;
    
    for (let i = 0; i < lines.length; i += batchSize) {
        const batch = lines.slice(i, i + batchSize);
        const values = batch.map(line => {
            const fields = line.split(',');
            return {
                word: fields[0],
                reading: fields[7],
                part_of_speech: fields[1],
                semantic_category: fields[2]
            };
        });
        
        await dbManager.insertBatch('morphology_dict', values);
        insertedCount += batch.length;
    }
    
    console.log(`IPADicå°å…¥å®Œäº†: ${insertedCount}ä»¶`);
    
    // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèª
    const count = await dbManager.count('morphology_dict');
    expect(count).toBeGreaterThan(50000); // IPADICæœ€å°ã‚¨ãƒ³ãƒˆãƒªæ•°
    
    // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç¢ºèª
    const sample = await dbManager.findOne('morphology_dict', { word: 'æ˜“çµŒ' });
    expect(sample).toBeDefined();
    expect(sample.reading).toBeDefined();
});
```

### 2.2 MongoDBçµ±åˆãƒ†ã‚¹ãƒˆ

#### TC-DB-003: MongoDBã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ»ã‚¹ã‚­ãƒ¼ãƒãƒ†ã‚¹ãƒˆ
```javascript
describe('MongoDB Integration', () => {
    let mongoManager;
    
    beforeAll(async () => {
        mongoManager = new MongoManager('mongodb://localhost:27017/haqei_test');
        await mongoManager.connect();
    });
    
    test('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆ', async () => {
        const collection = mongoManager.getCollection('user_feedback');
        
        // ã‚¹ã‚­ãƒ¼ãƒãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        await mongoManager.createCollection('user_feedback', {
            validator: {
                $jsonSchema: {
                    bsonType: "object",
                    required: ["timestamp", "user_input", "predicted_line", "user_feedback"],
                    properties: {
                        timestamp: { bsonType: "date" },
                        user_input: { bsonType: "string", minLength: 1 },
                        predicted_line: { bsonType: "int", minimum: 1, maximum: 384 },
                        user_feedback: {
                            bsonType: "object",
                            required: ["correct_line", "accuracy_rating"],
                            properties: {
                                correct_line: { bsonType: "int", minimum: 1, maximum: 384 },
                                accuracy_rating: { bsonType: "int", minimum: 1, maximum: 5 }
                            }
                        }
                    }
                }
            }
        });
        
        expect(collection).toBeDefined();
    });
    
    test('ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿æŒ¿å…¥ãƒ»æ¤œç´¢ãƒ†ã‚¹ãƒˆ', async () => {
        const testFeedback = {
            timestamp: new Date(),
            user_input: "ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã‚’ç™ºæ®ã—ãŸã„",
            predicted_line: 5,
            user_feedback: {
                correct_line: 5,
                accuracy_rating: 5
            },
            analysis_data: {
                extracted_keywords: ["ãƒªãƒ¼ãƒ€ãƒ¼", "ç™ºæ®"],
                morphology_result: { /* MeCabçµæœ */ },
                similarity_scores: { /* WordNetçµæœ */ }
            }
        };
        
        const result = await mongoManager.insertOne('user_feedback', testFeedback);
        expect(result.insertedId).toBeDefined();
        
        // æ¤œç´¢ãƒ†ã‚¹ãƒˆ
        const found = await mongoManager.findOne('user_feedback', { 
            "user_feedback.correct_line": 5 
        });
        expect(found).toBeDefined();
        expect(found.user_input).toBe("ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã‚’ç™ºæ®ã—ãŸã„");
    });
});
```

### 2.3 Redisçµ±åˆãƒ†ã‚¹ãƒˆ

#### TC-DB-004: Redis ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
```javascript
describe('Redis Cache Integration', () => {
    let redisManager;
    
    beforeAll(async () => {
        redisManager = new RedisManager('redis://localhost:6379');
        await redisManager.connect();
    });
    
    test('åˆ†æçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½', async () => {
        const inputText = "æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å§‹ã‚ã‚‹";
        const textHash = crypto.createHash('sha256').update(inputText).digest('hex').substring(0, 16);
        const cacheKey = `analysis:${textHash}:result`;
        
        // åˆ†æçµæœã®ãƒ¢ãƒƒã‚¯
        const analysisResult = {
            line_384_id: 1,
            confidence_score: 0.85,
            morphology: ["æ–°ã—ã„", "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ", "å§‹ã‚ã‚‹"],
            synonyms_matched: ["é–‹å§‹", "ç™ºç«¯", "å‰µå§‹"],
            processing_time: 3.2
        };
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
        await redisManager.setex(cacheKey, 3600, JSON.stringify(analysisResult));
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥å–å¾—ãƒ»æ¤œè¨¼
        const cached = await redisManager.get(cacheKey);
        expect(cached).toBeDefined();
        
        const parsedResult = JSON.parse(cached);
        expect(parsedResult.line_384_id).toBe(1);
        expect(parsedResult.confidence_score).toBe(0.85);
        
        // TTLç¢ºèª
        const ttl = await redisManager.ttl(cacheKey);
        expect(ttl).toBeGreaterThan(3500);
        expect(ttl).toBeLessThanOrEqual(3600);
    });
    
    test('å½¢æ…‹ç´ è§£æçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥', async () => {
        const text = "æ˜“çµŒã®çŸ¥æµã‚’æ´»ç”¨ã™ã‚‹";
        const textHash = crypto.createHash('sha256').update(text).digest('hex').substring(0, 16);
        const cacheKey = `morphology:${textHash}`;
        
        const morphologyResult = {
            tokens: [
                { surface: "æ˜“çµŒ", pos: "åè©", reading: "ã‚¨ã‚­ã‚±ã‚¤" },
                { surface: "ã®", pos: "åŠ©è©", reading: "ãƒ" },
                { surface: "çŸ¥æµ", pos: "åè©", reading: "ãƒã‚¨" },
                { surface: "ã‚’", pos: "åŠ©è©", reading: "ãƒ²" },
                { surface: "æ´»ç”¨", pos: "å‹•è©", reading: "ã‚«ãƒ„ãƒ¨ã‚¦" },
                { surface: "ã™ã‚‹", pos: "å‹•è©", reading: "ã‚¹ãƒ«" }
            ],
            keywords: ["æ˜“çµŒ", "çŸ¥æµ", "æ´»ç”¨"],
            semantic_categories: ["å“²å­¦", "å­¦å•", "è¡Œå‹•"]
        };
        
        // 24æ™‚é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        await redisManager.setex(cacheKey, 86400, JSON.stringify(morphologyResult));
        
        const cached = await redisManager.get(cacheKey);
        const parsed = JSON.parse(cached);
        
        expect(parsed.tokens).toHaveLength(6);
        expect(parsed.keywords).toContain("æ˜“çµŒ");
        expect(parsed.semantic_categories).toContain("å“²å­¦");
    });
});
```

---

## 3. è‡ªç„¶è¨€èªå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ

### 3.1 MeCabå½¢æ…‹ç´ è§£æãƒ†ã‚¹ãƒˆ

#### TC-NLP-001: MeCabçµ±åˆãƒ»ç²¾åº¦ãƒ†ã‚¹ãƒˆ
```javascript
describe('MeCab Morphological Analysis', () => {
    let mecabAnalyzer;
    
    beforeAll(async () => {
        mecabAnalyzer = new AdvancedMeCabAnalyzer('./data/ipadic');
        await mecabAnalyzer.initialize();
    });
    
    test('æ—¥æœ¬èªæ–‡ç« ã®å½¢æ…‹ç´ è§£æ', async () => {
        const testText = "æ˜“çµŒã®å…­åå››å¦ã‹ã‚‰äººç”Ÿã®çŸ¥æµã‚’å­¦ã¶";
        const result = await mecabAnalyzer.analyze(testText);
        
        // åŸºæœ¬æ§‹é€ ç¢ºèª
        expect(result).toHaveProperty('tokens');
        expect(result).toHaveProperty('keywords');
        expect(result).toHaveProperty('semantic_categories');
        
        // ãƒˆãƒ¼ã‚¯ãƒ³è§£æçµæœç¢ºèª
        expect(result.tokens).toBeDefined();
        expect(result.tokens.length).toBeGreaterThan(5);
        
        // æ˜“çµŒé–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡ºç¢ºèª
        expect(result.keywords).toContain("æ˜“çµŒ");
        expect(result.keywords).toContain("å…­åå››å¦");
        expect(result.keywords).toContain("çŸ¥æµ");
        
        // æ„å‘³ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ†é¡ç¢ºèª
        expect(result.semantic_categories).toContain("å“²å­¦");
        expect(result.semantic_categories).toContain("å­¦å•");
    });
    
    test('å°‚é–€ç”¨èªè¾æ›¸çµ±åˆãƒ†ã‚¹ãƒˆ', async () => {
        // æ˜“çµŒå°‚é–€ç”¨èªãƒ†ã‚¹ãƒˆ
        const yijingTerms = [
            "ä¹¾ç‚ºå¤©", "å¤ç‚ºåœ°", "æ°´é›·å±¯", "å±±æ°´è’™",
            "é™°çˆ»", "é™½çˆ»", "ä¸Šå¦", "ä¸‹å¦",
            "çˆ»è¾", "å¦è¾", "å½–è¾", "è±¡è¾"
        ];
        
        for (const term of yijingTerms) {
            const result = await mecabAnalyzer.analyze(term);
            
            // å°‚é–€ç”¨èªã¨ã—ã¦èªè­˜ã•ã‚Œã¦ã„ã‚‹ã‹
            const termToken = result.tokens.find(token => token.surface === term);
            if (termToken) {
                expect(termToken.pos).toContain("åè©");
                expect(result.semantic_categories).toContain("æ˜“çµŒ");
            }
            
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨ã—ã¦æŠ½å‡ºã•ã‚Œã¦ã„ã‚‹ã‹
            expect(result.keywords).toContain(term);
        }
    });
});
```

### 3.2 WordNeté¡ç¾©èªã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ

#### TC-NLP-002: WordNet-jpçµ±åˆãƒ»é¡ä¼¼åº¦è¨ˆç®—ãƒ†ã‚¹ãƒˆ
```javascript
describe('WordNet Synonym Matching', () => {
    let synonymMatcher;
    
    beforeAll(async () => {
        synonymMatcher = new SynonymMatcher();
        await synonymMatcher.initialize();
    });
    
    test('é¡ç¾©èªé¡ä¼¼åº¦è¨ˆç®—ï¼ˆWu-Palmerï¼‰', async () => {
        const testPairs = [
            { word1: "ãƒªãƒ¼ãƒ€ãƒ¼", word2: "æŒ‡å°è€…", expectedSim: 0.8 },
            { word1: "å§‹ã¾ã‚Š", word2: "é–‹å§‹", expectedSim: 0.7 },
            { word1: "å›°é›£", word2: "å•é¡Œ", expectedSim: 0.6 },
            { word1: "æˆåŠŸ", word2: "é”æˆ", expectedSim: 0.7 },
            { word1: "çŸ¥æµ", word2: "æ™ºæ…§", expectedSim: 0.9 }
        ];
        
        for (const pair of testPairs) {
            const similarity = await synonymMatcher.findSimilarity(pair.word1, pair.word2);
            
            expect(similarity).toBeGreaterThan(pair.expectedSim - 0.2);
            expect(similarity).toBeLessThanOrEqual(1.0);
            
            console.log(`${pair.word1} - ${pair.word2}: ${similarity.toFixed(3)}`);
        }
    });
    
    test('æ˜“çµŒç”¨èªé¡ç¾©èªãƒãƒƒãƒ”ãƒ³ã‚°', async () => {
        const yijingSynonyms = [
            { term: "ä¹¾", synonyms: ["å¤©", "å‰µé€ ", "çˆ¶æ€§"] },
            { term: "å¤", synonyms: ["åœ°", "å—å®¹", "æ¯æ€§"] },
            { term: "éœ‡", synonyms: ["é›·", "å‹•ã", "é•·ç”·"] },
            { term: "å·½", synonyms: ["é¢¨", "æŸ”è»Ÿ", "é•·å¥³"] }
        ];
        
        for (const entry of yijingSynonyms) {
            for (const synonym of entry.synonyms) {
                const similarity = await synonymMatcher.findSimilarity(entry.term, synonym);
                
                // æ˜“çµŒç”¨èªã®é¡ç¾©èªã¯é«˜ã„é¡ä¼¼åº¦ã‚’æœŸå¾…
                expect(similarity).toBeGreaterThan(0.3);
                
                console.log(`${entry.term} - ${synonym}: ${similarity.toFixed(3)}`);
            }
        }
    });
});
```

---

## 4. ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ

### 4.1 çµ±åˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãƒ†ã‚¹ãƒˆ

#### TC-SCORING-001: è¤‡åˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ç²¾åº¦ãƒ†ã‚¹ãƒˆ
```javascript
describe('Intelligent Scoring Algorithm', () => {
    let intelligentScorer;
    
    beforeAll(async () => {
        intelligentScorer = new IntelligentScoringEngine();
        await intelligentScorer.initialize();
    });
    
    test('5è¦ç´ çµ±åˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°', async () => {
        const testCases = [
            {
                input: "ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦çµ„ç¹”ã‚’ç‡ã„ã¦æˆåŠŸã«å°ã",
                expectedLineRange: [5, 23, 41, 59, 77, 95], // äº”çˆ»ï¼ˆãƒªãƒ¼ãƒ€ãƒ¼ãƒã‚¸ã‚·ãƒ§ãƒ³ï¼‰
                expectedMinScore: 0.7
            },
            {
                input: "æ–°ã—ã„äº‹æ¥­ã‚’å§‹ã‚ã‚‹æº–å‚™ã‚’ã—ã¦ã„ã‚‹",
                expectedLineRange: [1, 19, 37, 55, 73, 91], // åˆçˆ»ï¼ˆå§‹ã¾ã‚Šãƒã‚¸ã‚·ãƒ§ãƒ³ï¼‰
                expectedMinScore: 0.6
            },
            {
                input: "å›°é›£ãªå•é¡Œã«ç›´é¢ã—ã¦è§£æ±ºç­–ã‚’æ¨¡ç´¢ã™ã‚‹",
                expectedLineRange: [3, 21, 39, 57, 75, 93], // ä¸‰çˆ»ï¼ˆå›°é›£ãƒã‚¸ã‚·ãƒ§ãƒ³ï¼‰
                expectedMinScore: 0.6
            }
        ];
        
        for (const testCase of testCases) {
            const result = await intelligentScorer.calculateComprehensiveScore(testCase.input);
            
            // çµæœæ§‹é€ ç¢ºèª
            expect(result).toHaveProperty('final_line_id');
            expect(result).toHaveProperty('confidence_score');
            expect(result).toHaveProperty('component_scores');
            
            // ä¿¡é ¼åº¦ç¢ºèª
            expect(result.confidence_score).toBeGreaterThan(testCase.expectedMinScore);
            
            // æœŸå¾…ã•ã‚Œã‚‹ãƒã‚¸ã‚·ãƒ§ãƒ³ç¯„å›²ç¢ºèª
            expect(testCase.expectedLineRange).toContain(result.final_line_id);
            
            // æ§‹æˆè¦ç´ ã‚¹ã‚³ã‚¢ç¢ºèª
            const scores = result.component_scores;
            expect(scores).toHaveProperty('morphology_score');
            expect(scores).toHaveProperty('synonym_score');
            expect(scores).toHaveProperty('yaoci_score');
            expect(scores).toHaveProperty('learning_score');
            expect(scores).toHaveProperty('context_score');
            
            // ã‚¹ã‚³ã‚¢é…åˆ†ç¢ºèªï¼ˆå„è¦ç´ ãŒå¯„ä¸ã—ã¦ã„ã‚‹ã‹ï¼‰
            expect(scores.morphology_score).toBeGreaterThan(0);
            expect(scores.synonym_score).toBeGreaterThan(0);
            expect(scores.yaoci_score).toBeGreaterThan(0);
            
            console.log(`å…¥åŠ›: "${testCase.input}"`);
            console.log(`çµæœ: Line ${result.final_line_id}, ä¿¡é ¼åº¦: ${result.confidence_score.toFixed(3)}`);
            console.log('æ§‹æˆè¦ç´ ã‚¹ã‚³ã‚¢:', scores);
        }
    });
    
    test('å­¦ç¿’é‡ã¿å‹•çš„èª¿æ•´ãƒ†ã‚¹ãƒˆ', async () => {
        // åˆæœŸçŠ¶æ…‹ã®ã‚¹ã‚³ã‚¢å–å¾—
        const inputText = "æŒ‡å°è€…ã¨ã—ã¦æ±ºæ–­ã‚’ä¸‹ã™";
        const initialResult = await intelligentScorer.calculateComprehensiveScore(inputText);
        
        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿é€ä¿¡ï¼ˆæ­£è§£ï¼šäº”çˆ»ï¼‰
        await intelligentScorer.submitFeedback({
            input: inputText,
            predicted_line: initialResult.final_line_id,
            correct_line: 5, // ä¹¾ç‚ºå¤© ä¹äº”
            accuracy_rating: 5
        });
        
        // å­¦ç¿’å¾Œã®ã‚¹ã‚³ã‚¢å†è¨ˆç®—
        const learnedResult = await intelligentScorer.calculateComprehensiveScore(inputText);
        
        // å­¦ç¿’åŠ¹æœç¢ºèª
        if (initialResult.final_line_id !== 5) {
            // å­¦ç¿’ã«ã‚ˆã‚Šäº”çˆ»ã¸ã®é‡ã¿ãŒå¢—åŠ ã—ã¦ã„ã‚‹ã‹
            expect(learnedResult.component_scores.learning_score).toBeGreaterThan(
                initialResult.component_scores.learning_score
            );
        }
        
        console.log('å­¦ç¿’å‰ã‚¹ã‚³ã‚¢:', initialResult.component_scores);
        console.log('å­¦ç¿’å¾Œã‚¹ã‚³ã‚¢:', learnedResult.component_scores);
    });
});
```

---

## 5. æ€§èƒ½ãƒ»å“è³ªãƒ†ã‚¹ãƒˆ

### 5.1 æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ

#### TC-PERF-001: ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒ»ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
```javascript
describe('Performance Benchmarks', () => {
    let performanceTester;
    
    beforeAll(async () => {
        performanceTester = new PerformanceTester();
        await performanceTester.initialize();
    });
    
    test('å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒ†ã‚¹ãƒˆï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆæ™‚ï¼‰', async () => {
        const testInputs = [
            "ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã‚’ç™ºæ®ã™ã‚‹",
            "æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å§‹ã‚ã‚‹",
            "å›°é›£ãªå•é¡Œã‚’è§£æ±ºã™ã‚‹"
        ];
        
        // åˆå›å®Ÿè¡Œï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥æ§‹ç¯‰ï¼‰
        for (const input of testInputs) {
            await performanceTester.analyzeText(input);
        }
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆæ™‚ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
        const times = [];
        for (let i = 0; i < 100; i++) {
            const randomInput = testInputs[i % testInputs.length];
            
            const startTime = performance.now();
            await performanceTester.analyzeText(randomInput);
            const endTime = performance.now();
            
            times.push(endTime - startTime);
        }
        
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        const p95Time = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];
        const p99Time = times.sort((a, b) => a - b)[Math.floor(times.length * 0.99)];
        
        console.log(`ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆæ™‚ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹:`);
        console.log(`å¹³å‡: ${avgTime.toFixed(2)}ms`);
        console.log(`95%ile: ${p95Time.toFixed(2)}ms`);
        console.log(`99%ile: ${p99Time.toFixed(2)}ms`);
        
        // æ€§èƒ½è¦ä»¶ç¢ºèª
        expect(avgTime).toBeLessThan(1.0);  // å¹³å‡1msä»¥å†…
        expect(p95Time).toBeLessThan(2.0);  // 95%ã§2msä»¥å†…
        expect(p99Time).toBeLessThan(5.0);  // 99%ã§5msä»¥å†…
    });
    
    test('åˆå›åˆ†æãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãƒ†ã‚¹ãƒˆ', async () => {
        const newInputs = [
            "å¤å…¸çš„ãªæ™ºæ…§ã‚’ç¾ä»£ã«å¿œç”¨ã™ã‚‹æ–¹æ³•è«–",
            "çµ„ç¹”å¤‰é©ã®ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—å®Ÿè·µè«–",
            "å‰µé€ çš„å•é¡Œè§£æ±ºã®æ€è€ƒãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯"
        ];
        
        const times = [];
        for (const input of newInputs) {
            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
            await performanceTester.clearCache(input);
            
            const startTime = performance.now();
            await performanceTester.analyzeText(input);
            const endTime = performance.now();
            
            times.push(endTime - startTime);
        }
        
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        const maxTime = Math.max(...times);
        
        console.log(`åˆå›åˆ†æãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹:`);
        console.log(`å¹³å‡: ${avgTime.toFixed(2)}ms`);
        console.log(`æœ€å¤§: ${maxTime.toFixed(2)}ms`);
        
        // æ€§èƒ½è¦ä»¶ç¢ºèª
        expect(avgTime).toBeLessThan(5.0);   // å¹³å‡5msä»¥å†…
        expect(maxTime).toBeLessThan(10.0);  // æœ€å¤§10msä»¥å†…
    });
    
    test('åŒæ™‚æ¥ç¶šè² è·ãƒ†ã‚¹ãƒˆ', async () => {
        const concurrentUsers = 50;
        const requestsPerUser = 10;
        
        const promises = [];
        
        for (let user = 0; user < concurrentUsers; user++) {
            const userRequests = [];
            for (let req = 0; req < requestsPerUser; req++) {
                userRequests.push(
                    performanceTester.analyzeText(`ãƒ¦ãƒ¼ã‚¶ãƒ¼${user}ãƒªã‚¯ã‚¨ã‚¹ãƒˆ${req}: ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦æ±ºæ–­ã™ã‚‹`)
                );
            }
            promises.push(Promise.all(userRequests));
        }
        
        const startTime = performance.now();
        await Promise.all(promises);
        const endTime = performance.now();
        
        const totalTime = endTime - startTime;
        const totalRequests = concurrentUsers * requestsPerUser;
        const throughput = totalRequests / (totalTime / 1000);
        
        console.log(`åŒæ™‚æ¥ç¶šè² è·ãƒ†ã‚¹ãƒˆçµæœ:`);
        console.log(`ç·ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: ${totalRequests}`);
        console.log(`ç·å®Ÿè¡Œæ™‚é–“: ${totalTime.toFixed(0)}ms`);
        console.log(`ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: ${throughput.toFixed(1)} req/sec`);
        
        // ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆè¦ä»¶ç¢ºèª
        expect(throughput).toBeGreaterThan(100); // 100 req/secä»¥ä¸Š
    });
});
```

### 5.2 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ€§èƒ½ãƒ†ã‚¹ãƒˆ

#### TC-PERF-002: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆ¥æ€§èƒ½ãƒ†ã‚¹ãƒˆ
```javascript
describe('Database Performance', () => {
    test('SQLiteã‚¯ã‚¨ãƒªæ€§èƒ½ãƒ†ã‚¹ãƒˆ', async () => {
        const sqliteManager = new SQLiteManager('./dbs/main.db');
        
        // å½¢æ…‹ç´ è§£æè¾æ›¸ã‚¯ã‚¨ãƒªæ€§èƒ½
        const morphologyQueries = [
            "SELECT * FROM morphology_dict WHERE word = 'ãƒªãƒ¼ãƒ€ãƒ¼'",
            "SELECT * FROM morphology_dict WHERE word LIKE 'å§‹ã¾ã‚Š%'",
            "SELECT * FROM synonym_dict WHERE word = 'æˆåŠŸ' ORDER BY similarity_score DESC LIMIT 10"
        ];
        
        for (const query of morphologyQueries) {
            const times = [];
            
            for (let i = 0; i < 100; i++) {
                const startTime = performance.now();
                await sqliteManager.execute(query);
                const endTime = performance.now();
                times.push(endTime - startTime);
            }
            
            const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
            console.log(`SQLite Query: ${avgTime.toFixed(3)}ms - ${query.substring(0, 50)}...`);
            
            // SQLiteæ€§èƒ½è¦ä»¶ï¼š0.5msä»¥å†…
            expect(avgTime).toBeLessThan(0.5);
        }
    });
    
    test('MongoDBæ›¸ãè¾¼ã¿æ€§èƒ½ãƒ†ã‚¹ãƒˆ', async () => {
        const mongoManager = new MongoManager('mongodb://localhost:27017/haqei');
        
        const sampleFeedback = {
            timestamp: new Date(),
            user_input: "æ€§èƒ½ãƒ†ã‚¹ãƒˆç”¨å…¥åŠ›",
            predicted_line: 1,
            user_feedback: { correct_line: 1, accuracy_rating: 5 }
        };
        
        const times = [];
        
        for (let i = 0; i < 50; i++) {
            const testData = { ...sampleFeedback, test_id: i };
            
            const startTime = performance.now();
            await mongoManager.insertOne('user_feedback', testData);
            const endTime = performance.now();
            
            times.push(endTime - startTime);
        }
        
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        console.log(`MongoDBæ›¸ãè¾¼ã¿å¹³å‡æ™‚é–“: ${avgTime.toFixed(3)}ms`);
        
        // MongoDBæ€§èƒ½è¦ä»¶ï¼š2msä»¥å†…
        expect(avgTime).toBeLessThan(2.0);
    });
    
    test('Redisæ“ä½œæ€§èƒ½ãƒ†ã‚¹ãƒˆ', async () => {
        const redisManager = new RedisManager('redis://localhost:6379');
        
        const operations = [
            () => redisManager.set('perf_test_key', 'test_value'),
            () => redisManager.get('perf_test_key'),
            () => redisManager.setex('perf_test_ttl', 3600, 'ttl_value'),
            () => redisManager.del('perf_test_key')
        ];
        
        for (const operation of operations) {
            const times = [];
            
            for (let i = 0; i < 1000; i++) {
                const startTime = performance.now();
                await operation();
                const endTime = performance.now();
                times.push(endTime - startTime);
            }
            
            const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
            console.log(`Redisæ“ä½œå¹³å‡æ™‚é–“: ${avgTime.toFixed(3)}ms`);
            
            // Redisæ€§èƒ½è¦ä»¶ï¼š0.1msä»¥å†…
            expect(avgTime).toBeLessThan(0.1);
        }
    });
});
```

---

## 6. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

### 6.1 æš—å·åŒ–ãƒ»ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ãƒ†ã‚¹ãƒˆ

#### TC-SEC-001: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æš—å·åŒ–ãƒ†ã‚¹ãƒˆ
```javascript
describe('Database Security', () => {
    test('SQLCipheræš—å·åŒ–ãƒ†ã‚¹ãƒˆ', async () => {
        const encryptedDB = new SQLiteManager('./dbs/encrypted_test.db', {
            encryption: {
                key: 'test_encryption_key_256bit_length_required',
                cipher: 'aes-256-gcm'
            }
        });
        
        // æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã®æ›¸ãè¾¼ã¿
        await encryptedDB.execute(`
            CREATE TABLE test_secure (
                id INTEGER PRIMARY KEY,
                sensitive_data TEXT
            )
        `);
        
        await encryptedDB.insert('test_secure', {
            sensitive_data: 'ã“ã®ãƒ‡ãƒ¼ã‚¿ã¯æš—å·åŒ–ã•ã‚Œã¦ã„ã¾ã™'
        });
        
        // æ­£ã—ã„ã‚­ãƒ¼ã§ã®èª­ã¿è¾¼ã¿
        const result = await encryptedDB.findOne('test_secure', { id: 1 });
        expect(result.sensitive_data).toBe('ã“ã®ãƒ‡ãƒ¼ã‚¿ã¯æš—å·åŒ–ã•ã‚Œã¦ã„ã¾ã™');
        
        // æš—å·åŒ–ãªã—ã§ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œï¼ˆå¤±æ•—ã™ã‚‹ã¹ãï¼‰
        const unencryptedDB = new SQLiteManager('./dbs/encrypted_test.db');
        
        try {
            await unencryptedDB.execute('SELECT * FROM test_secure');
            fail('æš—å·åŒ–ãªã—ã§ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¦ã—ã¾ã„ã¾ã—ãŸ');
        } catch (error) {
            expect(error.message).toContain('database is locked');
        }
    });
    
    test('MongoDBèªè¨¼ãƒ»èªå¯ãƒ†ã‚¹ãƒˆ', async () => {
        // èªè¨¼æƒ…å ±ã‚’å«ã‚€MongoDBæ¥ç¶š
        const secureMongoManager = new MongoManager(
            'mongodb://haqei_user:secure_password@localhost:27017/haqei',
            {
                authSource: 'haqei',
                authMechanism: 'SCRAM-SHA-256'
            }
        );
        
        await secureMongoManager.connect();
        
        // æ¨©é™å†…æ“ä½œï¼ˆæˆåŠŸã™ã‚‹ã¹ãï¼‰
        const result = await secureMongoManager.insertOne('user_feedback', {
            test: 'authorized_access',
            timestamp: new Date()
        });
        expect(result.insertedId).toBeDefined();
        
        // æ¨©é™å¤–æ“ä½œãƒ†ã‚¹ãƒˆï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
        // ç®¡ç†è€…é™å®šã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ç­‰
    });
});
```

### 6.2 å…¥åŠ›æ¤œè¨¼ãƒ»SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢ãƒ†ã‚¹ãƒˆ

#### TC-SEC-002: å…¥åŠ›ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
```javascript
describe('Input Security', () => {
    test('SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢ãƒ†ã‚¹ãƒˆ', async () => {
        const sqliteManager = new SQLiteManager('./dbs/main.db');
        
        // SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œãƒ‘ã‚¿ãƒ¼ãƒ³
        const injectionAttempts = [
            "'; DROP TABLE morphology_dict; --",
            "' OR '1'='1",
            "admin'--",
            "admin'/*",
            "' UNION SELECT password FROM users--"
        ];
        
        for (const maliciousInput of injectionAttempts) {
            try {
                // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªã§ã®å®‰å…¨ãªå®Ÿè¡Œ
                const result = await sqliteManager.findOne('morphology_dict', { 
                    word: maliciousInput 
                });
                
                // ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¤±æ•—ï¼ˆæ­£å¸¸å‹•ä½œï¼‰
                expect(result).toBeNull(); // è©²å½“ãƒ¬ã‚³ãƒ¼ãƒ‰ãªã—
                
            } catch (error) {
                // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã«ã‚ˆã‚Šå®‰å…¨ã«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                expect(error.message).not.toContain('syntax error');
            }
        }
    });
    
    test('NoSQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢ãƒ†ã‚¹ãƒˆ', async () => {
        const mongoManager = new MongoManager('mongodb://localhost:27017/haqei');
        
        // NoSQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è©¦è¡Œãƒ‘ã‚¿ãƒ¼ãƒ³
        const noSQLInjections = [
            { user_input: { $ne: null } },
            { user_input: { $regex: ".*", $options: "i" } },
            { user_input: { $where: "this.password == 'admin'" } }
        ];
        
        for (const injection of noSQLInjections) {
            try {
                // é©åˆ‡ãªå…¥åŠ›æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
                const sanitizedQuery = mongoManager.sanitizeQuery(injection);
                const result = await mongoManager.findOne('user_feedback', sanitizedQuery);
                
                // ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢æˆåŠŸ
                expect(result).not.toBe('INJECTION_SUCCESS');
                
            } catch (error) {
                // é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
                expect(error.message).toContain('Invalid query format');
            }
        }
    });
});
```

---

## 7. çµ±åˆãƒ»E2Eãƒ†ã‚¹ãƒˆ

### 7.1 ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ

#### TC-E2E-001: å®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ
```javascript
describe('End-to-End Workflow Tests', () => {
    let textTo384Bridge;
    
    beforeAll(async () => {
        // å…¨ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
        textTo384Bridge = new TextTo384LinesBridge();
        await textTo384Bridge.initializeAll(); // å…¨DB + NLPåˆæœŸåŒ–
    });
    
    test('å®Œå…¨åˆ†æãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼šå…¥åŠ›â†’åˆ†æâ†’å­¦ç¿’', async () => {
        const testScenario = {
            user_input: "çµ„ç¹”ã®ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦å›°é›£ãªæ™‚æœŸã«æ±ºæ–­ã‚’ä¸‹ã—ã€ãƒãƒ¼ãƒ ã‚’æˆåŠŸã¸å°ãè²¬ä»»ã‚’æŒã¤",
            expected_themes: ["ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—", "è²¬ä»»", "æ±ºæ–­", "å›°é›£", "æˆåŠŸ"],
            expected_position_range: [5], // äº”çˆ»ï¼ˆãƒªãƒ¼ãƒ€ãƒ¼ãƒã‚¸ã‚·ãƒ§ãƒ³ï¼‰
            user_feedback: {
                correct_line: 5, // ä¹¾ç‚ºå¤© ä¹äº”
                accuracy_rating: 5
            }
        };
        
        // Phase 1: å®Œå…¨åˆ†æå®Ÿè¡Œ
        console.log("Phase 1: å®Œå…¨åˆ†æå®Ÿè¡Œ");
        const analysisResult = await textTo384Bridge.analyzeTextToSpecificLine(testScenario.user_input);
        
        // åˆ†æçµæœæ¤œè¨¼
        expect(analysisResult).toHaveProperty('line_384_id');
        expect(analysisResult).toHaveProperty('confidence_score');
        expect(analysisResult).toHaveProperty('analysis_breakdown');
        
        const breakdown = analysisResult.analysis_breakdown;
        expect(breakdown).toHaveProperty('morphology_analysis');
        expect(breakdown).toHaveProperty('synonym_matches');
        expect(breakdown).toHaveProperty('yaoci_relevance');
        expect(breakdown).toHaveProperty('learning_weights');
        
        // å½¢æ…‹ç´ è§£æçµæœç¢ºèª
        expect(breakdown.morphology_analysis.keywords).toEqual(
            expect.arrayContaining(["ãƒªãƒ¼ãƒ€ãƒ¼", "æ±ºæ–­", "è²¬ä»»"])
        );
        
        // é¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°ç¢ºèª
        expect(breakdown.synonym_matches.length).toBeGreaterThan(0);
        expect(breakdown.synonym_matches.some(match => 
            match.synonym.includes("æŒ‡å°è€…") || match.synonym.includes("çµ±ç‡")
        )).toBe(true);
        
        console.log("åˆ†æçµæœ:", {
            line_id: analysisResult.line_384_id,
            confidence: analysisResult.confidence_score,
            morphology: breakdown.morphology_analysis.keywords,
            synonyms: breakdown.synonym_matches.map(m => m.synonym)
        });
        
        // Phase 2: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡ã¨å­¦ç¿’
        console.log("Phase 2: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡ã¨å­¦ç¿’");
        const feedbackResult = await textTo384Bridge.submitUserFeedback({
            original_input: testScenario.user_input,
            predicted_line: analysisResult.line_384_id,
            user_feedback: testScenario.user_feedback,
            analysis_data: breakdown
        });
        
        expect(feedbackResult.feedback_id).toBeDefined();
        expect(feedbackResult.learning_applied).toBe(true);
        
        // Phase 3: å­¦ç¿’åŠ¹æœç¢ºèªï¼ˆå†åˆ†æï¼‰
        console.log("Phase 3: å­¦ç¿’åŠ¹æœç¢ºèª");
        await new Promise(resolve => setTimeout(resolve, 100)); // å­¦ç¿’åæ˜ å¾…æ©Ÿ
        
        const reAnalysisResult = await textTo384Bridge.analyzeTextToSpecificLine(testScenario.user_input);
        
        // å­¦ç¿’åŠ¹æœç¢ºèª
        if (analysisResult.line_384_id !== testScenario.user_feedback.correct_line) {
            // å­¦ç¿’ã«ã‚ˆã‚Šæ­£è§£ã¸ã®é‡ã¿ãŒå¢—åŠ ã—ã¦ã„ã‚‹ã‹
            expect(reAnalysisResult.confidence_score).toBeGreaterThan(analysisResult.confidence_score);
            expect(reAnalysisResult.analysis_breakdown.learning_weights[testScenario.user_feedback.correct_line])
                .toBeGreaterThan(breakdown.learning_weights[testScenario.user_feedback.correct_line] || 0);
        }
        
        console.log("å­¦ç¿’åŠ¹æœ:", {
            original_line: analysisResult.line_384_id,
            learned_line: reAnalysisResult.line_384_id,
            confidence_improvement: reAnalysisResult.confidence_score - analysisResult.confidence_score
        });
        
        // Phase 4: ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‹•ä½œç¢ºèª
        console.log("Phase 4: ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‹•ä½œç¢ºèª");
        const cachedStartTime = performance.now();
        const cachedResult = await textTo384Bridge.analyzeTextToSpecificLine(testScenario.user_input);
        const cachedEndTime = performance.now();
        
        const cachedResponseTime = cachedEndTime - cachedStartTime;
        expect(cachedResponseTime).toBeLessThan(2.0); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥åŠ¹æœã§é«˜é€ŸåŒ–
        
        expect(cachedResult.line_384_id).toBe(reAnalysisResult.line_384_id); // çµæœä¸€è²«æ€§
        
        console.log("ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ€§èƒ½:", {
            response_time: cachedResponseTime.toFixed(2) + "ms",
            cache_hit: cachedResult.cache_hit || false
        });
    });
});
```

---

## 8. å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ»ç¶™ç¶šç›£è¦–ãƒ†ã‚¹ãƒˆ

### 8.1 ã‚·ã‚¹ãƒ†ãƒ å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹

#### TC-METRICS-001: InfluxDBãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ãƒ†ã‚¹ãƒˆ
```javascript
describe('Quality Metrics Collection', () => {
    let metricsCollector;
    
    beforeAll(async () => {
        metricsCollector = new InfluxDBMetricsCollector('http://localhost:8086');
        await metricsCollector.initialize();
    });
    
    test('æ€§èƒ½ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ãƒ»é›†ç´„', async () => {
        // æ€§èƒ½ãƒ¡ãƒˆãƒªã‚¯ã‚¹ç”Ÿæˆï¼ˆå®Ÿéš›ã®åˆ†æå‡¦ç†å®Ÿè¡Œï¼‰
        const testInputs = [
            "ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦æ±ºæ–­ã‚’ä¸‹ã™",
            "æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‹å§‹ã™ã‚‹", 
            "å›°é›£ãªå•é¡Œã‚’è§£æ±ºã™ã‚‹æ–¹æ³•ã‚’æ¨¡ç´¢ã™ã‚‹"
        ];
        
        for (const input of testInputs) {
            const startTime = Date.now();
            
            const result = await textTo384Bridge.analyzeTextToSpecificLine(input);
            
            const endTime = Date.now();
            const responseTime = endTime - startTime;
            
            // InfluxDBã«ãƒ¡ãƒˆãƒªã‚¯ã‚¹é€ä¿¡
            await metricsCollector.writeMetrics('analysis_performance', {
                response_time: responseTime,
                confidence_score: result.confidence_score,
                cache_hit: result.cache_hit || false,
                line_id: result.line_384_id
            }, {
                input_length: input.length,
                timestamp: startTime
            });
        }
        
        // ãƒ¡ãƒˆãƒªã‚¯ã‚¹é›†ç´„ãƒ»ç¢ºèª
        const aggregatedMetrics = await metricsCollector.query(`
            SELECT 
                MEAN(response_time) as avg_response_time,
                PERCENTILE(response_time, 95) as p95_response_time,
                MEAN(confidence_score) as avg_confidence,
                COUNT(*) as total_requests
            FROM analysis_performance 
            WHERE time >= now() - 5m
        `);
        
        expect(aggregatedMetrics.length).toBeGreaterThan(0);
        
        const metrics = aggregatedMetrics[0];
        expect(metrics.avg_response_time).toBeLessThan(10); // 10msä»¥å†…
        expect(metrics.p95_response_time).toBeLessThan(20); // 95%ile 20msä»¥å†…
        expect(metrics.avg_confidence).toBeGreaterThan(0.5); // å¹³å‡ä¿¡é ¼åº¦50%ä»¥ä¸Š
        
        console.log("æ€§èƒ½ãƒ¡ãƒˆãƒªã‚¯ã‚¹:", {
            avg_response: metrics.avg_response_time.toFixed(2) + "ms",
            p95_response: metrics.p95_response_time.toFixed(2) + "ms", 
            avg_confidence: metrics.avg_confidence.toFixed(3),
            total_requests: metrics.total_requests
        });
    });
    
    test('åˆ†é¡ç²¾åº¦ãƒ»ã‚«ãƒãƒ¼ç‡ãƒ¡ãƒˆãƒªã‚¯ã‚¹', async () => {
        const testSamples = 100;
        const usedLines = new Set();
        let correctPredictions = 0;
        
        // ãƒ†ã‚¹ãƒˆã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆãƒ»åˆ†æ
        for (let i = 0; i < testSamples; i++) {
            const testInput = generateTestInput(i); // ãƒ†ã‚¹ãƒˆç”¨å…¥åŠ›ç”Ÿæˆ
            const result = await textTo384Bridge.analyzeTextToSpecificLine(testInput);
            
            usedLines.add(result.line_384_id);
            
            // ä¿¡é ¼åº¦ãŒé«˜ã„å ´åˆã‚’æ­£è§£ã¨ã¿ãªã™ï¼ˆç°¡æ˜“è©•ä¾¡ï¼‰
            if (result.confidence_score > 0.7) {
                correctPredictions++;
            }
            
            // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
            await metricsCollector.writeMetrics('classification_quality', {
                line_id: result.line_384_id,
                confidence_score: result.confidence_score,
                is_high_confidence: result.confidence_score > 0.7
            }, {
                sample_id: i,
                timestamp: Date.now()
            });
        }
        
        // ã‚«ãƒãƒ¼ç‡è¨ˆç®—
        const coverageRate = usedLines.size / 384;
        const accuracyRate = correctPredictions / testSamples;
        
        // å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
        await metricsCollector.writeMetrics('system_quality', {
            coverage_rate: coverageRate,
            accuracy_rate: accuracyRate,
            unique_lines_used: usedLines.size,
            total_samples: testSamples
        });
        
        console.log("å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹:", {
            coverage_rate: (coverageRate * 100).toFixed(1) + "%",
            accuracy_rate: (accuracyRate * 100).toFixed(1) + "%",
            unique_lines: usedLines.size
        });
        
        // å“è³ªè¦ä»¶ç¢ºèª
        expect(coverageRate).toBeGreaterThan(0.20); // ã‚«ãƒãƒ¼ç‡20%ä»¥ä¸Š
        expect(accuracyRate).toBeGreaterThan(0.70); // ç²¾åº¦70%ä»¥ä¸Š
    });
});

function generateTestInput(index) {
    const patterns = [
        "ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦çµ„ç¹”ã‚’å°ã",
        "æ–°ã—ã„æŒ‘æˆ¦ã‚’å§‹ã‚ã‚‹",
        "å›°é›£ãªå•é¡Œã«ç«‹ã¡å‘ã‹ã†",
        "æˆé•·ã®æ©Ÿä¼šã‚’æ´ã‚€",
        "å¤‰åŒ–ã®æ™‚ä»£ã‚’ä¹—ã‚Šè¶Šãˆã‚‹",
        "çŸ¥æµã¨çµŒé¨“ã‚’æ´»ã‹ã™"
    ];
    
    const variations = [
        "æ–¹æ³•ã‚’æ¨¡ç´¢ã—ã¦ã„ã‚‹",
        "æˆ¦ç•¥ã‚’ç·´ã£ã¦ã„ã‚‹", 
        "æ±ºæ„ã‚’å›ºã‚ã¦ã„ã‚‹",
        "è²¬ä»»ã‚’æ„Ÿã˜ã¦ã„ã‚‹",
        "å¯èƒ½æ€§ã‚’ä¿¡ã˜ã¦ã„ã‚‹"
    ];
    
    const pattern = patterns[index % patterns.length];
    const variation = variations[Math.floor(index / patterns.length) % variations.length];
    
    return `${pattern}${variation}`;
}
```

---

## 9. å—ã‘å…¥ã‚Œãƒ†ã‚¹ãƒˆåŸºæº–

### 9.1 å¿…é ˆåˆæ ¼åŸºæº–

| ã‚«ãƒ†ã‚´ãƒª | ãƒ†ã‚¹ãƒˆé …ç›® | åˆæ ¼åŸºæº– | æ¸¬å®šæ–¹æ³• |
|---------|-----------|---------|---------|
| **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ** | 4DBæ¥ç¶šæˆåŠŸç‡ | 100% | èµ·å‹•æ™‚æ¥ç¶šãƒ†ã‚¹ãƒˆ |
| **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆ** | ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ | 100% | å…¨ãƒ†ãƒ¼ãƒ–ãƒ«æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ |
| **è‡ªç„¶è¨€èªå‡¦ç†** | MeCabè§£ææˆåŠŸç‡ | 95%ä»¥ä¸Š | 1000ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚¹ãƒˆ |
| **è‡ªç„¶è¨€èªå‡¦ç†** | WordNeté¡ä¼¼åº¦è¨ˆç®— | 90%ä»¥ä¸Š | é¡ç¾©èªãƒšã‚¢ãƒ†ã‚¹ãƒˆ |
| **ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆåˆ†æ** | åˆ†é¡ç²¾åº¦ | 85%ä»¥ä¸Š | å°‚é–€å®¶è©•ä¾¡500ã‚µãƒ³ãƒ—ãƒ« |
| **ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆåˆ†æ** | ã‚«ãƒãƒ¼ç‡ | 60%ä»¥ä¸Š | 1000ã‚µãƒ³ãƒ—ãƒ«åˆ†æ |
| **å­¦ç¿’æ©Ÿèƒ½** | ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ ç‡ | 80%ä»¥ä¸Š | å­¦ç¿’å‰å¾Œæ¯”è¼ƒ |
| **æ€§èƒ½** | å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ | 3msä»¥å†… | 1000å›å®Ÿè¡Œå¹³å‡ |
| **æ€§èƒ½** | 95%ileãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ | 5msä»¥å†… | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ |
| **æ€§èƒ½** | åŒæ™‚æ¥ç¶šå¯¾å¿œ | 100ãƒ¦ãƒ¼ã‚¶ãƒ¼ | è² è·ãƒ†ã‚¹ãƒˆ |
| **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£** | æš—å·åŒ–å‹•ä½œ | 100% | SQLCipheræ¤œè¨¼ |
| **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£** | ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢ | 100% | æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ |

### 9.2 æ®µéšåˆ¥å—ã‘å…¥ã‚ŒåŸºæº–

#### Phase 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åŸºç›¤ï¼ˆWeek 1-2ï¼‰
```yaml
å¿…é ˆè¦ä»¶:
  - SQLiteæ¥ç¶šãƒ»ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ: 100%æˆåŠŸ
  - MongoDBæ¥ç¶šãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆ: 100%æˆåŠŸ  
  - Redisæ¥ç¶šãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ“ä½œ: 100%æˆåŠŸ
  - åŸºæœ¬ãƒ‡ãƒ¼ã‚¿å°å…¥: IPADic, WordNet-jpå®Œäº†
  
è©•ä¾¡åŸºæº–:
  - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èµ·å‹•ãƒ»æ¥ç¶šæ™‚é–“: 5ç§’ä»¥å†…
  - åŸºæœ¬ã‚¯ã‚¨ãƒªå¿œç­”æ™‚é–“: SQLite 1ms, MongoDB 3ms, Redis 0.1ms
  - ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§: 100%ï¼ˆæ¬ æãƒ»é‡è¤‡ãªã—ï¼‰
```

#### Phase 2: NLPãƒ»AIæ©Ÿèƒ½ï¼ˆWeek 3-5ï¼‰
```yaml
å¿…é ˆè¦ä»¶:
  - MeCabå½¢æ…‹ç´ è§£æ: 95%ä»¥ä¸Šã®ç²¾åº¦
  - WordNeté¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°: 90%ä»¥ä¸Šã®é©åˆç‡
  - ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°: 85%ä»¥ä¸Šã®åˆ†é¡ç²¾åº¦
  - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ : 95%ä»¥ä¸Šã®ãƒ’ãƒƒãƒˆç‡ï¼ˆåŒä¸€å…¥åŠ›ï¼‰
  
è©•ä¾¡åŸºæº–:
  - åˆ†æå‡¦ç†æ™‚é–“: å¹³å‡5msä»¥å†…
  - ã‚«ãƒãƒ¼ç‡: 40%ä»¥ä¸Šï¼ˆ200ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚¹ãƒˆï¼‰
  - ä¿¡é ¼åº¦åˆ†å¸ƒ: 70%ä»¥ä¸Šã®ã‚¯ã‚¨ãƒªã§0.6ä»¥ä¸Šã®ã‚¹ã‚³ã‚¢
```

#### Phase 3: å­¦ç¿’ãƒ»æœ€é©åŒ–ï¼ˆWeek 6-8ï¼‰
```yaml
å¿…é ˆè¦ä»¶:
  - ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å­¦ç¿’: 80%ä»¥ä¸Šã®æ”¹å–„åŠ¹æœ
  - æ€§èƒ½æœ€é©åŒ–: å¹³å‡3msä»¥å†…ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
  - ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ : InfluxDB + Grafanaãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
  - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: SQLCipheræš—å·åŒ–ã€èªè¨¼ãƒ»èªå¯å®Œå‚™
  
è©•ä¾¡åŸºæº–:
  - åˆ†é¡ç²¾åº¦: 85%ä»¥ä¸Šï¼ˆå°‚é–€å®¶è©•ä¾¡ï¼‰
  - ã‚«ãƒãƒ¼ç‡: 60%ä»¥ä¸Šï¼ˆ1000ã‚µãƒ³ãƒ—ãƒ«ï¼‰
  - å­¦ç¿’åŠ¹æœ: æœˆæ¬¡ã§2%ä»¥ä¸Šã®ç²¾åº¦æ”¹å–„
  - ç¨¼åƒç‡: 99.9%ä»¥ä¸Šï¼ˆç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ç¢ºèªï¼‰
```

---

## 10. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ»é‹ç”¨ã‚¬ã‚¤ãƒ‰

### 10.1 ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰

#### ç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
```bash
# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç’°å¢ƒæ§‹ç¯‰
./scripts/setup-databases.sh

# ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿å°å…¥
./scripts/import-test-data.sh

# MCPï¼ˆMulti-database Control Protocolï¼‰èµ·å‹•
npm run mcp:databases
```

#### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test -- --testPathPattern=384-database-integration

# ã‚«ãƒ†ã‚´ãƒªåˆ¥ãƒ†ã‚¹ãƒˆ
npm test -- --testNamePattern="Database Integration"
npm test -- --testNamePattern="NLP Processing" 
npm test -- --testNamePattern="Performance"
npm test -- --testNamePattern="Security"

# ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ
npm test -- --coverage --testPathPattern=384

# æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
npm run benchmark:384-system

# E2Eãƒ†ã‚¹ãƒˆï¼ˆæœ¬ç•ªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½¿ç”¨ï¼‰
npm run test:e2e:384-integration
```

#### ç¶™ç¶šç›£è¦–
```bash
# ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†é–‹å§‹
npm run metrics:start

# Grafanaãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰èµ·å‹•
docker-compose up grafana

# ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®šç¢ºèª
./scripts/check-monitoring-alerts.sh
```

### 10.2 ãƒ†ã‚¹ãƒˆçµæœãƒ¬ãƒãƒ¼ãƒˆ

#### è‡ªå‹•ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
```javascript
// ãƒ†ã‚¹ãƒˆå®Œäº†å¾Œã®è‡ªå‹•ãƒ¬ãƒãƒ¼ãƒˆ
const generateTestReport = async () => {
    const report = {
        test_summary: {
            total_tests: jest.getTestResults().numTotalTests,
            passed_tests: jest.getTestResults().numPassedTests,
            failed_tests: jest.getTestResults().numFailedTests,
            coverage_percentage: jest.getCoverageData().percentage
        },
        
        database_metrics: {
            sqlite_avg_response: await measureSQLitePerformance(),
            mongodb_avg_response: await measureMongoDBPerformance(), 
            redis_avg_response: await measureRedisPerformance(),
            influxdb_status: await checkInfluxDBConnection()
        },
        
        quality_metrics: {
            classification_accuracy: await calculateClassificationAccuracy(),
            coverage_rate: await calculateCoverageRate(),
            learning_effectiveness: await measureLearningEffectiveness()
        },
        
        security_verification: {
            encryption_status: await verifySQLCipherEncryption(),
            injection_prevention: await testInjectionPrevention(),
            authentication_status: await verifyDatabaseAuthentication()
        }
    };
    
    // ãƒ¬ãƒãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ
    await fs.writeFile(
        `./test-reports/384-integration-report-${new Date().toISOString().split('T')[0]}.json`,
        JSON.stringify(report, null, 2)
    );
    
    // Slackã‚„Emailã§ã®é€šçŸ¥
    await notifyTestCompletion(report);
};
```

---

## 11. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»FAQ

### 11.1 ã‚ˆãã‚ã‚‹å•é¡Œã¨å¯¾ç­–

#### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¨ãƒ©ãƒ¼
```yaml
å•é¡Œ: "SQLite database locked"
åŸå› : è¤‡æ•°ãƒ—ãƒ­ã‚»ã‚¹ã®åŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹
å¯¾ç­–: 
  - connection poolingã®ç¢ºèª
  - WAL modeã®æœ‰åŠ¹åŒ–
  - ãƒ•ã‚¡ã‚¤ãƒ«ãƒ­ãƒƒã‚¯çŠ¶æ³ã®ç¢ºèª

å•é¡Œ: "MongoDB connection timeout"
åŸå› : ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ»èªè¨¼è¨­å®š
å¯¾ç­–:
  - MongoDB serviceèµ·å‹•ç¢ºèª
  - èªè¨¼æƒ…å ±ã®ç¢ºèª
  - ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«è¨­å®šç¢ºèª

å•é¡Œ: "Redis ECONNREFUSED"
åŸå› : Redisã‚µãƒ¼ãƒãƒ¼æœªèµ·å‹•
å¯¾ç­–:
  - Redis serviceé–‹å§‹
  - ãƒãƒ¼ãƒˆç•ªå·ç¢ºèªï¼ˆ6379ï¼‰
  - ãƒ¡ãƒ¢ãƒªä¸è¶³ã®ç¢ºèª
```

#### è‡ªç„¶è¨€èªå‡¦ç†ã‚¨ãƒ©ãƒ¼
```yaml
å•é¡Œ: "MeCab initialization failed"
åŸå› : è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ã‚·ã‚¹ãƒ†ãƒ è¨­å®š
å¯¾ç­–:
  - IPADicè¾æ›¸ã®å­˜åœ¨ç¢ºèª
  - MeCabãƒ‘ã‚¹ã®ç’°å¢ƒå¤‰æ•°ç¢ºèª
  - æ–‡å­—ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆUTF-8ï¼‰ç¢ºèª

å•é¡Œ: "WordNet database not found"
åŸå› : WordNet-jpæœªå°å…¥
å¯¾ç­–:
  - WordNet-jpãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ»ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  - SQLiteè¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¨©é™ç¢ºèª
  - æ—¥æœ¬èªã‚¨ãƒ³ãƒˆãƒªæ•°ã®æ¤œè¨¼
```

#### æ€§èƒ½å•é¡Œ
```yaml
å•é¡Œ: ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ãŒè¦ä»¶ã‚’è¶…é
åŸå› : ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­å®š
å¯¾ç­–:
  - SQLiteã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
  - Redisã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­å®šè¦‹ç›´ã—
  - ã‚¯ã‚¨ãƒªå®Ÿè¡Œè¨ˆç”»ã®åˆ†æ

å•é¡Œ: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡éå¤š
åŸå› : ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»æ¥ç¶šãƒ—ãƒ¼ãƒ«è¨­å®š
å¯¾ç­–:
  - Redis maxmemoryè¨­å®šèª¿æ•´
  - æ¥ç¶šãƒ—ãƒ¼ãƒ«ã‚µã‚¤ã‚ºæœ€é©åŒ–
  - ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ç¢ºèª
```

### 11.2 ãƒ‡ãƒãƒƒã‚°ãƒ»ãƒ­ã‚°è¨­å®š

#### è©³ç´°ãƒ­ã‚°æœ‰åŠ¹åŒ–
```javascript
// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰è¨­å®š
process.env.DEBUG_384_SYSTEM = "true";
process.env.LOG_LEVEL = "debug";

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆ¥ãƒ­ã‚°è¨­å®š
const logConfig = {
    sqlite: {
        enable: true,
        level: "debug",
        include_queries: true
    },
    mongodb: {
        enable: true,
        level: "info", 
        include_operations: true
    },
    redis: {
        enable: true,
        level: "warn",
        include_commands: false
    }
};

// NLPå‡¦ç†ãƒ­ã‚°
const nlpLogConfig = {
    mecab: {
        log_analysis_steps: true,
        log_performance: true
    },
    wordnet: {
        log_similarity_calculation: true,
        log_cache_hits: true
    }
};
```

---

## 12. æ‰¿èªãƒ»å®Œäº†ç¢ºèª

### 12.1 æ‰¿èªãƒ—ãƒ­ã‚»ã‚¹

| æ®µéš | æ‰¿èªè€… | ç¢ºèªé …ç›® | æ‰¿èªåŸºæº– |
|------|-------|---------|---------|
| **Phase 1å®Œäº†** | DBã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ | ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆåŸºç›¤ | å…¨DBæ¥ç¶šãƒ»åŸºæœ¬æ©Ÿèƒ½100%å‹•ä½œ |
| **Phase 2å®Œäº†** | AIã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ | NLPãƒ»åˆ†æã‚¨ãƒ³ã‚¸ãƒ³ | åˆ†é¡ç²¾åº¦85%ä»¥ä¸Šé”æˆ |
| **Phase 3å®Œäº†** | ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼ | å®Œå…¨ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ | å…¨è¦ä»¶æº€è¶³ãƒ»æœ¬ç•ªé‹ç”¨å¯èƒ½ |
| **æœ€çµ‚æ‰¿èª** | CTOã¾ãŸã¯æŠ€è¡“è²¬ä»»è€… | ç·åˆå“è³ªè©•ä¾¡ | ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»æ€§èƒ½ãƒ»å“è³ªå…¨é …ç›®åˆæ ¼ |

### 12.2 å®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

#### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆåŸºç›¤
- [ ] SQLite: è¾æ›¸ãƒ‡ãƒ¼ã‚¿å®Œå…¨å°å…¥ãƒ»æš—å·åŒ–å‹•ä½œç¢ºèª
- [ ] MongoDB: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œãƒ»èªè¨¼è¨­å®šå®Œäº†
- [ ] Redis: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œãƒ»ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–å®Œäº†
- [ ] InfluxDB: ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ãƒ»Grafanaé€£æºå®Œäº†
- [ ] å…¨DB: èµ·å‹•ãƒ»æ¥ç¶šãƒ»åŸºæœ¬ã‚¯ã‚¨ãƒªãŒ5ç§’ä»¥å†…ã«å®Œäº†

#### AIãƒ»NLPæ©Ÿèƒ½
- [ ] MeCab: æ—¥æœ¬èªå½¢æ…‹ç´ è§£æ95%ç²¾åº¦é”æˆ
- [ ] WordNet: é¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°90%é©åˆç‡é”æˆ
- [ ] ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°: 85%ä»¥ä¸Šã®åˆ†é¡ç²¾åº¦é”æˆ
- [ ] å­¦ç¿’æ©Ÿèƒ½: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ 80%ä»¥ä¸Šã®åŠ¹æœ

#### æ€§èƒ½ãƒ»å“è³ª
- [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“: å¹³å‡3msã€95%ile 5msä»¥å†…
- [ ] åŒæ™‚æ¥ç¶š: 100ãƒ¦ãƒ¼ã‚¶ãƒ¼è² è·ãƒ†ã‚¹ãƒˆåˆæ ¼
- [ ] ã‚«ãƒãƒ¼ç‡: 60%ä»¥ä¸Šï¼ˆ1000ã‚µãƒ³ãƒ—ãƒ«ï¼‰
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: æš—å·åŒ–ãƒ»èªè¨¼ãƒ»ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢100%

#### é‹ç”¨æº–å‚™
- [ ] ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ : InfluxDB + Grafanaãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰å®Œæˆ
- [ ] ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š: æ€§èƒ½ãƒ»ã‚¨ãƒ©ãƒ¼ç›£è¦–å®Œå‚™
- [ ] ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—: è‡ªå‹•æ—¥æ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: é‹ç”¨ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ãƒ»ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°å®Œå‚™

---

## æ‰¿èª

| å½¹å‰² | æ°å | æ‰¿èªæ—¥ | ç½²å |
|------|------|--------|------|
| QAãƒªãƒ¼ãƒ‰ | | | |
| DBã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ | | | |
| AIã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ | | | |
| ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ | | | |
| ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼ | | | |
| CTO/æŠ€è¡“è²¬ä»»è€… | | | |

---

**æ–‡æ›¸ç®¡ç†**
- **ä½œæˆæ ¹æ‹ **: è¦ä»¶å®šç¾©æ›¸v3.0ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã«åŸºã¥ãåŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆæˆ¦ç•¥
- **å®Ÿè¡Œé–‹å§‹**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç’°å¢ƒæ§‹ç¯‰å®Œäº†å¾Œå³åº§ã«é–‹å§‹å¯èƒ½
- **ç¶™ç¶šç›£è¦–**: InfluxDB + Grafanaã«ã‚ˆã‚‹æœ¬ç•ªé‹ç”¨å¾Œã®ç¶™ç¶šçš„å“è³ªç›£è¦–
- **é…å¸ƒå…ˆ**: QAãƒãƒ¼ãƒ ã€é–‹ç™ºãƒãƒ¼ãƒ ã€ã‚¤ãƒ³ãƒ•ãƒ©ãƒãƒ¼ãƒ ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒ¼ãƒ 

**é‡è¦**: ã“ã®ãƒ†ã‚¹ãƒˆè¨ˆç”»æ›¸ã¯å˜ç´”ãªJSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ†ã‚¹ãƒˆã§ã¯ãªãã€çœŸã®ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºã‚°ãƒ¬ãƒ¼ãƒ‰ãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆã‚·ã‚¹ãƒ†ãƒ ã®ãŸã‚ã®åŒ…æ‹¬çš„å“è³ªä¿è¨¼æˆ¦ç•¥ã§ã™ã€‚