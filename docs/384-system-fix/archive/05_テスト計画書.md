# 🧪 384爻システム文脈理解機能 テスト計画書（データベース統合版）

**文書番号**: TP-384-003  
**バージョン**: 3.0  
**作成日**: 2025年8月28日  
**作成者**: HAQEI開発チーム  
**承認者**: [未承認]  

---

## 1. テスト概要

### 1.1 テスト目的
SQLite、MongoDB、Redis、InfluxDBを統合した包括的データベースシステムによる真の文脈理解機能の品質保証。MeCab形態素解析、WordNet類義語マッチング、学習機能を含む高度AI分析システムの全面検証。

### 1.2 テスト範囲
| テストカテゴリ | 検証内容 | 優先度 | DB対象 |
|-------------|---------|--------|--------|
| データベース統合 | 4DB接続・クエリ・整合性 | 必須 | SQLite/MongoDB/Redis/InfluxDB |
| 形態素解析システム | MeCab + IPADic解析精度 | 必須 | SQLite |
| 類義語マッチング | WordNet-jp類似度計算 | 必須 | SQLite |
| インテリジェントスコアリング | 複合アルゴリズム精度 | 必須 | 全DB |
| 学習・フィードバック | 動的重み調整機能 | 必須 | MongoDB |
| キャッシュ性能 | Redisキャッシュ戦略 | 必須 | Redis |
| 性能監視 | メトリクス収集・分析 | 推奨 | InfluxDB |
| セキュリティ | 暗号化・アクセス制御 | 必須 | 全DB |

### 1.3 テスト実行環境
```yaml
database_environment:
  sqlite:
    path: "./dbs/main.db"
    version: "3.40+"
    encryption: "SQLCipher AES-256"
  
  mongodb:
    uri: "mongodb://localhost:27017/haqei"
    version: "6.0+"
    collections: ["feedback", "learning_stats", "analysis_logs"]
  
  redis:
    uri: "redis://localhost:6379"
    version: "7.0+"
    memory: "50MB"
  
  influxdb:
    uri: "http://localhost:8086"
    version: "2.6+"
    bucket: "haqei_metrics"

natural_language_processing:
  mecab:
    dictionary: "./data/ipadic"
    custom_dict: "./data/yijing_terms.csv"
  
  wordnet:
    version: "WordNet-jp 1.1"
    database: "./dbs/synonyms.db"
```

---

## 2. データベース統合テスト

### 2.1 SQLite統合テスト

#### TC-DB-001: データベース初期化テスト
```javascript
describe('SQLite Database Initialization', () => {
    let dbManager;
    
    beforeAll(async () => {
        dbManager = new SQLiteManager('./dbs/test_main.db');
    });
    
    test('形態素解析辞書テーブル作成', async () => {
        const result = await dbManager.execute(`
            CREATE TABLE IF NOT EXISTS morphology_dict (
                id INTEGER PRIMARY KEY,
                word TEXT NOT NULL,
                reading TEXT,
                part_of_speech TEXT,
                semantic_category TEXT,
                INDEX idx_word (word)
            )
        `);
        
        expect(result).toBeDefined();
        
        // インデックス確認
        const indexes = await dbManager.getIndexes('morphology_dict');
        expect(indexes.some(idx => idx.name === 'idx_word')).toBe(true);
    });
    
    test('類義語辞書テーブル作成', async () => {
        const result = await dbManager.execute(`
            CREATE TABLE IF NOT EXISTS synonym_dict (
                id INTEGER PRIMARY KEY,
                word TEXT NOT NULL,
                synonym TEXT NOT NULL,
                similarity_score REAL,
                INDEX idx_word_synonym (word, synonym)
            )
        `);
        
        expect(result).toBeDefined();
    });
    
    test('384爻キーワード辞書テーブル作成', async () => {
        const result = await dbManager.execute(`
            CREATE TABLE IF NOT EXISTS line_keywords (
                line_id INTEGER,
                keyword TEXT,
                weight REAL DEFAULT 1.0,
                category TEXT,
                PRIMARY KEY (line_id, keyword)
            )
        `);
        
        expect(result).toBeDefined();
    });
});
```

#### TC-DB-002: データ導入・整合性テスト
```javascript
test('IPADic辞書データ導入', async () => {
    // IPADic CSV読み込み
    const ipadicData = await fs.readFile('./data/ipadic/mecab-ipadic.csv', 'utf-8');
    const lines = ipadicData.split('\n').filter(line => line.trim());
    
    // バッチ挿入テスト
    const batchSize = 1000;
    let insertedCount = 0;
    
    for (let i = 0; i < lines.length; i += batchSize) {
        const batch = lines.slice(i, i + batchSize);
        const values = batch.map(line => {
            const fields = line.split(',');
            return {
                word: fields[0],
                reading: fields[7],
                part_of_speech: fields[1],
                semantic_category: fields[2]
            };
        });
        
        await dbManager.insertBatch('morphology_dict', values);
        insertedCount += batch.length;
    }
    
    console.log(`IPADic導入完了: ${insertedCount}件`);
    
    // データ整合性確認
    const count = await dbManager.count('morphology_dict');
    expect(count).toBeGreaterThan(50000); // IPADIC最小エントリ数
    
    // サンプルデータ確認
    const sample = await dbManager.findOne('morphology_dict', { word: '易経' });
    expect(sample).toBeDefined();
    expect(sample.reading).toBeDefined();
});
```

### 2.2 MongoDB統合テスト

#### TC-DB-003: MongoDBコレクション・スキーマテスト
```javascript
describe('MongoDB Integration', () => {
    let mongoManager;
    
    beforeAll(async () => {
        mongoManager = new MongoManager('mongodb://localhost:27017/haqei_test');
        await mongoManager.connect();
    });
    
    test('ユーザーフィードバックコレクション作成', async () => {
        const collection = mongoManager.getCollection('user_feedback');
        
        // スキーマバリデーション設定
        await mongoManager.createCollection('user_feedback', {
            validator: {
                $jsonSchema: {
                    bsonType: "object",
                    required: ["timestamp", "user_input", "predicted_line", "user_feedback"],
                    properties: {
                        timestamp: { bsonType: "date" },
                        user_input: { bsonType: "string", minLength: 1 },
                        predicted_line: { bsonType: "int", minimum: 1, maximum: 384 },
                        user_feedback: {
                            bsonType: "object",
                            required: ["correct_line", "accuracy_rating"],
                            properties: {
                                correct_line: { bsonType: "int", minimum: 1, maximum: 384 },
                                accuracy_rating: { bsonType: "int", minimum: 1, maximum: 5 }
                            }
                        }
                    }
                }
            }
        });
        
        expect(collection).toBeDefined();
    });
    
    test('フィードバックデータ挿入・検索テスト', async () => {
        const testFeedback = {
            timestamp: new Date(),
            user_input: "リーダーシップを発揮したい",
            predicted_line: 5,
            user_feedback: {
                correct_line: 5,
                accuracy_rating: 5
            },
            analysis_data: {
                extracted_keywords: ["リーダー", "発揮"],
                morphology_result: { /* MeCab結果 */ },
                similarity_scores: { /* WordNet結果 */ }
            }
        };
        
        const result = await mongoManager.insertOne('user_feedback', testFeedback);
        expect(result.insertedId).toBeDefined();
        
        // 検索テスト
        const found = await mongoManager.findOne('user_feedback', { 
            "user_feedback.correct_line": 5 
        });
        expect(found).toBeDefined();
        expect(found.user_input).toBe("リーダーシップを発揮したい");
    });
});
```

### 2.3 Redis統合テスト

#### TC-DB-004: Redis キャッシュシステムテスト
```javascript
describe('Redis Cache Integration', () => {
    let redisManager;
    
    beforeAll(async () => {
        redisManager = new RedisManager('redis://localhost:6379');
        await redisManager.connect();
    });
    
    test('分析結果キャッシュ機能', async () => {
        const inputText = "新しいプロジェクトを始める";
        const textHash = crypto.createHash('sha256').update(inputText).digest('hex').substring(0, 16);
        const cacheKey = `analysis:${textHash}:result`;
        
        // 分析結果のモック
        const analysisResult = {
            line_384_id: 1,
            confidence_score: 0.85,
            morphology: ["新しい", "プロジェクト", "始める"],
            synonyms_matched: ["開始", "発端", "創始"],
            processing_time: 3.2
        };
        
        // キャッシュ保存
        await redisManager.setex(cacheKey, 3600, JSON.stringify(analysisResult));
        
        // キャッシュ取得・検証
        const cached = await redisManager.get(cacheKey);
        expect(cached).toBeDefined();
        
        const parsedResult = JSON.parse(cached);
        expect(parsedResult.line_384_id).toBe(1);
        expect(parsedResult.confidence_score).toBe(0.85);
        
        // TTL確認
        const ttl = await redisManager.ttl(cacheKey);
        expect(ttl).toBeGreaterThan(3500);
        expect(ttl).toBeLessThanOrEqual(3600);
    });
    
    test('形態素解析結果キャッシュ', async () => {
        const text = "易経の知恵を活用する";
        const textHash = crypto.createHash('sha256').update(text).digest('hex').substring(0, 16);
        const cacheKey = `morphology:${textHash}`;
        
        const morphologyResult = {
            tokens: [
                { surface: "易経", pos: "名詞", reading: "エキケイ" },
                { surface: "の", pos: "助詞", reading: "ノ" },
                { surface: "知恵", pos: "名詞", reading: "チエ" },
                { surface: "を", pos: "助詞", reading: "ヲ" },
                { surface: "活用", pos: "動詞", reading: "カツヨウ" },
                { surface: "する", pos: "動詞", reading: "スル" }
            ],
            keywords: ["易経", "知恵", "活用"],
            semantic_categories: ["哲学", "学問", "行動"]
        };
        
        // 24時間キャッシュ
        await redisManager.setex(cacheKey, 86400, JSON.stringify(morphologyResult));
        
        const cached = await redisManager.get(cacheKey);
        const parsed = JSON.parse(cached);
        
        expect(parsed.tokens).toHaveLength(6);
        expect(parsed.keywords).toContain("易経");
        expect(parsed.semantic_categories).toContain("哲学");
    });
});
```

---

## 3. 自然言語処理システムテスト

### 3.1 MeCab形態素解析テスト

#### TC-NLP-001: MeCab統合・精度テスト
```javascript
describe('MeCab Morphological Analysis', () => {
    let mecabAnalyzer;
    
    beforeAll(async () => {
        mecabAnalyzer = new AdvancedMeCabAnalyzer('./data/ipadic');
        await mecabAnalyzer.initialize();
    });
    
    test('日本語文章の形態素解析', async () => {
        const testText = "易経の六十四卦から人生の知恵を学ぶ";
        const result = await mecabAnalyzer.analyze(testText);
        
        // 基本構造確認
        expect(result).toHaveProperty('tokens');
        expect(result).toHaveProperty('keywords');
        expect(result).toHaveProperty('semantic_categories');
        
        // トークン解析結果確認
        expect(result.tokens).toBeDefined();
        expect(result.tokens.length).toBeGreaterThan(5);
        
        // 易経関連キーワード抽出確認
        expect(result.keywords).toContain("易経");
        expect(result.keywords).toContain("六十四卦");
        expect(result.keywords).toContain("知恵");
        
        // 意味カテゴリー分類確認
        expect(result.semantic_categories).toContain("哲学");
        expect(result.semantic_categories).toContain("学問");
    });
    
    test('専門用語辞書統合テスト', async () => {
        // 易経専門用語テスト
        const yijingTerms = [
            "乾為天", "坤為地", "水雷屯", "山水蒙",
            "陰爻", "陽爻", "上卦", "下卦",
            "爻辞", "卦辞", "彖辞", "象辞"
        ];
        
        for (const term of yijingTerms) {
            const result = await mecabAnalyzer.analyze(term);
            
            // 専門用語として認識されているか
            const termToken = result.tokens.find(token => token.surface === term);
            if (termToken) {
                expect(termToken.pos).toContain("名詞");
                expect(result.semantic_categories).toContain("易経");
            }
            
            // キーワードとして抽出されているか
            expect(result.keywords).toContain(term);
        }
    });
});
```

### 3.2 WordNet類義語システムテスト

#### TC-NLP-002: WordNet-jp統合・類似度計算テスト
```javascript
describe('WordNet Synonym Matching', () => {
    let synonymMatcher;
    
    beforeAll(async () => {
        synonymMatcher = new SynonymMatcher();
        await synonymMatcher.initialize();
    });
    
    test('類義語類似度計算（Wu-Palmer）', async () => {
        const testPairs = [
            { word1: "リーダー", word2: "指導者", expectedSim: 0.8 },
            { word1: "始まり", word2: "開始", expectedSim: 0.7 },
            { word1: "困難", word2: "問題", expectedSim: 0.6 },
            { word1: "成功", word2: "達成", expectedSim: 0.7 },
            { word1: "知恵", word2: "智慧", expectedSim: 0.9 }
        ];
        
        for (const pair of testPairs) {
            const similarity = await synonymMatcher.findSimilarity(pair.word1, pair.word2);
            
            expect(similarity).toBeGreaterThan(pair.expectedSim - 0.2);
            expect(similarity).toBeLessThanOrEqual(1.0);
            
            console.log(`${pair.word1} - ${pair.word2}: ${similarity.toFixed(3)}`);
        }
    });
    
    test('易経用語類義語マッピング', async () => {
        const yijingSynonyms = [
            { term: "乾", synonyms: ["天", "創造", "父性"] },
            { term: "坤", synonyms: ["地", "受容", "母性"] },
            { term: "震", synonyms: ["雷", "動き", "長男"] },
            { term: "巽", synonyms: ["風", "柔軟", "長女"] }
        ];
        
        for (const entry of yijingSynonyms) {
            for (const synonym of entry.synonyms) {
                const similarity = await synonymMatcher.findSimilarity(entry.term, synonym);
                
                // 易経用語の類義語は高い類似度を期待
                expect(similarity).toBeGreaterThan(0.3);
                
                console.log(`${entry.term} - ${synonym}: ${similarity.toFixed(3)}`);
            }
        }
    });
});
```

---

## 4. インテリジェントスコアリングテスト

### 4.1 統合スコアリングアルゴリズムテスト

#### TC-SCORING-001: 複合アルゴリズム精度テスト
```javascript
describe('Intelligent Scoring Algorithm', () => {
    let intelligentScorer;
    
    beforeAll(async () => {
        intelligentScorer = new IntelligentScoringEngine();
        await intelligentScorer.initialize();
    });
    
    test('5要素統合スコアリング', async () => {
        const testCases = [
            {
                input: "リーダーとして組織を率いて成功に導く",
                expectedLineRange: [5, 23, 41, 59, 77, 95], // 五爻（リーダーポジション）
                expectedMinScore: 0.7
            },
            {
                input: "新しい事業を始める準備をしている",
                expectedLineRange: [1, 19, 37, 55, 73, 91], // 初爻（始まりポジション）
                expectedMinScore: 0.6
            },
            {
                input: "困難な問題に直面して解決策を模索する",
                expectedLineRange: [3, 21, 39, 57, 75, 93], // 三爻（困難ポジション）
                expectedMinScore: 0.6
            }
        ];
        
        for (const testCase of testCases) {
            const result = await intelligentScorer.calculateComprehensiveScore(testCase.input);
            
            // 結果構造確認
            expect(result).toHaveProperty('final_line_id');
            expect(result).toHaveProperty('confidence_score');
            expect(result).toHaveProperty('component_scores');
            
            // 信頼度確認
            expect(result.confidence_score).toBeGreaterThan(testCase.expectedMinScore);
            
            // 期待されるポジション範囲確認
            expect(testCase.expectedLineRange).toContain(result.final_line_id);
            
            // 構成要素スコア確認
            const scores = result.component_scores;
            expect(scores).toHaveProperty('morphology_score');
            expect(scores).toHaveProperty('synonym_score');
            expect(scores).toHaveProperty('yaoci_score');
            expect(scores).toHaveProperty('learning_score');
            expect(scores).toHaveProperty('context_score');
            
            // スコア配分確認（各要素が寄与しているか）
            expect(scores.morphology_score).toBeGreaterThan(0);
            expect(scores.synonym_score).toBeGreaterThan(0);
            expect(scores.yaoci_score).toBeGreaterThan(0);
            
            console.log(`入力: "${testCase.input}"`);
            console.log(`結果: Line ${result.final_line_id}, 信頼度: ${result.confidence_score.toFixed(3)}`);
            console.log('構成要素スコア:', scores);
        }
    });
    
    test('学習重み動的調整テスト', async () => {
        // 初期状態のスコア取得
        const inputText = "指導者として決断を下す";
        const initialResult = await intelligentScorer.calculateComprehensiveScore(inputText);
        
        // フィードバックデータ送信（正解：五爻）
        await intelligentScorer.submitFeedback({
            input: inputText,
            predicted_line: initialResult.final_line_id,
            correct_line: 5, // 乾為天 九五
            accuracy_rating: 5
        });
        
        // 学習後のスコア再計算
        const learnedResult = await intelligentScorer.calculateComprehensiveScore(inputText);
        
        // 学習効果確認
        if (initialResult.final_line_id !== 5) {
            // 学習により五爻への重みが増加しているか
            expect(learnedResult.component_scores.learning_score).toBeGreaterThan(
                initialResult.component_scores.learning_score
            );
        }
        
        console.log('学習前スコア:', initialResult.component_scores);
        console.log('学習後スコア:', learnedResult.component_scores);
    });
});
```

---

## 5. 性能・品質テスト

### 5.1 性能ベンチマークテスト

#### TC-PERF-001: レスポンス時間・スループットテスト
```javascript
describe('Performance Benchmarks', () => {
    let performanceTester;
    
    beforeAll(async () => {
        performanceTester = new PerformanceTester();
        await performanceTester.initialize();
    });
    
    test('平均レスポンス時間テスト（キャッシュヒット時）', async () => {
        const testInputs = [
            "リーダーシップを発揮する",
            "新しいプロジェクトを始める",
            "困難な問題を解決する"
        ];
        
        // 初回実行（キャッシュ構築）
        for (const input of testInputs) {
            await performanceTester.analyzeText(input);
        }
        
        // キャッシュヒット時のパフォーマンス測定
        const times = [];
        for (let i = 0; i < 100; i++) {
            const randomInput = testInputs[i % testInputs.length];
            
            const startTime = performance.now();
            await performanceTester.analyzeText(randomInput);
            const endTime = performance.now();
            
            times.push(endTime - startTime);
        }
        
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        const p95Time = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];
        const p99Time = times.sort((a, b) => a - b)[Math.floor(times.length * 0.99)];
        
        console.log(`キャッシュヒット時パフォーマンス:`);
        console.log(`平均: ${avgTime.toFixed(2)}ms`);
        console.log(`95%ile: ${p95Time.toFixed(2)}ms`);
        console.log(`99%ile: ${p99Time.toFixed(2)}ms`);
        
        // 性能要件確認
        expect(avgTime).toBeLessThan(1.0);  // 平均1ms以内
        expect(p95Time).toBeLessThan(2.0);  // 95%で2ms以内
        expect(p99Time).toBeLessThan(5.0);  // 99%で5ms以内
    });
    
    test('初回分析レスポンス時間テスト', async () => {
        const newInputs = [
            "古典的な智慧を現代に応用する方法論",
            "組織変革のリーダーシップ実践論",
            "創造的問題解決の思考フレームワーク"
        ];
        
        const times = [];
        for (const input of newInputs) {
            // キャッシュクリア
            await performanceTester.clearCache(input);
            
            const startTime = performance.now();
            await performanceTester.analyzeText(input);
            const endTime = performance.now();
            
            times.push(endTime - startTime);
        }
        
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        const maxTime = Math.max(...times);
        
        console.log(`初回分析パフォーマンス:`);
        console.log(`平均: ${avgTime.toFixed(2)}ms`);
        console.log(`最大: ${maxTime.toFixed(2)}ms`);
        
        // 性能要件確認
        expect(avgTime).toBeLessThan(5.0);   // 平均5ms以内
        expect(maxTime).toBeLessThan(10.0);  // 最大10ms以内
    });
    
    test('同時接続負荷テスト', async () => {
        const concurrentUsers = 50;
        const requestsPerUser = 10;
        
        const promises = [];
        
        for (let user = 0; user < concurrentUsers; user++) {
            const userRequests = [];
            for (let req = 0; req < requestsPerUser; req++) {
                userRequests.push(
                    performanceTester.analyzeText(`ユーザー${user}リクエスト${req}: リーダーとして決断する`)
                );
            }
            promises.push(Promise.all(userRequests));
        }
        
        const startTime = performance.now();
        await Promise.all(promises);
        const endTime = performance.now();
        
        const totalTime = endTime - startTime;
        const totalRequests = concurrentUsers * requestsPerUser;
        const throughput = totalRequests / (totalTime / 1000);
        
        console.log(`同時接続負荷テスト結果:`);
        console.log(`総リクエスト: ${totalRequests}`);
        console.log(`総実行時間: ${totalTime.toFixed(0)}ms`);
        console.log(`スループット: ${throughput.toFixed(1)} req/sec`);
        
        // スループット要件確認
        expect(throughput).toBeGreaterThan(100); // 100 req/sec以上
    });
});
```

### 5.2 データベース性能テスト

#### TC-PERF-002: データベース別性能テスト
```javascript
describe('Database Performance', () => {
    test('SQLiteクエリ性能テスト', async () => {
        const sqliteManager = new SQLiteManager('./dbs/main.db');
        
        // 形態素解析辞書クエリ性能
        const morphologyQueries = [
            "SELECT * FROM morphology_dict WHERE word = 'リーダー'",
            "SELECT * FROM morphology_dict WHERE word LIKE '始まり%'",
            "SELECT * FROM synonym_dict WHERE word = '成功' ORDER BY similarity_score DESC LIMIT 10"
        ];
        
        for (const query of morphologyQueries) {
            const times = [];
            
            for (let i = 0; i < 100; i++) {
                const startTime = performance.now();
                await sqliteManager.execute(query);
                const endTime = performance.now();
                times.push(endTime - startTime);
            }
            
            const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
            console.log(`SQLite Query: ${avgTime.toFixed(3)}ms - ${query.substring(0, 50)}...`);
            
            // SQLite性能要件：0.5ms以内
            expect(avgTime).toBeLessThan(0.5);
        }
    });
    
    test('MongoDB書き込み性能テスト', async () => {
        const mongoManager = new MongoManager('mongodb://localhost:27017/haqei');
        
        const sampleFeedback = {
            timestamp: new Date(),
            user_input: "性能テスト用入力",
            predicted_line: 1,
            user_feedback: { correct_line: 1, accuracy_rating: 5 }
        };
        
        const times = [];
        
        for (let i = 0; i < 50; i++) {
            const testData = { ...sampleFeedback, test_id: i };
            
            const startTime = performance.now();
            await mongoManager.insertOne('user_feedback', testData);
            const endTime = performance.now();
            
            times.push(endTime - startTime);
        }
        
        const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
        console.log(`MongoDB書き込み平均時間: ${avgTime.toFixed(3)}ms`);
        
        // MongoDB性能要件：2ms以内
        expect(avgTime).toBeLessThan(2.0);
    });
    
    test('Redis操作性能テスト', async () => {
        const redisManager = new RedisManager('redis://localhost:6379');
        
        const operations = [
            () => redisManager.set('perf_test_key', 'test_value'),
            () => redisManager.get('perf_test_key'),
            () => redisManager.setex('perf_test_ttl', 3600, 'ttl_value'),
            () => redisManager.del('perf_test_key')
        ];
        
        for (const operation of operations) {
            const times = [];
            
            for (let i = 0; i < 1000; i++) {
                const startTime = performance.now();
                await operation();
                const endTime = performance.now();
                times.push(endTime - startTime);
            }
            
            const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
            console.log(`Redis操作平均時間: ${avgTime.toFixed(3)}ms`);
            
            // Redis性能要件：0.1ms以内
            expect(avgTime).toBeLessThan(0.1);
        }
    });
});
```

---

## 6. セキュリティテスト

### 6.1 暗号化・アクセス制御テスト

#### TC-SEC-001: データベース暗号化テスト
```javascript
describe('Database Security', () => {
    test('SQLCipher暗号化テスト', async () => {
        const encryptedDB = new SQLiteManager('./dbs/encrypted_test.db', {
            encryption: {
                key: 'test_encryption_key_256bit_length_required',
                cipher: 'aes-256-gcm'
            }
        });
        
        // 暗号化データベースへの書き込み
        await encryptedDB.execute(`
            CREATE TABLE test_secure (
                id INTEGER PRIMARY KEY,
                sensitive_data TEXT
            )
        `);
        
        await encryptedDB.insert('test_secure', {
            sensitive_data: 'このデータは暗号化されています'
        });
        
        // 正しいキーでの読み込み
        const result = await encryptedDB.findOne('test_secure', { id: 1 });
        expect(result.sensitive_data).toBe('このデータは暗号化されています');
        
        // 暗号化なしでのアクセス試行（失敗するべき）
        const unencryptedDB = new SQLiteManager('./dbs/encrypted_test.db');
        
        try {
            await unencryptedDB.execute('SELECT * FROM test_secure');
            fail('暗号化なしでのアクセスが成功してしまいました');
        } catch (error) {
            expect(error.message).toContain('database is locked');
        }
    });
    
    test('MongoDB認証・認可テスト', async () => {
        // 認証情報を含むMongoDB接続
        const secureMongoManager = new MongoManager(
            'mongodb://haqei_user:secure_password@localhost:27017/haqei',
            {
                authSource: 'haqei',
                authMechanism: 'SCRAM-SHA-256'
            }
        );
        
        await secureMongoManager.connect();
        
        // 権限内操作（成功するべき）
        const result = await secureMongoManager.insertOne('user_feedback', {
            test: 'authorized_access',
            timestamp: new Date()
        });
        expect(result.insertedId).toBeDefined();
        
        // 権限外操作テスト（必要に応じて）
        // 管理者限定コレクションへのアクセス等
    });
});
```

### 6.2 入力検証・SQLインジェクション防止テスト

#### TC-SEC-002: 入力セキュリティテスト
```javascript
describe('Input Security', () => {
    test('SQLインジェクション防止テスト', async () => {
        const sqliteManager = new SQLiteManager('./dbs/main.db');
        
        // SQLインジェクション試行パターン
        const injectionAttempts = [
            "'; DROP TABLE morphology_dict; --",
            "' OR '1'='1",
            "admin'--",
            "admin'/*",
            "' UNION SELECT password FROM users--"
        ];
        
        for (const maliciousInput of injectionAttempts) {
            try {
                // パラメータ化クエリでの安全な実行
                const result = await sqliteManager.findOne('morphology_dict', { 
                    word: maliciousInput 
                });
                
                // インジェクション失敗（正常動作）
                expect(result).toBeNull(); // 該当レコードなし
                
            } catch (error) {
                // パラメータ化により安全にエラーハンドリング
                expect(error.message).not.toContain('syntax error');
            }
        }
    });
    
    test('NoSQLインジェクション防止テスト', async () => {
        const mongoManager = new MongoManager('mongodb://localhost:27017/haqei');
        
        // NoSQLインジェクション試行パターン
        const noSQLInjections = [
            { user_input: { $ne: null } },
            { user_input: { $regex: ".*", $options: "i" } },
            { user_input: { $where: "this.password == 'admin'" } }
        ];
        
        for (const injection of noSQLInjections) {
            try {
                // 適切な入力検証とサニタイゼーション
                const sanitizedQuery = mongoManager.sanitizeQuery(injection);
                const result = await mongoManager.findOne('user_feedback', sanitizedQuery);
                
                // インジェクション防止成功
                expect(result).not.toBe('INJECTION_SUCCESS');
                
            } catch (error) {
                // 適切なエラーハンドリング
                expect(error.message).toContain('Invalid query format');
            }
        }
    });
});
```

---

## 7. 統合・E2Eテスト

### 7.1 エンドツーエンドシナリオテスト

#### TC-E2E-001: 完全ワークフローテスト
```javascript
describe('End-to-End Workflow Tests', () => {
    let textTo384Bridge;
    
    beforeAll(async () => {
        // 全システム初期化
        textTo384Bridge = new TextTo384LinesBridge();
        await textTo384Bridge.initializeAll(); // 全DB + NLP初期化
    });
    
    test('完全分析ワークフロー：入力→分析→学習', async () => {
        const testScenario = {
            user_input: "組織のリーダーとして困難な時期に決断を下し、チームを成功へ導く責任を持つ",
            expected_themes: ["リーダーシップ", "責任", "決断", "困難", "成功"],
            expected_position_range: [5], // 五爻（リーダーポジション）
            user_feedback: {
                correct_line: 5, // 乾為天 九五
                accuracy_rating: 5
            }
        };
        
        // Phase 1: 完全分析実行
        console.log("Phase 1: 完全分析実行");
        const analysisResult = await textTo384Bridge.analyzeTextToSpecificLine(testScenario.user_input);
        
        // 分析結果検証
        expect(analysisResult).toHaveProperty('line_384_id');
        expect(analysisResult).toHaveProperty('confidence_score');
        expect(analysisResult).toHaveProperty('analysis_breakdown');
        
        const breakdown = analysisResult.analysis_breakdown;
        expect(breakdown).toHaveProperty('morphology_analysis');
        expect(breakdown).toHaveProperty('synonym_matches');
        expect(breakdown).toHaveProperty('yaoci_relevance');
        expect(breakdown).toHaveProperty('learning_weights');
        
        // 形態素解析結果確認
        expect(breakdown.morphology_analysis.keywords).toEqual(
            expect.arrayContaining(["リーダー", "決断", "責任"])
        );
        
        // 類義語マッチング確認
        expect(breakdown.synonym_matches.length).toBeGreaterThan(0);
        expect(breakdown.synonym_matches.some(match => 
            match.synonym.includes("指導者") || match.synonym.includes("統率")
        )).toBe(true);
        
        console.log("分析結果:", {
            line_id: analysisResult.line_384_id,
            confidence: analysisResult.confidence_score,
            morphology: breakdown.morphology_analysis.keywords,
            synonyms: breakdown.synonym_matches.map(m => m.synonym)
        });
        
        // Phase 2: フィードバック送信と学習
        console.log("Phase 2: フィードバック送信と学習");
        const feedbackResult = await textTo384Bridge.submitUserFeedback({
            original_input: testScenario.user_input,
            predicted_line: analysisResult.line_384_id,
            user_feedback: testScenario.user_feedback,
            analysis_data: breakdown
        });
        
        expect(feedbackResult.feedback_id).toBeDefined();
        expect(feedbackResult.learning_applied).toBe(true);
        
        // Phase 3: 学習効果確認（再分析）
        console.log("Phase 3: 学習効果確認");
        await new Promise(resolve => setTimeout(resolve, 100)); // 学習反映待機
        
        const reAnalysisResult = await textTo384Bridge.analyzeTextToSpecificLine(testScenario.user_input);
        
        // 学習効果確認
        if (analysisResult.line_384_id !== testScenario.user_feedback.correct_line) {
            // 学習により正解への重みが増加しているか
            expect(reAnalysisResult.confidence_score).toBeGreaterThan(analysisResult.confidence_score);
            expect(reAnalysisResult.analysis_breakdown.learning_weights[testScenario.user_feedback.correct_line])
                .toBeGreaterThan(breakdown.learning_weights[testScenario.user_feedback.correct_line] || 0);
        }
        
        console.log("学習効果:", {
            original_line: analysisResult.line_384_id,
            learned_line: reAnalysisResult.line_384_id,
            confidence_improvement: reAnalysisResult.confidence_score - analysisResult.confidence_score
        });
        
        // Phase 4: キャッシュ動作確認
        console.log("Phase 4: キャッシュ動作確認");
        const cachedStartTime = performance.now();
        const cachedResult = await textTo384Bridge.analyzeTextToSpecificLine(testScenario.user_input);
        const cachedEndTime = performance.now();
        
        const cachedResponseTime = cachedEndTime - cachedStartTime;
        expect(cachedResponseTime).toBeLessThan(2.0); // キャッシュ効果で高速化
        
        expect(cachedResult.line_384_id).toBe(reAnalysisResult.line_384_id); // 結果一貫性
        
        console.log("キャッシュ性能:", {
            response_time: cachedResponseTime.toFixed(2) + "ms",
            cache_hit: cachedResult.cache_hit || false
        });
    });
});
```

---

## 8. 品質メトリクス・継続監視テスト

### 8.1 システム品質メトリクス

#### TC-METRICS-001: InfluxDBメトリクス収集テスト
```javascript
describe('Quality Metrics Collection', () => {
    let metricsCollector;
    
    beforeAll(async () => {
        metricsCollector = new InfluxDBMetricsCollector('http://localhost:8086');
        await metricsCollector.initialize();
    });
    
    test('性能メトリクス収集・集約', async () => {
        // 性能メトリクス生成（実際の分析処理実行）
        const testInputs = [
            "リーダーとして決断を下す",
            "新しいプロジェクトを開始する", 
            "困難な問題を解決する方法を模索する"
        ];
        
        for (const input of testInputs) {
            const startTime = Date.now();
            
            const result = await textTo384Bridge.analyzeTextToSpecificLine(input);
            
            const endTime = Date.now();
            const responseTime = endTime - startTime;
            
            // InfluxDBにメトリクス送信
            await metricsCollector.writeMetrics('analysis_performance', {
                response_time: responseTime,
                confidence_score: result.confidence_score,
                cache_hit: result.cache_hit || false,
                line_id: result.line_384_id
            }, {
                input_length: input.length,
                timestamp: startTime
            });
        }
        
        // メトリクス集約・確認
        const aggregatedMetrics = await metricsCollector.query(`
            SELECT 
                MEAN(response_time) as avg_response_time,
                PERCENTILE(response_time, 95) as p95_response_time,
                MEAN(confidence_score) as avg_confidence,
                COUNT(*) as total_requests
            FROM analysis_performance 
            WHERE time >= now() - 5m
        `);
        
        expect(aggregatedMetrics.length).toBeGreaterThan(0);
        
        const metrics = aggregatedMetrics[0];
        expect(metrics.avg_response_time).toBeLessThan(10); // 10ms以内
        expect(metrics.p95_response_time).toBeLessThan(20); // 95%ile 20ms以内
        expect(metrics.avg_confidence).toBeGreaterThan(0.5); // 平均信頼度50%以上
        
        console.log("性能メトリクス:", {
            avg_response: metrics.avg_response_time.toFixed(2) + "ms",
            p95_response: metrics.p95_response_time.toFixed(2) + "ms", 
            avg_confidence: metrics.avg_confidence.toFixed(3),
            total_requests: metrics.total_requests
        });
    });
    
    test('分類精度・カバー率メトリクス', async () => {
        const testSamples = 100;
        const usedLines = new Set();
        let correctPredictions = 0;
        
        // テストサンプル生成・分析
        for (let i = 0; i < testSamples; i++) {
            const testInput = generateTestInput(i); // テスト用入力生成
            const result = await textTo384Bridge.analyzeTextToSpecificLine(testInput);
            
            usedLines.add(result.line_384_id);
            
            // 信頼度が高い場合を正解とみなす（簡易評価）
            if (result.confidence_score > 0.7) {
                correctPredictions++;
            }
            
            // メトリクス記録
            await metricsCollector.writeMetrics('classification_quality', {
                line_id: result.line_384_id,
                confidence_score: result.confidence_score,
                is_high_confidence: result.confidence_score > 0.7
            }, {
                sample_id: i,
                timestamp: Date.now()
            });
        }
        
        // カバー率計算
        const coverageRate = usedLines.size / 384;
        const accuracyRate = correctPredictions / testSamples;
        
        // 品質メトリクス記録
        await metricsCollector.writeMetrics('system_quality', {
            coverage_rate: coverageRate,
            accuracy_rate: accuracyRate,
            unique_lines_used: usedLines.size,
            total_samples: testSamples
        });
        
        console.log("品質メトリクス:", {
            coverage_rate: (coverageRate * 100).toFixed(1) + "%",
            accuracy_rate: (accuracyRate * 100).toFixed(1) + "%",
            unique_lines: usedLines.size
        });
        
        // 品質要件確認
        expect(coverageRate).toBeGreaterThan(0.20); // カバー率20%以上
        expect(accuracyRate).toBeGreaterThan(0.70); // 精度70%以上
    });
});

function generateTestInput(index) {
    const patterns = [
        "リーダーとして組織を導く",
        "新しい挑戦を始める",
        "困難な問題に立ち向かう",
        "成長の機会を掴む",
        "変化の時代を乗り越える",
        "知恵と経験を活かす"
    ];
    
    const variations = [
        "方法を模索している",
        "戦略を練っている", 
        "決意を固めている",
        "責任を感じている",
        "可能性を信じている"
    ];
    
    const pattern = patterns[index % patterns.length];
    const variation = variations[Math.floor(index / patterns.length) % variations.length];
    
    return `${pattern}${variation}`;
}
```

---

## 9. 受け入れテスト基準

### 9.1 必須合格基準

| カテゴリ | テスト項目 | 合格基準 | 測定方法 |
|---------|-----------|---------|---------|
| **データベース統合** | 4DB接続成功率 | 100% | 起動時接続テスト |
| **データベース統合** | データ整合性 | 100% | 全テーブル整合性チェック |
| **自然言語処理** | MeCab解析成功率 | 95%以上 | 1000サンプルテスト |
| **自然言語処理** | WordNet類似度計算 | 90%以上 | 類義語ペアテスト |
| **インテリジェント分析** | 分類精度 | 85%以上 | 専門家評価500サンプル |
| **インテリジェント分析** | カバー率 | 60%以上 | 1000サンプル分析 |
| **学習機能** | フィードバック反映率 | 80%以上 | 学習前後比較 |
| **性能** | 平均レスポンス時間 | 3ms以内 | 1000回実行平均 |
| **性能** | 95%ileレスポンス時間 | 5ms以内 | パフォーマンステスト |
| **性能** | 同時接続対応 | 100ユーザー | 負荷テスト |
| **セキュリティ** | 暗号化動作 | 100% | SQLCipher検証 |
| **セキュリティ** | インジェクション防止 | 100% | 攻撃パターンテスト |

### 9.2 段階別受け入れ基準

#### Phase 1: データベース基盤（Week 1-2）
```yaml
必須要件:
  - SQLite接続・テーブル作成: 100%成功
  - MongoDB接続・コレクション作成: 100%成功  
  - Redis接続・キャッシュ操作: 100%成功
  - 基本データ導入: IPADic, WordNet-jp完了
  
評価基準:
  - データベース起動・接続時間: 5秒以内
  - 基本クエリ応答時間: SQLite 1ms, MongoDB 3ms, Redis 0.1ms
  - データ整合性: 100%（欠損・重複なし）
```

#### Phase 2: NLP・AI機能（Week 3-5）
```yaml
必須要件:
  - MeCab形態素解析: 95%以上の精度
  - WordNet類義語マッチング: 90%以上の適合率
  - インテリジェントスコアリング: 85%以上の分類精度
  - キャッシュシステム: 95%以上のヒット率（同一入力）
  
評価基準:
  - 分析処理時間: 平均5ms以内
  - カバー率: 40%以上（200サンプルテスト）
  - 信頼度分布: 70%以上のクエリで0.6以上のスコア
```

#### Phase 3: 学習・最適化（Week 6-8）
```yaml
必須要件:
  - フィードバック学習: 80%以上の改善効果
  - 性能最適化: 平均3ms以内のレスポンス
  - 監視システム: InfluxDB + Grafanaダッシュボード
  - セキュリティ: SQLCipher暗号化、認証・認可完備
  
評価基準:
  - 分類精度: 85%以上（専門家評価）
  - カバー率: 60%以上（1000サンプル）
  - 学習効果: 月次で2%以上の精度改善
  - 稼働率: 99.9%以上（監視システム確認）
```

---

## 10. テスト実行・運用ガイド

### 10.1 テスト実行コマンド

#### 環境セットアップ
```bash
# データベース環境構築
./scripts/setup-databases.sh

# テストデータ導入
./scripts/import-test-data.sh

# MCP（Multi-database Control Protocol）起動
npm run mcp:databases
```

#### テスト実行
```bash
# 全テスト実行
npm test -- --testPathPattern=384-database-integration

# カテゴリ別テスト
npm test -- --testNamePattern="Database Integration"
npm test -- --testNamePattern="NLP Processing" 
npm test -- --testNamePattern="Performance"
npm test -- --testNamePattern="Security"

# カバレッジレポート
npm test -- --coverage --testPathPattern=384

# 性能ベンチマーク
npm run benchmark:384-system

# E2Eテスト（本番データベース使用）
npm run test:e2e:384-integration
```

#### 継続監視
```bash
# メトリクス収集開始
npm run metrics:start

# Grafanaダッシュボード起動
docker-compose up grafana

# アラート設定確認
./scripts/check-monitoring-alerts.sh
```

### 10.2 テスト結果レポート

#### 自動レポート生成
```javascript
// テスト完了後の自動レポート
const generateTestReport = async () => {
    const report = {
        test_summary: {
            total_tests: jest.getTestResults().numTotalTests,
            passed_tests: jest.getTestResults().numPassedTests,
            failed_tests: jest.getTestResults().numFailedTests,
            coverage_percentage: jest.getCoverageData().percentage
        },
        
        database_metrics: {
            sqlite_avg_response: await measureSQLitePerformance(),
            mongodb_avg_response: await measureMongoDBPerformance(), 
            redis_avg_response: await measureRedisPerformance(),
            influxdb_status: await checkInfluxDBConnection()
        },
        
        quality_metrics: {
            classification_accuracy: await calculateClassificationAccuracy(),
            coverage_rate: await calculateCoverageRate(),
            learning_effectiveness: await measureLearningEffectiveness()
        },
        
        security_verification: {
            encryption_status: await verifySQLCipherEncryption(),
            injection_prevention: await testInjectionPrevention(),
            authentication_status: await verifyDatabaseAuthentication()
        }
    };
    
    // レポートファイル生成
    await fs.writeFile(
        `./test-reports/384-integration-report-${new Date().toISOString().split('T')[0]}.json`,
        JSON.stringify(report, null, 2)
    );
    
    // SlackやEmailでの通知
    await notifyTestCompletion(report);
};
```

---

## 11. トラブルシューティング・FAQ

### 11.1 よくある問題と対策

#### データベース接続エラー
```yaml
問題: "SQLite database locked"
原因: 複数プロセスの同時アクセス
対策: 
  - connection poolingの確認
  - WAL modeの有効化
  - ファイルロック状況の確認

問題: "MongoDB connection timeout"
原因: ネットワーク・認証設定
対策:
  - MongoDB service起動確認
  - 認証情報の確認
  - ファイアウォール設定確認

問題: "Redis ECONNREFUSED"
原因: Redisサーバー未起動
対策:
  - Redis service開始
  - ポート番号確認（6379）
  - メモリ不足の確認
```

#### 自然言語処理エラー
```yaml
問題: "MeCab initialization failed"
原因: 辞書ファイル・システム設定
対策:
  - IPADic辞書の存在確認
  - MeCabパスの環境変数確認
  - 文字エンコーディング（UTF-8）確認

問題: "WordNet database not found"
原因: WordNet-jp未導入
対策:
  - WordNet-jpダウンロード・インポート
  - SQLite辞書ファイルの権限確認
  - 日本語エントリ数の検証
```

#### 性能問題
```yaml
問題: レスポンス時間が要件を超過
原因: データベースインデックス・キャッシュ設定
対策:
  - SQLiteインデックス最適化
  - Redisキャッシュ設定見直し
  - クエリ実行計画の分析

問題: メモリ使用量過多
原因: キャッシュ・接続プール設定
対策:
  - Redis maxmemory設定調整
  - 接続プールサイズ最適化
  - ガベージコレクション確認
```

### 11.2 デバッグ・ログ設定

#### 詳細ログ有効化
```javascript
// デバッグモード設定
process.env.DEBUG_384_SYSTEM = "true";
process.env.LOG_LEVEL = "debug";

// データベース別ログ設定
const logConfig = {
    sqlite: {
        enable: true,
        level: "debug",
        include_queries: true
    },
    mongodb: {
        enable: true,
        level: "info", 
        include_operations: true
    },
    redis: {
        enable: true,
        level: "warn",
        include_commands: false
    }
};

// NLP処理ログ
const nlpLogConfig = {
    mecab: {
        log_analysis_steps: true,
        log_performance: true
    },
    wordnet: {
        log_similarity_calculation: true,
        log_cache_hits: true
    }
};
```

---

## 12. 承認・完了確認

### 12.1 承認プロセス

| 段階 | 承認者 | 確認項目 | 承認基準 |
|------|-------|---------|---------|
| **Phase 1完了** | DBアーキテクト | データベース統合基盤 | 全DB接続・基本機能100%動作 |
| **Phase 2完了** | AIエンジニア | NLP・分析エンジン | 分類精度85%以上達成 |
| **Phase 3完了** | プロダクトオーナー | 完全システム統合 | 全要件満足・本番運用可能 |
| **最終承認** | CTOまたは技術責任者 | 総合品質評価 | セキュリティ・性能・品質全項目合格 |

### 12.2 完了チェックリスト

#### データベース統合基盤
- [ ] SQLite: 辞書データ完全導入・暗号化動作確認
- [ ] MongoDB: フィードバックシステム動作・認証設定完了
- [ ] Redis: キャッシュシステム動作・メモリ最適化完了
- [ ] InfluxDB: メトリクス収集・Grafana連携完了
- [ ] 全DB: 起動・接続・基本クエリが5秒以内に完了

#### AI・NLP機能
- [ ] MeCab: 日本語形態素解析95%精度達成
- [ ] WordNet: 類義語マッチング90%適合率達成
- [ ] スコアリング: 85%以上の分類精度達成
- [ ] 学習機能: フィードバック反映80%以上の効果

#### 性能・品質
- [ ] レスポンス時間: 平均3ms、95%ile 5ms以内
- [ ] 同時接続: 100ユーザー負荷テスト合格
- [ ] カバー率: 60%以上（1000サンプル）
- [ ] セキュリティ: 暗号化・認証・インジェクション防止100%

#### 運用準備
- [ ] 監視システム: InfluxDB + Grafanaダッシュボード完成
- [ ] アラート設定: 性能・エラー監視完備
- [ ] バックアップ: 自動日次バックアップ設定
- [ ] ドキュメント: 運用マニュアル・トラブルシューティング完備

---

## 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| QAリード | | | |
| DBアーキテクト | | | |
| AIエンジニア | | | |
| セキュリティエンジニア | | | |
| プロダクトオーナー | | | |
| CTO/技術責任者 | | | |

---

**文書管理**
- **作成根拠**: 要件定義書v3.0のデータベース統合アーキテクチャに基づく包括的テスト戦略
- **実行開始**: データベース環境構築完了後即座に開始可能
- **継続監視**: InfluxDB + Grafanaによる本番運用後の継続的品質監視
- **配布先**: QAチーム、開発チーム、インフラチーム、セキュリティチーム

**重要**: このテスト計画書は単純なJSONファイルテストではなく、真のエンタープライズグレード・データベース統合システムのための包括的品質保証戦略です。