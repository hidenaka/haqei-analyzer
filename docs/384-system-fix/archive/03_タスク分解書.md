# 📝 384爻システム Cloudflare Pages対応 タスク分解書

**文書番号**: TD-384-004  
**バージョン**: 4.0（Cloudflare Pages対応版）  
**作成日**: 2025年8月28日  
**作成者**: HAQEI開発チーム  
**承認者**: [未承認]  

---

## 1. タスク分解概要

### 1.1 WBS（Work Breakdown Structure）

```
384爻システム 現実的Cloudflare Pages実装プロジェクト
├─ Phase 1: 基盤構築（2週間）
│   ├─ Task 1.1: Cloudflare Pages環境セットアップ
│   ├─ Task 1.2: D1 Database初期化・koudo_shishin.json統合
│   ├─ Task 1.3: Workers KV設定・基本動作確認
│   └─ Task 1.4: IndexedDB基本キャッシュ実装
├─ Phase 2: 決定論的分析システム（2週間）
│   ├─ Task 2.1: 基本テキスト分析エンジン実装
│   ├─ Task 2.2: 決定論的スコアリングアルゴリズム実装
│   ├─ Task 2.3: 384爻データマッチング機能
│   └─ Task 2.4: キャッシング・パフォーマンス最適化
├─ Phase 3: 学習システム（2週間）
│   ├─ Task 3.1: フィードバック収集システム
│   ├─ Task 3.2: 日次バッチ学習システム実装
│   ├─ Task 3.3: データバージョニング・決定論性保証
│   └─ Task 3.4: 学習統計・レポート機能
└─ Phase 4: 統合・デプロイ（1週間）
    ├─ Task 4.1: 統合テスト・決定論性確認
    ├─ Task 4.2: 性能テスト・最適化
    ├─ Task 4.3: Cloudflare Pages本番デプロイ
    └─ Task 4.4: 運用監視・エラーハンドリング
```

### 1.2 現実的工数見積もり
- **総工数**: 7週間（35営業日）
- **必要人員**: 2名（フルスタック開発者2名）
- **前提条件**: JavaScript、Cloudflare基本知識、決定論的システム理解

---

## 2. Phase 1: Edge開発環境構築（1週間）

### Task 1.1: Cloudflare Pages環境セットアップ（2日）

| ID | 作業項目 | 実装内容 | 完了条件 |
|----|---------|---------|----------|
| 1.1.1 | Cloudflare Pages設定 | GitHub連携・自動デプロイ設定 | ビルド・デプロイ動作確認 |
| 1.1.2 | Workers設定 | Functions/_middleware.ts設定 | Edge処理動作確認 |
| 1.1.3 | Custom Domain設定 | DNS・SSL証明書設定 | HTTPS接続確認 |
| 1.1.4 | 環境変数・Secrets設定 | D1・KV接続情報設定 | 認証動作確認 |

**具体的な実装作業**:
```bash
# Cloudflare CLI setup
npm install -g wrangler
wrangler login

# プロジェクト初期化
wrangler pages project create haqei-analyzer
wrangler pages deployment list

# Functions設定
mkdir -p functions
cat > functions/_middleware.ts << 'EOF'
export async function onRequest(context) {
  // Edge middleware setup
  const response = await context.next();
  
  // Security headers
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  
  return response;
}
EOF

# 環境変数設定
wrangler pages secret put D1_DATABASE_ID
wrangler pages secret put KV_NAMESPACE_ID
```

### Task 1.2: D1 Database初期化・構築（2日）

| ID | 作業項目 | データソース | 容量制限 | 処理時間 |
|----|---------|------------|----------|----------|
| 1.2.1 | D1 Database作成 | Cloudflare Dashboard | 50MB | 30分 |
| 1.2.2 | 384爻統合テーブル構築 | 4つのJSONファイル統合 | 30MB | 2時間 |
| 1.2.3 | 学習フィードバックテーブル | Edge用軽量スキーマ | 10MB | 1時間 |
| 1.2.4 | データ統合・インポート | JSON → D1 migration | - | 3時間 |

**D1データベースセットアップスクリプト**:
```typescript
// D1 Database初期化
interface Env {
  DB: D1Database;
  KV: KVNamespace;
}

export class D1DatabaseManager {
  constructor(private env: Env) {}
  
  async initializeDatabase(): Promise<void> {
    // 384爻統合テーブル作成
    await this.env.DB.exec(`
      CREATE TABLE IF NOT EXISTS lines_384 (
        line_id INTEGER PRIMARY KEY,
        hexagram_id INTEGER NOT NULL,
        line_position INTEGER NOT NULL,
        hexagram_name TEXT NOT NULL,
        line_name TEXT NOT NULL,
        
        -- enhanced_hexagrams_complete.json データ
        yaoci_text TEXT,
        yaoci_meaning TEXT,
        personality_trait TEXT,
        transformation_potential TEXT,
        
        -- yaoci_31-63.json データ  
        extended_yaoci TEXT,
        classical_interpretation TEXT,
        
        -- h384.json データ
        basic_meaning TEXT,
        keywords TEXT, -- JSON配列文字列
        category TEXT,
        
        -- koudo_shishin.json データ（既存互換性）
        shin_data TEXT,
        hen_data TEXT,
        
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );
    `);
    
    // インデックス作成
    await this.env.DB.exec(`
      CREATE INDEX IF NOT EXISTS idx_hexagram_position 
      ON lines_384(hexagram_id, line_position);
      
      CREATE INDEX IF NOT EXISTS idx_keywords_search 
      ON lines_384(keywords);
    `);
    
    // 学習フィードバックテーブル
    await this.env.DB.exec(`
      CREATE TABLE IF NOT EXISTS user_feedback (
        id INTEGER PRIMARY KEY,
        session_id TEXT NOT NULL,
        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
        input_text TEXT NOT NULL,
        predicted_line_id INTEGER,
        confidence_score REAL,
        correct_line_id INTEGER,
        accuracy_rating INTEGER,
        feedback_comment TEXT
      );
    `);
  }
  
  async importJSONData(): Promise<void> {
    // enhanced_hexagrams_complete.json統合
    const enhancedHexagrams = await this.loadJSON('/data/enhanced_hexagrams_complete.json');
    for (const hexagram of enhancedHexagrams) {
      for (let position = 1; position <= 6; position++) {
        const line = hexagram.six_lines[position - 1];
        const lineId = (hexagram.number - 1) * 6 + position;
        
        await this.env.DB.prepare(`
          INSERT OR REPLACE INTO lines_384 (
            line_id, hexagram_id, line_position, hexagram_name, line_name,
            yaoci_text, yaoci_meaning, personality_trait, transformation_potential
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).bind(
          lineId, hexagram.number, position, hexagram.name,
          line.name || `${this.getPositionName(position)}`,
          line.text, line.meaning, line.personality_trait, line.transformation_potential
        ).run();
      }
    }
    
    console.log('✅ D1 Database初期化完了');
  }
}

### Task 1.3: 基本接続・テスト環境（1.5日）

**データベース接続マネージャー実装**:
```javascript
// DatabaseManager.js
class DatabaseManager {
    constructor() {
        this.connections = {
            sqlite: null,
            mongodb: null,
            redis: null,
            influxdb: null
        };
    }
    
    async initializeSQLite() {
        const sqlite3 = require('sqlite3');
        const path = require('path');
        
        this.connections.sqlite = new sqlite3.Database(
            path.join(__dirname, '../databases/sqlite/main.db'),
            sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE,
            (err) => {
                if (err) throw new Error(`SQLite connection failed: ${err.message}`);
                console.log('✅ SQLite connection established');
            }
        );
        
        // 暗号化設定
        this.connections.sqlite.run("PRAGMA key = 'haqei-encryption-key'");
    }
    
    async initializeMongoDB() {
        const { MongoClient } = require('mongodb');
        const client = new MongoClient('mongodb://localhost:27017', {
            useUnifiedTopology: true,
            authSource: 'admin',
            authMechanism: 'SCRAM-SHA-256'
        });
        
        await client.connect();
        this.connections.mongodb = client.db('haqei_analyzer');
        console.log('✅ MongoDB connection established');
    }
    
    async initializeRedis() {
        const redis = require('redis');
        this.connections.redis = redis.createClient({
            host: 'localhost',
            port: 6379,
            password: 'haqei-secure-password',
            db: 0
        });
        
        await this.connections.redis.connect();
        console.log('✅ Redis connection established');
    }
    
    async healthCheck() {
        const results = {};
        
        // SQLite健康性チェック
        try {
            await new Promise((resolve, reject) => {
                this.connections.sqlite.get("SELECT 1", (err, row) => {
                    err ? reject(err) : resolve(row);
                });
            });
            results.sqlite = '✅ OK';
        } catch (error) {
            results.sqlite = `❌ ERROR: ${error.message}`;
        }
        
        // MongoDB健康性チェック
        try {
            await this.connections.mongodb.admin().ping();
            results.mongodb = '✅ OK';
        } catch (error) {
            results.mongodb = `❌ ERROR: ${error.message}`;
        }
        
        // Redis健康性チェック
        try {
            await this.connections.redis.ping();
            results.redis = '✅ OK';
        } catch (error) {
            results.redis = `❌ ERROR: ${error.message}`;
        }
        
        return results;
    }
}
```

---

## 3. Phase 2: SQLite辞書システム実装（2週間）

### Task 2.1: 形態素解析辞書データベース構築（4日）

**データベーススキーマ実装**:
```sql
-- morphology.db
CREATE TABLE morphology_dict (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    word TEXT NOT NULL,
    reading TEXT,
    part_of_speech TEXT NOT NULL,
    semantic_category TEXT,
    frequency INTEGER DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_word_lookup ON morphology_dict(word);
CREATE INDEX idx_pos_category ON morphology_dict(part_of_speech, semantic_category);

CREATE TABLE specialized_terms (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    term TEXT NOT NULL UNIQUE,
    domain TEXT NOT NULL,  -- 'yijing', 'philosophy', etc.
    weight REAL DEFAULT 1.0,
    synonyms TEXT,  -- JSON array
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_term_domain ON specialized_terms(term, domain);
```

**MeCab統合クラス実装**:
```javascript
class MeCabAnalyzer {
    constructor(databaseManager) {
        this.mecab = require('mecab-async');
        this.db = databaseManager.connections.sqlite;
    }
    
    async analyze(text) {
        // MeCab形態素解析実行
        const result = await this.mecab.parse(text);
        const tokens = result.map(token => ({
            surface: token[0],
            pos: token[1],
            pos_detail: token[2],
            reading: token[7],
            base_form: token[6]
        }));
        
        // データベースから追加情報取得
        const enrichedTokens = [];
        for (const token of tokens) {
            const dbInfo = await this.queryMorphologyDB(token.base_form);
            enrichedTokens.push({
                ...token,
                semantic_category: dbInfo?.semantic_category,
                frequency: dbInfo?.frequency || 1,
                is_specialized: await this.isSpecializedTerm(token.base_form)
            });
        }
        
        return {
            tokens: enrichedTokens,
            keywords: this.extractKeywords(enrichedTokens),
            semantic_analysis: this.analyzeSemantics(enrichedTokens)
        };
    }
    
    async queryMorphologyDB(word) {
        return new Promise((resolve, reject) => {
            this.db.get(
                "SELECT * FROM morphology_dict WHERE word = ?",
                [word],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });
    }
    
    extractKeywords(tokens) {
        return tokens
            .filter(token => ['名詞', '動詞', '形容詞'].includes(token.pos))
            .filter(token => token.surface.length > 1)
            .map(token => ({
                word: token.base_form || token.surface,
                pos: token.pos,
                weight: this.calculateWeight(token),
                semantic_category: token.semantic_category
            }))
            .sort((a, b) => b.weight - a.weight);
    }
    
    calculateWeight(token) {
        let weight = 1.0;
        
        // 品詞による重み付け
        if (token.pos === '名詞') weight *= 1.2;
        if (token.pos === '動詞') weight *= 1.1;
        if (token.pos === '形容詞') weight *= 1.0;
        
        // 頻度による重み付け（逆相関）
        if (token.frequency) {
            weight *= Math.log(10000 / token.frequency);
        }
        
        // 専門用語による重み付け
        if (token.is_specialized) weight *= 1.5;
        
        return weight;
    }
}
```

### Task 2.2: 類義語辞書データベース構築（4日）

**WordNet統合クラス実装**:
```javascript
class WordNetSynonymMatcher {
    constructor(databaseManager) {
        this.db = databaseManager.connections.sqlite;
        this.wordnet = require('wordnet');  // 日本語WordNetライブラリ
    }
    
    async findSynonyms(word, threshold = 0.7) {
        // データベースキャッシュ確認
        const cached = await this.getCachedSynonyms(word);
        if (cached.length > 0) return cached;
        
        // WordNetから類義語検索
        const synsets = await this.wordnet.lookup(word);
        const synonyms = [];
        
        for (const synset of synsets) {
            // 同じシンセット内の語彙
            for (const synonym of synset.words) {
                if (synonym !== word) {
                    synonyms.push({
                        word: synonym,
                        similarity: 1.0,
                        relation: 'synonym',
                        source: 'wordnet'
                    });
                }
            }
            
            // 上位概念（hypernym）
            for (const hypernym of synset.hypernyms()) {
                for (const word of hypernym.words) {
                    synonyms.push({
                        word: word,
                        similarity: 0.8,
                        relation: 'hypernym',
                        source: 'wordnet'
                    });
                }
            }
            
            // 下位概念（hyponym）
            for (const hyponym of synset.hyponyms()) {
                for (const word of hyponym.words) {
                    synonyms.push({
                        word: word,
                        similarity: 0.7,
                        relation: 'hyponym',
                        source: 'wordnet'
                    });
                }
            }
        }
        
        // 閾値フィルタリング・重複除去
        const filtered = synonyms
            .filter(syn => syn.similarity >= threshold)
            .reduce((acc, current) => {
                const exists = acc.find(item => item.word === current.word);
                if (!exists || exists.similarity < current.similarity) {
                    return [...acc.filter(item => item.word !== current.word), current];
                }
                return acc;
            }, []);
        
        // データベースキャッシュ保存
        await this.cacheSynonyms(word, filtered);
        
        return filtered;
    }
    
    async getCachedSynonyms(word) {
        return new Promise((resolve, reject) => {
            this.db.all(`
                SELECT word2, similarity_score, relation_type 
                FROM synonym_relations 
                WHERE word1 = ? AND similarity_score >= 0.7
                ORDER BY similarity_score DESC
            `, [word], (err, rows) => {
                if (err) reject(err);
                else resolve(rows.map(row => ({
                    word: row.word2,
                    similarity: row.similarity_score,
                    relation: row.relation_type,
                    source: 'cache'
                })));
            });
        });
    }
    
    async calculateSemanticSimilarity(word1, word2) {
        // Wu-Palmer類似度計算
        const synsets1 = await this.wordnet.lookup(word1);
        const synsets2 = await this.wordnet.lookup(word2);
        
        let maxSimilarity = 0;
        
        for (const synset1 of synsets1) {
            for (const synset2 of synsets2) {
                const similarity = await this.wupSimilarity(synset1, synset2);
                maxSimilarity = Math.max(maxSimilarity, similarity);
            }
        }
        
        return maxSimilarity;
    }
}
```

### Task 2.3: 384爻キーワードシステム統合（3日）

**爻キーワード管理システム**:
```javascript
class LineKeywordManager {
    constructor(databaseManager) {
        this.db = databaseManager.connections.sqlite;
    }
    
    async buildKeywordDatabase() {
        // 既存JSONデータからキーワード抽出
        const enhancedHexagrams = await this.loadEnhancedHexagrams();
        const koudoShishin = await this.loadKoudoShishin();
        
        for (let lineId = 1; lineId <= 384; lineId++) {
            const hexagramId = Math.ceil(lineId / 6);
            const position = ((lineId - 1) % 6) + 1;
            
            // enhanced_hexagrams_complete.jsonからキーワード抽出
            const hexagram = enhancedHexagrams.find(h => h.hexagram_id === hexagramId);
            if (hexagram && hexagram.six_lines[position - 1]) {
                const lineData = hexagram.six_lines[position - 1];
                await this.extractAndStoreKeywords(lineId, lineData.text, 'yaoci', 'enhanced_hexagrams');
                await this.extractAndStoreKeywords(lineId, lineData.meaning, 'meaning', 'enhanced_hexagrams');
                await this.extractAndStoreKeywords(lineId, lineData.personality_trait, 'personality', 'enhanced_hexagrams');
            }
            
            // koudo_shishin.jsonからキーワード抽出
            const koudoData = koudoShishin[lineId - 1];
            if (koudoData) {
                await this.extractAndStoreKeywords(lineId, koudoData.shin, 'shin', 'koudo_shishin');
                await this.extractAndStoreKeywords(lineId, koudoData.hen, 'hen', 'koudo_shishin');
            }
        }
    }
    
    async extractAndStoreKeywords(lineId, text, category, source) {
        if (!text) return;
        
        // MeCab解析でキーワード抽出
        const analyzer = new MeCabAnalyzer(this.db);
        const analysis = await analyzer.analyze(text);
        
        for (const keyword of analysis.keywords) {
            // 重複チェック・重み計算
            const weight = await this.calculateKeywordWeight(keyword, category);
            
            await this.storeKeyword(lineId, keyword.word, weight, category, source);
        }
    }
    
    async storeKeyword(lineId, keyword, weight, category, source) {
        return new Promise((resolve, reject) => {
            this.db.run(`
                INSERT OR REPLACE INTO line_keywords 
                (line_id, keyword, weight, category, source, updated_at) 
                VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            `, [lineId, keyword, weight, category, source], (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    }
    
    async getLineKeywords(lineId, category = null) {
        const whereClause = category ? 'WHERE line_id = ? AND category = ?' : 'WHERE line_id = ?';
        const params = category ? [lineId, category] : [lineId];
        
        return new Promise((resolve, reject) => {
            this.db.all(`
                SELECT keyword, weight, category, source 
                FROM line_keywords ${whereClause}
                ORDER BY weight DESC
            `, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
}
```

---

## 4. Phase 3: MongoDB学習システム実装（2週間）

### Task 3.1: ユーザーフィードバック収集システム（4日）

**フィードバック管理システム**:
```javascript
class FeedbackManager {
    constructor(databaseManager) {
        this.mongodb = databaseManager.connections.mongodb;
        this.collection = this.mongodb.collection('user_feedback');
    }
    
    async recordFeedback(sessionId, userInput, analysisResult, userFeedback) {
        const feedbackDocument = {
            timestamp: new Date(),
            session_id: sessionId,
            user_input: {
                text: userInput.text,
                length: userInput.text.length,
                language: await this.detectLanguage(userInput.text)
            },
            analysis_result: {
                predicted_line_id: analysisResult.lineId,
                confidence_score: analysisResult.confidence,
                processing_time_ms: analysisResult.processingTime,
                morphology_tokens: analysisResult.morphologyTokens,
                extracted_keywords: analysisResult.keywords,
                similarity_scores: analysisResult.allScores
            },
            user_feedback: {
                rating: userFeedback.rating,
                correct_line_id: userFeedback.correctLineId,
                feedback_type: userFeedback.type,
                comments: userFeedback.comments
            },
            metadata: {
                user_agent: userInput.userAgent,
                ip_address: userInput.ipAddress,
                feature_flags: userInput.featureFlags
            }
        };
        
        const result = await this.collection.insertOne(feedbackDocument);
        
        // 即座に学習統計更新
        await this.updateLearningStatistics(analysisResult.lineId, userFeedback);
        
        return result.insertedId;
    }
    
    async updateLearningStatistics(lineId, userFeedback) {
        const statsCollection = this.mongodb.collection('learning_statistics');
        const today = new Date().toISOString().split('T')[0];
        
        // 今日の統計取得または初期化
        let stats = await statsCollection.findOne({ line_id: lineId, date: today });
        if (!stats) {
            stats = {
                line_id: lineId,
                date: today,
                statistics: {
                    total_predictions: 0,
                    correct_predictions: 0,
                    accuracy_rate: 0,
                    avg_confidence: 0,
                    common_mistakes: [],
                    improvement_trend: []
                },
                keyword_performance: {
                    effective_keywords: {},
                    ineffective_keywords: {},
                    new_keywords: []
                }
            };
        }
        
        // 統計更新
        stats.statistics.total_predictions++;
        if (userFeedback.rating >= 4) {
            stats.statistics.correct_predictions++;
        }
        stats.statistics.accuracy_rate = stats.statistics.correct_predictions / stats.statistics.total_predictions;
        
        // 間違いパターン記録
        if (userFeedback.correctLineId && userFeedback.correctLineId !== lineId) {
            const mistake = stats.statistics.common_mistakes.find(m => m.confused_with === userFeedback.correctLineId);
            if (mistake) {
                mistake.frequency++;
            } else {
                stats.statistics.common_mistakes.push({
                    confused_with: userFeedback.correctLineId,
                    frequency: 1
                });
            }
        }
        
        // 統計保存
        await statsCollection.replaceOne(
            { line_id: lineId, date: today },
            stats,
            { upsert: true }
        );
    }
}
```

### Task 3.2: 学習データ分析・統計システム（4日）

**学習統計分析システム**:
```javascript
class LearningAnalytics {
    constructor(databaseManager) {
        this.mongodb = databaseManager.connections.mongodb;
    }
    
    async generateDailyReport(date = null) {
        const targetDate = date || new Date().toISOString().split('T')[0];
        
        const pipeline = [
            { $match: { date: targetDate } },
            { $group: {
                _id: null,
                total_lines_analyzed: { $sum: "$statistics.total_predictions" },
                total_correct: { $sum: "$statistics.correct_predictions" },
                avg_accuracy: { $avg: "$statistics.accuracy_rate" },
                lines_with_improvement: { $sum: { $cond: [{ $gt: ["$statistics.accuracy_rate", 0.7] }, 1, 0] } }
            }},
            { $addFields: {
                overall_accuracy: { $divide: ["$total_correct", "$total_lines_analyzed"] },
                improvement_percentage: { $multiply: [{ $divide: ["$lines_with_improvement", 384] }, 100] }
            }}
        ];
        
        const result = await this.mongodb.collection('learning_statistics').aggregate(pipeline).toArray();
        return result[0] || null;
    }
    
    async identifyProblematicLines(threshold = 0.5) {
        const pipeline = [
            { $match: { 
                "statistics.total_predictions": { $gte: 10 },  // 十分なサンプル数
                "statistics.accuracy_rate": { $lt: threshold }
            }},
            { $sort: { "statistics.accuracy_rate": 1 } },
            { $limit: 20 },
            { $project: {
                line_id: 1,
                accuracy_rate: "$statistics.accuracy_rate",
                total_predictions: "$statistics.total_predictions",
                common_mistakes: "$statistics.common_mistakes"
            }}
        ];
        
        return await this.mongodb.collection('learning_statistics').aggregate(pipeline).toArray();
    }
    
    async generateKeywordEffectivenessReport() {
        const pipeline = [
            { $unwind: { path: "$keyword_performance.effective_keywords", preserveNullAndEmptyArrays: true } },
            { $group: {
                _id: "$keyword_performance.effective_keywords.k",
                total_usage: { $sum: 1 },
                avg_success_rate: { $avg: "$keyword_performance.effective_keywords.v" },
                lines_using: { $addToSet: "$line_id" }
            }},
            { $match: { avg_success_rate: { $gte: 0.8 } } },
            { $sort: { avg_success_rate: -1 } },
            { $limit: 50 }
        ];
        
        return await this.mongodb.collection('learning_statistics').aggregate(pipeline).toArray();
    }
    
    async predictOptimalWeights(lineId) {
        // 過去30日間のフィードバックデータ分析
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const feedbackData = await this.mongodb.collection('user_feedback').find({
            'analysis_result.predicted_line_id': lineId,
            timestamp: { $gte: thirtyDaysAgo }
        }).toArray();
        
        if (feedbackData.length < 5) {
            return null;  // 不十分なデータ
        }
        
        // 成功・失敗パターン分析
        const successful = feedbackData.filter(fb => fb.user_feedback.rating >= 4);
        const unsuccessful = feedbackData.filter(fb => fb.user_feedback.rating < 4);
        
        const successfulKeywords = this.extractKeywordPatterns(successful);
        const unsuccessfulKeywords = this.extractKeywordPatterns(unsuccessful);
        
        // 重み最適化提案
        const optimizedWeights = {};
        for (const keyword of Object.keys(successfulKeywords)) {
            const successRate = successfulKeywords[keyword].frequency / feedbackData.length;
            const failureRate = unsuccessfulKeywords[keyword]?.frequency || 0;
            
            if (successRate > failureRate) {
                optimizedWeights[keyword] = Math.min(2.0, successRate * 1.5);
            } else {
                optimizedWeights[keyword] = Math.max(0.1, successRate * 0.5);
            }
        }
        
        return optimizedWeights;
    }
}
```

---

## 5. リスク管理・品質保証

### 5.1 技術的リスクと対策

| リスク | 発生確率 | 影響度 | 対策 |
|--------|---------|-------|------|
| データベース性能問題 | 中 | 高 | インデックス最適化・コネクションプール |
| MeCab辞書互換性 | 低 | 中 | 複数辞書バージョン対応 |
| WordNet日本語対応制限 | 中 | 中 | カスタム類義語辞書補完 |
| MongoDB学習データ肥大化 | 高 | 中 | TTL・アーカイブ機能実装 |
| Redis高メモリ使用量 | 中 | 中 | 適切なTTL・LRU設定 |

### 5.2 品質ゲート

各フェーズの完了条件:
- **Phase 1**: 全データベース接続成功・健康性チェック通過
- **Phase 2**: MeCab解析精度90%以上・類義語マッチング70%以上
- **Phase 3**: フィードバックループ動作・学習効果確認
- **Phase 4**: レスポンス時間5ms以下・キャッシュヒット率80%以上

---

## 6. 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| プロジェクトマネージャー | | | |
| テックリード | | | |
| データベース管理者 | | | |

---

**文書管理**
- データベース統合に特化したタスク分解
- 8週間での段階的実装
- 配布先: 開発チーム、DBAチーム