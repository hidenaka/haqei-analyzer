# 🏗️ 384爻システム Cloudflare Pages対応システム設計書

**文書番号**: SD-384-005  
**バージョン**: 5.0（現実的Cloudflare Pages版）  
**作成日**: 2025年8月28日  
**作成者**: HAQEI開発チーム  
**承認者**: [未承認]  

---

## 1. システム概要

### 1.1 Cloudflare Pages対応アーキテクチャ

#### Cloudflare Pages制約と現実的対応策
```yaml
制約事項:
  - サーバーサイドDBMS不可: SQLite, MongoDB等は使用不可
  - 永続ストレージ制限: サーバーサイド永続化は不可
  - エッジ環境実行: 軽量・高速処理が必須
  - データライセンス制約: 外部辞書の配布・利用制限
  - 開発リソース制限: 現実的な工数・スケジュール

現実的Cloudflare Pages対応策:
  - Edge-Native設計: Workers + KV + D1 Database
  - 段階的実装: 既存koudo_shishin.jsonから開始
  - 軽量NLP: ブラウザ内基本形態素解析 + 簡易類義語
  - 決定論的学習: 日次バッチ更新による一貫性保証
  - 拡張可能設計: 将来的なデータ追加に備えた柔軟性
```

#### Cloudflare Pages対応システムアーキテクチャ
```
┌─────────────────────────────────────────────────────────┐
│                384爻 Edge AI分析システム                   │
├─────────────────────────────────────────────────────────┤
│                     クライアント層                          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│  │ Browser UI  │ │ Service     │ │ IndexedDB   │  │
│  │ (Vanilla JS)│ │ Worker      │ │ Cache       │  │
│  └─────────────┘ └─────────────┘ └─────────────┘  │
├─────────────────────────────────────────────────────────┤
│                  Cloudflare Edge層                      │
│  ┌─────────────────────────────────────────────────────┐  │
│  │         EdgeIntelligentScoringEngine               │  │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐  │  │
│  │  │WASM     │ │Browser  │ │JSON     │ │KV学習   │  │  │
│  │  │形態素解析│ │類義語   │ │爻辞     │ │重み     │  │  │
│  │  │25%      │ │35%     │ │20%     │ │15%     │  │  │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘  │  │
│  │           ┌─────────┐                           │  │
│  │           │文脈5%  │                           │  │
│  │           └─────────┘                           │  │
│  └─────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────┤
│                  Cloudflare Storage層                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│  │Workers KV   │ │ D1 Database │ │JSON Static  │  │
│  │学習データ    │ │統合データ   │ │Assets       │  │
│  └─────────────┘ └─────────────┘ └─────────────┘  │
├─────────────────────────────────────────────────────────┤
│                      Edge Storage                        │
│  ┌─────────────────────┐ ┌───────────┐ ┌──────────┐  │
│  │D1 Database (50MB)   │ │Workers KV │ │JSON Files│  │
│  │┌──────────────────┐ │ │学習データ │ │(Static)  │  │
│  ││384爻統合テーブル  │ │ │10MB/月   │ │20MB     │  │
│  ││MeCab辞書(WASM)  │ │ └───────────┘ └──────────┘  │
│  ││WordNet(Browser) │ │                           │
│  ││JSON統合データ   │ │                           │
│  │└──────────────────┘ │                           │
│  └─────────────────────┘                           │
└─────────────────────────────────────────────────────────┘
```

### 1.2 Cloudflare Edge Storage設計原則

#### 1.2.1 D1 Database: Edge統合データベース
**役割**: Cloudflare Edge環境での構造化データ管理

**現実的統合対象**:
```yaml
Phase 1 - 確実データ統合:
  koudo_shishin.json:
    - 既存shin/henデータ（384エントリ確実）
    - 統合先: lines_384テーブル (D1)
    - ライセンス: プロジェクト内部データ（使用可能）
    - データサイズ: ~2MB

Phase 2 - 拡張可能設計（オプショナル）:
  将来追加データ対応:
    - 外部データ取得時の拡張スロット
    - ライセンス確認後の段階的統合
    - 統合先: lines_384テーブル (拡張列)

Edge対応軽量NLP:
  Browser基本形態素解析:
    - JavaScript正規表現による基本分析
    - ひらがな/カタカナ/漢字分離
    - 基本語幹抽出（辞書不要）
    
  簡易類義語マッチング:
    - ハードコード類義語リスト（易経用語）
    - 編集距離による曖昧マッチング
    - 段階的辞書拡張対応
```

**現実的D1 Database テーブル設計**:
```sql
-- 1. 384爻基本データテーブル (Cloudflare D1 - Phase 1)
CREATE TABLE lines_384 (
    -- 基本識別情報
    line_id INTEGER PRIMARY KEY,           -- 1-384 (一意識別子)
    hexagram_id INTEGER NOT NULL,          -- 1-64 (卦番号)  
    line_position INTEGER NOT NULL,        -- 1-6 (爻位置: 初爻-上爻)
    hexagram_name TEXT NOT NULL,           -- 卦名 (例: "乾為天")
    line_name TEXT,                        -- 爻名 (例: "初九")
    
    -- koudo_shishin.json 確実データ
    shin_data TEXT,                        -- 既存shinデータ
    hen_data TEXT,                         -- 既存henデータ
    
    -- Phase 2 拡張用スロット（将来使用）
    extended_data_1 TEXT,                  -- 将来拡張データ1
    extended_data_2 TEXT,                  -- 将来拡張データ2
    extended_keywords TEXT,                -- 将来キーワードデータ（JSON）
    
    -- メタデータ・バージョニング
    data_version INTEGER DEFAULT 1,       -- データバージョン（決定論性保証）
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 決定論性保証インデックス
CREATE INDEX idx_hexagram_position ON lines_384(hexagram_id, line_position);
CREATE INDEX idx_data_version ON lines_384(data_version);  
CREATE INDEX idx_shin_hen_search ON lines_384(shin_data, hen_data);

-- 2. 決定論的学習フィードバックテーブル (D1)
CREATE TABLE user_feedback (
    id INTEGER PRIMARY KEY,
    session_id TEXT NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    batch_date TEXT NOT NULL,        -- YYYY-MM-DD（決定論性保証）
    
    -- 入力データ
    input_text TEXT NOT NULL,
    text_length INTEGER,
    
    -- 予測結果（データバージョン記録）
    predicted_line_id INTEGER,
    confidence_score REAL,
    data_version INTEGER DEFAULT 1,  -- 使用したデータバージョン
    
    -- ユーザー評価
    correct_line_id INTEGER,
    accuracy_rating INTEGER,         -- 1-5評価
    feedback_comment TEXT,
    
    -- バッチ処理管理
    processed_in_batch INTEGER DEFAULT 0, -- 0:未処理 1:処理済み
    batch_applied_date TEXT         -- バッチ適用日
);

CREATE INDEX idx_batch_date ON user_feedback(batch_date);
CREATE INDEX idx_processed_batch ON user_feedback(processed_in_batch);
CREATE INDEX idx_data_version ON user_feedback(data_version);

-- 3. 日次統計・バッチ管理テーブル (D1)
CREATE TABLE daily_batch_log (
    batch_date TEXT PRIMARY KEY,    -- YYYY-MM-DD形式
    
    -- バッチ処理統計
    total_feedback_processed INTEGER DEFAULT 0,
    weight_updates_applied INTEGER DEFAULT 0,
    new_data_version INTEGER DEFAULT 1,
    
    -- 決定論性保証
    batch_status TEXT DEFAULT 'pending', -- pending/processing/completed
    batch_applied_at DATETIME,
    next_batch_date TEXT,           -- 次回バッチ予定日
    
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_batch_status ON daily_batch_log(batch_status);
```

#### 1.2.2 Workers KV: 決定論的学習データ管理
**役割**: Edge環境での決定論性保証付き学習データ管理

**決定論的 Workers KV データ構造**:
```javascript
// KVキー: "weights:version:{data_version}" 
// KV値: 確定済み重みデータ（日次バッチ更新）
{
  data_version: 1,
  effective_date: "2025-08-28",
  batch_applied: true,
  
  // 決定論的重み設定（同一入力→同一出力保証）
  scoring_weights: {
    shin_match: 0.35,            // shin完全一致重み
    hen_match: 0.25,             // hen完全一致重み  
    partial_match: 0.20,         // 部分一致重み
    length_similarity: 0.10,     // 文字列長類似度重み
    context_bonus: 0.10          // 文脈ボーナス重み
  },
  
  // 簡易類義語マッピング（固定・決定論的）
  deterministic_synonyms: {
    "リーダー": ["指導者", "統率者", "リード"],
    "組織": ["グループ", "チーム", "集団"],
    "責任": ["義務", "使命", "役割"],
    "導く": ["指導", "統率", "引率"]
  },
  
  // バッチメタデータ
  batch_metadata: {
    previous_version: 0,
    feedback_count_processed: 156,
    accuracy_improvement: 0.023,
    next_update_scheduled: "2025-08-29"
  }
}

// KVキー: "temp:feedback:{session_id}"
// KV値: バッチ処理待ちフィードバック（一時保存）
{
  session_id: "user_session_12345",
  timestamp: "2025-08-28T12:00:00Z",
  batch_date: "2025-08-29",      // 次回バッチ処理対象日
  
  // 最小限フィードバックデータ
  feedback_data: {
    input_text: "リーダーとして組織を導く責任を感じている",
    predicted_line_id: 23,
    correct_line_id: 5,
    accuracy_rating: 4,
    data_version_used: 1         // 予測時使用データバージョン
  },
  
  // バッチ処理管理
  processing_status: "pending",  // pending/processing/completed
  ttl: 86400                     // 24時間TTL（バッチ処理後削除）
}

// KVキー: "stats:daily:{YYYY-MM-DD}"  
// KV値: 日次統計データJSON
{
  date: "2025-08-28",
  
  // Edge日次統計サマリー
  daily_summary: {
    total_predictions: 1247,       // 総予測数
    accurate_predictions: 1059,    // 正解予測数
    accuracy_rate: 0.849,          // 精度
    avg_confidence: 0.731,         // 平均信頼度
    feedback_received: 89,         // フィードバック受信数
    edge_processing_time: 2.1,     // 平均Edge処理時間(ms)
    browser_success_rate: 0.956    // ブラウザ処理成功率
  },
  
  // 上位パフォーマンス爻（上位10爻のみKV保存）
  top_line_performance: [
    {
      line_id: 5,                  // 乾為天 九五
      prediction_count: 45,        // 予測回数
      correct_count: 41,           // 正解数
      accuracy_rate: 0.911,        // 精度
      avg_confidence: 0.856,       // 平均信頼度
      feedback_count: 8,           // フィードバック数
      top_keywords: ["リーダー", "責任", "決断"]
    }
    // ... 上位9爻のデータ
  ],
  
  // 決定論的重み情報（参照用）
  deterministic_weights_applied: {
    current_version: 1,
    applied_weights: {
      shin_match: 0.35,            // shin完全一致重み
      hen_match: 0.25,             // hen完全一致重み
      partial_match: 0.20,         // 部分一致重み
      length_similarity: 0.10,     // 文字列長類似度重み
      context_bonus: 0.10          // 文脈ボーナス重み
    },
    last_batch_update: {
      batch_date: "2025-08-28",
      changes_applied: 3,
      improvement_measured: 0.023,
      next_update_date: "2025-08-29"
    }
  }
}
```

#### 1.2.3 Browser IndexedDB: クライアント高速キャッシュ
**役割**: Edgeレスポンス時間最適化とオフライン対応

**現実的IndexedDB ストア設計**:
```yaml
分析結果キャッシュ:
  store: "analysis_cache"
  key: "sha256(input_text + data_version)"
  ttl: 3600000 # 1時間(ms)
  size_estimate: "~1KB/entry"
  description: "決定論的分析結果をIndexedDBに格納"

基本テキスト分析キャッシュ:
  store: "text_analysis_cache"
  key: "sha256(text)"
  ttl: 86400000 # 24時間(ms)
  size_estimate: "~500B/entry"
  description: "基本形態素解析（正規表現ベース）結果キャッシュ"

簡易類義語キャッシュ:
  store: "synonym_cache"
  key: "word"
  ttl: 43200000 # 12時間(ms)
  size_estimate: "~200B/entry"
  description: "固定類義語リストの検索結果キャッシュ"

ユーザーセッション:
  store: "session_data"
  key: "session_id"
  ttl: 1800000 # 30分(ms)
  size_estimate: "~300B/entry"
  description: "クライアントセッション・文脈情報"

統計データキャッシュ:
  store: "stats_cache"
  key: "date"
  ttl: 604800000 # 7日(ms)
  size_estimate: "~3KB/entry"
  description: "Workers KVから取得した統計情報のローカルキャッシュ"
```

---

## 2. 現実的自然言語処理エンジン設計

### 2.1 Browser基本テキスト解析システム

#### 2.1.1 現実的・軽量アーキテクチャ設計
```javascript
class EdgeBasicTextAnalyzer {
    constructor(kvWeights, indexedDBCache) {
        this.weights = kvWeights;
        this.cache = indexedDBCache;
        this.synonymMap = this.initializeSynonyms();
    }
    
    async analyzeText(inputText, dataVersion = 1) {
        const startTime = performance.now();
        const cacheKey = this.generateCacheKey(inputText, dataVersion);
        
        // 1. IndexedDBキャッシュ確認（決定論性保証）
        const cached = await this.cache.get('text_analysis_cache', cacheKey);
        if (cached && !this.isCacheExpired(cached)) {
            return { ...cached.result, cache_hit: true };
        }
        
        // 2. 基本テキスト分割・分析
        const tokens = this.basicTokenize(inputText);
        
        // 3. 易経専門用語の識別
        const enhancedTokens = this.identifyYijingTerms(tokens);
        
        // 4. キーワード抽出
        const keywords = this.extractKeywords(enhancedTokens);
        
        // 5. 簡易類義語マッピング
        const synonymMatches = this.findSimpleSynonyms(keywords);
        
        const result = {
            tokens: enhancedTokens,
            keywords: keywords,
            synonym_matches: synonymMatches,
            processing_time_ms: performance.now() - startTime,
            data_version: dataVersion,
            cache_hit: false
        };
        
        // 6. IndexedDBキャッシュ保存
        await this.cache.set('text_analysis_cache', cacheKey, {
            result: result,
            cached_at: Date.now(),
            ttl: 86400000 // 24時間
        });
        
        return result;
    }
    
    basicTokenize(text) {
        // JavaScript正規表現による基本分割
        const tokens = [];
        
        // 1. 句読点・記号での分割
        const sentences = text.split(/[。！？\n]+/).filter(s => s.trim());
        
        for (const sentence of sentences) {
            // 2. ひらがな・カタカナ・漢字・英数字の分離
            const matches = sentence.match(/[\u3040-\u309F]+|[\u30A0-\u30FF]+|[\u4E00-\u9FAF]+|[a-zA-Z0-9]+/g);
            
            if (matches) {
                tokens.push(...matches.map(token => ({
                    surface: token,
                    type: this.getTokenType(token),
                    length: token.length
                })));
            }
        }
        
        return tokens;
    }
    
    getTokenType(token) {
        if (/^[\u3040-\u309F]+$/.test(token)) return 'hiragana';
        if (/^[\u30A0-\u30FF]+$/.test(token)) return 'katakana';
        if (/^[\u4E00-\u9FAF]+$/.test(token)) return 'kanji';
        if (/^[a-zA-Z0-9]+$/.test(token)) return 'alphanumeric';
        return 'mixed';
    }
    
    identifyYijingTerms(tokens) {
        // 易経専門用語パターンの識別
        const yijingPatterns = [
            { regex: /^(乾|坤|震|巽|坎|離|艮|兌)/, weight: 3.0, category: 'trigram' },
            { regex: /(天|地|雷|風|水|火|山|澤)/, weight: 2.5, category: 'element' },
            { regex: /(リーダー|指導|統率)/, weight: 2.0, category: 'leadership' },
            { regex: /(組織|チーム|グループ)/, weight: 1.8, category: 'group' },
            { regex: /(責任|義務|使命)/, weight: 1.5, category: 'duty' }
        ];
        
        return tokens.map(token => {
            for (const pattern of yijingPatterns) {
                if (pattern.regex.test(token.surface)) {
                    return {
                        ...token,
                        yijing_category: pattern.category,
                        weight: pattern.weight,
                        is_yijing_term: true
                    };
                }
            }
            return { ...token, weight: 1.0, is_yijing_term: false };
        });
    }
    
    extractKeywords(tokens) {
        return tokens
            .filter(token => token.length > 1) // 1文字語を除外
            .filter(token => token.type === 'kanji' || token.is_yijing_term) // 漢字または易経用語
            .sort((a, b) => b.weight - a.weight) // 重み順
            .slice(0, 10); // 上位10語
    }
    
    findSimpleSynonyms(keywords) {
        const matches = [];
        
        for (const keyword of keywords) {
            const synonyms = this.synonymMap[keyword.surface] || [];
            if (synonyms.length > 0) {
                matches.push({
                    word: keyword.surface,
                    synonyms: synonyms,
                    weight: keyword.weight
                });
            }
        }
        
        return matches;
    }
    
    initializeSynonyms() {
        // 固定類義語マッピング（決定論的）
        return {
            'リーダー': ['指導者', '統率者', 'リード'],
            '組織': ['グループ', 'チーム', '集団'],
            '責任': ['義務', '使命', '役割'],
            '導く': ['指導', '統率', '引率'],
            '決断': ['判断', '決定', '選択'],
            '成長': ['発展', '向上', '進歩'],
            '困難': ['問題', '課題', '試練'],
            '智慧': ['知恵', '叡智', '洞察']
        };
    }
}
```

### 2.2 決定論的スコアリングエンジン

#### 2.2.1 決定論的スコアリングアルゴリズム
```javascript
class DeterministicScoringEngine {
    constructor(d1Database, kvWeights, indexedDBCache) {
        this.db = d1Database;
        this.weights = kvWeights;
        this.cache = indexedDBCache;
    
    async findSynonyms(word, maxResults = 10) {
        const cacheKey = `synonyms:${word}:matches`;
        
        // Redisキャッシュ確認
        let cached = await this.redis.get(cacheKey);
        if (cached) {
            return JSON.parse(cached);
        }
        
        // データベースから類義語を検索
        const synonyms = await this.db.all(`
            SELECT word2 as synonym, similarity_score, yijing_relevance, domain_category
            FROM synonym_relations 
            WHERE word1 = ? AND similarity_score > ?
            
            UNION
            
            SELECT word1 as synonym, similarity_score, yijing_relevance, domain_category  
            FROM synonym_relations
            WHERE word2 = ? AND similarity_score > ?
            
            ORDER BY 
                yijing_relevance DESC,
                similarity_score DESC
            LIMIT ?
        `, [word, this.similarityThreshold, word, this.similarityThreshold, maxResults]);
        
        // 12時間キャッシュ
        await this.redis.setex(cacheKey, 43200, JSON.stringify(synonyms));
        
        return synonyms;
    }
    
    async calculateContextualSimilarity(word1, word2, context = []) {
        // Wu-Palmer類似度 + 文脈重み
        const baseSimilarity = await this.getBaseSimilarity(word1, word2);
        if (!baseSimilarity) return 0;
        
        // 文脈による重み調整
        let contextBonus = 0;
        for (const contextWord of context) {
            const c1 = await this.getBaseSimilarity(word1, contextWord);
            const c2 = await this.getBaseSimilarity(word2, contextWord);
            if (c1 && c2) {
                contextBonus += (c1.similarity_score + c2.similarity_score) * 0.1;
            }
        }
        
        return Math.min(1.0, baseSimilarity.similarity_score + contextBonus);
    }
    
    async getBaseSimilarity(word1, word2) {
        const result = await this.db.get(`
            SELECT similarity_score, yijing_relevance
            FROM synonym_relations
            WHERE (word1 = ? AND word2 = ?) OR (word1 = ? AND word2 = ?)
        `, [word1, word2, word2, word1]);
        
        return result;
    }
    
    async updateSynonymStrength(word1, word2, feedback) {
        // フィードバック基づく類義語関係強化
        const currentRelation = await this.getBaseSimilarity(word1, word2);
        
        if (currentRelation) {
            // 既存関係の強化
            const newScore = this.adjustSimilarityScore(
                currentRelation.similarity_score,
                feedback
            );
            
            await this.db.run(`
                UPDATE synonym_relations 
                SET similarity_score = ?, last_updated = CURRENT_TIMESTAMP
                WHERE (word1 = ? AND word2 = ?) OR (word1 = ? AND word2 = ?)
            `, [newScore, word1, word2, word2, word1]);
        } else if (feedback.accuracy > 0.8) {
            // 新規関係の追加（高精度フィードバックのみ）
            await this.db.run(`
                INSERT INTO synonym_relations 
                (word1, word2, similarity_score, relation_type, yijing_relevance, learned_weight)
                VALUES (?, ?, ?, ?, ?, ?)
            `, [
                word1, word2, 
                0.5, 'learned_synonym', 
                feedback.yijing_context ? 0.8 : 0.2,
                1.2
            ]);
        }
    }
}
```

---

## 3. インテリジェント分析エンジン

### 3.1 統合スコアリングシステム

#### 3.1.1 5要素統合アルゴリズム
```javascript
class IntelligentScoringEngine {
    constructor(databases) {
        this.sqlite = databases.sqlite;
        this.mongo = databases.mongo;
        this.redis = databases.redis;
        
        // 動的重み（MongoDB学習データから取得）
        this.weights = {
            morphology: 0.25,    // 形態素解析スコア
            synonym: 0.35,       // 類義語マッチングスコア  
            yaoci: 0.20,         // 爻辞直接マッチスコア
            learning: 0.15,      // 学習重みスコア
            context: 0.05        // 文脈スコア
        };
        
        this.mecabEngine = new DatabaseIntegratedMeCabEngine();
        this.synonymEngine = new WordNetSynonymEngine(this.sqlite, this.redis);
    }
    
    async analyzeTextToLine(inputText) {
        const analysisId = this.generateAnalysisId();
        const startTime = performance.now();
        
        // キャッシュ確認
        const cacheKey = `analysis:${this.hashText(inputText)}:result`;
        const cached = await this.redis.get(cacheKey);
        if (cached) {
            const result = JSON.parse(cached);
            return { ...result, cache_hit: true, analysis_id: analysisId };
        }
        
        try {
            // 1. 動的重みの最新化
            await this.updateDynamicWeights();
            
            // 2. 形態素解析実行
            const morphologyResult = await this.mecabEngine.analyze(inputText);
            
            // 3. 全384爻に対するスコア計算
            const lineScores = await this.calculateAllLineScores(
                inputText, morphologyResult
            );
            
            // 4. 最高スコア爻の決定
            const bestMatch = this.selectBestMatch(lineScores);
            
            // 5. 結果構造化
            const result = {
                analysis_id: analysisId,
                line_384_id: bestMatch.line_id,
                confidence_score: bestMatch.total_score,
                
                // 基本情報
                hexagram_name: bestMatch.hexagram_name,
                line_name: bestMatch.line_name,
                yaoci_text: bestMatch.yaoci_text,
                yaoci_meaning: bestMatch.yaoci_meaning,
                personality_trait: bestMatch.personality_trait,
                
                // 詳細スコア分解
                score_breakdown: {
                    morphology_score: bestMatch.morphology_score,
                    synonym_score: bestMatch.synonym_score,
                    yaoci_match_score: bestMatch.yaoci_score,
                    learning_weight_score: bestMatch.learning_score,
                    context_score: bestMatch.context_score
                },
                
                // 分析データ
                analysis_details: {
                    input_features: morphologyResult,
                    alternative_matches: lineScores.slice(1, 6), // 上位5候補
                    processing_time_ms: performance.now() - startTime
                },
                
                cache_hit: false,
                timestamp: new Date().toISOString()
            };
            
            // 6. 結果キャッシュ（1時間）
            await this.redis.setex(cacheKey, 3600, JSON.stringify(result));
            
            return result;
            
        } catch (error) {
            throw new AnalysisError(`分析処理エラー: ${error.message}`, {
                input_text: inputText,
                analysis_id: analysisId,
                error_stage: error.stage || 'unknown'
            });
        }
    }
    
    async calculateAllLineScores(inputText, morphologyResult) {
        // 全384爻データを取得
        const allLines = await this.sqlite.all(`
            SELECT 
                line_id, hexagram_id, line_position,
                hexagram_name, line_name,
                yaoci_text, yaoci_meaning, personality_trait,
                keywords, basic_meaning
            FROM lines_384
            ORDER BY line_id
        `);
        
        const lineScores = [];
        
        // 各爻に対してスコア計算
        for (const line of allLines) {
            try {
                const scores = await this.calculateSingleLineScore(
                    line, inputText, morphologyResult
                );
                
                lineScores.push({
                    ...line,
                    ...scores,
                    total_score: 
                        scores.morphology_score * this.weights.morphology +
                        scores.synonym_score * this.weights.synonym +
                        scores.yaoci_score * this.weights.yaoci +
                        scores.learning_score * this.weights.learning +
                        scores.context_score * this.weights.context
                });
                
            } catch (error) {
                // 個別爻の計算エラーは0点として継続
                console.warn(`Line ${line.line_id} scoring error:`, error.message);
                lineScores.push({
                    ...line,
                    morphology_score: 0,
                    synonym_score: 0,
                    yaoci_score: 0,
                    learning_score: 0,
                    context_score: 0,
                    total_score: 0
                });
            }
        }
        
        // 総合スコア順でソート
        return lineScores.sort((a, b) => b.total_score - a.total_score);
    }
    
    async calculateSingleLineScore(line, inputText, morphologyResult) {
        // 1. 形態素解析スコア（25%重み）
        const morphologyScore = await this.calculateMorphologyScore(
            line, morphologyResult.keywords
        );
        
        // 2. 類義語マッチングスコア（35%重み）
        const synonymScore = await this.calculateSynonymScore(
            line, morphologyResult.keywords
        );
        
        // 3. 爻辞直接マッチスコア（20%重み）
        const yaociScore = await this.calculateYaociMatchScore(
            line, morphologyResult.tokens, inputText
        );
        
        // 4. 学習重みスコア（15%重み）
        const learningScore = await this.calculateLearningScore(line.line_id);
        
        // 5. 文脈スコア（5%重み）
        const contextScore = await this.calculateContextScore(
            line, inputText, morphologyResult
        );
        
        return {
            morphology_score: morphologyScore,
            synonym_score: synonymScore,
            yaoci_score: yaociScore,
            learning_score: learningScore,
            context_score: contextScore
        };
    }
    
    async calculateMorphologyScore(line, extractedKeywords) {
        if (!extractedKeywords.length) return 0;
        
        let totalScore = 0;
        let maxPossibleScore = 0;
        
        for (const keyword of extractedKeywords) {
            maxPossibleScore += keyword.weight;
            
            // 爻の各テキストフィールドでの検索
            const fields = [
                line.yaoci_text,
                line.yaoci_meaning, 
                line.basic_meaning,
                line.personality_trait
            ].filter(field => field);
            
            let bestFieldScore = 0;
            
            for (const field of fields) {
                if (field.includes(keyword.word)) {
                    // 完全一致
                    bestFieldScore = Math.max(bestFieldScore, keyword.weight);
                } else if (field.includes(keyword.base_form)) {
                    // 基本形一致
                    bestFieldScore = Math.max(bestFieldScore, keyword.weight * 0.8);
                }
            }
            
            totalScore += bestFieldScore;
        }
        
        return maxPossibleScore > 0 ? totalScore / maxPossibleScore : 0;
    }
    
    async calculateSynonymScore(line, extractedKeywords) {
        if (!extractedKeywords.length) return 0;
        
        let totalScore = 0;
        let maxPossibleScore = 0;
        
        for (const keyword of extractedKeywords) {
            maxPossibleScore += keyword.weight;
            
            // 類義語検索
            const synonyms = await this.synonymEngine.findSynonyms(keyword.word, 5);
            
            let bestSynonymScore = 0;
            
            for (const synonym of synonyms) {
                const fields = [
                    line.yaoci_text,
                    line.yaoci_meaning,
                    line.basic_meaning,
                    line.personality_trait
                ].filter(field => field);
                
                for (const field of fields) {
                    if (field.includes(synonym.synonym)) {
                        const score = keyword.weight * synonym.similarity_score;
                        bestSynonymScore = Math.max(bestSynonymScore, score);
                    }
                }
            }
            
            totalScore += bestSynonymScore;
        }
        
        return maxPossibleScore > 0 ? totalScore / maxPossibleScore : 0;
    }
    
    async calculateYaociMatchScore(line, tokens, inputText) {
        // 爻辞テキストとの直接マッチング度を計算
        const yaociText = line.yaoci_text + ' ' + (line.yaoci_meaning || '');
        if (!yaociText.trim()) return 0;
        
        // 文字レベルでの類似度計算（簡易版）
        let matchScore = 0;
        const inputChars = inputText.length;
        
        for (const token of tokens) {
            if (yaociText.includes(token.surface)) {
                matchScore += token.surface.length;
            }
        }
        
        return inputChars > 0 ? matchScore / inputChars : 0;
    }
    
    async calculateLearningScore(lineId) {
        // MongoDB学習データから動的重みを取得
        try {
            const todayStats = await this.mongo.collection('learning_statistics')
                .findOne({
                    date: new Date().toISOString().split('T')[0]
                });
            
            if (todayStats && todayStats.line_performance) {
                const linePerf = todayStats.line_performance.find(
                    p => p.line_id === lineId
                );
                
                if (linePerf) {
                    // 精度とフィードバック数を重み付け
                    return Math.min(1.0, 
                        linePerf.accuracy_rate * 0.7 + 
                        (linePerf.feedback_count / 100) * 0.3
                    );
                }
            }
            
            return 0.5; // デフォルト値
            
        } catch (error) {
            console.warn('Learning score calculation error:', error.message);
            return 0.5;
        }
    }
    
    async calculateContextScore(line, inputText, morphologyResult) {
        // 文全体の文脈と爻の意味的整合性
        const semanticCategories = morphologyResult.semantic_categories || [];
        
        // 易経カテゴリのマッチング
        let categoryScore = 0;
        const lineCategories = this.extractLineCategories(line);
        
        for (const category of semanticCategories) {
            if (lineCategories.includes(category)) {
                categoryScore += 0.2;
            }
        }
        
        return Math.min(1.0, categoryScore);
    }
    
    extractLineCategories(line) {
        const categories = [];
        
        // 爻位置による分類
        switch (line.line_position) {
            case 1: categories.push('beginning', 'foundation'); break;
            case 2: categories.push('development', 'growth'); break;
            case 3: categories.push('difficulty', 'challenge'); break;
            case 4: categories.push('transition', 'change'); break;
            case 5: categories.push('leadership', 'success'); break;
            case 6: categories.push('completion', 'culmination'); break;
        }
        
        return categories;
    }
    
    selectBestMatch(lineScores) {
        // 最高スコア爻を選択（信頼度チェック付き）
        const best = lineScores[0];
        
        if (best.total_score < 0.3) {
            // 低信頼度の場合のフォールバック処理
            console.warn(`Low confidence score: ${best.total_score}`);
        }
        
        return best;
    }
    
    async updateDynamicWeights() {
        // MongoDB学習データから最新の重みを取得・更新
        try {
            const latestStats = await this.mongo.collection('learning_statistics')
                .findOne(
                    {},
                    { sort: { date: -1 } }
                );
            
            if (latestStats && latestStats.weight_adjustments) {
                const weights = latestStats.weight_adjustments.current_weights;
                if (weights) {
                    this.weights = { ...this.weights, ...weights };
                }
            }
            
        } catch (error) {
            console.warn('Dynamic weight update error:', error.message);
        }
    }
}

class AnalysisError extends Error {
    constructor(message, metadata = {}) {
        super(message);
        this.name = 'AnalysisError';
        this.metadata = metadata;
    }
}
```

---

## 4. データ統合・移行設計

### 4.1 JSONデータ統合プロセス

#### 4.1.1 データ統合スクリプト設計
```javascript
class DataIntegrationManager {
    constructor() {
        this.sqlite = new SQLiteConnection('./dbs/haqei_master.db');
        this.dataPath = './public/data/';
        this.integratedData = new Map();
    }
    
    async executeFullIntegration() {
        console.log('🚀 384爻データベース統合開始...');
        
        try {
            // 1. データベース初期化
            await this.initializeDatabase();
            
            // 2. JSONファイル統合
            await this.integrateEnhancedHexagrams();
            await this.integrateYaociData();
            await this.integrateH384Data();
            await this.integrateKoudoShishin();
            
            // 3. 外部辞書導入
            await this.importIPADictionary();
            await this.importWordNetJp();
            
            // 4. データ検証・最適化
            await this.validateIntegratedData();
            await this.optimizeDatabase();
            
            console.log('✅ データ統合完了');
            
        } catch (error) {
            console.error('❌ データ統合エラー:', error);
            throw error;
        }
    }
    
    async integrateEnhancedHexagrams() {
        console.log('📚 enhanced_hexagrams_complete.json 統合中...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/enhanced_hexagrams_complete.json`)
        );
        
        const insertStmt = this.sqlite.prepare(`
            INSERT OR REPLACE INTO lines_384 (
                line_id, hexagram_id, line_position, 
                hexagram_name, line_name,
                yaoci_text, yaoci_meaning, 
                personality_trait, transformation_potential
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        let insertedCount = 0;
        
        for (const hexagram of data) {
            for (let position = 1; position <= 6; position++) {
                const line = hexagram.six_lines[position - 1];
                const lineId = (hexagram.number - 1) * 6 + position;
                
                insertStmt.run([
                    lineId,                           // line_id
                    hexagram.number,                  // hexagram_id  
                    position,                         // line_position
                    hexagram.name,                    // hexagram_name
                    line.name || `${this.getPositionName(position)}`, // line_name
                    line.text || null,                // yaoci_text
                    line.meaning || null,             // yaoci_meaning
                    line.personality_trait || null,   // personality_trait
                    line.transformation_potential || null // transformation_potential
                ]);
                
                insertedCount++;
            }
        }
        
        insertStmt.finalize();
        console.log(`✅ enhanced_hexagrams: ${insertedCount}レコード統合完了`);
    }
    
    async integrateYaociData() {
        console.log('📜 yaoci_31-63.json 統合中...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/yaoci_31-63.json`)
        );
        
        const updateStmt = this.sqlite.prepare(`
            UPDATE lines_384 
            SET extended_yaoci = ?, classical_interpretation = ?
            WHERE line_id = ?
        `);
        
        let updatedCount = 0;
        
        for (const [key, value] of Object.entries(data)) {
            // キーから line_id を推定（例: "31-1" -> line_id = 181）
            const [hexagramNum, linePos] = key.split('-').map(Number);
            const lineId = (hexagramNum - 1) * 6 + linePos;
            
            if (lineId >= 1 && lineId <= 384) {
                updateStmt.run([
                    value.extended_text || null,
                    value.classical_interpretation || null,
                    lineId
                ]);
                updatedCount++;
            }
        }
        
        updateStmt.finalize();
        console.log(`✅ yaoci_31-63: ${updatedCount}レコード統合完了`);
    }
    
    async integrateH384Data() {
        console.log('🔢 h384.json 統合中...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/h384.json`)
        );
        
        const updateStmt = this.sqlite.prepare(`
            UPDATE lines_384 
            SET basic_meaning = ?, keywords = ?
            WHERE line_id = ?
        `);
        
        let updatedCount = 0;
        
        for (const item of data) {
            if (item.id >= 1 && item.id <= 384) {
                updateStmt.run([
                    item.meaning || null,
                    JSON.stringify(item.keywords || []),
                    item.id
                ]);
                updatedCount++;
            }
        }
        
        updateStmt.finalize();
        console.log(`✅ h384: ${updatedCount}レコード統合完了`);
    }
    
    async integrateKoudoShishin() {
        console.log('🔄 koudo_shishin.json 統合中（既存互換性維持）...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/koudo_shishin.json`)
        );
        
        const updateStmt = this.sqlite.prepare(`
            UPDATE lines_384 
            SET shin_data = ?, hen_data = ?
            WHERE line_id = ?
        `);
        
        let updatedCount = 0;
        
        for (const item of data) {
            if (item.id >= 1 && item.id <= 384) {
                updateStmt.run([
                    item.shin || null,
                    item.hen || null,
                    item.id
                ]);
                updatedCount++;
            }
        }
        
        updateStmt.finalize();
        console.log(`✅ koudo_shishin: ${updatedCount}レコード統合完了（既存互換性維持）`);
    }
    
    async importIPADictionary() {
        console.log('📖 MeCab IPA辞書 導入中...');
        
        // IPA辞書のダウンロード・変換処理（実装例）
        await this.downloadIPADictionary();
        
        const csvPath = './data/ipadic/mecab-ipadic.csv';
        const csvData = fs.readFileSync(csvPath, 'utf-8');
        const lines = csvData.split('\n').filter(line => line.trim());
        
        const insertStmt = this.sqlite.prepare(`
            INSERT OR REPLACE INTO morphology_dict (
                surface, left_context_id, right_context_id, cost,
                part_of_speech, pos_detail1, pos_detail2, pos_detail3,
                inflection_type, inflection_form, base_form, reading, pronunciation,
                yijing_category, semantic_weight
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        let insertedCount = 0;
        
        for (const line of lines) {
            const fields = line.split(',');
            if (fields.length >= 13) {
                // 易経カテゴリの自動判定
                const yijingCategory = this.detectYijingCategory(fields[0], fields[10]);
                const semanticWeight = this.calculateSemanticWeight(fields[4], yijingCategory);
                
                insertStmt.run([
                    fields[0],  // surface
                    parseInt(fields[1]) || 0,  // left_context_id
                    parseInt(fields[2]) || 0,  // right_context_id
                    parseInt(fields[3]) || 0,  // cost
                    fields[4],  // part_of_speech
                    fields[5],  // pos_detail1
                    fields[6],  // pos_detail2
                    fields[7],  // pos_detail3
                    fields[8],  // inflection_type
                    fields[9],  // inflection_form
                    fields[10], // base_form
                    fields[11], // reading
                    fields[12], // pronunciation
                    yijingCategory,
                    semanticWeight
                ]);
                
                insertedCount++;
            }
        }
        
        insertStmt.finalize();
        console.log(`✅ IPA辞書: ${insertedCount}エントリ導入完了`);
    }
    
    async importWordNetJp() {
        console.log('🌐 WordNet-jp 導入中...');
        
        // WordNet-jpデータのダウンロード・変換
        await this.downloadWordNetJp();
        
        const synonymData = await this.parseWordNetData('./data/wordnet-jp/');
        
        const insertStmt = this.sqlite.prepare(`
            INSERT OR REPLACE INTO synonym_relations (
                word1, word2, relation_type, similarity_score,
                yijing_relevance, domain_category
            ) VALUES (?, ?, ?, ?, ?, ?)
        `);
        
        let insertedCount = 0;
        
        for (const relation of synonymData) {
            const yijingRelevance = this.calculateYijingRelevance(
                relation.word1, relation.word2
            );
            
            insertStmt.run([
                relation.word1,
                relation.word2,
                relation.relation_type,
                relation.similarity_score,
                yijingRelevance,
                relation.domain || 'general'
            ]);
            
            insertedCount++;
        }
        
        insertStmt.finalize();
        console.log(`✅ WordNet-jp: ${insertedCount}関係導入完了`);
    }
    
    // ユーティリティメソッド
    detectYijingCategory(surface, baseForm) {
        const yijingTerms = {
            'hexagram_name': /^(乾|坤|震|巽|坎|離|艮|兌|天|地|雷|風|水|火|山|澤)/,
            'leadership': /^(リーダー|指導|統率|責任|決断)/,
            'growth': /^(成長|発展|進歩|向上|改善)/,
            'challenge': /^(困難|問題|障害|試練|課題)/,
            'wisdom': /^(智慧|知恵|学習|理解|洞察)/
        };
        
        for (const [category, pattern] of Object.entries(yijingTerms)) {
            if (pattern.test(surface) || pattern.test(baseForm)) {
                return category;
            }
        }
        
        return null;
    }
    
    calculateSemanticWeight(partOfSpeech, yijingCategory) {
        let weight = 1.0;
        
        // 品詞による基本重み
        if (['名詞', '動詞', '形容詞'].includes(partOfSpeech)) {
            weight = 1.5;
        }
        
        // 易経カテゴリによるブースト
        if (yijingCategory) {
            weight *= 2.0;
        }
        
        return Math.min(3.0, weight);
    }
    
    calculateYijingRelevance(word1, word2) {
        // 易経関連度の計算ロジック
        const yijingWords = [
            '乾', '坤', '震', '巽', '坎', '離', '艮', '兌',
            'リーダー', '指導', '成長', '困難', '智慧', '責任'
        ];
        
        let relevance = 0;
        
        for (const word of yijingWords) {
            if (word1.includes(word) || word2.includes(word)) {
                relevance += 0.2;
            }
        }
        
        return Math.min(1.0, relevance);
    }
}
```

---

## 5. 承認・完了基準

### 5.1 技術仕様承認基準

| 承認項目 | 承認基準 | 検証方法 |
|---------|---------|---------|
| **データ統合** | 4つのJSONファイル100%統合 | SQLiteクエリでの全データ確認 |
| **辞書統合** | IPA辞書50MB + WordNet-jp20MB | データベースサイズ・エントリ数確認 |
| **API設計** | 全エンドポイント仕様書準拠 | OpenAPI仕様との整合性確認 |
| **性能設計** | 3ms以内レスポンス設計 | アーキテクチャレビュー |
| **拡張性** | 学習機能・フィードバック対応 | MongoDB設計レビュー |

### 5.2 段階別完了基準

#### Phase 1: データベース基盤（Week 1-2）
- [ ] SQLite統合DB: テーブル作成・データ統合100%完了
- [ ] MongoDB: 学習データコレクション設計・作成完了
- [ ] Redis: キャッシュ戦略実装・動作確認完了
- [ ] 外部辞書: IPA辞書・WordNet-jp導入完了

#### Phase 2: NLP エンジン（Week 3-4）  
- [ ] MeCab統合: SQLite辞書連携・精度90%以上達成
- [ ] WordNet統合: 類義語検索・類似度計算機能完了
- [ ] スコアリング: 5要素統合アルゴリズム実装完了
- [ ] API実装: 基本分析エンドポイント動作確認

#### Phase 3: 学習システム（Week 5-6）
- [ ] フィードバック: MongoDB学習データ保存・更新機能
- [ ] 動的重み: 学習基づく重み自動調整機能
- [ ] 性能最適化: 平均3ms以内レスポンス達成
- [ ] 統合テスト: 全機能統合動作確認完了

---

## 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| システムアーキテクト | | | |
| データベース設計者 | | | |
| 自然言語処理エンジニア | | | |
| 技術リード | | | |

---

**文書管理**
- **設計原則**: 真のデータベース統合による高度AI分析システム
- **技術選定**: SQLite + MongoDB + Redis マルチDBMS構成
- **データ活用**: 75%未活用データの完全統合活用
- **実装詳細**: 具体的コード例・設計パターンを含む包括的設計
- **配布先**: 開発チーム、アーキテクトチーム、QAチーム