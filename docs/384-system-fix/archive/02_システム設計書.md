# ğŸ—ï¸ 384çˆ»ã‚·ã‚¹ãƒ†ãƒ  Cloudflare Pageså¯¾å¿œã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆæ›¸

**æ–‡æ›¸ç•ªå·**: SD-384-005  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 5.0ï¼ˆç¾å®Ÿçš„Cloudflare Pagesç‰ˆï¼‰  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ28æ—¥  
**ä½œæˆè€…**: HAQEIé–‹ç™ºãƒãƒ¼ãƒ   
**æ‰¿èªè€…**: [æœªæ‰¿èª]  

---

## 1. ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦

### 1.1 Cloudflare Pageså¯¾å¿œã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

#### Cloudflare Pagesåˆ¶ç´„ã¨ç¾å®Ÿçš„å¯¾å¿œç­–
```yaml
åˆ¶ç´„äº‹é …:
  - ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰DBMSä¸å¯: SQLite, MongoDBç­‰ã¯ä½¿ç”¨ä¸å¯
  - æ°¸ç¶šã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸åˆ¶é™: ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰æ°¸ç¶šåŒ–ã¯ä¸å¯
  - ã‚¨ãƒƒã‚¸ç’°å¢ƒå®Ÿè¡Œ: è»½é‡ãƒ»é«˜é€Ÿå‡¦ç†ãŒå¿…é ˆ
  - ãƒ‡ãƒ¼ã‚¿ãƒ©ã‚¤ã‚»ãƒ³ã‚¹åˆ¶ç´„: å¤–éƒ¨è¾æ›¸ã®é…å¸ƒãƒ»åˆ©ç”¨åˆ¶é™
  - é–‹ç™ºãƒªã‚½ãƒ¼ã‚¹åˆ¶é™: ç¾å®Ÿçš„ãªå·¥æ•°ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

ç¾å®Ÿçš„Cloudflare Pageså¯¾å¿œç­–:
  - Edge-Nativeè¨­è¨ˆ: Workers + KV + D1 Database
  - æ®µéšçš„å®Ÿè£…: æ—¢å­˜koudo_shishin.jsonã‹ã‚‰é–‹å§‹
  - è»½é‡NLP: ãƒ–ãƒ©ã‚¦ã‚¶å†…åŸºæœ¬å½¢æ…‹ç´ è§£æ + ç°¡æ˜“é¡ç¾©èª
  - æ±ºå®šè«–çš„å­¦ç¿’: æ—¥æ¬¡ãƒãƒƒãƒæ›´æ–°ã«ã‚ˆã‚‹ä¸€è²«æ€§ä¿è¨¼
  - æ‹¡å¼µå¯èƒ½è¨­è¨ˆ: å°†æ¥çš„ãªãƒ‡ãƒ¼ã‚¿è¿½åŠ ã«å‚™ãˆãŸæŸ”è»Ÿæ€§
```

#### Cloudflare Pageså¯¾å¿œã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                384çˆ» Edge AIåˆ†æã‚·ã‚¹ãƒ†ãƒ                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå±¤                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Browser UI  â”‚ â”‚ Service     â”‚ â”‚ IndexedDB   â”‚  â”‚
â”‚  â”‚ (Vanilla JS)â”‚ â”‚ Worker      â”‚ â”‚ Cache       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Cloudflare Edgeå±¤                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         EdgeIntelligentScoringEngine               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚WASM     â”‚ â”‚Browser  â”‚ â”‚JSON     â”‚ â”‚KVå­¦ç¿’   â”‚  â”‚  â”‚
â”‚  â”‚  â”‚å½¢æ…‹ç´ è§£æâ”‚ â”‚é¡ç¾©èª   â”‚ â”‚çˆ»è¾     â”‚ â”‚é‡ã¿     â”‚  â”‚  â”‚
â”‚  â”‚  â”‚25%      â”‚ â”‚35%     â”‚ â”‚20%     â”‚ â”‚15%     â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚  â”‚
â”‚  â”‚           â”‚æ–‡è„ˆ5%  â”‚                           â”‚  â”‚
â”‚  â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Cloudflare Storageå±¤                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Workers KV   â”‚ â”‚ D1 Database â”‚ â”‚JSON Static  â”‚  â”‚
â”‚  â”‚å­¦ç¿’ãƒ‡ãƒ¼ã‚¿    â”‚ â”‚çµ±åˆãƒ‡ãƒ¼ã‚¿   â”‚ â”‚Assets       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Edge Storage                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚D1 Database (50MB)   â”‚ â”‚Workers KV â”‚ â”‚JSON Filesâ”‚  â”‚
â”‚  â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ â”‚ â”‚(Static)  â”‚  â”‚
â”‚  â”‚â”‚384çˆ»çµ±åˆãƒ†ãƒ¼ãƒ–ãƒ«  â”‚ â”‚ â”‚10MB/æœˆ   â”‚ â”‚20MB     â”‚  â”‚
â”‚  â”‚â”‚MeCabè¾æ›¸(WASM)  â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”‚â”‚WordNet(Browser) â”‚ â”‚                           â”‚
â”‚  â”‚â”‚JSONçµ±åˆãƒ‡ãƒ¼ã‚¿   â”‚ â”‚                           â”‚
â”‚  â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚                           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Cloudflare Edge Storageè¨­è¨ˆåŸå‰‡

#### 1.2.1 D1 Database: Edgeçµ±åˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
**å½¹å‰²**: Cloudflare Edgeç’°å¢ƒã§ã®æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ç®¡ç†

**ç¾å®Ÿçš„çµ±åˆå¯¾è±¡**:
```yaml
Phase 1 - ç¢ºå®Ÿãƒ‡ãƒ¼ã‚¿çµ±åˆ:
  koudo_shishin.json:
    - æ—¢å­˜shin/henãƒ‡ãƒ¼ã‚¿ï¼ˆ384ã‚¨ãƒ³ãƒˆãƒªç¢ºå®Ÿï¼‰
    - çµ±åˆå…ˆ: lines_384ãƒ†ãƒ¼ãƒ–ãƒ« (D1)
    - ãƒ©ã‚¤ã‚»ãƒ³ã‚¹: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…éƒ¨ãƒ‡ãƒ¼ã‚¿ï¼ˆä½¿ç”¨å¯èƒ½ï¼‰
    - ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º: ~2MB

Phase 2 - æ‹¡å¼µå¯èƒ½è¨­è¨ˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ï¼‰:
  å°†æ¥è¿½åŠ ãƒ‡ãƒ¼ã‚¿å¯¾å¿œ:
    - å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿å–å¾—æ™‚ã®æ‹¡å¼µã‚¹ãƒ­ãƒƒãƒˆ
    - ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ç¢ºèªå¾Œã®æ®µéšçš„çµ±åˆ
    - çµ±åˆå…ˆ: lines_384ãƒ†ãƒ¼ãƒ–ãƒ« (æ‹¡å¼µåˆ—)

Edgeå¯¾å¿œè»½é‡NLP:
  BrowseråŸºæœ¬å½¢æ…‹ç´ è§£æ:
    - JavaScriptæ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹åŸºæœ¬åˆ†æ
    - ã²ã‚‰ãŒãª/ã‚«ã‚¿ã‚«ãƒŠ/æ¼¢å­—åˆ†é›¢
    - åŸºæœ¬èªå¹¹æŠ½å‡ºï¼ˆè¾æ›¸ä¸è¦ï¼‰
    
  ç°¡æ˜“é¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°:
    - ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰é¡ç¾©èªãƒªã‚¹ãƒˆï¼ˆæ˜“çµŒç”¨èªï¼‰
    - ç·¨é›†è·é›¢ã«ã‚ˆã‚‹æ›–æ˜§ãƒãƒƒãƒãƒ³ã‚°
    - æ®µéšçš„è¾æ›¸æ‹¡å¼µå¯¾å¿œ
```

**ç¾å®Ÿçš„D1 Database ãƒ†ãƒ¼ãƒ–ãƒ«è¨­è¨ˆ**:
```sql
-- 1. 384çˆ»åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ« (Cloudflare D1 - Phase 1)
CREATE TABLE lines_384 (
    -- åŸºæœ¬è­˜åˆ¥æƒ…å ±
    line_id INTEGER PRIMARY KEY,           -- 1-384 (ä¸€æ„è­˜åˆ¥å­)
    hexagram_id INTEGER NOT NULL,          -- 1-64 (å¦ç•ªå·)  
    line_position INTEGER NOT NULL,        -- 1-6 (çˆ»ä½ç½®: åˆçˆ»-ä¸Šçˆ»)
    hexagram_name TEXT NOT NULL,           -- å¦å (ä¾‹: "ä¹¾ç‚ºå¤©")
    line_name TEXT,                        -- çˆ»å (ä¾‹: "åˆä¹")
    
    -- koudo_shishin.json ç¢ºå®Ÿãƒ‡ãƒ¼ã‚¿
    shin_data TEXT,                        -- æ—¢å­˜shinãƒ‡ãƒ¼ã‚¿
    hen_data TEXT,                         -- æ—¢å­˜henãƒ‡ãƒ¼ã‚¿
    
    -- Phase 2 æ‹¡å¼µç”¨ã‚¹ãƒ­ãƒƒãƒˆï¼ˆå°†æ¥ä½¿ç”¨ï¼‰
    extended_data_1 TEXT,                  -- å°†æ¥æ‹¡å¼µãƒ‡ãƒ¼ã‚¿1
    extended_data_2 TEXT,                  -- å°†æ¥æ‹¡å¼µãƒ‡ãƒ¼ã‚¿2
    extended_keywords TEXT,                -- å°†æ¥ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ï¼ˆJSONï¼‰
    
    -- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°
    data_version INTEGER DEFAULT 1,       -- ãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆæ±ºå®šè«–æ€§ä¿è¨¼ï¼‰
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- æ±ºå®šè«–æ€§ä¿è¨¼ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_hexagram_position ON lines_384(hexagram_id, line_position);
CREATE INDEX idx_data_version ON lines_384(data_version);  
CREATE INDEX idx_shin_hen_search ON lines_384(shin_data, hen_data);

-- 2. æ±ºå®šè«–çš„å­¦ç¿’ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ†ãƒ¼ãƒ–ãƒ« (D1)
CREATE TABLE user_feedback (
    id INTEGER PRIMARY KEY,
    session_id TEXT NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    batch_date TEXT NOT NULL,        -- YYYY-MM-DDï¼ˆæ±ºå®šè«–æ€§ä¿è¨¼ï¼‰
    
    -- å…¥åŠ›ãƒ‡ãƒ¼ã‚¿
    input_text TEXT NOT NULL,
    text_length INTEGER,
    
    -- äºˆæ¸¬çµæœï¼ˆãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¨˜éŒ²ï¼‰
    predicted_line_id INTEGER,
    confidence_score REAL,
    data_version INTEGER DEFAULT 1,  -- ä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³
    
    -- ãƒ¦ãƒ¼ã‚¶ãƒ¼è©•ä¾¡
    correct_line_id INTEGER,
    accuracy_rating INTEGER,         -- 1-5è©•ä¾¡
    feedback_comment TEXT,
    
    -- ãƒãƒƒãƒå‡¦ç†ç®¡ç†
    processed_in_batch INTEGER DEFAULT 0, -- 0:æœªå‡¦ç† 1:å‡¦ç†æ¸ˆã¿
    batch_applied_date TEXT         -- ãƒãƒƒãƒé©ç”¨æ—¥
);

CREATE INDEX idx_batch_date ON user_feedback(batch_date);
CREATE INDEX idx_processed_batch ON user_feedback(processed_in_batch);
CREATE INDEX idx_data_version ON user_feedback(data_version);

-- 3. æ—¥æ¬¡çµ±è¨ˆãƒ»ãƒãƒƒãƒç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ« (D1)
CREATE TABLE daily_batch_log (
    batch_date TEXT PRIMARY KEY,    -- YYYY-MM-DDå½¢å¼
    
    -- ãƒãƒƒãƒå‡¦ç†çµ±è¨ˆ
    total_feedback_processed INTEGER DEFAULT 0,
    weight_updates_applied INTEGER DEFAULT 0,
    new_data_version INTEGER DEFAULT 1,
    
    -- æ±ºå®šè«–æ€§ä¿è¨¼
    batch_status TEXT DEFAULT 'pending', -- pending/processing/completed
    batch_applied_at DATETIME,
    next_batch_date TEXT,           -- æ¬¡å›ãƒãƒƒãƒäºˆå®šæ—¥
    
    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_batch_status ON daily_batch_log(batch_status);
```

#### 1.2.2 Workers KV: æ±ºå®šè«–çš„å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ç®¡ç†
**å½¹å‰²**: Edgeç’°å¢ƒã§ã®æ±ºå®šè«–æ€§ä¿è¨¼ä»˜ãå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ç®¡ç†

**æ±ºå®šè«–çš„ Workers KV ãƒ‡ãƒ¼ã‚¿æ§‹é€ **:
```javascript
// KVã‚­ãƒ¼: "weights:version:{data_version}" 
// KVå€¤: ç¢ºå®šæ¸ˆã¿é‡ã¿ãƒ‡ãƒ¼ã‚¿ï¼ˆæ—¥æ¬¡ãƒãƒƒãƒæ›´æ–°ï¼‰
{
  data_version: 1,
  effective_date: "2025-08-28",
  batch_applied: true,
  
  // æ±ºå®šè«–çš„é‡ã¿è¨­å®šï¼ˆåŒä¸€å…¥åŠ›â†’åŒä¸€å‡ºåŠ›ä¿è¨¼ï¼‰
  scoring_weights: {
    shin_match: 0.35,            // shinå®Œå…¨ä¸€è‡´é‡ã¿
    hen_match: 0.25,             // henå®Œå…¨ä¸€è‡´é‡ã¿  
    partial_match: 0.20,         // éƒ¨åˆ†ä¸€è‡´é‡ã¿
    length_similarity: 0.10,     // æ–‡å­—åˆ—é•·é¡ä¼¼åº¦é‡ã¿
    context_bonus: 0.10          // æ–‡è„ˆãƒœãƒ¼ãƒŠã‚¹é‡ã¿
  },
  
  // ç°¡æ˜“é¡ç¾©èªãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆå›ºå®šãƒ»æ±ºå®šè«–çš„ï¼‰
  deterministic_synonyms: {
    "ãƒªãƒ¼ãƒ€ãƒ¼": ["æŒ‡å°è€…", "çµ±ç‡è€…", "ãƒªãƒ¼ãƒ‰"],
    "çµ„ç¹”": ["ã‚°ãƒ«ãƒ¼ãƒ—", "ãƒãƒ¼ãƒ ", "é›†å›£"],
    "è²¬ä»»": ["ç¾©å‹™", "ä½¿å‘½", "å½¹å‰²"],
    "å°ã": ["æŒ‡å°", "çµ±ç‡", "å¼•ç‡"]
  },
  
  // ãƒãƒƒãƒãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  batch_metadata: {
    previous_version: 0,
    feedback_count_processed: 156,
    accuracy_improvement: 0.023,
    next_update_scheduled: "2025-08-29"
  }
}

// KVã‚­ãƒ¼: "temp:feedback:{session_id}"
// KVå€¤: ãƒãƒƒãƒå‡¦ç†å¾…ã¡ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆä¸€æ™‚ä¿å­˜ï¼‰
{
  session_id: "user_session_12345",
  timestamp: "2025-08-28T12:00:00Z",
  batch_date: "2025-08-29",      // æ¬¡å›ãƒãƒƒãƒå‡¦ç†å¯¾è±¡æ—¥
  
  // æœ€å°é™ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿
  feedback_data: {
    input_text: "ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦çµ„ç¹”ã‚’å°ãè²¬ä»»ã‚’æ„Ÿã˜ã¦ã„ã‚‹",
    predicted_line_id: 23,
    correct_line_id: 5,
    accuracy_rating: 4,
    data_version_used: 1         // äºˆæ¸¬æ™‚ä½¿ç”¨ãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³
  },
  
  // ãƒãƒƒãƒå‡¦ç†ç®¡ç†
  processing_status: "pending",  // pending/processing/completed
  ttl: 86400                     // 24æ™‚é–“TTLï¼ˆãƒãƒƒãƒå‡¦ç†å¾Œå‰Šé™¤ï¼‰
}

// KVã‚­ãƒ¼: "stats:daily:{YYYY-MM-DD}"  
// KVå€¤: æ—¥æ¬¡çµ±è¨ˆãƒ‡ãƒ¼ã‚¿JSON
{
  date: "2025-08-28",
  
  // Edgeæ—¥æ¬¡çµ±è¨ˆã‚µãƒãƒªãƒ¼
  daily_summary: {
    total_predictions: 1247,       // ç·äºˆæ¸¬æ•°
    accurate_predictions: 1059,    // æ­£è§£äºˆæ¸¬æ•°
    accuracy_rate: 0.849,          // ç²¾åº¦
    avg_confidence: 0.731,         // å¹³å‡ä¿¡é ¼åº¦
    feedback_received: 89,         // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å—ä¿¡æ•°
    edge_processing_time: 2.1,     // å¹³å‡Edgeå‡¦ç†æ™‚é–“(ms)
    browser_success_rate: 0.956    // ãƒ–ãƒ©ã‚¦ã‚¶å‡¦ç†æˆåŠŸç‡
  },
  
  // ä¸Šä½ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çˆ»ï¼ˆä¸Šä½10çˆ»ã®ã¿KVä¿å­˜ï¼‰
  top_line_performance: [
    {
      line_id: 5,                  // ä¹¾ç‚ºå¤© ä¹äº”
      prediction_count: 45,        // äºˆæ¸¬å›æ•°
      correct_count: 41,           // æ­£è§£æ•°
      accuracy_rate: 0.911,        // ç²¾åº¦
      avg_confidence: 0.856,       // å¹³å‡ä¿¡é ¼åº¦
      feedback_count: 8,           // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ•°
      top_keywords: ["ãƒªãƒ¼ãƒ€ãƒ¼", "è²¬ä»»", "æ±ºæ–­"]
    }
    // ... ä¸Šä½9çˆ»ã®ãƒ‡ãƒ¼ã‚¿
  ],
  
  // æ±ºå®šè«–çš„é‡ã¿æƒ…å ±ï¼ˆå‚ç…§ç”¨ï¼‰
  deterministic_weights_applied: {
    current_version: 1,
    applied_weights: {
      shin_match: 0.35,            // shinå®Œå…¨ä¸€è‡´é‡ã¿
      hen_match: 0.25,             // henå®Œå…¨ä¸€è‡´é‡ã¿
      partial_match: 0.20,         // éƒ¨åˆ†ä¸€è‡´é‡ã¿
      length_similarity: 0.10,     // æ–‡å­—åˆ—é•·é¡ä¼¼åº¦é‡ã¿
      context_bonus: 0.10          // æ–‡è„ˆãƒœãƒ¼ãƒŠã‚¹é‡ã¿
    },
    last_batch_update: {
      batch_date: "2025-08-28",
      changes_applied: 3,
      improvement_measured: 0.023,
      next_update_date: "2025-08-29"
    }
  }
}
```

#### 1.2.3 Browser IndexedDB: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé«˜é€Ÿã‚­ãƒ£ãƒƒã‚·ãƒ¥
**å½¹å‰²**: Edgeãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“æœ€é©åŒ–ã¨ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œ

**ç¾å®Ÿçš„IndexedDB ã‚¹ãƒˆã‚¢è¨­è¨ˆ**:
```yaml
åˆ†æçµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥:
  store: "analysis_cache"
  key: "sha256(input_text + data_version)"
  ttl: 3600000 # 1æ™‚é–“(ms)
  size_estimate: "~1KB/entry"
  description: "æ±ºå®šè«–çš„åˆ†æçµæœã‚’IndexedDBã«æ ¼ç´"

åŸºæœ¬ãƒ†ã‚­ã‚¹ãƒˆåˆ†æã‚­ãƒ£ãƒƒã‚·ãƒ¥:
  store: "text_analysis_cache"
  key: "sha256(text)"
  ttl: 86400000 # 24æ™‚é–“(ms)
  size_estimate: "~500B/entry"
  description: "åŸºæœ¬å½¢æ…‹ç´ è§£æï¼ˆæ­£è¦è¡¨ç¾ãƒ™ãƒ¼ã‚¹ï¼‰çµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥"

ç°¡æ˜“é¡ç¾©èªã‚­ãƒ£ãƒƒã‚·ãƒ¥:
  store: "synonym_cache"
  key: "word"
  ttl: 43200000 # 12æ™‚é–“(ms)
  size_estimate: "~200B/entry"
  description: "å›ºå®šé¡ç¾©èªãƒªã‚¹ãƒˆã®æ¤œç´¢çµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥"

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³:
  store: "session_data"
  key: "session_id"
  ttl: 1800000 # 30åˆ†(ms)
  size_estimate: "~300B/entry"
  description: "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ»æ–‡è„ˆæƒ…å ±"

çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥:
  store: "stats_cache"
  key: "date"
  ttl: 604800000 # 7æ—¥(ms)
  size_estimate: "~3KB/entry"
  description: "Workers KVã‹ã‚‰å–å¾—ã—ãŸçµ±è¨ˆæƒ…å ±ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥"
```

---

## 2. ç¾å®Ÿçš„è‡ªç„¶è¨€èªå‡¦ç†ã‚¨ãƒ³ã‚¸ãƒ³è¨­è¨ˆ

### 2.1 BrowseråŸºæœ¬ãƒ†ã‚­ã‚¹ãƒˆè§£æã‚·ã‚¹ãƒ†ãƒ 

#### 2.1.1 ç¾å®Ÿçš„ãƒ»è»½é‡ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ
```javascript
class EdgeBasicTextAnalyzer {
    constructor(kvWeights, indexedDBCache) {
        this.weights = kvWeights;
        this.cache = indexedDBCache;
        this.synonymMap = this.initializeSynonyms();
    }
    
    async analyzeText(inputText, dataVersion = 1) {
        const startTime = performance.now();
        const cacheKey = this.generateCacheKey(inputText, dataVersion);
        
        // 1. IndexedDBã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèªï¼ˆæ±ºå®šè«–æ€§ä¿è¨¼ï¼‰
        const cached = await this.cache.get('text_analysis_cache', cacheKey);
        if (cached && !this.isCacheExpired(cached)) {
            return { ...cached.result, cache_hit: true };
        }
        
        // 2. åŸºæœ¬ãƒ†ã‚­ã‚¹ãƒˆåˆ†å‰²ãƒ»åˆ†æ
        const tokens = this.basicTokenize(inputText);
        
        // 3. æ˜“çµŒå°‚é–€ç”¨èªã®è­˜åˆ¥
        const enhancedTokens = this.identifyYijingTerms(tokens);
        
        // 4. ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æŠ½å‡º
        const keywords = this.extractKeywords(enhancedTokens);
        
        // 5. ç°¡æ˜“é¡ç¾©èªãƒãƒƒãƒ”ãƒ³ã‚°
        const synonymMatches = this.findSimpleSynonyms(keywords);
        
        const result = {
            tokens: enhancedTokens,
            keywords: keywords,
            synonym_matches: synonymMatches,
            processing_time_ms: performance.now() - startTime,
            data_version: dataVersion,
            cache_hit: false
        };
        
        // 6. IndexedDBã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
        await this.cache.set('text_analysis_cache', cacheKey, {
            result: result,
            cached_at: Date.now(),
            ttl: 86400000 // 24æ™‚é–“
        });
        
        return result;
    }
    
    basicTokenize(text) {
        // JavaScriptæ­£è¦è¡¨ç¾ã«ã‚ˆã‚‹åŸºæœ¬åˆ†å‰²
        const tokens = [];
        
        // 1. å¥èª­ç‚¹ãƒ»è¨˜å·ã§ã®åˆ†å‰²
        const sentences = text.split(/[ã€‚ï¼ï¼Ÿ\n]+/).filter(s => s.trim());
        
        for (const sentence of sentences) {
            // 2. ã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠãƒ»æ¼¢å­—ãƒ»è‹±æ•°å­—ã®åˆ†é›¢
            const matches = sentence.match(/[\u3040-\u309F]+|[\u30A0-\u30FF]+|[\u4E00-\u9FAF]+|[a-zA-Z0-9]+/g);
            
            if (matches) {
                tokens.push(...matches.map(token => ({
                    surface: token,
                    type: this.getTokenType(token),
                    length: token.length
                })));
            }
        }
        
        return tokens;
    }
    
    getTokenType(token) {
        if (/^[\u3040-\u309F]+$/.test(token)) return 'hiragana';
        if (/^[\u30A0-\u30FF]+$/.test(token)) return 'katakana';
        if (/^[\u4E00-\u9FAF]+$/.test(token)) return 'kanji';
        if (/^[a-zA-Z0-9]+$/.test(token)) return 'alphanumeric';
        return 'mixed';
    }
    
    identifyYijingTerms(tokens) {
        // æ˜“çµŒå°‚é–€ç”¨èªãƒ‘ã‚¿ãƒ¼ãƒ³ã®è­˜åˆ¥
        const yijingPatterns = [
            { regex: /^(ä¹¾|å¤|éœ‡|å·½|å|é›¢|è‰®|å…Œ)/, weight: 3.0, category: 'trigram' },
            { regex: /(å¤©|åœ°|é›·|é¢¨|æ°´|ç«|å±±|æ¾¤)/, weight: 2.5, category: 'element' },
            { regex: /(ãƒªãƒ¼ãƒ€ãƒ¼|æŒ‡å°|çµ±ç‡)/, weight: 2.0, category: 'leadership' },
            { regex: /(çµ„ç¹”|ãƒãƒ¼ãƒ |ã‚°ãƒ«ãƒ¼ãƒ—)/, weight: 1.8, category: 'group' },
            { regex: /(è²¬ä»»|ç¾©å‹™|ä½¿å‘½)/, weight: 1.5, category: 'duty' }
        ];
        
        return tokens.map(token => {
            for (const pattern of yijingPatterns) {
                if (pattern.regex.test(token.surface)) {
                    return {
                        ...token,
                        yijing_category: pattern.category,
                        weight: pattern.weight,
                        is_yijing_term: true
                    };
                }
            }
            return { ...token, weight: 1.0, is_yijing_term: false };
        });
    }
    
    extractKeywords(tokens) {
        return tokens
            .filter(token => token.length > 1) // 1æ–‡å­—èªã‚’é™¤å¤–
            .filter(token => token.type === 'kanji' || token.is_yijing_term) // æ¼¢å­—ã¾ãŸã¯æ˜“çµŒç”¨èª
            .sort((a, b) => b.weight - a.weight) // é‡ã¿é †
            .slice(0, 10); // ä¸Šä½10èª
    }
    
    findSimpleSynonyms(keywords) {
        const matches = [];
        
        for (const keyword of keywords) {
            const synonyms = this.synonymMap[keyword.surface] || [];
            if (synonyms.length > 0) {
                matches.push({
                    word: keyword.surface,
                    synonyms: synonyms,
                    weight: keyword.weight
                });
            }
        }
        
        return matches;
    }
    
    initializeSynonyms() {
        // å›ºå®šé¡ç¾©èªãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆæ±ºå®šè«–çš„ï¼‰
        return {
            'ãƒªãƒ¼ãƒ€ãƒ¼': ['æŒ‡å°è€…', 'çµ±ç‡è€…', 'ãƒªãƒ¼ãƒ‰'],
            'çµ„ç¹”': ['ã‚°ãƒ«ãƒ¼ãƒ—', 'ãƒãƒ¼ãƒ ', 'é›†å›£'],
            'è²¬ä»»': ['ç¾©å‹™', 'ä½¿å‘½', 'å½¹å‰²'],
            'å°ã': ['æŒ‡å°', 'çµ±ç‡', 'å¼•ç‡'],
            'æ±ºæ–­': ['åˆ¤æ–­', 'æ±ºå®š', 'é¸æŠ'],
            'æˆé•·': ['ç™ºå±•', 'å‘ä¸Š', 'é€²æ­©'],
            'å›°é›£': ['å•é¡Œ', 'èª²é¡Œ', 'è©¦ç·´'],
            'æ™ºæ…§': ['çŸ¥æµ', 'å¡æ™º', 'æ´å¯Ÿ']
        };
    }
}
```

### 2.2 æ±ºå®šè«–çš„ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚¨ãƒ³ã‚¸ãƒ³

#### 2.2.1 æ±ºå®šè«–çš„ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
```javascript
class DeterministicScoringEngine {
    constructor(d1Database, kvWeights, indexedDBCache) {
        this.db = d1Database;
        this.weights = kvWeights;
        this.cache = indexedDBCache;
    
    async findSynonyms(word, maxResults = 10) {
        const cacheKey = `synonyms:${word}:matches`;
        
        // Redisã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª
        let cached = await this.redis.get(cacheKey);
        if (cached) {
            return JSON.parse(cached);
        }
        
        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰é¡ç¾©èªã‚’æ¤œç´¢
        const synonyms = await this.db.all(`
            SELECT word2 as synonym, similarity_score, yijing_relevance, domain_category
            FROM synonym_relations 
            WHERE word1 = ? AND similarity_score > ?
            
            UNION
            
            SELECT word1 as synonym, similarity_score, yijing_relevance, domain_category  
            FROM synonym_relations
            WHERE word2 = ? AND similarity_score > ?
            
            ORDER BY 
                yijing_relevance DESC,
                similarity_score DESC
            LIMIT ?
        `, [word, this.similarityThreshold, word, this.similarityThreshold, maxResults]);
        
        // 12æ™‚é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        await this.redis.setex(cacheKey, 43200, JSON.stringify(synonyms));
        
        return synonyms;
    }
    
    async calculateContextualSimilarity(word1, word2, context = []) {
        // Wu-Palmeré¡ä¼¼åº¦ + æ–‡è„ˆé‡ã¿
        const baseSimilarity = await this.getBaseSimilarity(word1, word2);
        if (!baseSimilarity) return 0;
        
        // æ–‡è„ˆã«ã‚ˆã‚‹é‡ã¿èª¿æ•´
        let contextBonus = 0;
        for (const contextWord of context) {
            const c1 = await this.getBaseSimilarity(word1, contextWord);
            const c2 = await this.getBaseSimilarity(word2, contextWord);
            if (c1 && c2) {
                contextBonus += (c1.similarity_score + c2.similarity_score) * 0.1;
            }
        }
        
        return Math.min(1.0, baseSimilarity.similarity_score + contextBonus);
    }
    
    async getBaseSimilarity(word1, word2) {
        const result = await this.db.get(`
            SELECT similarity_score, yijing_relevance
            FROM synonym_relations
            WHERE (word1 = ? AND word2 = ?) OR (word1 = ? AND word2 = ?)
        `, [word1, word2, word2, word1]);
        
        return result;
    }
    
    async updateSynonymStrength(word1, word2, feedback) {
        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åŸºã¥ãé¡ç¾©èªé–¢ä¿‚å¼·åŒ–
        const currentRelation = await this.getBaseSimilarity(word1, word2);
        
        if (currentRelation) {
            // æ—¢å­˜é–¢ä¿‚ã®å¼·åŒ–
            const newScore = this.adjustSimilarityScore(
                currentRelation.similarity_score,
                feedback
            );
            
            await this.db.run(`
                UPDATE synonym_relations 
                SET similarity_score = ?, last_updated = CURRENT_TIMESTAMP
                WHERE (word1 = ? AND word2 = ?) OR (word1 = ? AND word2 = ?)
            `, [newScore, word1, word2, word2, word1]);
        } else if (feedback.accuracy > 0.8) {
            // æ–°è¦é–¢ä¿‚ã®è¿½åŠ ï¼ˆé«˜ç²¾åº¦ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®ã¿ï¼‰
            await this.db.run(`
                INSERT INTO synonym_relations 
                (word1, word2, similarity_score, relation_type, yijing_relevance, learned_weight)
                VALUES (?, ?, ?, ?, ?, ?)
            `, [
                word1, word2, 
                0.5, 'learned_synonym', 
                feedback.yijing_context ? 0.8 : 0.2,
                1.2
            ]);
        }
    }
}
```

---

## 3. ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆåˆ†æã‚¨ãƒ³ã‚¸ãƒ³

### 3.1 çµ±åˆã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 

#### 3.1.1 5è¦ç´ çµ±åˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
```javascript
class IntelligentScoringEngine {
    constructor(databases) {
        this.sqlite = databases.sqlite;
        this.mongo = databases.mongo;
        this.redis = databases.redis;
        
        // å‹•çš„é‡ã¿ï¼ˆMongoDBå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—ï¼‰
        this.weights = {
            morphology: 0.25,    // å½¢æ…‹ç´ è§£æã‚¹ã‚³ã‚¢
            synonym: 0.35,       // é¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°ã‚¹ã‚³ã‚¢  
            yaoci: 0.20,         // çˆ»è¾ç›´æ¥ãƒãƒƒãƒã‚¹ã‚³ã‚¢
            learning: 0.15,      // å­¦ç¿’é‡ã¿ã‚¹ã‚³ã‚¢
            context: 0.05        // æ–‡è„ˆã‚¹ã‚³ã‚¢
        };
        
        this.mecabEngine = new DatabaseIntegratedMeCabEngine();
        this.synonymEngine = new WordNetSynonymEngine(this.sqlite, this.redis);
    }
    
    async analyzeTextToLine(inputText) {
        const analysisId = this.generateAnalysisId();
        const startTime = performance.now();
        
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª
        const cacheKey = `analysis:${this.hashText(inputText)}:result`;
        const cached = await this.redis.get(cacheKey);
        if (cached) {
            const result = JSON.parse(cached);
            return { ...result, cache_hit: true, analysis_id: analysisId };
        }
        
        try {
            // 1. å‹•çš„é‡ã¿ã®æœ€æ–°åŒ–
            await this.updateDynamicWeights();
            
            // 2. å½¢æ…‹ç´ è§£æå®Ÿè¡Œ
            const morphologyResult = await this.mecabEngine.analyze(inputText);
            
            // 3. å…¨384çˆ»ã«å¯¾ã™ã‚‹ã‚¹ã‚³ã‚¢è¨ˆç®—
            const lineScores = await this.calculateAllLineScores(
                inputText, morphologyResult
            );
            
            // 4. æœ€é«˜ã‚¹ã‚³ã‚¢çˆ»ã®æ±ºå®š
            const bestMatch = this.selectBestMatch(lineScores);
            
            // 5. çµæœæ§‹é€ åŒ–
            const result = {
                analysis_id: analysisId,
                line_384_id: bestMatch.line_id,
                confidence_score: bestMatch.total_score,
                
                // åŸºæœ¬æƒ…å ±
                hexagram_name: bestMatch.hexagram_name,
                line_name: bestMatch.line_name,
                yaoci_text: bestMatch.yaoci_text,
                yaoci_meaning: bestMatch.yaoci_meaning,
                personality_trait: bestMatch.personality_trait,
                
                // è©³ç´°ã‚¹ã‚³ã‚¢åˆ†è§£
                score_breakdown: {
                    morphology_score: bestMatch.morphology_score,
                    synonym_score: bestMatch.synonym_score,
                    yaoci_match_score: bestMatch.yaoci_score,
                    learning_weight_score: bestMatch.learning_score,
                    context_score: bestMatch.context_score
                },
                
                // åˆ†æãƒ‡ãƒ¼ã‚¿
                analysis_details: {
                    input_features: morphologyResult,
                    alternative_matches: lineScores.slice(1, 6), // ä¸Šä½5å€™è£œ
                    processing_time_ms: performance.now() - startTime
                },
                
                cache_hit: false,
                timestamp: new Date().toISOString()
            };
            
            // 6. çµæœã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆ1æ™‚é–“ï¼‰
            await this.redis.setex(cacheKey, 3600, JSON.stringify(result));
            
            return result;
            
        } catch (error) {
            throw new AnalysisError(`åˆ†æå‡¦ç†ã‚¨ãƒ©ãƒ¼: ${error.message}`, {
                input_text: inputText,
                analysis_id: analysisId,
                error_stage: error.stage || 'unknown'
            });
        }
    }
    
    async calculateAllLineScores(inputText, morphologyResult) {
        // å…¨384çˆ»ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const allLines = await this.sqlite.all(`
            SELECT 
                line_id, hexagram_id, line_position,
                hexagram_name, line_name,
                yaoci_text, yaoci_meaning, personality_trait,
                keywords, basic_meaning
            FROM lines_384
            ORDER BY line_id
        `);
        
        const lineScores = [];
        
        // å„çˆ»ã«å¯¾ã—ã¦ã‚¹ã‚³ã‚¢è¨ˆç®—
        for (const line of allLines) {
            try {
                const scores = await this.calculateSingleLineScore(
                    line, inputText, morphologyResult
                );
                
                lineScores.push({
                    ...line,
                    ...scores,
                    total_score: 
                        scores.morphology_score * this.weights.morphology +
                        scores.synonym_score * this.weights.synonym +
                        scores.yaoci_score * this.weights.yaoci +
                        scores.learning_score * this.weights.learning +
                        scores.context_score * this.weights.context
                });
                
            } catch (error) {
                // å€‹åˆ¥çˆ»ã®è¨ˆç®—ã‚¨ãƒ©ãƒ¼ã¯0ç‚¹ã¨ã—ã¦ç¶™ç¶š
                console.warn(`Line ${line.line_id} scoring error:`, error.message);
                lineScores.push({
                    ...line,
                    morphology_score: 0,
                    synonym_score: 0,
                    yaoci_score: 0,
                    learning_score: 0,
                    context_score: 0,
                    total_score: 0
                });
            }
        }
        
        // ç·åˆã‚¹ã‚³ã‚¢é †ã§ã‚½ãƒ¼ãƒˆ
        return lineScores.sort((a, b) => b.total_score - a.total_score);
    }
    
    async calculateSingleLineScore(line, inputText, morphologyResult) {
        // 1. å½¢æ…‹ç´ è§£æã‚¹ã‚³ã‚¢ï¼ˆ25%é‡ã¿ï¼‰
        const morphologyScore = await this.calculateMorphologyScore(
            line, morphologyResult.keywords
        );
        
        // 2. é¡ç¾©èªãƒãƒƒãƒãƒ³ã‚°ã‚¹ã‚³ã‚¢ï¼ˆ35%é‡ã¿ï¼‰
        const synonymScore = await this.calculateSynonymScore(
            line, morphologyResult.keywords
        );
        
        // 3. çˆ»è¾ç›´æ¥ãƒãƒƒãƒã‚¹ã‚³ã‚¢ï¼ˆ20%é‡ã¿ï¼‰
        const yaociScore = await this.calculateYaociMatchScore(
            line, morphologyResult.tokens, inputText
        );
        
        // 4. å­¦ç¿’é‡ã¿ã‚¹ã‚³ã‚¢ï¼ˆ15%é‡ã¿ï¼‰
        const learningScore = await this.calculateLearningScore(line.line_id);
        
        // 5. æ–‡è„ˆã‚¹ã‚³ã‚¢ï¼ˆ5%é‡ã¿ï¼‰
        const contextScore = await this.calculateContextScore(
            line, inputText, morphologyResult
        );
        
        return {
            morphology_score: morphologyScore,
            synonym_score: synonymScore,
            yaoci_score: yaociScore,
            learning_score: learningScore,
            context_score: contextScore
        };
    }
    
    async calculateMorphologyScore(line, extractedKeywords) {
        if (!extractedKeywords.length) return 0;
        
        let totalScore = 0;
        let maxPossibleScore = 0;
        
        for (const keyword of extractedKeywords) {
            maxPossibleScore += keyword.weight;
            
            // çˆ»ã®å„ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã®æ¤œç´¢
            const fields = [
                line.yaoci_text,
                line.yaoci_meaning, 
                line.basic_meaning,
                line.personality_trait
            ].filter(field => field);
            
            let bestFieldScore = 0;
            
            for (const field of fields) {
                if (field.includes(keyword.word)) {
                    // å®Œå…¨ä¸€è‡´
                    bestFieldScore = Math.max(bestFieldScore, keyword.weight);
                } else if (field.includes(keyword.base_form)) {
                    // åŸºæœ¬å½¢ä¸€è‡´
                    bestFieldScore = Math.max(bestFieldScore, keyword.weight * 0.8);
                }
            }
            
            totalScore += bestFieldScore;
        }
        
        return maxPossibleScore > 0 ? totalScore / maxPossibleScore : 0;
    }
    
    async calculateSynonymScore(line, extractedKeywords) {
        if (!extractedKeywords.length) return 0;
        
        let totalScore = 0;
        let maxPossibleScore = 0;
        
        for (const keyword of extractedKeywords) {
            maxPossibleScore += keyword.weight;
            
            // é¡ç¾©èªæ¤œç´¢
            const synonyms = await this.synonymEngine.findSynonyms(keyword.word, 5);
            
            let bestSynonymScore = 0;
            
            for (const synonym of synonyms) {
                const fields = [
                    line.yaoci_text,
                    line.yaoci_meaning,
                    line.basic_meaning,
                    line.personality_trait
                ].filter(field => field);
                
                for (const field of fields) {
                    if (field.includes(synonym.synonym)) {
                        const score = keyword.weight * synonym.similarity_score;
                        bestSynonymScore = Math.max(bestSynonymScore, score);
                    }
                }
            }
            
            totalScore += bestSynonymScore;
        }
        
        return maxPossibleScore > 0 ? totalScore / maxPossibleScore : 0;
    }
    
    async calculateYaociMatchScore(line, tokens, inputText) {
        // çˆ»è¾ãƒ†ã‚­ã‚¹ãƒˆã¨ã®ç›´æ¥ãƒãƒƒãƒãƒ³ã‚°åº¦ã‚’è¨ˆç®—
        const yaociText = line.yaoci_text + ' ' + (line.yaoci_meaning || '');
        if (!yaociText.trim()) return 0;
        
        // æ–‡å­—ãƒ¬ãƒ™ãƒ«ã§ã®é¡ä¼¼åº¦è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        let matchScore = 0;
        const inputChars = inputText.length;
        
        for (const token of tokens) {
            if (yaociText.includes(token.surface)) {
                matchScore += token.surface.length;
            }
        }
        
        return inputChars > 0 ? matchScore / inputChars : 0;
    }
    
    async calculateLearningScore(lineId) {
        // MongoDBå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å‹•çš„é‡ã¿ã‚’å–å¾—
        try {
            const todayStats = await this.mongo.collection('learning_statistics')
                .findOne({
                    date: new Date().toISOString().split('T')[0]
                });
            
            if (todayStats && todayStats.line_performance) {
                const linePerf = todayStats.line_performance.find(
                    p => p.line_id === lineId
                );
                
                if (linePerf) {
                    // ç²¾åº¦ã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ•°ã‚’é‡ã¿ä»˜ã‘
                    return Math.min(1.0, 
                        linePerf.accuracy_rate * 0.7 + 
                        (linePerf.feedback_count / 100) * 0.3
                    );
                }
            }
            
            return 0.5; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
            
        } catch (error) {
            console.warn('Learning score calculation error:', error.message);
            return 0.5;
        }
    }
    
    async calculateContextScore(line, inputText, morphologyResult) {
        // æ–‡å…¨ä½“ã®æ–‡è„ˆã¨çˆ»ã®æ„å‘³çš„æ•´åˆæ€§
        const semanticCategories = morphologyResult.semantic_categories || [];
        
        // æ˜“çµŒã‚«ãƒ†ã‚´ãƒªã®ãƒãƒƒãƒãƒ³ã‚°
        let categoryScore = 0;
        const lineCategories = this.extractLineCategories(line);
        
        for (const category of semanticCategories) {
            if (lineCategories.includes(category)) {
                categoryScore += 0.2;
            }
        }
        
        return Math.min(1.0, categoryScore);
    }
    
    extractLineCategories(line) {
        const categories = [];
        
        // çˆ»ä½ç½®ã«ã‚ˆã‚‹åˆ†é¡
        switch (line.line_position) {
            case 1: categories.push('beginning', 'foundation'); break;
            case 2: categories.push('development', 'growth'); break;
            case 3: categories.push('difficulty', 'challenge'); break;
            case 4: categories.push('transition', 'change'); break;
            case 5: categories.push('leadership', 'success'); break;
            case 6: categories.push('completion', 'culmination'); break;
        }
        
        return categories;
    }
    
    selectBestMatch(lineScores) {
        // æœ€é«˜ã‚¹ã‚³ã‚¢çˆ»ã‚’é¸æŠï¼ˆä¿¡é ¼åº¦ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
        const best = lineScores[0];
        
        if (best.total_score < 0.3) {
            // ä½ä¿¡é ¼åº¦ã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
            console.warn(`Low confidence score: ${best.total_score}`);
        }
        
        return best;
    }
    
    async updateDynamicWeights() {
        // MongoDBå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æœ€æ–°ã®é‡ã¿ã‚’å–å¾—ãƒ»æ›´æ–°
        try {
            const latestStats = await this.mongo.collection('learning_statistics')
                .findOne(
                    {},
                    { sort: { date: -1 } }
                );
            
            if (latestStats && latestStats.weight_adjustments) {
                const weights = latestStats.weight_adjustments.current_weights;
                if (weights) {
                    this.weights = { ...this.weights, ...weights };
                }
            }
            
        } catch (error) {
            console.warn('Dynamic weight update error:', error.message);
        }
    }
}

class AnalysisError extends Error {
    constructor(message, metadata = {}) {
        super(message);
        this.name = 'AnalysisError';
        this.metadata = metadata;
    }
}
```

---

## 4. ãƒ‡ãƒ¼ã‚¿çµ±åˆãƒ»ç§»è¡Œè¨­è¨ˆ

### 4.1 JSONãƒ‡ãƒ¼ã‚¿çµ±åˆãƒ—ãƒ­ã‚»ã‚¹

#### 4.1.1 ãƒ‡ãƒ¼ã‚¿çµ±åˆã‚¹ã‚¯ãƒªãƒ—ãƒˆè¨­è¨ˆ
```javascript
class DataIntegrationManager {
    constructor() {
        this.sqlite = new SQLiteConnection('./dbs/haqei_master.db');
        this.dataPath = './public/data/';
        this.integratedData = new Map();
    }
    
    async executeFullIntegration() {
        console.log('ğŸš€ 384çˆ»ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆé–‹å§‹...');
        
        try {
            // 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
            await this.initializeDatabase();
            
            // 2. JSONãƒ•ã‚¡ã‚¤ãƒ«çµ±åˆ
            await this.integrateEnhancedHexagrams();
            await this.integrateYaociData();
            await this.integrateH384Data();
            await this.integrateKoudoShishin();
            
            // 3. å¤–éƒ¨è¾æ›¸å°å…¥
            await this.importIPADictionary();
            await this.importWordNetJp();
            
            // 4. ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼ãƒ»æœ€é©åŒ–
            await this.validateIntegratedData();
            await this.optimizeDatabase();
            
            console.log('âœ… ãƒ‡ãƒ¼ã‚¿çµ±åˆå®Œäº†');
            
        } catch (error) {
            console.error('âŒ ãƒ‡ãƒ¼ã‚¿çµ±åˆã‚¨ãƒ©ãƒ¼:', error);
            throw error;
        }
    }
    
    async integrateEnhancedHexagrams() {
        console.log('ğŸ“š enhanced_hexagrams_complete.json çµ±åˆä¸­...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/enhanced_hexagrams_complete.json`)
        );
        
        const insertStmt = this.sqlite.prepare(`
            INSERT OR REPLACE INTO lines_384 (
                line_id, hexagram_id, line_position, 
                hexagram_name, line_name,
                yaoci_text, yaoci_meaning, 
                personality_trait, transformation_potential
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        let insertedCount = 0;
        
        for (const hexagram of data) {
            for (let position = 1; position <= 6; position++) {
                const line = hexagram.six_lines[position - 1];
                const lineId = (hexagram.number - 1) * 6 + position;
                
                insertStmt.run([
                    lineId,                           // line_id
                    hexagram.number,                  // hexagram_id  
                    position,                         // line_position
                    hexagram.name,                    // hexagram_name
                    line.name || `${this.getPositionName(position)}`, // line_name
                    line.text || null,                // yaoci_text
                    line.meaning || null,             // yaoci_meaning
                    line.personality_trait || null,   // personality_trait
                    line.transformation_potential || null // transformation_potential
                ]);
                
                insertedCount++;
            }
        }
        
        insertStmt.finalize();
        console.log(`âœ… enhanced_hexagrams: ${insertedCount}ãƒ¬ã‚³ãƒ¼ãƒ‰çµ±åˆå®Œäº†`);
    }
    
    async integrateYaociData() {
        console.log('ğŸ“œ yaoci_31-63.json çµ±åˆä¸­...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/yaoci_31-63.json`)
        );
        
        const updateStmt = this.sqlite.prepare(`
            UPDATE lines_384 
            SET extended_yaoci = ?, classical_interpretation = ?
            WHERE line_id = ?
        `);
        
        let updatedCount = 0;
        
        for (const [key, value] of Object.entries(data)) {
            // ã‚­ãƒ¼ã‹ã‚‰ line_id ã‚’æ¨å®šï¼ˆä¾‹: "31-1" -> line_id = 181ï¼‰
            const [hexagramNum, linePos] = key.split('-').map(Number);
            const lineId = (hexagramNum - 1) * 6 + linePos;
            
            if (lineId >= 1 && lineId <= 384) {
                updateStmt.run([
                    value.extended_text || null,
                    value.classical_interpretation || null,
                    lineId
                ]);
                updatedCount++;
            }
        }
        
        updateStmt.finalize();
        console.log(`âœ… yaoci_31-63: ${updatedCount}ãƒ¬ã‚³ãƒ¼ãƒ‰çµ±åˆå®Œäº†`);
    }
    
    async integrateH384Data() {
        console.log('ğŸ”¢ h384.json çµ±åˆä¸­...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/h384.json`)
        );
        
        const updateStmt = this.sqlite.prepare(`
            UPDATE lines_384 
            SET basic_meaning = ?, keywords = ?
            WHERE line_id = ?
        `);
        
        let updatedCount = 0;
        
        for (const item of data) {
            if (item.id >= 1 && item.id <= 384) {
                updateStmt.run([
                    item.meaning || null,
                    JSON.stringify(item.keywords || []),
                    item.id
                ]);
                updatedCount++;
            }
        }
        
        updateStmt.finalize();
        console.log(`âœ… h384: ${updatedCount}ãƒ¬ã‚³ãƒ¼ãƒ‰çµ±åˆå®Œäº†`);
    }
    
    async integrateKoudoShishin() {
        console.log('ğŸ”„ koudo_shishin.json çµ±åˆä¸­ï¼ˆæ—¢å­˜äº’æ›æ€§ç¶­æŒï¼‰...');
        
        const data = JSON.parse(
            fs.readFileSync(`${this.dataPath}/koudo_shishin.json`)
        );
        
        const updateStmt = this.sqlite.prepare(`
            UPDATE lines_384 
            SET shin_data = ?, hen_data = ?
            WHERE line_id = ?
        `);
        
        let updatedCount = 0;
        
        for (const item of data) {
            if (item.id >= 1 && item.id <= 384) {
                updateStmt.run([
                    item.shin || null,
                    item.hen || null,
                    item.id
                ]);
                updatedCount++;
            }
        }
        
        updateStmt.finalize();
        console.log(`âœ… koudo_shishin: ${updatedCount}ãƒ¬ã‚³ãƒ¼ãƒ‰çµ±åˆå®Œäº†ï¼ˆæ—¢å­˜äº’æ›æ€§ç¶­æŒï¼‰`);
    }
    
    async importIPADictionary() {
        console.log('ğŸ“– MeCab IPAè¾æ›¸ å°å…¥ä¸­...');
        
        // IPAè¾æ›¸ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ»å¤‰æ›å‡¦ç†ï¼ˆå®Ÿè£…ä¾‹ï¼‰
        await this.downloadIPADictionary();
        
        const csvPath = './data/ipadic/mecab-ipadic.csv';
        const csvData = fs.readFileSync(csvPath, 'utf-8');
        const lines = csvData.split('\n').filter(line => line.trim());
        
        const insertStmt = this.sqlite.prepare(`
            INSERT OR REPLACE INTO morphology_dict (
                surface, left_context_id, right_context_id, cost,
                part_of_speech, pos_detail1, pos_detail2, pos_detail3,
                inflection_type, inflection_form, base_form, reading, pronunciation,
                yijing_category, semantic_weight
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        let insertedCount = 0;
        
        for (const line of lines) {
            const fields = line.split(',');
            if (fields.length >= 13) {
                // æ˜“çµŒã‚«ãƒ†ã‚´ãƒªã®è‡ªå‹•åˆ¤å®š
                const yijingCategory = this.detectYijingCategory(fields[0], fields[10]);
                const semanticWeight = this.calculateSemanticWeight(fields[4], yijingCategory);
                
                insertStmt.run([
                    fields[0],  // surface
                    parseInt(fields[1]) || 0,  // left_context_id
                    parseInt(fields[2]) || 0,  // right_context_id
                    parseInt(fields[3]) || 0,  // cost
                    fields[4],  // part_of_speech
                    fields[5],  // pos_detail1
                    fields[6],  // pos_detail2
                    fields[7],  // pos_detail3
                    fields[8],  // inflection_type
                    fields[9],  // inflection_form
                    fields[10], // base_form
                    fields[11], // reading
                    fields[12], // pronunciation
                    yijingCategory,
                    semanticWeight
                ]);
                
                insertedCount++;
            }
        }
        
        insertStmt.finalize();
        console.log(`âœ… IPAè¾æ›¸: ${insertedCount}ã‚¨ãƒ³ãƒˆãƒªå°å…¥å®Œäº†`);
    }
    
    async importWordNetJp() {
        console.log('ğŸŒ WordNet-jp å°å…¥ä¸­...');
        
        // WordNet-jpãƒ‡ãƒ¼ã‚¿ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ»å¤‰æ›
        await this.downloadWordNetJp();
        
        const synonymData = await this.parseWordNetData('./data/wordnet-jp/');
        
        const insertStmt = this.sqlite.prepare(`
            INSERT OR REPLACE INTO synonym_relations (
                word1, word2, relation_type, similarity_score,
                yijing_relevance, domain_category
            ) VALUES (?, ?, ?, ?, ?, ?)
        `);
        
        let insertedCount = 0;
        
        for (const relation of synonymData) {
            const yijingRelevance = this.calculateYijingRelevance(
                relation.word1, relation.word2
            );
            
            insertStmt.run([
                relation.word1,
                relation.word2,
                relation.relation_type,
                relation.similarity_score,
                yijingRelevance,
                relation.domain || 'general'
            ]);
            
            insertedCount++;
        }
        
        insertStmt.finalize();
        console.log(`âœ… WordNet-jp: ${insertedCount}é–¢ä¿‚å°å…¥å®Œäº†`);
    }
    
    // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
    detectYijingCategory(surface, baseForm) {
        const yijingTerms = {
            'hexagram_name': /^(ä¹¾|å¤|éœ‡|å·½|å|é›¢|è‰®|å…Œ|å¤©|åœ°|é›·|é¢¨|æ°´|ç«|å±±|æ¾¤)/,
            'leadership': /^(ãƒªãƒ¼ãƒ€ãƒ¼|æŒ‡å°|çµ±ç‡|è²¬ä»»|æ±ºæ–­)/,
            'growth': /^(æˆé•·|ç™ºå±•|é€²æ­©|å‘ä¸Š|æ”¹å–„)/,
            'challenge': /^(å›°é›£|å•é¡Œ|éšœå®³|è©¦ç·´|èª²é¡Œ)/,
            'wisdom': /^(æ™ºæ…§|çŸ¥æµ|å­¦ç¿’|ç†è§£|æ´å¯Ÿ)/
        };
        
        for (const [category, pattern] of Object.entries(yijingTerms)) {
            if (pattern.test(surface) || pattern.test(baseForm)) {
                return category;
            }
        }
        
        return null;
    }
    
    calculateSemanticWeight(partOfSpeech, yijingCategory) {
        let weight = 1.0;
        
        // å“è©ã«ã‚ˆã‚‹åŸºæœ¬é‡ã¿
        if (['åè©', 'å‹•è©', 'å½¢å®¹è©'].includes(partOfSpeech)) {
            weight = 1.5;
        }
        
        // æ˜“çµŒã‚«ãƒ†ã‚´ãƒªã«ã‚ˆã‚‹ãƒ–ãƒ¼ã‚¹ãƒˆ
        if (yijingCategory) {
            weight *= 2.0;
        }
        
        return Math.min(3.0, weight);
    }
    
    calculateYijingRelevance(word1, word2) {
        // æ˜“çµŒé–¢é€£åº¦ã®è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
        const yijingWords = [
            'ä¹¾', 'å¤', 'éœ‡', 'å·½', 'å', 'é›¢', 'è‰®', 'å…Œ',
            'ãƒªãƒ¼ãƒ€ãƒ¼', 'æŒ‡å°', 'æˆé•·', 'å›°é›£', 'æ™ºæ…§', 'è²¬ä»»'
        ];
        
        let relevance = 0;
        
        for (const word of yijingWords) {
            if (word1.includes(word) || word2.includes(word)) {
                relevance += 0.2;
            }
        }
        
        return Math.min(1.0, relevance);
    }
}
```

---

## 5. æ‰¿èªãƒ»å®Œäº†åŸºæº–

### 5.1 æŠ€è¡“ä»•æ§˜æ‰¿èªåŸºæº–

| æ‰¿èªé …ç›® | æ‰¿èªåŸºæº– | æ¤œè¨¼æ–¹æ³• |
|---------|---------|---------|
| **ãƒ‡ãƒ¼ã‚¿çµ±åˆ** | 4ã¤ã®JSONãƒ•ã‚¡ã‚¤ãƒ«100%çµ±åˆ | SQLiteã‚¯ã‚¨ãƒªã§ã®å…¨ãƒ‡ãƒ¼ã‚¿ç¢ºèª |
| **è¾æ›¸çµ±åˆ** | IPAè¾æ›¸50MB + WordNet-jp20MB | ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚µã‚¤ã‚ºãƒ»ã‚¨ãƒ³ãƒˆãƒªæ•°ç¢ºèª |
| **APIè¨­è¨ˆ** | å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä»•æ§˜æ›¸æº–æ‹  | OpenAPIä»•æ§˜ã¨ã®æ•´åˆæ€§ç¢ºèª |
| **æ€§èƒ½è¨­è¨ˆ** | 3msä»¥å†…ãƒ¬ã‚¹ãƒãƒ³ã‚¹è¨­è¨ˆ | ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ¬ãƒ“ãƒ¥ãƒ¼ |
| **æ‹¡å¼µæ€§** | å­¦ç¿’æ©Ÿèƒ½ãƒ»ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å¯¾å¿œ | MongoDBè¨­è¨ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ |

### 5.2 æ®µéšåˆ¥å®Œäº†åŸºæº–

#### Phase 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åŸºç›¤ï¼ˆWeek 1-2ï¼‰
- [ ] SQLiteçµ±åˆDB: ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆãƒ»ãƒ‡ãƒ¼ã‚¿çµ±åˆ100%å®Œäº†
- [ ] MongoDB: å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³è¨­è¨ˆãƒ»ä½œæˆå®Œäº†
- [ ] Redis: ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥å®Ÿè£…ãƒ»å‹•ä½œç¢ºèªå®Œäº†
- [ ] å¤–éƒ¨è¾æ›¸: IPAè¾æ›¸ãƒ»WordNet-jpå°å…¥å®Œäº†

#### Phase 2: NLP ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆWeek 3-4ï¼‰  
- [ ] MeCabçµ±åˆ: SQLiteè¾æ›¸é€£æºãƒ»ç²¾åº¦90%ä»¥ä¸Šé”æˆ
- [ ] WordNetçµ±åˆ: é¡ç¾©èªæ¤œç´¢ãƒ»é¡ä¼¼åº¦è¨ˆç®—æ©Ÿèƒ½å®Œäº†
- [ ] ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°: 5è¦ç´ çµ±åˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè£…å®Œäº†
- [ ] APIå®Ÿè£…: åŸºæœ¬åˆ†æã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå‹•ä½œç¢ºèª

#### Phase 3: å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ï¼ˆWeek 5-6ï¼‰
- [ ] ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: MongoDBå­¦ç¿’ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ»æ›´æ–°æ©Ÿèƒ½
- [ ] å‹•çš„é‡ã¿: å­¦ç¿’åŸºã¥ãé‡ã¿è‡ªå‹•èª¿æ•´æ©Ÿèƒ½
- [ ] æ€§èƒ½æœ€é©åŒ–: å¹³å‡3msä»¥å†…ãƒ¬ã‚¹ãƒãƒ³ã‚¹é”æˆ
- [ ] çµ±åˆãƒ†ã‚¹ãƒˆ: å…¨æ©Ÿèƒ½çµ±åˆå‹•ä½œç¢ºèªå®Œäº†

---

## æ‰¿èª

| å½¹å‰² | æ°å | æ‰¿èªæ—¥ | ç½²å |
|------|------|--------|------|
| ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ | | | |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆè€… | | | |
| è‡ªç„¶è¨€èªå‡¦ç†ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ | | | |
| æŠ€è¡“ãƒªãƒ¼ãƒ‰ | | | |

---

**æ–‡æ›¸ç®¡ç†**
- **è¨­è¨ˆåŸå‰‡**: çœŸã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹çµ±åˆã«ã‚ˆã‚‹é«˜åº¦AIåˆ†æã‚·ã‚¹ãƒ†ãƒ 
- **æŠ€è¡“é¸å®š**: SQLite + MongoDB + Redis ãƒãƒ«ãƒDBMSæ§‹æˆ
- **ãƒ‡ãƒ¼ã‚¿æ´»ç”¨**: 75%æœªæ´»ç”¨ãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨çµ±åˆæ´»ç”¨
- **å®Ÿè£…è©³ç´°**: å…·ä½“çš„ã‚³ãƒ¼ãƒ‰ä¾‹ãƒ»è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å«ã‚€åŒ…æ‹¬çš„è¨­è¨ˆ
- **é…å¸ƒå…ˆ**: é–‹ç™ºãƒãƒ¼ãƒ ã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆãƒãƒ¼ãƒ ã€QAãƒãƒ¼ãƒ 