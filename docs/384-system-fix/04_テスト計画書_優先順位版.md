# ğŸ§ª 384çˆ»ã‚·ã‚¹ãƒ†ãƒ  å„ªå…ˆé †ä½ä»˜ããƒ†ã‚¹ãƒˆè¨ˆç”»æ›¸

**æ–‡æ›¸ç•ªå·**: TP-384-PR-001  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0ï¼ˆå„ªå…ˆé †ä½ç‰ˆï¼‰  
**ä½œæˆæ—¥**: 2025å¹´8æœˆ28æ—¥  
**ä½œæˆè€…**: HAQEIé–‹ç™ºãƒãƒ¼ãƒ   
**æ‰¿èªè€…**: [æœªæ‰¿èª]

---

## 1. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥æ¦‚è¦

### 1.1 å„ªå…ˆé †ä½ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆæ–¹é‡

```yaml
ãƒ†ã‚¹ãƒˆå„ªå…ˆåº¦:
  P0_Criticalï¼ˆå¿…é ˆï¼‰:
    - Edgeåˆ¶ç´„é•åãƒ†ã‚¹ãƒˆ
    - åŸºæœ¬å‹•ä½œç¢ºèª
    - ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§
    - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½
    
  P1_Highï¼ˆé‡è¦ï¼‰:
    - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
    - ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‹•ä½œ
    - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    
  P2_Mediumï¼ˆæ¨™æº–ï¼‰:
    - NLPç²¾åº¦ãƒ†ã‚¹ãƒˆ
    - çµ±åˆãƒ†ã‚¹ãƒˆ
    - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºæœ¬
    
  P3_Lowï¼ˆè¿½åŠ ï¼‰:
    - MLç²¾åº¦æ¤œè¨¼
    - è² è·ãƒ†ã‚¹ãƒˆè©³ç´°
    - ã‚«ã‚ªã‚¹ãƒ†ã‚¹ãƒˆ
```

### 1.2 æ®µéšçš„ãƒ†ã‚¹ãƒˆå®Ÿè¡Œè¨ˆç”»

| Phase | æœŸé–“ | å„ªå…ˆåº¦ | ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ | åˆæ ¼åŸºæº– |
|-------|------|--------|-----------|----------|
| Phase 1 | Week 1 | P0 | åˆ¶ç´„ç¢ºèª | 100%åˆæ ¼ |
| Phase 2 | Week 2 | P0+P1 | åŸºæœ¬æ©Ÿèƒ½ | 95%åˆæ ¼ |
| Phase 3 | Week 3 | P1+P2 | å“è³ªç¢ºä¿ | 90%åˆæ ¼ |
| Phase 4 | Week 4 | P2+P3 | æœ€é©åŒ– | 85%åˆæ ¼ |

---

## 2. P0: Critical - åˆ¶ç´„ç¢ºèªãƒ†ã‚¹ãƒˆï¼ˆå¿…é ˆï¼‰

### 2.1 Edgeç’°å¢ƒåˆ¶ç´„ãƒ†ã‚¹ãƒˆ

```javascript
// tests/p0/edge_constraints.test.js
describe('P0: Edgeç’°å¢ƒåˆ¶ç´„ãƒ†ã‚¹ãƒˆ', () => {
  
  test('CPUæ™‚é–“åˆ¶é™ï¼ˆ50msï¼‰', async () => {
    const startTime = performance.now();
    const response = await fetch('/api/analyze', {
      method: 'POST',
      body: JSON.stringify({ text: 'ãƒ†ã‚¹ãƒˆå…¥åŠ›' })
    });
    const duration = performance.now() - startTime;
    
    expect(duration).toBeLessThan(50);
    expect(response.status).toBe(200);
  });
  
  test('D1ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚µã‚¤ã‚ºï¼ˆ50MBä»¥å†…ï¼‰', async () => {
    const dbSize = await getD1DatabaseSize();
    expect(dbSize).toBeLessThan(50 * 1024 * 1024); // 50MB
  });
  
  test('Workers KVå€¤ã‚µã‚¤ã‚ºï¼ˆ25MBä»¥å†…ï¼‰', async () => {
    const kvEntries = await getAllKVEntries();
    
    for (const entry of kvEntries) {
      const size = new Blob([entry.value]).size;
      expect(size).toBeLessThan(25 * 1024 * 1024); // 25MB/å€¤
    }
  });
  
  test('ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ï¼ˆ128MBä»¥å†…ï¼‰', async () => {
    const memoryUsage = performance.memory?.usedJSHeapSize || 0;
    expect(memoryUsage).toBeLessThan(128 * 1024 * 1024);
  });
  
  test('ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºï¼ˆ100MBä»¥å†…ï¼‰', async () => {
    const largeInput = 'x'.repeat(100 * 1024 * 1024 + 1);
    
    const response = await fetch('/api/analyze', {
      method: 'POST',
      body: JSON.stringify({ text: largeInput })
    });
    
    expect(response.status).toBe(413); // Payload Too Large
  });
});
```

### 2.2 åŸºæœ¬å‹•ä½œç¢ºèªãƒ†ã‚¹ãƒˆ

```javascript
// tests/p0/basic_functionality.test.js
describe('P0: åŸºæœ¬å‹•ä½œç¢ºèª', () => {
  
  test('æœ€å°é™ã®åˆ†é¡æ©Ÿèƒ½', async () => {
    const testCases = [
      { input: 'ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—', expectedRange: [1, 64] },
      { input: 'å¤‰åŒ–ã¨æˆé•·', expectedRange: [65, 128] },
      { input: 'å›°é›£ã‚’ä¹—ã‚Šè¶Šãˆã‚‹', expectedRange: [129, 192] }
    ];
    
    for (const testCase of testCases) {
      const result = await analyze(testCase.input);
      
      expect(result).toHaveProperty('line_id');
      expect(result.line_id).toBeGreaterThanOrEqual(testCase.expectedRange[0]);
      expect(result.line_id).toBeLessThanOrEqual(testCase.expectedRange[1]);
    }
  });
  
  test('ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ç¢ºèª', async () => {
    const db = getD1Instance();
    
    // åŸºæœ¬ãƒ‡ãƒ¼ã‚¿å­˜åœ¨ç¢ºèª
    const count = await db.prepare(
      'SELECT COUNT(*) as count FROM lines_384_core'
    ).first();
    
    expect(count.count).toBe(384);
    
    // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç¢ºèª
    const sample = await db.prepare(
      'SELECT * FROM lines_384_core WHERE line_id = 1'
    ).first();
    
    expect(sample).toHaveProperty('hexagram_id');
    expect(sample).toHaveProperty('shin_data');
    expect(sample).toHaveProperty('hen_data');
  });
  
  test('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹•ä½œ', async () => {
    // ãƒ¡ã‚¤ãƒ³å‡¦ç†ã‚’æ„å›³çš„ã«å¤±æ•—ã•ã›ã‚‹
    const mockError = new Error('Simulated failure');
    jest.spyOn(global, 'mainProcess').mockRejectedValueOnce(mockError);
    
    const result = await analyzeWithFallback('ãƒ†ã‚¹ãƒˆå…¥åŠ›');
    
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå‹•ä½œã™ã‚‹ã“ã¨
    expect(result).toHaveProperty('line_id');
    expect(result).toHaveProperty('fallback_used', true);
    expect(result.confidence).toBeLessThan(0.7); // ä½ä¿¡é ¼åº¦
  });
});
```

### 2.3 ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆ

```javascript
// tests/p0/data_integrity.test.js
describe('P0: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§', () => {
  
  test('IDé€£ç¶šæ€§', async () => {
    const ids = await getAllLineIds();
    
    expect(ids).toHaveLength(384);
    for (let i = 0; i < 384; i++) {
      expect(ids).toContain(i + 1);
    }
  });
  
  test('å¦ã¨çˆ»ã®å¯¾å¿œ', async () => {
    for (let hexagram = 1; hexagram <= 64; hexagram++) {
      for (let line = 1; line <= 6; line++) {
        const lineId = (hexagram - 1) * 6 + line;
        const data = await getLineData(lineId);
        
        expect(data.hexagram_id).toBe(hexagram);
        expect(data.line_position).toBe(line);
      }
    }
  });
  
  test('åœ§ç¸®ãƒ‡ãƒ¼ã‚¿ã®å¾©å…ƒå¯èƒ½æ€§', async () => {
    const compressed = await getCompressedData();
    const decompressed = decompress(compressed);
    
    expect(decompressed).toBeDefined();
    expect(decompressed.length).toBeGreaterThan(0);
    
    // ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ç¢ºèª
    const parsed = JSON.parse(decompressed);
    expect(parsed).toHaveProperty('version');
    expect(parsed).toHaveProperty('data');
  });
});
```

---

## 3. P1: High - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆé‡è¦ï¼‰

### 3.1 å¿œç­”æ™‚é–“ãƒ†ã‚¹ãƒˆ

```javascript
// tests/p1/performance.test.js
describe('P1: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ', () => {
  
  test('å¿œç­”æ™‚é–“åˆ†å¸ƒ', async () => {
    const iterations = 100;
    const responseTimes = [];
    
    for (let i = 0; i < iterations; i++) {
      const start = performance.now();
      await analyze(`ãƒ†ã‚¹ãƒˆå…¥åŠ› ${i}`);
      responseTimes.push(performance.now() - start);
    }
    
    const p50 = percentile(responseTimes, 50);
    const p95 = percentile(responseTimes, 95);
    const p99 = percentile(responseTimes, 99);
    
    expect(p50).toBeLessThan(30);  // ç›®æ¨™: 30ms
    expect(p95).toBeLessThan(50);  // ç›®æ¨™: 50ms
    expect(p99).toBeLessThan(100); // ç›®æ¨™: 100ms
  });
  
  test('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡', async () => {
    const testInputs = [
      'ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—',
      'å¤‰åŒ–ã¨æˆé•·',
      'ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—', // é‡è¤‡
      'è²¬ä»»ã¨ç¾©å‹™',
      'å¤‰åŒ–ã¨æˆé•·'       // é‡è¤‡
    ];
    
    let cacheHits = 0;
    
    for (const input of testInputs) {
      const result = await analyze(input);
      if (result.cached) cacheHits++;
    }
    
    const hitRate = cacheHits / testInputs.length;
    expect(hitRate).toBeGreaterThan(0.4); // 40%ä»¥ä¸Šï¼ˆé‡è¤‡åˆ†ï¼‰
  });
  
  test('ä¸¦è¡Œå‡¦ç†æ€§èƒ½', async () => {
    const concurrentRequests = 50;
    const promises = [];
    
    const start = performance.now();
    
    for (let i = 0; i < concurrentRequests; i++) {
      promises.push(analyze(`ä¸¦è¡Œãƒ†ã‚¹ãƒˆ ${i}`));
    }
    
    const results = await Promise.all(promises);
    const duration = performance.now() - start;
    
    // å…¨ãƒªã‚¯ã‚¨ã‚¹ãƒˆæˆåŠŸ
    expect(results.every(r => r.line_id)).toBe(true);
    
    // å¹³å‡å‡¦ç†æ™‚é–“
    const avgTime = duration / concurrentRequests;
    expect(avgTime).toBeLessThan(50);
  });
});
```

### 3.2 ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‹•ä½œãƒ†ã‚¹ãƒˆ

```javascript
// tests/p1/cache.test.js
describe('P1: ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‹•ä½œ', () => {
  
  test('å¤šå±¤ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‹•ä½œ', async () => {
    const cache = new MultiLevelCache();
    const key = 'test_key';
    const value = { data: 'test' };
    
    // æ›¸ãè¾¼ã¿
    await cache.set(key, value);
    
    // L1ï¼ˆãƒ¡ãƒ¢ãƒªï¼‰ã‹ã‚‰å–å¾—
    const l1Result = await cache.get(key);
    expect(l1Result.source).toBe('memory');
    expect(l1Result.data).toEqual(value);
    
    // L1ã‚¯ãƒªã‚¢å¾Œã€L2ï¼ˆKVï¼‰ã‹ã‚‰å–å¾—
    cache.l1.clear();
    const l2Result = await cache.get(key);
    expect(l2Result.source).toBe('kv');
    
    // L2ã‚¯ãƒªã‚¢å¾Œã€L3ï¼ˆCache APIï¼‰ã‹ã‚‰å–å¾—
    await env.KV.delete(key);
    const l3Result = await cache.get(key);
    expect(l3Result.source).toBe('cache');
  });
  
  test('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç„¡åŠ¹åŒ–', async () => {
    const cache = new MultiLevelCache();
    
    // ãƒ‡ãƒ¼ã‚¿è¨­å®š
    await cache.set('test', { version: 1 });
    
    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ›´æ–°ã«ã‚ˆã‚‹ç„¡åŠ¹åŒ–
    await cache.invalidate('test');
    
    const result = await cache.get('test');
    expect(result).toBeNull();
  });
  
  test('TTLå‹•ä½œ', async () => {
    const cache = new MultiLevelCache();
    
    // çŸ­ã„TTLã§è¨­å®š
    await cache.set('ttl_test', { data: 'test' }, 1); // 1ç§’
    
    // å³åº§ã«å–å¾—å¯èƒ½
    const immediate = await cache.get('ttl_test');
    expect(immediate).toBeDefined();
    
    // 2ç§’å¾Œã¯å–å¾—ä¸å¯
    await new Promise(resolve => setTimeout(resolve, 2000));
    const expired = await cache.get('ttl_test');
    expect(expired).toBeNull();
  });
});
```

---

## 4. P2: Medium - å“è³ªãƒ†ã‚¹ãƒˆï¼ˆæ¨™æº–ï¼‰

### 4.1 NLPç²¾åº¦ãƒ†ã‚¹ãƒˆ

```javascript
// tests/p2/nlp_accuracy.test.js
describe('P2: NLPç²¾åº¦ãƒ†ã‚¹ãƒˆ', () => {
  
  test('å½¢æ…‹ç´ è§£æç²¾åº¦', async () => {
    const testCases = [
      {
        input: 'ä¹¾ç‚ºå¤©ã®åˆä¹',
        expected: ['ä¹¾ç‚ºå¤©', 'ã®', 'åˆä¹']
      },
      {
        input: 'ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦è²¬ä»»ã‚’æŒã¤',
        expected: ['ãƒªãƒ¼ãƒ€ãƒ¼', 'ã¨ã—ã¦', 'è²¬ä»»', 'ã‚’', 'æŒã¤']
      }
    ];
    
    for (const testCase of testCases) {
      const tokens = await tokenize(testCase.input);
      const surfaces = tokens.map(t => t.surface);
      
      // ä¸»è¦ãƒˆãƒ¼ã‚¯ãƒ³ãŒå«ã¾ã‚Œã‚‹ã“ã¨
      for (const expected of testCase.expected) {
        expect(surfaces).toContain(expected);
      }
    }
  });
  
  test('é¡ç¾©èªå±•é–‹', async () => {
    const synonymTests = [
      {
        word: 'ãƒªãƒ¼ãƒ€ãƒ¼',
        expectedSynonyms: ['æŒ‡å°è€…', 'çµ±ç‡è€…']
      },
      {
        word: 'å¤‰åŒ–',
        expectedSynonyms: ['å¤‰å‹•', 'å¤‰é·']
      }
    ];
    
    for (const test of synonymTests) {
      const synonyms = await expandSynonyms(test.word);
      
      for (const expected of test.expectedSynonyms) {
        expect(synonyms).toContain(expected);
      }
    }
  });
  
  test('åˆ†é¡ç²¾åº¦ï¼ˆã‚µãƒ³ãƒ—ãƒ«100ä»¶ï¼‰', async () => {
    const testData = await loadTestDataset(100);
    let correct = 0;
    
    for (const item of testData) {
      const result = await analyze(item.input);
      if (result.line_id === item.expected_line_id) {
        correct++;
      }
    }
    
    const accuracy = correct / testData.length;
    expect(accuracy).toBeGreaterThan(0.75); // 75%ä»¥ä¸Š
  });
});
```

### 4.2 çµ±åˆãƒ†ã‚¹ãƒˆ

```javascript
// tests/p2/integration.test.js
describe('P2: çµ±åˆãƒ†ã‚¹ãƒˆ', () => {
  
  test('ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ•ãƒ­ãƒ¼', async () => {
    // 1. å…¥åŠ›å—ä»˜
    const input = {
      text: 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦å›°é›£ã‚’ä¹—ã‚Šè¶Šãˆã‚‹',
      session_id: 'test_session'
    };
    
    // 2. åˆ†æå®Ÿè¡Œ
    const response = await fetch('/api/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input)
    });
    
    expect(response.status).toBe(200);
    
    const result = await response.json();
    
    // 3. çµæœæ¤œè¨¼
    expect(result).toHaveProperty('line_id');
    expect(result).toHaveProperty('confidence');
    expect(result).toHaveProperty('processing_time');
    expect(result.processing_time).toBeLessThan(50);
    
    // 4. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡
    const feedback = {
      session_id: input.session_id,
      predicted: result.line_id,
      actual: 1,
      rating: 4
    };
    
    const feedbackResponse = await fetch('/api/feedback', {
      method: 'POST',
      body: JSON.stringify(feedback)
    });
    
    expect(feedbackResponse.status).toBe(201);
  });
  
  test('ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼', async () => {
    // ä¸æ­£ãªå…¥åŠ›
    const invalidInputs = [
      { text: null },
      { text: '' },
      { text: 'x'.repeat(10000) },
      { invalid: 'field' }
    ];
    
    for (const input of invalidInputs) {
      const response = await fetch('/api/analyze', {
        method: 'POST',
        body: JSON.stringify(input)
      });
      
      // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ãªã„
      expect([400, 422]).toContain(response.status);
      
      const error = await response.json();
      expect(error).toHaveProperty('error');
    }
  });
});
```

---

## 5. P3: Low - è¿½åŠ ãƒ†ã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

### 5.1 æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«æ¤œè¨¼

```javascript
// tests/p3/ml_validation.test.js
describe('P3: MLæ¤œè¨¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰', () => {
  
  test.skip('ãƒ¢ãƒ‡ãƒ«åœ§ç¸®å‰å¾Œã®ç²¾åº¦', async () => {
    const fullModel = await loadFullModel();
    const compressedModel = await loadCompressedModel();
    const testSet = await loadTestDataset(500);
    
    let fullCorrect = 0;
    let compressedCorrect = 0;
    
    for (const item of testSet) {
      const fullPred = await fullModel.predict(item.input);
      const compPred = await compressedModel.predict(item.input);
      
      if (fullPred === item.expected) fullCorrect++;
      if (compPred === item.expected) compressedCorrect++;
    }
    
    const fullAccuracy = fullCorrect / testSet.length;
    const compAccuracy = compressedCorrect / testSet.length;
    
    // åœ§ç¸®ã«ã‚ˆã‚‹ç²¾åº¦ä½ä¸‹ãŒ5%ä»¥å†…
    expect(fullAccuracy - compAccuracy).toBeLessThan(0.05);
  });
  
  test.skip('æ¨è«–æ™‚é–“æ¯”è¼ƒ', async () => {
    const models = {
      rule: new RuleBasedModel(),
      compressed: new CompressedMLModel(),
      full: new FullMLModel()
    };
    
    const input = 'ãƒ†ã‚¹ãƒˆå…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆ';
    const times = {};
    
    for (const [name, model] of Object.entries(models)) {
      const start = performance.now();
      await model.predict(input);
      times[name] = performance.now() - start;
    }
    
    expect(times.rule).toBeLessThan(5);
    expect(times.compressed).toBeLessThan(20);
    expect(times.full).toBeLessThan(50);
  });
});
```

### 5.2 ã‚«ã‚ªã‚¹ãƒ†ã‚¹ãƒˆ

```javascript
// tests/p3/chaos.test.js
describe('P3: ã‚«ã‚ªã‚¹ãƒ†ã‚¹ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰', () => {
  
  test.skip('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é…å»¶ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³', async () => {
    // äººå·¥çš„ãªé…å»¶ã‚’è¿½åŠ 
    const addLatency = (ms) => {
      return new Promise(resolve => setTimeout(resolve, ms));
    };
    
    const originalFetch = global.fetch;
    global.fetch = async (...args) => {
      await addLatency(500); // 500msé…å»¶
      return originalFetch(...args);
    };
    
    const result = await analyzeWithTimeout('ãƒ†ã‚¹ãƒˆ', 1000);
    
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã›ãšã«çµæœã‚’è¿”ã™ã“ã¨
    expect(result).toHaveProperty('line_id');
    
    global.fetch = originalFetch;
  });
  
  test.skip('éƒ¨åˆ†çš„ãƒ‡ãƒ¼ã‚¿æ¬ æ', async () => {
    // ä¸€éƒ¨ãƒ‡ãƒ¼ã‚¿ã‚’æ„å›³çš„ã«å‰Šé™¤
    await corruptData(['lines_100_to_150']);
    
    // å½±éŸ¿ç¯„å›²ã®ãƒ†ã‚¹ãƒˆ
    const affected = await analyze('è©²å½“ç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆ');
    expect(affected.fallback_used).toBe(true);
    
    // å½±éŸ¿ç¯„å›²å¤–ã®ãƒ†ã‚¹ãƒˆ
    const unaffected = await analyze('å½±éŸ¿å¤–ã®ãƒ†ã‚­ã‚¹ãƒˆ');
    expect(unaffected.fallback_used).toBeFalsy();
    
    // ãƒ‡ãƒ¼ã‚¿å¾©æ—§
    await restoreData();
  });
});
```

---

## 6. ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–ã¨CI/CD

### 6.1 å„ªå…ˆåº¦åˆ¥å®Ÿè¡Œè¨­å®š

```yaml
# .github/workflows/test.yml
name: å„ªå…ˆåº¦åˆ¥ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  p0-critical:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p0
      - name: P0å¤±æ•—æ™‚ã¯å³åº§ã«åœæ­¢
        if: failure()
        run: exit 1
        
  p1-high:
    needs: p0-critical
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p1
      
  p2-medium:
    needs: p1-high
    runs-on: ubuntu-latest
    timeout-minutes: 30
    continue-on-error: true  # P2å¤±æ•—ã§ã‚‚ç¶šè¡Œ
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p2
      
  p3-low:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: p2-medium
    runs-on: ubuntu-latest
    timeout-minutes: 60
    continue-on-error: true  # P3ã¯å‚è€ƒå€¤
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p3
```

### 6.2 ãƒ†ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ

```javascript
// scripts/generate_test_report.js
class TestReporter {
  generatePriorityReport(results) {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        p0: this.summarize(results.p0),
        p1: this.summarize(results.p1),
        p2: this.summarize(results.p2),
        p3: this.summarize(results.p3)
      },
      recommendation: this.getRecommendation(results)
    };
    
    return report;
  }
  
  getRecommendation(results) {
    if (results.p0.failureRate > 0) {
      return 'BLOCK: Criticalåˆ¶ç´„é•å - ãƒ‡ãƒ—ãƒ­ã‚¤ä¸å¯';
    }
    
    if (results.p1.failureRate > 0.05) {
      return 'WARNING: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ - æ”¹å–„å¿…è¦';
    }
    
    if (results.p2.failureRate > 0.15) {
      return 'CAUTION: å“è³ªæ”¹å–„æ¨å¥¨';
    }
    
    return 'READY: ãƒ‡ãƒ—ãƒ­ã‚¤å¯èƒ½';
  }
}
```

---

## 7. æˆåŠŸåŸºæº–

### 7.1 å„ªå…ˆåº¦åˆ¥åˆæ ¼åŸºæº–

| å„ªå…ˆåº¦ | ãƒ†ã‚¹ãƒˆé …ç›® | å¿…é ˆåˆæ ¼ç‡ | ç›®æ¨™åˆæ ¼ç‡ | ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚° |
|--------|-----------|------------|------------|--------------|
| P0 | åˆ¶ç´„ç¢ºèª | 100% | 100% | Yes |
| P1 | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ | 95% | 98% | Yes |
| P2 | å“è³ªãƒ»ç²¾åº¦ | 85% | 90% | No |
| P3 | è¿½åŠ æ¤œè¨¼ | 70% | 80% | No |

### 7.2 ç’°å¢ƒåˆ‡æ›¿ãƒ†ã‚¹ãƒˆ

```javascript
// tests/environment_switching.test.js

describe('Multi-Environment Adapter Tests', () => {
    test('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼è‡ªå‹•åˆ‡æ›¿', async () => {
        // é–‹ç™ºç’°å¢ƒ: SQLite
        process.env.NODE_ENV = 'development';
        let db = await DatabaseAdapter.create();
        expect(db.type).toBe('sqlite');
        
        // æœ¬ç•ªç’°å¢ƒ: D1
        process.env.NODE_ENV = 'production';
        db = await DatabaseAdapter.create();
        expect(db.type).toBe('d1');
        expect(db.sizeLimit).toBe(50 * 1024 * 1024); // 50MB
    });
    
    test('ã‚­ãƒ£ãƒƒã‚·ãƒ¥å±¤ã®ç’°å¢ƒåˆ¥å‹•ä½œ', async () => {
        const testKey = 'test_key';
        const testValue = { data: 'test' };
        
        // é–‹ç™º: Redis
        process.env.NODE_ENV = 'development';
        const devCache = await CacheAdapter.create();
        await devCache.set(testKey, testValue);
        expect(await devCache.get(testKey)).toEqual(testValue);
        
        // æœ¬ç•ª: Workers KV
        process.env.NODE_ENV = 'production';
        const prodCache = await CacheAdapter.create();
        await prodCache.set(testKey, testValue);
        expect(await prodCache.get(testKey)).toEqual(testValue);
    });
    
    test('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿æˆ¦ç•¥ã®åˆ‡æ›¿', async () => {
        // é–‹ç™º: ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«
        process.env.NODE_ENV = 'development';
        const devModel = await ModelLoader.load();
        expect(devModel.source).toBe('local');
        
        // æœ¬ç•ª: CDNé…ä¿¡
        process.env.NODE_ENV = 'production';
        const prodModel = await ModelLoader.load();
        expect(prodModel.source).toBe('cdn');
        expect(prodModel.compressed).toBe(true);
    });
    
    test('ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ä¸€è²«æ€§', async () => {
        const envs = ['development', 'production'];
        
        for (const env of envs) {
            process.env.NODE_ENV = env;
            const db = await DatabaseAdapter.create();
            
            try {
                await db.query('INVALID SQL');
            } catch (error) {
                // å…¨ç’°å¢ƒã§çµ±ä¸€ã‚¨ãƒ©ãƒ¼å½¢å¼
                expect(error).toHaveProperty('code');
                expect(error).toHaveProperty('message');
            }
        }
    });
});
```

### 7.3 æ®µéšçš„ãƒªãƒªãƒ¼ã‚¹åˆ¤å®š

```yaml
ãƒªãƒªãƒ¼ã‚¹åˆ¤å®šåŸºæº–:
  ã‚¢ãƒ«ãƒ•ã‚¡ç‰ˆ:
    - P0: 100%åˆæ ¼
    - P1: 90%åˆæ ¼
    - ç’°å¢ƒåˆ‡æ›¿: åŸºæœ¬å‹•ä½œç¢ºèª
    
  ãƒ™ãƒ¼ã‚¿ç‰ˆ:
    - P0: 100%åˆæ ¼
    - P1: 95%åˆæ ¼
    - P2: 80%åˆæ ¼
    - ç’°å¢ƒåˆ‡æ›¿: å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼
    
  æ­£å¼ç‰ˆ:
    - P0: 100%åˆæ ¼
    - P1: 98%åˆæ ¼
    - P2: 90%åˆæ ¼
    - P3: 70%åˆæ ¼
    - ç’°å¢ƒåˆ‡æ›¿: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åŸºæº–é”æˆ
```

---

## 8. ãƒ†ã‚¹ãƒˆè¨ˆç”»ã®ç¶™ç¶šçš„è¦‹ç›´ã—ãƒ—ãƒ­ã‚»ã‚¹

### 8.1 é€±æ¬¡ãƒ¬ãƒ“ãƒ¥ãƒ¼

```yaml
é€±æ¬¡ãƒ†ã‚¹ãƒˆãƒ¬ãƒ“ãƒ¥ãƒ¼:
  å®Ÿæ–½æ—¥: æ¯é€±é‡‘æ›œæ—¥
  
  ãƒ¬ãƒ“ãƒ¥ãƒ¼é …ç›®:
    - ä»Šé€±ã®ãƒ†ã‚¹ãƒˆçµæœåˆ†æ
    - æ–°è¦ç™ºè¦‹ã•ã‚ŒãŸå•é¡Œã®å„ªå…ˆåº¦è©•ä¾¡
    - ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®è¿½åŠ ãƒ»ä¿®æ­£åˆ¤æ–­
    - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¨ç§»ã®ç¢ºèª
    
  ã‚¢ã‚¯ã‚·ãƒ§ãƒ³:
    - P0ãƒ†ã‚¹ãƒˆå¤±æ•—æ™‚: å³åº§ã«é–‹ç™ºåœæ­¢ãƒ»ä¿®æ­£
    - P1ãƒ†ã‚¹ãƒˆåŠ£åŒ–æ™‚: æ¬¡é€±ã¾ã§ã«æ”¹å–„è¨ˆç”»
    - æ–°è¦Edgeåˆ¶ç´„ç™ºè¦‹æ™‚: ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹è¿½åŠ 
```

### 8.2 ãƒ•ã‚§ãƒ¼ã‚ºæ¯ã®è¦‹ç›´ã—

```javascript
// tests/review_manager.js
class TestPlanReviewer {
    async phaseReview(phase) {
        const metrics = await this.collectPhaseMetrics(phase);
        
        return {
            // å®Ÿè£…ã«ã‚ˆã‚‹å¤‰å‹•ã‚’åæ˜ 
            performance_adjustment: {
                cpu_time: metrics.actual_cpu,
                memory_usage: metrics.actual_memory,
                new_threshold: this.calculateNewThreshold(metrics)
            },
            
            // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æ‹¡å¼µ
            test_expansion: {
                edge_cases: this.identifyNewEdgeCases(metrics),
                load_patterns: this.generateLoadPatterns(metrics),
                accuracy_scenarios: this.createAccuracyTests(metrics)
            },
            
            // å„ªå…ˆåº¦å†è©•ä¾¡
            priority_reassessment: {
                promote_to_p0: this.findCriticalTests(metrics),
                demote_to_p2: this.findStableTests(metrics)
            }
        };
    }
    
    expandTestCases(phase, results) {
        const expansions = [];
        
        // CPUæ™‚é–“ãŒäºˆæƒ³ã‚ˆã‚Šé•·ã„å ´åˆ
        if (results.cpu_time_p99 > 40) {
            expansions.push({
                priority: 'P0',
                test: 'CPUæ™‚é–“åˆ¶é™å³å¯†ãƒ†ã‚¹ãƒˆ',
                threshold: 45,
                action: 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥ã®å†æ¤œè¨¼'
            });
        }
        
        // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¢—åŠ å‚¾å‘
        if (results.memory_trend > 0.1) {
            expansions.push({
                priority: 'P1',
                test: 'ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ',
                duration: '24h',
                action: 'ãƒªãƒ¼ã‚¯ç®‡æ‰€ã®ç‰¹å®šã¨ä¿®æ­£'
            });
        }
        
        // ç²¾åº¦ãŒæœŸå¾…å€¤ã‚’ä¸‹å›ã‚‹
        if (results.accuracy < this.getExpectedAccuracy(phase)) {
            expansions.push({
                priority: 'P1',
                test: 'ç²¾åº¦åŠ£åŒ–è¦å› åˆ†æ',
                samples: 1000,
                action: 'åœ§ç¸®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´'
            });
        }
        
        return expansions;
    }
}
```

### 8.3 ç¶™ç¶šçš„æ”¹å–„ãƒ•ãƒ­ãƒ¼

```yaml
æœˆæ¬¡ãƒ†ã‚¹ãƒˆè¨ˆç”»æ›´æ–°:
  ç¬¬1é€±:
    - å‰æœˆã®ãƒ†ã‚¹ãƒˆçµæœç·æ‹¬
    - å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æ
    - ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–ã®æ‹¡å……
    
  ç¬¬2é€±:
    - æ–°è¦è¦ä»¶ã«åŸºã¥ããƒ†ã‚¹ãƒˆè¿½åŠ 
    - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ›´æ–°
    - Edgeåˆ¶ç´„ã®å†è©•ä¾¡
    
  ç¬¬3é€±:
    - ç²¾åº¦ç›®æ¨™ã®èª¿æ•´
    - è² è·ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªæ›´æ–°
    - ç’°å¢ƒåˆ¥ãƒ†ã‚¹ãƒˆã®æœ€é©åŒ–
    
  ç¬¬4é€±:
    - æ¬¡æœˆã®ãƒ†ã‚¹ãƒˆè¨ˆç”»ç­–å®š
    - ãƒªã‚½ãƒ¼ã‚¹é…åˆ†ã®è¦‹ç›´ã—
    - CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ”¹å–„
```

---

## æ‰¿èª

| å½¹å‰² | æ°å | æ‰¿èªæ—¥ | ç½²å |
|------|------|--------|------|
| QAãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ | | | |
| ãƒ†ã‚¹ãƒˆãƒªãƒ¼ãƒ‰ | | | |
| ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆã‚ªãƒ¼ãƒŠãƒ¼ | | | |

**æ–‡æ›¸ç®¡ç†**
- **ãƒ†ã‚¹ãƒˆæˆ¦ç•¥**: å„ªå…ˆé †ä½ãƒ™ãƒ¼ã‚¹æ®µéšå®Ÿè¡Œ
- **é‡ç‚¹é …ç›®**: Edgeåˆ¶ç´„ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- **è‡ªå‹•åŒ–**: CI/CDçµ±åˆæ¸ˆã¿
- **ç¶™ç¶šæ”¹å–„**: é€±æ¬¡ãƒ»æœˆæ¬¡ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹
- **é…å¸ƒå…ˆ**: QAãƒãƒ¼ãƒ ã€é–‹ç™ºãƒãƒ¼ãƒ ã€PM