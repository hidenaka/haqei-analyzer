# 🧪 384爻システム 優先順位付きテスト計画書

**文書番号**: TP-384-PR-001  
**バージョン**: 1.0（優先順位版）  
**作成日**: 2025年8月28日  
**作成者**: HAQEI開発チーム  
**承認者**: [未承認]

---

## 1. テスト戦略概要

### 1.1 優先順位ベーステスト方針

```yaml
テスト優先度:
  P0_Critical（必須）:
    - Edge制約違反テスト
    - 基本動作確認
    - データ整合性
    - フォールバック機能
    
  P1_High（重要）:
    - パフォーマンステスト
    - キャッシュ動作
    - エラーハンドリング
    
  P2_Medium（標準）:
    - NLP精度テスト
    - 統合テスト
    - セキュリティ基本
    
  P3_Low（追加）:
    - ML精度検証
    - 負荷テスト詳細
    - カオステスト
```

### 1.2 段階的テスト実行計画

| Phase | 期間 | 優先度 | フォーカス | 合格基準 |
|-------|------|--------|-----------|----------|
| Phase 1 | Week 1 | P0 | 制約確認 | 100%合格 |
| Phase 2 | Week 2 | P0+P1 | 基本機能 | 95%合格 |
| Phase 3 | Week 3 | P1+P2 | 品質確保 | 90%合格 |
| Phase 4 | Week 4 | P2+P3 | 最適化 | 85%合格 |

---

## 2. P0: Critical - 制約確認テスト（必須）

### 2.1 Edge環境制約テスト

```javascript
// tests/p0/edge_constraints.test.js
describe('P0: Edge環境制約テスト', () => {
  
  test('CPU時間制限（50ms）', async () => {
    const startTime = performance.now();
    const response = await fetch('/api/analyze', {
      method: 'POST',
      body: JSON.stringify({ text: 'テスト入力' })
    });
    const duration = performance.now() - startTime;
    
    expect(duration).toBeLessThan(50);
    expect(response.status).toBe(200);
  });
  
  test('D1データベースサイズ（50MB以内）', async () => {
    const dbSize = await getD1DatabaseSize();
    expect(dbSize).toBeLessThan(50 * 1024 * 1024); // 50MB
  });
  
  test('Workers KV値サイズ（25MB以内）', async () => {
    const kvEntries = await getAllKVEntries();
    
    for (const entry of kvEntries) {
      const size = new Blob([entry.value]).size;
      expect(size).toBeLessThan(25 * 1024 * 1024); // 25MB/値
    }
  });
  
  test('メモリ使用量（128MB以内）', async () => {
    const memoryUsage = performance.memory?.usedJSHeapSize || 0;
    expect(memoryUsage).toBeLessThan(128 * 1024 * 1024);
  });
  
  test('ペイロードサイズ（100MB以内）', async () => {
    const largeInput = 'x'.repeat(100 * 1024 * 1024 + 1);
    
    const response = await fetch('/api/analyze', {
      method: 'POST',
      body: JSON.stringify({ text: largeInput })
    });
    
    expect(response.status).toBe(413); // Payload Too Large
  });
});
```

### 2.2 基本動作確認テスト

```javascript
// tests/p0/basic_functionality.test.js
describe('P0: 基本動作確認', () => {
  
  test('最小限の分類機能', async () => {
    const testCases = [
      { input: 'リーダーシップ', expectedRange: [1, 64] },
      { input: '変化と成長', expectedRange: [65, 128] },
      { input: '困難を乗り越える', expectedRange: [129, 192] }
    ];
    
    for (const testCase of testCases) {
      const result = await analyze(testCase.input);
      
      expect(result).toHaveProperty('line_id');
      expect(result.line_id).toBeGreaterThanOrEqual(testCase.expectedRange[0]);
      expect(result.line_id).toBeLessThanOrEqual(testCase.expectedRange[1]);
    }
  });
  
  test('データ存在確認', async () => {
    const db = getD1Instance();
    
    // 基本データ存在確認
    const count = await db.prepare(
      'SELECT COUNT(*) as count FROM lines_384_core'
    ).first();
    
    expect(count.count).toBe(384);
    
    // 必須フィールド確認
    const sample = await db.prepare(
      'SELECT * FROM lines_384_core WHERE line_id = 1'
    ).first();
    
    expect(sample).toHaveProperty('hexagram_id');
    expect(sample).toHaveProperty('shin_data');
    expect(sample).toHaveProperty('hen_data');
  });
  
  test('フォールバック動作', async () => {
    // メイン処理を意図的に失敗させる
    const mockError = new Error('Simulated failure');
    jest.spyOn(global, 'mainProcess').mockRejectedValueOnce(mockError);
    
    const result = await analyzeWithFallback('テスト入力');
    
    // フォールバックが動作すること
    expect(result).toHaveProperty('line_id');
    expect(result).toHaveProperty('fallback_used', true);
    expect(result.confidence).toBeLessThan(0.7); // 低信頼度
  });
});
```

### 2.3 データ整合性テスト

```javascript
// tests/p0/data_integrity.test.js
describe('P0: データ整合性', () => {
  
  test('ID連続性', async () => {
    const ids = await getAllLineIds();
    
    expect(ids).toHaveLength(384);
    for (let i = 0; i < 384; i++) {
      expect(ids).toContain(i + 1);
    }
  });
  
  test('卦と爻の対応', async () => {
    for (let hexagram = 1; hexagram <= 64; hexagram++) {
      for (let line = 1; line <= 6; line++) {
        const lineId = (hexagram - 1) * 6 + line;
        const data = await getLineData(lineId);
        
        expect(data.hexagram_id).toBe(hexagram);
        expect(data.line_position).toBe(line);
      }
    }
  });
  
  test('圧縮データの復元可能性', async () => {
    const compressed = await getCompressedData();
    const decompressed = decompress(compressed);
    
    expect(decompressed).toBeDefined();
    expect(decompressed.length).toBeGreaterThan(0);
    
    // データの妥当性確認
    const parsed = JSON.parse(decompressed);
    expect(parsed).toHaveProperty('version');
    expect(parsed).toHaveProperty('data');
  });
});
```

---

## 3. P1: High - パフォーマンステスト（重要）

### 3.1 応答時間テスト

```javascript
// tests/p1/performance.test.js
describe('P1: パフォーマンステスト', () => {
  
  test('応答時間分布', async () => {
    const iterations = 100;
    const responseTimes = [];
    
    for (let i = 0; i < iterations; i++) {
      const start = performance.now();
      await analyze(`テスト入力 ${i}`);
      responseTimes.push(performance.now() - start);
    }
    
    const p50 = percentile(responseTimes, 50);
    const p95 = percentile(responseTimes, 95);
    const p99 = percentile(responseTimes, 99);
    
    expect(p50).toBeLessThan(30);  // 目標: 30ms
    expect(p95).toBeLessThan(50);  // 目標: 50ms
    expect(p99).toBeLessThan(100); // 目標: 100ms
  });
  
  test('キャッシュヒット率', async () => {
    const testInputs = [
      'リーダーシップ',
      '変化と成長',
      'リーダーシップ', // 重複
      '責任と義務',
      '変化と成長'       // 重複
    ];
    
    let cacheHits = 0;
    
    for (const input of testInputs) {
      const result = await analyze(input);
      if (result.cached) cacheHits++;
    }
    
    const hitRate = cacheHits / testInputs.length;
    expect(hitRate).toBeGreaterThan(0.4); // 40%以上（重複分）
  });
  
  test('並行処理性能', async () => {
    const concurrentRequests = 50;
    const promises = [];
    
    const start = performance.now();
    
    for (let i = 0; i < concurrentRequests; i++) {
      promises.push(analyze(`並行テスト ${i}`));
    }
    
    const results = await Promise.all(promises);
    const duration = performance.now() - start;
    
    // 全リクエスト成功
    expect(results.every(r => r.line_id)).toBe(true);
    
    // 平均処理時間
    const avgTime = duration / concurrentRequests;
    expect(avgTime).toBeLessThan(50);
  });
});
```

### 3.2 キャッシュ動作テスト

```javascript
// tests/p1/cache.test.js
describe('P1: キャッシュ動作', () => {
  
  test('多層キャッシュ動作', async () => {
    const cache = new MultiLevelCache();
    const key = 'test_key';
    const value = { data: 'test' };
    
    // 書き込み
    await cache.set(key, value);
    
    // L1（メモリ）から取得
    const l1Result = await cache.get(key);
    expect(l1Result.source).toBe('memory');
    expect(l1Result.data).toEqual(value);
    
    // L1クリア後、L2（KV）から取得
    cache.l1.clear();
    const l2Result = await cache.get(key);
    expect(l2Result.source).toBe('kv');
    
    // L2クリア後、L3（Cache API）から取得
    await env.KV.delete(key);
    const l3Result = await cache.get(key);
    expect(l3Result.source).toBe('cache');
  });
  
  test('キャッシュ無効化', async () => {
    const cache = new MultiLevelCache();
    
    // データ設定
    await cache.set('test', { version: 1 });
    
    // バージョン更新による無効化
    await cache.invalidate('test');
    
    const result = await cache.get('test');
    expect(result).toBeNull();
  });
  
  test('TTL動作', async () => {
    const cache = new MultiLevelCache();
    
    // 短いTTLで設定
    await cache.set('ttl_test', { data: 'test' }, 1); // 1秒
    
    // 即座に取得可能
    const immediate = await cache.get('ttl_test');
    expect(immediate).toBeDefined();
    
    // 2秒後は取得不可
    await new Promise(resolve => setTimeout(resolve, 2000));
    const expired = await cache.get('ttl_test');
    expect(expired).toBeNull();
  });
});
```

---

## 4. P2: Medium - 品質テスト（標準）

### 4.1 NLP精度テスト

```javascript
// tests/p2/nlp_accuracy.test.js
describe('P2: NLP精度テスト', () => {
  
  test('形態素解析精度', async () => {
    const testCases = [
      {
        input: '乾為天の初九',
        expected: ['乾為天', 'の', '初九']
      },
      {
        input: 'リーダーとして責任を持つ',
        expected: ['リーダー', 'として', '責任', 'を', '持つ']
      }
    ];
    
    for (const testCase of testCases) {
      const tokens = await tokenize(testCase.input);
      const surfaces = tokens.map(t => t.surface);
      
      // 主要トークンが含まれること
      for (const expected of testCase.expected) {
        expect(surfaces).toContain(expected);
      }
    }
  });
  
  test('類義語展開', async () => {
    const synonymTests = [
      {
        word: 'リーダー',
        expectedSynonyms: ['指導者', '統率者']
      },
      {
        word: '変化',
        expectedSynonyms: ['変動', '変遷']
      }
    ];
    
    for (const test of synonymTests) {
      const synonyms = await expandSynonyms(test.word);
      
      for (const expected of test.expectedSynonyms) {
        expect(synonyms).toContain(expected);
      }
    }
  });
  
  test('分類精度（サンプル100件）', async () => {
    const testData = await loadTestDataset(100);
    let correct = 0;
    
    for (const item of testData) {
      const result = await analyze(item.input);
      if (result.line_id === item.expected_line_id) {
        correct++;
      }
    }
    
    const accuracy = correct / testData.length;
    expect(accuracy).toBeGreaterThan(0.75); // 75%以上
  });
});
```

### 4.2 統合テスト

```javascript
// tests/p2/integration.test.js
describe('P2: 統合テスト', () => {
  
  test('エンドツーエンドフロー', async () => {
    // 1. 入力受付
    const input = {
      text: 'プロジェクトリーダーとして困難を乗り越える',
      session_id: 'test_session'
    };
    
    // 2. 分析実行
    const response = await fetch('/api/analyze', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(input)
    });
    
    expect(response.status).toBe(200);
    
    const result = await response.json();
    
    // 3. 結果検証
    expect(result).toHaveProperty('line_id');
    expect(result).toHaveProperty('confidence');
    expect(result).toHaveProperty('processing_time');
    expect(result.processing_time).toBeLessThan(50);
    
    // 4. フィードバック送信
    const feedback = {
      session_id: input.session_id,
      predicted: result.line_id,
      actual: 1,
      rating: 4
    };
    
    const feedbackResponse = await fetch('/api/feedback', {
      method: 'POST',
      body: JSON.stringify(feedback)
    });
    
    expect(feedbackResponse.status).toBe(201);
  });
  
  test('エラーリカバリー', async () => {
    // 不正な入力
    const invalidInputs = [
      { text: null },
      { text: '' },
      { text: 'x'.repeat(10000) },
      { invalid: 'field' }
    ];
    
    for (const input of invalidInputs) {
      const response = await fetch('/api/analyze', {
        method: 'POST',
        body: JSON.stringify(input)
      });
      
      // エラーでもクラッシュしない
      expect([400, 422]).toContain(response.status);
      
      const error = await response.json();
      expect(error).toHaveProperty('error');
    }
  });
});
```

---

## 5. P3: Low - 追加テスト（オプション）

### 5.1 機械学習モデル検証

```javascript
// tests/p3/ml_validation.test.js
describe('P3: ML検証（オプション）', () => {
  
  test.skip('モデル圧縮前後の精度', async () => {
    const fullModel = await loadFullModel();
    const compressedModel = await loadCompressedModel();
    const testSet = await loadTestDataset(500);
    
    let fullCorrect = 0;
    let compressedCorrect = 0;
    
    for (const item of testSet) {
      const fullPred = await fullModel.predict(item.input);
      const compPred = await compressedModel.predict(item.input);
      
      if (fullPred === item.expected) fullCorrect++;
      if (compPred === item.expected) compressedCorrect++;
    }
    
    const fullAccuracy = fullCorrect / testSet.length;
    const compAccuracy = compressedCorrect / testSet.length;
    
    // 圧縮による精度低下が5%以内
    expect(fullAccuracy - compAccuracy).toBeLessThan(0.05);
  });
  
  test.skip('推論時間比較', async () => {
    const models = {
      rule: new RuleBasedModel(),
      compressed: new CompressedMLModel(),
      full: new FullMLModel()
    };
    
    const input = 'テスト入力テキスト';
    const times = {};
    
    for (const [name, model] of Object.entries(models)) {
      const start = performance.now();
      await model.predict(input);
      times[name] = performance.now() - start;
    }
    
    expect(times.rule).toBeLessThan(5);
    expect(times.compressed).toBeLessThan(20);
    expect(times.full).toBeLessThan(50);
  });
});
```

### 5.2 カオステスト

```javascript
// tests/p3/chaos.test.js
describe('P3: カオステスト（オプション）', () => {
  
  test.skip('ネットワーク遅延シミュレーション', async () => {
    // 人工的な遅延を追加
    const addLatency = (ms) => {
      return new Promise(resolve => setTimeout(resolve, ms));
    };
    
    const originalFetch = global.fetch;
    global.fetch = async (...args) => {
      await addLatency(500); // 500ms遅延
      return originalFetch(...args);
    };
    
    const result = await analyzeWithTimeout('テスト', 1000);
    
    // タイムアウトせずに結果を返すこと
    expect(result).toHaveProperty('line_id');
    
    global.fetch = originalFetch;
  });
  
  test.skip('部分的データ欠損', async () => {
    // 一部データを意図的に削除
    await corruptData(['lines_100_to_150']);
    
    // 影響範囲のテスト
    const affected = await analyze('該当範囲のテキスト');
    expect(affected.fallback_used).toBe(true);
    
    // 影響範囲外のテスト
    const unaffected = await analyze('影響外のテキスト');
    expect(unaffected.fallback_used).toBeFalsy();
    
    // データ復旧
    await restoreData();
  });
});
```

---

## 6. テスト自動化とCI/CD

### 6.1 優先度別実行設定

```yaml
# .github/workflows/test.yml
name: 優先度別テスト実行

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  p0-critical:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p0
      - name: P0失敗時は即座に停止
        if: failure()
        run: exit 1
        
  p1-high:
    needs: p0-critical
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p1
      
  p2-medium:
    needs: p1-high
    runs-on: ubuntu-latest
    timeout-minutes: 30
    continue-on-error: true  # P2失敗でも続行
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p2
      
  p3-low:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: p2-medium
    runs-on: ubuntu-latest
    timeout-minutes: 60
    continue-on-error: true  # P3は参考値
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run test:p3
```

### 6.2 テストレポート生成

```javascript
// scripts/generate_test_report.js
class TestReporter {
  generatePriorityReport(results) {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        p0: this.summarize(results.p0),
        p1: this.summarize(results.p1),
        p2: this.summarize(results.p2),
        p3: this.summarize(results.p3)
      },
      recommendation: this.getRecommendation(results)
    };
    
    return report;
  }
  
  getRecommendation(results) {
    if (results.p0.failureRate > 0) {
      return 'BLOCK: Critical制約違反 - デプロイ不可';
    }
    
    if (results.p1.failureRate > 0.05) {
      return 'WARNING: パフォーマンス問題 - 改善必要';
    }
    
    if (results.p2.failureRate > 0.15) {
      return 'CAUTION: 品質改善推奨';
    }
    
    return 'READY: デプロイ可能';
  }
}
```

---

## 7. 成功基準

### 7.1 優先度別合格基準

| 優先度 | テスト項目 | 必須合格率 | 目標合格率 | ブロッキング |
|--------|-----------|------------|------------|--------------|
| P0 | 制約確認 | 100% | 100% | Yes |
| P1 | パフォーマンス | 95% | 98% | Yes |
| P2 | 品質・精度 | 85% | 90% | No |
| P3 | 追加検証 | 70% | 80% | No |

### 7.2 環境切替テスト

```javascript
// tests/environment_switching.test.js

describe('Multi-Environment Adapter Tests', () => {
    test('データベースアダプター自動切替', async () => {
        // 開発環境: SQLite
        process.env.NODE_ENV = 'development';
        let db = await DatabaseAdapter.create();
        expect(db.type).toBe('sqlite');
        
        // 本番環境: D1
        process.env.NODE_ENV = 'production';
        db = await DatabaseAdapter.create();
        expect(db.type).toBe('d1');
        expect(db.sizeLimit).toBe(50 * 1024 * 1024); // 50MB
    });
    
    test('キャッシュ層の環境別動作', async () => {
        const testKey = 'test_key';
        const testValue = { data: 'test' };
        
        // 開発: Redis
        process.env.NODE_ENV = 'development';
        const devCache = await CacheAdapter.create();
        await devCache.set(testKey, testValue);
        expect(await devCache.get(testKey)).toEqual(testValue);
        
        // 本番: Workers KV
        process.env.NODE_ENV = 'production';
        const prodCache = await CacheAdapter.create();
        await prodCache.set(testKey, testValue);
        expect(await prodCache.get(testKey)).toEqual(testValue);
    });
    
    test('モデル読み込み戦略の切替', async () => {
        // 開発: ローカルファイル
        process.env.NODE_ENV = 'development';
        const devModel = await ModelLoader.load();
        expect(devModel.source).toBe('local');
        
        // 本番: CDN配信
        process.env.NODE_ENV = 'production';
        const prodModel = await ModelLoader.load();
        expect(prodModel.source).toBe('cdn');
        expect(prodModel.compressed).toBe(true);
    });
    
    test('エラーハンドリングの一貫性', async () => {
        const envs = ['development', 'production'];
        
        for (const env of envs) {
            process.env.NODE_ENV = env;
            const db = await DatabaseAdapter.create();
            
            try {
                await db.query('INVALID SQL');
            } catch (error) {
                // 全環境で統一エラー形式
                expect(error).toHaveProperty('code');
                expect(error).toHaveProperty('message');
            }
        }
    });
});
```

### 7.3 段階的リリース判定

```yaml
リリース判定基準:
  アルファ版:
    - P0: 100%合格
    - P1: 90%合格
    - 環境切替: 基本動作確認
    
  ベータ版:
    - P0: 100%合格
    - P1: 95%合格
    - P2: 80%合格
    - 環境切替: 全テスト合格
    
  正式版:
    - P0: 100%合格
    - P1: 98%合格
    - P2: 90%合格
    - P3: 70%合格
    - 環境切替: パフォーマンス基準達成
```

---

## 8. テスト計画の継続的見直しプロセス

### 8.1 週次レビュー

```yaml
週次テストレビュー:
  実施日: 毎週金曜日
  
  レビュー項目:
    - 今週のテスト結果分析
    - 新規発見された問題の優先度評価
    - テストケースの追加・修正判断
    - パフォーマンス推移の確認
    
  アクション:
    - P0テスト失敗時: 即座に開発停止・修正
    - P1テスト劣化時: 次週までに改善計画
    - 新規Edge制約発見時: テストケース追加
```

### 8.2 フェーズ毎の見直し

```javascript
// tests/review_manager.js
class TestPlanReviewer {
    async phaseReview(phase) {
        const metrics = await this.collectPhaseMetrics(phase);
        
        return {
            // 実装による変動を反映
            performance_adjustment: {
                cpu_time: metrics.actual_cpu,
                memory_usage: metrics.actual_memory,
                new_threshold: this.calculateNewThreshold(metrics)
            },
            
            // テストケース拡張
            test_expansion: {
                edge_cases: this.identifyNewEdgeCases(metrics),
                load_patterns: this.generateLoadPatterns(metrics),
                accuracy_scenarios: this.createAccuracyTests(metrics)
            },
            
            // 優先度再評価
            priority_reassessment: {
                promote_to_p0: this.findCriticalTests(metrics),
                demote_to_p2: this.findStableTests(metrics)
            }
        };
    }
    
    expandTestCases(phase, results) {
        const expansions = [];
        
        // CPU時間が予想より長い場合
        if (results.cpu_time_p99 > 40) {
            expansions.push({
                priority: 'P0',
                test: 'CPU時間制限厳密テスト',
                threshold: 45,
                action: 'フォールバック戦略の再検証'
            });
        }
        
        // メモリ使用量が増加傾向
        if (results.memory_trend > 0.1) {
            expansions.push({
                priority: 'P1',
                test: 'メモリリークテスト',
                duration: '24h',
                action: 'リーク箇所の特定と修正'
            });
        }
        
        // 精度が期待値を下回る
        if (results.accuracy < this.getExpectedAccuracy(phase)) {
            expansions.push({
                priority: 'P1',
                test: '精度劣化要因分析',
                samples: 1000,
                action: '圧縮パラメータ調整'
            });
        }
        
        return expansions;
    }
}
```

### 8.3 継続的改善フロー

```yaml
月次テスト計画更新:
  第1週:
    - 前月のテスト結果総括
    - 問題パターンの分析
    - テスト自動化の拡充
    
  第2週:
    - 新規要件に基づくテスト追加
    - パフォーマンスベースライン更新
    - Edge制約の再評価
    
  第3週:
    - 精度目標の調整
    - 負荷テストシナリオ更新
    - 環境別テストの最適化
    
  第4週:
    - 次月のテスト計画策定
    - リソース配分の見直し
    - CI/CDパイプライン改善
```

---

## 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| QAマネージャー | | | |
| テストリード | | | |
| プロダクトオーナー | | | |

**文書管理**
- **テスト戦略**: 優先順位ベース段階実行
- **重点項目**: Edge制約とパフォーマンス
- **自動化**: CI/CD統合済み
- **継続改善**: 週次・月次レビュープロセス
- **配布先**: QAチーム、開発チーム、PM