# 📊 384爻システム 運用連携仕様書

**文書番号**: OP-384-EC-001  
**バージョン**: 1.0（Edge制約対応版）  
**作成日**: 2025年8月28日  
**作成者**: HAQEI開発チーム  
**承認者**: [未承認]

---

## 1. 学習/推論連携フロー

### 1.1 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│                   運用連携フロー                          │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ユーザー ─→ Edge推論 ─→ 結果返却                        │
│             ↓                ↑                          │
│         フィードバック    キャッシュ                      │
│             ↓                ↑                          │
│         Workers KV ───→ バッチ収集                      │
│                            ↓                            │
│                      バックエンド学習                     │
│                            ↓                            │
│                      モデル圧縮・検証                     │
│                            ↓                            │
│                      CDN配信 ─→ Edge更新                │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 1.2 データフロー詳細

#### 1.2.1 推論フェーズ（Edge）

```javascript
// edge/inference_flow.js
class EdgeInferenceFlow {
    constructor() {
        this.cpuBudget = {
            total: 45,           // Cloudflare Workers CPU制限
            cache: 2,            // キャッシュ確認
            inference: 30,       // 推論処理
            response: 2,         // レスポンス生成
            buffer: 11           // 安全マージン
        };
    }
    
    async process(request, env) {
        const startTime = Date.now();
        const flow = {
            // 1. リクエスト受信（0-1ms）
            receive: await this.receiveRequest(request),
            
            // 2. キャッシュ確認（1-2ms）- Workers KV
            cache: await this.checkCache(request, env.KV_CACHE),
            
            // 3. CPU時間監視付き推論実行（10-30ms）
            inference: await this.runInferenceWithLimit(
                request, 
                env,
                this.cpuBudget.inference
            ),
            
            // 4. 結果返却（1ms）
            response: await this.sendResponse(),
            
            // 5. 非同期フィードバック収集（waitUntil使用）
            feedback: null // ctx.waitUntilで処理
        };
        
        // CPU時間チェック
        const elapsed = Date.now() - startTime;
        if (elapsed > this.cpuBudget.total) {
            console.warn(`CPU time exceeded: ${elapsed}ms`);
        }
        
        return flow;
    }
    
    async runInferenceWithLimit(request, env, timeLimit) {
        const deadline = Date.now() + timeLimit;
        
        try {
            // 時間内に推論完了を試みる
            const result = await Promise.race([
                this.fullInference(request, env),
                this.timeoutFallback(deadline)
            ]);
            return result;
        } catch (error) {
            // エラー時は簡易スコアリングにフォールバック
            return this.simpleFallback(request);
        }
    }
}
```

#### 1.2.2 学習フェーズ（バックエンド）

```python
# backend/learning_flow.py
class LearningFlow:
    def daily_batch_process(self):
        """日次バッチ処理フロー（深夜2-4時実行）"""
        
        flow = {
            # 1. データ収集（5分）
            "01:collect": self.collect_edge_feedbacks(),
            
            # 2. データ前処理（10分）
            "02:preprocess": self.preprocess_data(),
            
            # 3. モデル学習（60分）
            "03:train": self.train_model(),
            
            # 4. モデル検証（15分）
            "04:validate": self.validate_model(),
            
            # 5. モデル圧縮（20分）
            "05:compress": self.compress_model(),
            
            # 6. デプロイ判定（5分）
            "06:deploy": self.deployment_decision(),
            
            # 7. CDN配信（5分）
            "07:distribute": self.distribute_to_cdn()
        }
        
        return flow
```

---

## 2. モデル更新サイクル

### 2.1 更新スケジュール

```yaml
定期更新:
  日次:
    時刻: 02:00-04:00 JST
    内容:
      - フィードバック収集
      - 軽微な重み調整
      - キャッシュ更新
    
  週次:
    曜日: 日曜日
    内容:
      - フルモデル再学習
      - 精度評価
      - A/Bテスト設定
    
  月次:
    日付: 月末
    内容:
      - 辞書・語彙更新
      - ベクトル再計算
      - アーキテクチャ見直し
```

### 2.2 バージョン管理と互換性保証

```javascript
// versioning/model_version.js
class ModelVersionManager {
    constructor() {
        this.versions = {
            current: "v1.2.3",
            canary: "v1.2.4-rc1",
            previous: "v1.2.2"
        };
        
        // 互換性マトリクス
        this.compatibility = {
            "v1.2.4": {
                backward_compatible: ["v1.2.3", "v1.2.2"],
                cache_invalidation: false,
                migration_required: false
            },
            "v1.3.0": {
                backward_compatible: ["v1.2.x"],
                cache_invalidation: true,
                migration_required: true,
                migration_script: "migrations/v1.3.0.js"
            }
        };
    }
    
    async deploymentStrategy() {
        return {
            // カナリアデプロイ
            canary: {
                percentage: 5,        // 5%のトラフィック
                duration: "6h",       // 6時間観察
                metrics: ["accuracy", "latency", "errors"],
                rollback_threshold: {
                    error_rate: 0.01,
                    accuracy_drop: 0.05
                }
            },
            
            // 段階的ロールアウト
            rollout: {
                stages: [
                    { percentage: 5, duration: "6h" },
                    { percentage: 25, duration: "12h" },
                    { percentage: 50, duration: "24h" },
                    { percentage: 100, duration: "permanent" }
                ]
            }
        };
    }
    
    async validateCompatibility(newVersion, currentVersion) {
        const compat = this.compatibility[newVersion];
        
        // 後方互換性チェック
        if (!compat.backward_compatible.includes(currentVersion)) {
            return {
                compatible: false,
                reason: 'Breaking changes detected',
                actions: [
                    'Run migration script',
                    'Clear cache',
                    'Update client code'
                ]
            };
        }
        
        // キャッシュ無効化の必要性
        if (compat.cache_invalidation) {
            await this.invalidateCache();
        }
        
        // マイグレーション実行
        if (compat.migration_required) {
            await this.runMigration(compat.migration_script);
        }
        
        return { compatible: true };
    }
    
    async switchModel(version) {
        const validation = await this.validateCompatibility(
            version, 
            this.versions.current
        );
        
        if (!validation.compatible) {
            throw new Error(`Incompatible version: ${validation.reason}`);
        }
        
        // 旧モデルをバックアップ
        this.versions.previous = this.versions.current;
        
        // 新モデルに切り替え
        this.versions.current = version;
        
        // ヘルスチェック
        const health = await this.healthCheck(version);
        
        if (!health.passed) {
            // 自動ロールバック
            await this.rollback();
            throw new Error('Health check failed, rolled back');
        }
        
        return { 
            success: true,
            version,
            switched_at: new Date().toISOString()
        };
    }
}
```

### 2.3 A/Bテスト実装

```javascript
// ab_testing/model_ab_test.js
class ModelABTest {
    async routeRequest(request) {
        const userId = this.getUserId(request);
        const bucket = this.hashToBucket(userId);
        
        // トラフィック分割
        if (bucket < 0.05) {
            // 5% - 新モデル（実験群）
            return await this.useModel('experimental');
        } else if (bucket < 0.10) {
            // 5% - コントロール群（計測用）
            return await this.useModel('control');
        } else {
            // 90% - 現行モデル
            return await this.useModel('current');
        }
    }
    
    async evaluateResults() {
        const metrics = await this.collectMetrics();
        
        return {
            experimental: {
                accuracy: metrics.experimental.accuracy,
                latency_p50: metrics.experimental.p50,
                conversion: metrics.experimental.conversion
            },
            control: {
                accuracy: metrics.control.accuracy,
                latency_p50: metrics.control.p50,
                conversion: metrics.control.conversion
            },
            statistical_significance: this.calculatePValue(
                metrics.experimental,
                metrics.control
            )
        };
    }
}
```

---

## 3. 圧縮辞書・ベクトルメンテナンス

### 3.1 辞書更新プロセス

```python
# maintenance/dictionary_updater.py
class DictionaryMaintenance:
    def monthly_update(self):
        """月次辞書更新プロセス"""
        
        # 1. 使用頻度分析
        word_frequencies = self.analyze_word_usage()
        
        # 2. 新語候補抽出
        new_words = self.extract_new_words(word_frequencies)
        
        # 3. 削除候補選定
        unused_words = self.find_unused_words(
            threshold_days=90,
            min_frequency=10
        )
        
        # 4. 辞書再構築
        updated_dict = self.rebuild_dictionary(
            keep_words=word_frequencies.top(900),
            add_words=new_words[:100],
            remove_words=unused_words
        )
        
        # 5. 圧縮・最適化
        compressed = self.compress_dictionary(
            updated_dict,
            target_size_kb=300
        )
        
        # 6. 検証
        validation = self.validate_dictionary(compressed)
        
        if validation.coverage > 0.85:
            return self.deploy_dictionary(compressed)
```

### 3.2 ベクトル最適化

```python
# maintenance/vector_optimizer.py
class VectorMaintenance:
    def optimize_vectors(self):
        """ベクトル次元削減と再計算"""
        
        # 1. 現行ベクトル分析
        current_vectors = self.load_vectors(dimension=50)
        
        # 2. 主成分分析（PCA）
        pca_analysis = self.perform_pca(current_vectors)
        
        # 3. 最適次元数決定
        optimal_dim = self.find_optimal_dimension(
            pca_analysis,
            min_variance_explained=0.95,
            max_dimension=50
        )
        
        # 4. 次元削減
        reduced_vectors = self.reduce_dimensions(
            current_vectors,
            target_dim=optimal_dim
        )
        
        # 5. 量子化
        quantized = self.quantize_vectors(
            reduced_vectors,
            dtype='float16'
        )
        
        # 6. バイナリ形式保存
        binary_vectors = self.save_as_binary(
            quantized,
            compression='gzip'
        )
        
        return {
            'original_dim': 50,
            'optimal_dim': optimal_dim,
            'size_mb': len(binary_vectors) / (1024 * 1024),
            'variance_retained': pca_analysis.explained_variance_ratio
        }
    
    def compress_for_edge(self):
        """Edge環境向け圧縮実装"""
        
        # 1. INT8量子化（精度劣化最小限）
        vectors_int8 = self.quantize_to_int8(
            scale_factor=127.0,
            zero_point=0
        )
        
        # 2. スパース表現（ゼロ値を除外）
        sparse_vectors = self.to_sparse_format(
            vectors_int8,
            threshold=0.01
        )
        
        # 3. 辞書圧縮（頻出パターン）
        compressed = self.dictionary_encode(
            sparse_vectors,
            dict_size=256
        )
        
        # 4. WebAssembly用バイナリ形式
        wasm_ready = self.prepare_for_wasm(
            compressed,
            simd_aligned=True
        )
        
        return {
            'compression_ratio': self.original_size / len(wasm_ready),
            'size_kb': len(wasm_ready) / 1024,
            'inference_speedup': '3.2x',
            'accuracy_retained': 0.97
        }
```

### 3.3 語彙カバレッジ監視

```javascript
// monitoring/vocabulary_coverage.js
class VocabularyCoverageMonitor {
    async analyzeCoverage() {
        // 過去30日のクエリ分析
        const queries = await this.getRecentQueries(30);
        
        // トークン化
        const allTokens = [];
        for (const query of queries) {
            const tokens = await this.tokenize(query);
            allTokens.push(...tokens);
        }
        
        // カバレッジ計算
        const uniqueTokens = new Set(allTokens);
        const coveredTokens = new Set();
        const uncoveredTokens = new Set();
        
        for (const token of uniqueTokens) {
            if (await this.isDictionaryWord(token)) {
                coveredTokens.add(token);
            } else {
                uncoveredTokens.add(token);
            }
        }
        
        // レポート生成
        return {
            coverage_rate: coveredTokens.size / uniqueTokens.size,
            total_unique_tokens: uniqueTokens.size,
            covered_tokens: coveredTokens.size,
            uncovered_tokens: Array.from(uncoveredTokens)
                .sort((a, b) => this.getFrequency(b) - this.getFrequency(a))
                .slice(0, 100),
            recommendation: this.generateRecommendation(coverage_rate)
        };
    }
}
```

---

## 4. 運用監視とアラート

### 4.1 監視項目

```yaml
リアルタイム監視:
  Edge性能:
    - CPU時間（閾値: 45ms）
    - メモリ使用量（閾値: 120MB）
    - キャッシュヒット率（閾値: 80%）
    - Workers Subrequest数（閾値: 50/req）
    - D1クエリ時間（閾値: 10ms）
    - KV読み取り時間（閾値: 5ms）
    
  精度指標:
    - 分類精度（閾値: 80%）
    - フォールバック率（閾値: 5%）
    - エラー率（閾値: 1%）
    - タイムアウト率（閾値: 0.1%）
    
  Cloudflare固有指標:
    - Workers CPU時間（p50/p95/p99）
    - D1行読み取り数/秒
    - KV読み取り数/秒
    - R2帯域使用量
    - Analytics Engine書き込み数
    
  ビジネス指標:
    - リクエスト数/分
    - ユニークユーザー数/日
    - API使用量
    - コスト/1000リクエスト

バッチ監視:
  学習プロセス:
    - データ収集成功率
    - モデル学習時間
    - 検証精度
    - 圧縮率達成度
    
  デプロイメント:
    - デプロイ成功率
    - ロールバック発生数
    - バージョン一貫性
    - CDN配信時間
```

### 4.2 アラート設定

```javascript
// monitoring/alert_config.js
const alertConfig = {
    critical: {
        // 即時対応必要
        conditions: [
            { metric: 'error_rate', operator: '>', threshold: 0.05 },
            { metric: 'cpu_time_p99', operator: '>', threshold: 50 },
            { metric: 'accuracy', operator: '<', threshold: 0.75 }
        ],
        actions: ['page_oncall', 'auto_rollback', 'create_incident']
    },
    
    warning: {
        // 注意必要
        conditions: [
            { metric: 'cache_hit_rate', operator: '<', threshold: 0.7 },
            { metric: 'fallback_rate', operator: '>', threshold: 0.1 },
            { metric: 'memory_usage', operator: '>', threshold: 100 }
        ],
        actions: ['send_slack', 'create_ticket']
    },
    
    info: {
        // 記録のみ
        conditions: [
            { metric: 'new_words_detected', operator: '>', threshold: 50 },
            { metric: 'model_update_available', operator: '==', value: true }
        ],
        actions: ['log_metric', 'weekly_report']
    }
};
```

---

## 5. コスト最適化

### 5.1 リソース使用最適化

```yaml
コスト削減施策:
  キャッシング:
    - 積極的キャッシュ（TTL: 24時間）
    - 頻出クエリの事前計算
    - CDNエッジキャッシュ活用
    
  処理最適化:
    - バッチ処理の集約
    - 非ピーク時の学習実行
    - 不要データの定期削除
    
  ストレージ:
    - 古いフィードバックの圧縮
    - モデル履歴の制限（最新5バージョン）
    - ログのローテーション（30日）
```

### 5.2 使用量予測とCloudflare最適化

```javascript
// cost/cloudflare_optimizer.js
class CloudflareCostOptimizer {
    predictMonthlyCost() {
        const usage = {
            // Workers (Free: 100k req/day, $0.50/million after)
            workers_requests: this.predictRequests(),
            
            // KV (Free: 100k reads/day, $0.50/million after)
            kv_reads: this.predictKVReads(),
            kv_writes: this.predictKVWrites(), // $5/million
            kv_storage_gb: this.calculateKVStorage(), // $0.50/GB
            
            // D1 (Free: 5GB storage, 5M rows read/day)
            d1_rows_read: this.predictD1Reads(),
            d1_rows_written: this.predictD1Writes(),
            d1_storage_gb: this.calculateD1Storage(),
            
            // R2 (Free: 10GB storage, 1M Class A operations)
            r2_storage_gb: this.calculateR2Storage(),
            r2_class_a_ops: this.predictR2ClassA(), // PUT/POST
            r2_class_b_ops: this.predictR2ClassB(), // GET
            
            // Analytics Engine (Free: 100M data points/month)
            analytics_points: this.predictAnalyticsPoints()
        };
        
        // Cloudflare実際の価格計算
        const costs = {
            workers: Math.max(0, (usage.workers_requests - 3000000) * 0.0000005),
            kv_reads: Math.max(0, (usage.kv_reads - 3000000) * 0.0000005),
            kv_writes: usage.kv_writes * 0.000005,
            kv_storage: usage.kv_storage_gb * 0.50,
            d1_reads: Math.max(0, (usage.d1_rows_read - 150000000) * 0.001 / 1000000),
            d1_writes: usage.d1_rows_written * 0.001 / 1000000,
            d1_storage: Math.max(0, (usage.d1_storage_gb - 5) * 0.75),
            r2_storage: Math.max(0, (usage.r2_storage_gb - 10) * 0.015),
            r2_class_a: Math.max(0, (usage.r2_class_a_ops - 1000000) * 0.0036 / 10000),
            r2_class_b: Math.max(0, (usage.r2_class_b_ops - 10000000) * 0.00036 / 10000),
            analytics: Math.max(0, (usage.analytics_points - 100000000) * 0.25 / 1000000)
        };
        
        return {
            total: Object.values(costs).reduce((a, b) => a + b),
            breakdown: costs,
            free_tier_usage: this.calculateFreeTierUsage(usage),
            optimization_suggestions: this.generateOptimizations(usage, costs)
        };
    }
    
    generateOptimizations(usage, costs) {
        const suggestions = [];
        
        // Workers最適化
        if (costs.workers > 0) {
            suggestions.push({
                area: 'Workers',
                saving: costs.workers * 0.3,
                action: 'キャッシュヒット率を85%→95%に向上',
                implementation: 'Workers KVでの積極的キャッシング'
            });
        }
        
        // D1最適化
        if (costs.d1_reads > 0) {
            suggestions.push({
                area: 'D1 Database',
                saving: costs.d1_reads * 0.5,
                action: 'クエリ結果をKVにキャッシュ',
                implementation: 'よく使われる384爻データを事前計算'
            });
        }
        
        // KV最適化
        if (usage.kv_writes > 100000) {
            suggestions.push({
                area: 'KV Writes',
                saving: costs.kv_writes * 0.4,
                action: 'バッチ書き込みに変更',
                implementation: 'フィードバックを10分間隔でバッチ処理'
            });
        }
        
        return suggestions;
    }
}

---

## 6. 圧縮データ品質保証

### 6.1 圧縮前後の品質検証プロセス

```python
# quality/compression_validator.py
class CompressionQualityValidator:
    def validate_compression(self, original_data, compressed_data):
        """圧縮データの品質検証"""
        
        metrics = {
            # 情報保持率（目標: 95%以上）
            'information_retention': self.calculate_info_retention(
                original_data, 
                compressed_data
            ),
            
            # セマンティック類似度（目標: 0.92以上）
            'semantic_similarity': self.measure_semantic_similarity(
                original_data,
                compressed_data
            ),
            
            # キーワードカバレッジ（目標: 90%以上）
            'keyword_coverage': self.check_keyword_coverage(
                original_data,
                compressed_data
            ),
            
            # 分類精度影響（許容劣化: 3%以内）
            'accuracy_impact': self.test_classification_accuracy(
                test_set=self.load_test_data(),
                original_model=original_data,
                compressed_model=compressed_data
            )
        }
        
        # 品質基準チェック
        quality_passed = (
            metrics['information_retention'] >= 0.95 and
            metrics['semantic_similarity'] >= 0.92 and
            metrics['keyword_coverage'] >= 0.90 and
            metrics['accuracy_impact'] <= 0.03
        )
        
        return {
            'passed': quality_passed,
            'metrics': metrics,
            'recommendations': self.generate_recommendations(metrics)
        }
```

### 6.2 段階的圧縮戦略

```yaml
圧縮段階:
  Stage 1 - 軽度圧縮（情報保持優先）:
    - 元サイズ: 10MB
    - 圧縮後: 5MB
    - 情報保持率: 98%
    - 精度劣化: 1%以内
    - 手法: Float32→Float16量子化
    
  Stage 2 - 中度圧縮（バランス型）:
    - 元サイズ: 5MB
    - 圧縮後: 2MB
    - 情報保持率: 95%
    - 精度劣化: 3%以内
    - 手法: INT8量子化 + スパース化
    
  Stage 3 - 高度圧縮（サイズ優先）:
    - 元サイズ: 2MB
    - 圧縮後: 800KB
    - 情報保持率: 90%
    - 精度劣化: 5%以内
    - 手法: 辞書符号化 + プルーニング

品質検証ポイント:
  - Phase 2開始時: Stage 1圧縮の精度確認
  - Phase 3開始時: Stage 2圧縮の影響評価
  - Phase 4開始時: 全圧縮の総合評価
  - 週次: A/Bテストによる実環境検証
```

### 6.3 精度劣化時の対処法

```javascript
// quality/fallback_strategy.js
class QualityFallbackStrategy {
    async handleAccuracyDegradation(metrics) {
        const degradation = metrics.current - metrics.baseline;
        
        if (degradation > 0.05) {  // 5%以上の劣化
            // Level 3: 緊急対応
            return {
                action: 'ROLLBACK',
                steps: [
                    '前バージョンへの即座のロールバック',
                    '圧縮パラメータの見直し',
                    'より保守的な圧縮設定で再圧縮'
                ]
            };
        } else if (degradation > 0.03) {  // 3-5%の劣化
            // Level 2: 調整対応
            return {
                action: 'ADJUST',
                steps: [
                    '重要キーワードの非圧縮化',
                    '頻出パターンの精度向上',
                    '部分的な圧縮緩和'
                ]
            };
        } else {  // 3%以内の劣化
            // Level 1: 監視継続
            return {
                action: 'MONITOR',
                steps: [
                    '24時間の継続監視',
                    'ユーザーフィードバック収集',
                    '次回更新での改善計画'
                ]
            };
        }
    }
}
```

---

## 7. 精度モニタリングと改善計画

### 7.1 精度追跡システム

```javascript
// monitoring/accuracy_tracker.js
class AccuracyMonitoringSystem {
    constructor() {
        this.metrics = {
            baseline: 0.50,      // 現状精度
            target: 0.85,        // 目標精度
            milestones: {
                week1: 0.60,     // 初期改善
                week2: 0.65,     // データ統合効果
                week4: 0.70,     // 軽量NLP導入
                week8: 0.75,     // 学習サイクル確立
                month3: 0.85     // 目標達成
            }
        };
    }
    
    async trackDailyAccuracy(env) {
        const today = new Date().toISOString().split('T')[0];
        
        // 1. リアルタイム精度計測
        const realTimeAccuracy = await this.measureRealTime(env);
        
        // 2. A/Bテスト結果収集
        const abTestResults = await this.collectABTests(env);
        
        // 3. フィードバック分析
        const feedbackScore = await this.analyzeFeedback(env);
        
        // 4. 統合精度スコア
        const accuracy = {
            date: today,
            realTime: realTimeAccuracy,
            abTest: abTestResults,
            feedback: feedbackScore,
            weighted: this.calculateWeighted(
                realTimeAccuracy * 0.5 +
                abTestResults * 0.3 +
                feedbackScore * 0.2
            )
        };
        
        // 5. Analytics Engineに記録
        await env.ANALYTICS.writeDataPoint({
            dataset: 'accuracy_tracking',
            ...accuracy
        });
        
        // 6. 改善必要性判定
        return this.evaluateImprovement(accuracy);
    }
    
    evaluateImprovement(accuracy) {
        const currentWeek = this.getCurrentWeek();
        const expectedAccuracy = this.getExpectedAccuracy(currentWeek);
        const gap = expectedAccuracy - accuracy.weighted;
        
        if (gap > 0.05) {
            return {
                status: 'URGENT',
                message: '精度が期待値を5%以上下回っています',
                actions: [
                    '圧縮パラメータの見直し',
                    'フィードバックデータの分析強化',
                    '学習頻度の増加（日次→12時間ごと）'
                ]
            };
        } else if (gap > 0.02) {
            return {
                status: 'WARNING',
                message: '精度改善が必要です',
                actions: [
                    'キーワード辞書の更新',
                    '頻出パターンの再学習'
                ]
            };
        }
        
        return {
            status: 'OK',
            message: '精度は期待通りに改善しています'
        };
    }
}
```

### 7.2 フィードバックループ最適化

```python
# learning/feedback_optimizer.py
class FeedbackLoopOptimizer:
    def optimize_learning_cycle(self):
        """1000件/日のフィードバックを効率的に活用"""
        
        return {
            # データ収集戦略
            'collection': {
                'implicit': {
                    'click_through': 300,     # クリック率から推定
                    'dwell_time': 200,        # 滞在時間から推定
                    'bounce_rate': 100        # 離脱率から推定
                },
                'explicit': {
                    'thumbs_up_down': 200,    # 明示的評価
                    'corrections': 100,        # ユーザー修正
                    'reports': 100            # 問題報告
                }
            },
            
            # 優先学習対象
            'priority_learning': {
                'misclassified': {
                    'weight': 3.0,            # 誤分類の重み付け
                    'batch_size': 100,
                    'iterations': 10
                },
                'low_confidence': {
                    'weight': 2.0,            # 低確信度の重み付け
                    'batch_size': 200,
                    'iterations': 5
                },
                'edge_cases': {
                    'weight': 2.5,            # エッジケースの重み付け
                    'batch_size': 50,
                    'iterations': 15
                }
            },
            
            # 学習スケジュール
            'schedule': {
                'immediate': {
                    'trigger': 'error_rate > 0.1',
                    'action': '緊急再学習（30分以内）'
                },
                'daily': {
                    'time': '02:00-04:00 JST',
                    'data_required': 500
                },
                'weekly': {
                    'day': 'Sunday',
                    'full_retrain': True,
                    'data_required': 5000
                }
            }
        }
```

### 7.3 精度向上ロードマップ

```yaml
Phase別精度改善計画:
  Week 1-2（初期改善）:
    現状: 50%
    目標: 60%
    施策:
      - koudo_shishin.json完全活用
      - 基本キーワードマッチング改善
      - キャッシュ導入による一貫性向上
    検証: 200サンプルでのA/Bテスト
    
  Week 3-4（データ統合）:
    現状: 60%
    目標: 70%
    施策:
      - 軽量化JSON統合（85%データ活用）
      - 正規表現形態素解析導入
      - 類義語マップ適用
    検証: 500サンプルでの精度測定
    
  Week 5-8（学習サイクル確立）:
    現状: 70%
    目標: 75%
    施策:
      - バックエンド学習開始
      - 日次モデル更新サイクル
      - フィードバック最適化
    検証: 1000件/日の実データ評価
    
  Month 2-3（目標達成）:
    現状: 75%
    目標: 85%
    施策:
      - 継続的学習の成熟
      - エッジケース対応
      - ドメイン特化最適化
    検証: 本番環境での継続監視

失敗時の対策:
  精度60%未達成時:
    - 圧縮率を緩和（5MB→7MB）
    - キャッシュ戦略の見直し
    
  精度70%未達成時:
    - 軽量NLPから中量NLPへ
    - API経由での高精度処理追加
    
  精度85%未達成時:
    - ハイブリッドアプローチ採用
    - 人間レビューの部分導入
```

---

## 8. 障害対応プロトコル

### 8.1 インシデント対応フロー

```yaml
Level 1（軽微）:
  症状:
    - 精度5%低下
    - レスポンス10ms増加
  対応:
    - 自動ログ記録
    - 翌営業日対応
    
Level 2（中程度）:
  症状:
    - フォールバック多発
    - キャッシュ異常
  対応:
    - Slack通知
    - 2時間以内調査開始
    
Level 3（重大）:
  症状:
    - サービス停止
    - データ不整合
  対応:
    - 即時エスカレーション
    - 自動ロールバック
    - 15分以内対応開始
```

### 6.2 復旧手順

```bash
#!/bin/bash
# recovery/emergency_recovery.sh

# 1. 現状確認
echo "Checking system status..."
wrangler tail --format json | jq '.outcome'

# 2. ロールバック判定
if [ "$ERROR_RATE" -gt "5" ]; then
    echo "High error rate detected. Rolling back..."
    wrangler publish --env previous
fi

# 3. キャッシュクリア
echo "Clearing cache..."
wrangler kv:key delete --namespace-id=$KV_NAMESPACE "*"

# 4. 簡易モード切替
echo "Switching to fallback mode..."
wrangler secret put FALLBACK_MODE "true"

# 5. 監視強化
echo "Enabling enhanced monitoring..."
wrangler tail --format json > recovery.log &
```

---

## 7. 今後の拡張計画

### 7.1 短期計画（3ヶ月）

- [ ] 自動A/Bテストフレームワーク実装
- [ ] リアルタイム精度監視ダッシュボード
- [ ] 多言語対応（英語・中国語）

### 7.2 中期計画（6ヶ月）

- [ ] フェデレーテッド学習導入
- [ ] エッジでの増分学習
- [ ] パーソナライゼーション機能

### 7.3 長期計画（1年）

- [ ] 完全自律型モデル更新
- [ ] マルチモーダル対応
- [ ] グローバル分散配信

---

## 承認

| 役割 | 氏名 | 承認日 | 署名 |
|------|------|--------|------|
| 運用責任者 | | | |
| MLエンジニアリード | | | |
| SREリード | | | |

**文書管理**
- **運用方針**: 学習/推論分離による安定運用
- **更新サイクル**: 日次/週次/月次の段階的更新
- **監視体制**: 24時間自動監視とアラート
- **配布先**: 運用チーム、MLチーム、SREチーム