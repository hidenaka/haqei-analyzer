<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>VirtualQuestionFlow デバッグテスト</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #1a1a2e;
            color: #f1f5f9;
        }
        
        #test-container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        #virtual-viewport {
            min-height: 200px;
            border: 2px solid #6366f1;
            padding: 20px;
            margin: 20px 0;
            background: rgba(30, 41, 59, 0.95);
        }
        
        .virtual-question-item {
            padding: 20px;
            margin: 10px 0;
            border: 1px solid #94a3b8;
            border-radius: 8px;
            background: rgba(51, 65, 85, 0.8);
        }
        
        .active-question {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.2);
        }
        
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #6366f1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #4f46e5;
        }
        
        #log {
            margin-top: 20px;
            padding: 15px;
            background: #000;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .test-info {
            background: rgba(99, 102, 241, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="test-container">
        <h1>VirtualQuestionFlow 偶数番設問表示デバッグ</h1>
        
        <div class="test-info">
            <h3>テスト概要</h3>
            <p>VirtualQuestionFlowのshowCurrentQuestionメソッドを再現し、偶数番設問が表示されない問題を調査します。</p>
        </div>
        
        <div id="questions-container" style="display: flex;">
            <div id="virtual-viewport"></div>
        </div>
        
        <div style="margin: 20px 0;">
            <button onclick="moveToQuestion(0)">Q1へ（奇数）</button>
            <button onclick="moveToQuestion(1)">Q2へ（偶数）</button>
            <button onclick="moveToQuestion(2)">Q3へ（奇数）</button>
            <button onclick="moveToQuestion(3)">Q4へ（偶数）</button>
            <button onclick="checkCurrentState()">現在の状態確認</button>
            <button onclick="forceShowEven()">偶数番強制表示</button>
        </div>
        
        <div id="log"></div>
    </div>

    <script>
        const log = (msg, data = null) => {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            let output = `[${timestamp}] ${msg}`;
            if (data) {
                output += '\n' + JSON.stringify(data, null, 2);
            }
            logEl.textContent = output + '\n\n' + logEl.textContent;
        };

        // VirtualQuestionFlowの簡易実装
        class SimpleVirtualFlow {
            constructor() {
                this.currentQuestionIndex = 0;
                this.activeElements = new Map();
                this.questions = [
                    { id: 'q1', title: '設問1（奇数）' },
                    { id: 'q2', title: '設問2（偶数）' },
                    { id: 'q3', title: '設問3（奇数）' },
                    { id: 'q4', title: '設問4（偶数）' }
                ];
                
                this.init();
            }
            
            init() {
                const viewport = document.getElementById('virtual-viewport');
                
                // すべての設問要素を作成
                this.questions.forEach((q, index) => {
                    const element = document.createElement('div');
                    element.className = 'virtual-question-item';
                    element.dataset.questionId = q.id;
                    element.innerHTML = `
                        <h3>${q.title}</h3>
                        <p>インデックス: ${index}</p>
                        <p>ID: ${q.id}</p>
                    `;
                    
                    // 初期状態で非表示（VirtualQuestionFlowと同じ）
                    element.style.display = 'none';
                    element.style.opacity = '0';
                    element.style.position = 'relative';
                    
                    viewport.appendChild(element);
                    this.activeElements.set(index, element);
                    
                    log(`要素作成: ${q.id} (index: ${index})`);
                });
                
                // 最初の設問を表示
                this.showCurrentQuestion();
            }
            
            /**
             * 現在の設問のみを表示し、他のすべての設問を非表示にする
             * 
             * 目的：
             * - 仮想スクロールの一環として、現在アクティブな設問のみを画面に表示
             * - 偶数番設問の表示問題を解決
             * 
             * 処理内容：
             * 1. activeElements Map内のすべての要素をループ
             * 2. currentQuestionIndexと一致するインデックスの要素のみ表示
             * 3. それ以外の要素は非表示に設定
             * 
             * 問題の診断：
             * - 偶数番設問が表示されない原因を特定するため、詳細なログを出力
             */
            showCurrentQuestion() {
                log(`\n========== showCurrentQuestion開始 ==========`);
                log(`現在のインデックス: ${this.currentQuestionIndex}`);
                
                // すべての要素の表示状態を制御
                for (const [index, element] of this.activeElements) {
                    const shouldShow = index === this.currentQuestionIndex;
                    const questionId = element.dataset.questionId;
                    const isEven = parseInt(questionId.replace('q', '')) % 2 === 0;
                    
                    log(`\n処理中: ${questionId} (index: ${index}, 偶数: ${isEven})`);
                    
                    // 処理前の状態を記録
                    const beforeStyle = {
                        display: element.style.display,
                        opacity: element.style.opacity,
                        computedDisplay: window.getComputedStyle(element).display
                    };
                    log(`処理前の状態:`, beforeStyle);
                    
                    if (shouldShow) {
                        // 表示する要素
                        log(`>>> ${questionId}を表示します`);
                        
                        // スタイルをリセット
                        element.removeAttribute('style');
                        
                        // 新しいスタイルを設定
                        element.style.display = 'block';
                        element.style.opacity = '1';
                        element.style.visibility = 'visible';
                        element.style.position = 'relative';
                        element.style.zIndex = '10';
                        element.classList.add('active-question');
                        
                        // 処理後の状態を確認
                        const afterStyle = {
                            display: element.style.display,
                            opacity: element.style.opacity,
                            computedDisplay: window.getComputedStyle(element).display,
                            classList: element.className
                        };
                        log(`処理後の状態:`, afterStyle);
                        
                        // 要素のサイズを確認
                        const rect = element.getBoundingClientRect();
                        log(`要素のサイズ: ${rect.width}x${rect.height}`);
                        
                        // 偶数番の場合は追加チェック
                        if (isEven) {
                            log(`⚠️ 偶数番設問の追加チェック:`, {
                                offsetHeight: element.offsetHeight,
                                offsetWidth: element.offsetWidth,
                                parentDisplay: element.parentElement ? window.getComputedStyle(element.parentElement).display : 'no parent'
                            });
                        }
                        
                    } else {
                        // 非表示にする要素
                        element.style.display = 'none';
                        element.style.opacity = '0';
                        element.classList.remove('active-question');
                        log(`${questionId}を非表示にしました`);
                    }
                }
                
                // 10ms後に最終確認
                setTimeout(() => {
                    const currentElement = this.activeElements.get(this.currentQuestionIndex);
                    if (currentElement) {
                        const finalCheck = {
                            questionId: currentElement.dataset.questionId,
                            display: window.getComputedStyle(currentElement).display,
                            opacity: window.getComputedStyle(currentElement).opacity,
                            visibility: window.getComputedStyle(currentElement).visibility,
                            offsetHeight: currentElement.offsetHeight
                        };
                        log(`\n最終確認 (10ms後):`, finalCheck);
                        
                        if (finalCheck.display === 'none' || finalCheck.offsetHeight === 0) {
                            log(`❌ エラー: 要素が表示されていません！`);
                        } else {
                            log(`✅ 要素は正しく表示されています`);
                        }
                    }
                }, 10);
                
                log(`========== showCurrentQuestion終了 ==========\n`);
            }
            
            goToQuestion(index) {
                this.currentQuestionIndex = index;
                this.showCurrentQuestion();
            }
        }

        // グローバルインスタンス
        let flow = null;

        // 初期化
        window.onload = () => {
            flow = new SimpleVirtualFlow();
            log('テスト環境を初期化しました');
        };

        // ボタンハンドラー
        function moveToQuestion(index) {
            if (flow) {
                flow.goToQuestion(index);
            }
        }

        function checkCurrentState() {
            if (!flow) return;
            
            log('\n===== 現在の状態チェック =====');
            for (const [index, element] of flow.activeElements) {
                const style = window.getComputedStyle(element);
                log(`${element.dataset.questionId}:`, {
                    index: index,
                    display: style.display,
                    opacity: style.opacity,
                    visibility: style.visibility,
                    offsetHeight: element.offsetHeight,
                    classList: element.className
                });
            }
        }

        function forceShowEven() {
            log('\n===== 偶数番強制表示テスト =====');
            
            // q2を強制的に表示
            const q2 = flow.activeElements.get(1);
            if (q2) {
                q2.style.cssText = 'display: block !important; opacity: 1 !important; visibility: visible !important;';
                
                setTimeout(() => {
                    const check = window.getComputedStyle(q2);
                    log('強制表示後のq2:', {
                        display: check.display,
                        opacity: check.opacity,
                        visibility: check.visibility,
                        offsetHeight: q2.offsetHeight
                    });
                }, 100);
            }
        }
    </script>
</body>
</html>