<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DataPersistenceManager テストケース - HAQEI Future Simulator</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
      min-height: 100vh;
    }
    
    .container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    
    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .test-section {
      margin: 20px 0;
      padding: 20px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      background: #f8f9fa;
    }
    
    .test-section h2 {
      color: #34495e;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 15px 0;
    }
    
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    .btn-primary {
      background: linear-gradient(45deg, #3498db, #2980b9);
      color: white;
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3);
    }
    
    .btn-success {
      background: linear-gradient(45deg, #27ae60, #229954);
      color: white;
    }
    
    .btn-success:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(39, 174, 96, 0.3);
    }
    
    .btn-warning {
      background: linear-gradient(45deg, #f39c12, #e67e22);
      color: white;
    }
    
    .btn-warning:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(243, 156, 18, 0.3);
    }
    
    .btn-danger {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      color: white;
    }
    
    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
    }
    
    .results {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #ffffff;
      border-left: 4px solid #3498db;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
      line-height: 1.4;
    }
    
    .success {
      border-left-color: #27ae60;
      background: #d5f4e6;
    }
    
    .error {
      border-left-color: #e74c3c;
      background: #fdf2f2;
    }
    
    .warning {
      border-left-color: #f39c12;
      background: #fef9e7;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      border-left: 4px solid #3498db;
    }
    
    .stat-card h3 {
      margin: 0 0 10px 0;
      color: #2c3e50;
      font-size: 16px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #3498db;
    }
    
    .progress-bar {
      width: 100%;
      height: 20px;
      background: #ecf0f1;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(45deg, #3498db, #2980b9);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .log-entry {
      padding: 8px 12px;
      margin: 5px 0;
      border-radius: 5px;
      border-left: 3px solid #bdc3c7;
      background: #f8f9fa;
    }
    
    .log-success {
      border-left-color: #27ae60;
      background: #d5f4e6;
    }
    
    .log-error {
      border-left-color: #e74c3c;
      background: #fdf2f2;
    }
    
    .log-info {
      border-left-color: #3498db;
      background: #e8f4f8;
    }
    
    .log-warning {
      border-left-color: #f39c12;
      background: #fef9e7;
    }
    
    #performanceChart {
      margin: 20px 0;
      height: 300px;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🗄️ DataPersistenceManager テストスイート</h1>
    
    <!-- 初期化テスト -->
    <div class="test-section">
      <h2>🚀 初期化・基本機能テスト</h2>
      <div class="button-group">
        <button class="btn-primary" onclick="testInitialization()">初期化テスト</button>
        <button class="btn-primary" onclick="testEncryption()">暗号化テスト</button>
        <button class="btn-primary" onclick="testDatabase()">データベーステスト</button>
        <button class="btn-success" onclick="runBasicTests()">基本テスト実行</button>
      </div>
      <div id="initResults" class="results"></div>
    </div>
    
    <!-- CRUD操作テスト -->
    <div class="test-section">
      <h2>📝 CRUD操作テスト</h2>
      <div class="button-group">
        <button class="btn-success" onclick="testCreate()">作成テスト</button>
        <button class="btn-primary" onclick="testRead()">読み取りテスト</button>
        <button class="btn-warning" onclick="testUpdate()">更新テスト</button>
        <button class="btn-danger" onclick="testDelete()">削除テスト</button>
        <button class="btn-success" onclick="runCRUDTests()">CRUD総合テスト</button>
      </div>
      <div id="crudResults" class="results"></div>
    </div>
    
    <!-- パフォーマンステスト -->
    <div class="test-section">
      <h2>⚡ パフォーマンステスト</h2>
      <div class="button-group">
        <button class="btn-primary" onclick="testBulkInsert()">大量データ挿入</button>
        <button class="btn-primary" onclick="testBulkQuery()">大量データ検索</button>
        <button class="btn-warning" onclick="testCachePerformance()">キャッシュ性能</button>
        <button class="btn-danger" onclick="testMemoryUsage()">メモリ使用量</button>
        <button class="btn-success" onclick="runPerformanceTests()">性能総合テスト</button>
      </div>
      <div id="performanceResults" class="results"></div>
      <div id="performanceChart"></div>
    </div>
    
    <!-- セキュリティテスト -->
    <div class="test-section">
      <h2>🔐 セキュリティテスト</h2>
      <div class="button-group">
        <button class="btn-primary" onclick="testDataEncryption()">データ暗号化</button>
        <button class="btn-primary" onclick="testDataAnonymization()">データ匿名化</button>
        <button class="btn-warning" onclick="testAutoCleanup()">自動削除</button>
        <button class="btn-success" onclick="runSecurityTests()">セキュリティ総合テスト</button>
      </div>
      <div id="securityResults" class="results"></div>
    </div>
    
    <!-- 統計・監視 -->
    <div class="test-section">
      <h2>📊 統計・監視</h2>
      <div class="button-group">
        <button class="btn-primary" onclick="showStatistics()">統計表示</button>
        <button class="btn-primary" onclick="showDatabaseInfo()">DB情報表示</button>
        <button class="btn-warning" onclick="clearAllData()">全データクリア</button>
        <button class="btn-success" onclick="createBackup()">バックアップ作成</button>
      </div>
      
      <div class="stats-grid" id="statsGrid">
        <!-- 統計カードが動的に生成される -->
      </div>
      
      <div id="monitoringResults" class="results"></div>
    </div>
    
    <!-- テストログ -->
    <div class="test-section">
      <h2>📋 テストログ</h2>
      <div class="button-group">
        <button class="btn-warning" onclick="clearLogs()">ログクリア</button>
        <button class="btn-success" onclick="exportTestResults()">結果エクスポート</button>
      </div>
      <div id="testLogs" class="results"></div>
    </div>
  </div>

  <!-- DataPersistenceManagerの読み込み -->
  <script src="./public/js/core/DataPersistenceManager.js"></script>
  
  <script>
    // テスト環境のグローバル変数
    let persistenceManager = null;
    let testResults = [];
    let testStartTime = null;
    let performanceMetrics = [];
    
    // ログ出力関数
    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const logEntry = `[${timestamp}] ${message}`;
      
      const testLogs = document.getElementById('testLogs');
      const logDiv = document.createElement('div');
      logDiv.className = `log-entry log-${type}`;
      logDiv.textContent = logEntry;
      testLogs.appendChild(logDiv);
      
      // 自動スクロール
      testLogs.scrollTop = testLogs.scrollHeight;
      
      console.log(logEntry);
    }
    
    // 結果表示関数
    function showResults(elementId, results, type = '') {
      const element = document.getElementById(elementId);
      element.innerHTML = JSON.stringify(results, null, 2);
      if (type) {
        element.className = `results ${type}`;
      }
    }
    
    // テスト実行時間測定
    function startTimer() {
      testStartTime = performance.now();
    }
    
    function endTimer() {
      return testStartTime ? performance.now() - testStartTime : 0;
    }
    
    // 初期化テスト
    async function testInitialization() {
      log('初期化テスト開始', 'info');
      startTimer();
      
      try {
        persistenceManager = new DataPersistenceManager();
        const result = await persistenceManager.initialize();
        
        const testTime = endTimer();
        
        testResults.push({
          test: 'initialization',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('initResults', result, result.success ? 'success' : 'error');
        log(`初期化テスト ${result.success ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        testResults.push({
          test: 'initialization',
          success: false,
          time: testTime,
          error: error.message
        });
        
        showResults('initResults', errorResult, 'error');
        log(`初期化テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 暗号化テスト
    async function testEncryption() {
      log('暗号化テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const testData = 'HAQEI暗号化テストデータ - 個人情報サンプル';
        
        // 暗号化
        const encrypted = await persistenceManager.encryptData(testData);
        log(`データ暗号化完了: ${encrypted.substring(0, 50)}...`, 'info');
        
        // 復号化
        const decrypted = await persistenceManager.decryptData(encrypted);
        log(`データ復号化完了: ${decrypted}`, 'info');
        
        // 検証
        const isValid = decrypted === testData;
        const testTime = endTimer();
        
        const result = {
          success: isValid,
          originalData: testData,
          encryptedData: encrypted,
          decryptedData: decrypted,
          testTime: testTime
        };
        
        testResults.push({
          test: 'encryption',
          success: isValid,
          time: testTime,
          details: result
        });
        
        showResults('initResults', result, isValid ? 'success' : 'error');
        log(`暗号化テスト ${isValid ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            isValid ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('initResults', errorResult, 'error');
        log(`暗号化テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // データベーステスト
    async function testDatabase() {
      log('データベーステスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // データベース情報取得
        const stats = persistenceManager.getPerformanceStatistics();
        const testTime = endTimer();
        
        const result = {
          success: stats.database.initialized,
          databaseInfo: stats.database,
          operations: stats.operations,
          testTime: testTime
        };
        
        testResults.push({
          test: 'database',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('initResults', result, result.success ? 'success' : 'error');
        log(`データベーステスト ${result.success ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('initResults', errorResult, 'error');
        log(`データベーステスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 基本テスト総合実行
    async function runBasicTests() {
      log('基本テスト総合実行開始', 'info');
      
      const results = {
        initialization: await testInitialization(),
        encryption: await testEncryption(),
        database: await testDatabase()
      };
      
      const allSuccessful = Object.values(results).every(r => r.success);
      
      showResults('initResults', results, allSuccessful ? 'success' : 'warning');
      log(`基本テスト総合結果: ${allSuccessful ? '全て成功' : '一部失敗'}`, 
          allSuccessful ? 'success' : 'warning');
      
      return results;
    }
    
    // 分析結果サンプルデータ生成
    function generateSampleAnalysisData(index = 0) {
      return {
        inputAnalysis: {
          originalText: `テストテキスト${index}: 仕事でのストレスと人間関係について悩んでいます。`,
          textLength: 30,
          complexity: 'medium'
        },
        finalResult: {
          hexagram: Math.floor(Math.random() * 64) + 1,
          line: Math.floor(Math.random() * 6) + 1,
          confidence: 0.7 + Math.random() * 0.3,
          reasoning: `分析結果${index}: この状況では慎重な判断が必要です。`,
          tripleOSIntegration: {
            engineOS: Math.random(),
            interfaceOS: Math.random(),
            safeModeOS: Math.random()
          }
        },
        stageResults: {
          stage1: { normalizedText: `正規化テキスト${index}` },
          stage2: { tokens: [], analysis: {} },
          stage3: { keywords: [], confidence: 0.8 },
          stage4: { emotionalAnalysis: {} },
          stage5: { osImpacts: {} },
          stage6: { hexagram: Math.floor(Math.random() * 64) + 1 },
          stage7: { finalResult: {} }
        },
        qualityMetrics: {
          overallConfidence: 0.8,
          stageCompletionRate: 1.0,
          errorCount: 0,
          processingTime: 150,
          qualityGrade: 'A'
        },
        systemInfo: {
          engineVersion: '2.1',
          timestamp: new Date().toISOString()
        }
      };
    }
    
    // 7変化パターンサンプルデータ生成
    function generateSamplePatterns(count = 7) {
      const patterns = [];
      const patternTypes = [
        'transformation', 'evolution', 'adaptation', 'innovation',
        'integration', 'optimization', 'realization'
      ];
      
      for (let i = 0; i < count; i++) {
        patterns.push({
          type: patternTypes[i] || `pattern_${i}`,
          data: {
            description: `パターン${i + 1}の詳細データ`,
            intensity: Math.random(),
            probability: Math.random(),
            timeframe: ['short', 'medium', 'long'][Math.floor(Math.random() * 3)]
          }
        });
      }
      
      return patterns;
    }
    
    // 作成テスト
    async function testCreate() {
      log('作成テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const analysisData = generateSampleAnalysisData(1);
        const patterns = generateSamplePatterns();
        const userProfile = {
          age: 30,
          location: { prefecture: '東京都' },
          interests: ['philosophy', 'self-development']
        };
        
        const result = await persistenceManager.saveAnalysisResult(analysisData, patterns, userProfile);
        const testTime = endTimer();
        
        testResults.push({
          test: 'create',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('crudResults', result, result.success ? 'success' : 'error');
        log(`作成テスト ${result.success ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        // 作成したIDを保存（他のテストで使用）
        if (result.success) {
          window.testAnalysisId = result.analysisId;
        }
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('crudResults', errorResult, 'error');
        log(`作成テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 読み取りテスト
    async function testRead() {
      log('読み取りテスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // 事前にデータを作成（存在しない場合）
        if (!window.testAnalysisId) {
          const createResult = await testCreate();
          if (!createResult.success) {
            throw new Error('テストデータ作成失敗');
          }
        }
        
        const result = await persistenceManager.getAnalysisResult(window.testAnalysisId);
        const testTime = endTimer();
        
        testResults.push({
          test: 'read',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('crudResults', result, result.success ? 'success' : 'error');
        log(`読み取りテスト ${result.success ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('crudResults', errorResult, 'error');
        log(`読み取りテスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 更新テスト（現在の実装では更新機能がないため、再保存テスト）
    async function testUpdate() {
      log('更新テスト開始（再保存）', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const analysisData = generateSampleAnalysisData(999); // 異なるデータ
        const patterns = generateSamplePatterns();
        
        const result = await persistenceManager.saveAnalysisResult(analysisData, patterns);
        const testTime = endTimer();
        
        testResults.push({
          test: 'update',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('crudResults', result, result.success ? 'success' : 'error');
        log(`更新テスト ${result.success ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('crudResults', errorResult, 'error');
        log(`更新テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 削除テスト
    async function testDelete() {
      log('削除テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // 削除用データ作成
        const analysisData = generateSampleAnalysisData(777);
        const patterns = generateSamplePatterns();
        const createResult = await persistenceManager.saveAnalysisResult(analysisData, patterns);
        
        if (!createResult.success) {
          throw new Error('削除テスト用データ作成失敗');
        }
        
        // 削除実行
        const result = await persistenceManager.deleteAnalysisResult(createResult.analysisId);
        const testTime = endTimer();
        
        testResults.push({
          test: 'delete',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('crudResults', result, result.success ? 'success' : 'error');
        log(`削除テスト ${result.success ? '成功' : '失敗'} (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('crudResults', errorResult, 'error');
        log(`削除テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // CRUD総合テスト
    async function runCRUDTests() {
      log('CRUD総合テスト開始', 'info');
      
      const results = {
        create: await testCreate(),
        read: await testRead(),
        update: await testUpdate(),
        delete: await testDelete()
      };
      
      const allSuccessful = Object.values(results).every(r => r.success);
      
      showResults('crudResults', results, allSuccessful ? 'success' : 'warning');
      log(`CRUD総合テスト結果: ${allSuccessful ? '全て成功' : '一部失敗'}`, 
          allSuccessful ? 'success' : 'warning');
      
      return results;
    }
    
    // 大量データ挿入テスト
    async function testBulkInsert() {
      log('大量データ挿入テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const testCount = 100; // 100件のテストデータ
        const promises = [];
        
        log(`${testCount}件のデータ挿入開始...`, 'info');
        
        for (let i = 0; i < testCount; i++) {
          const analysisData = generateSampleAnalysisData(i);
          const patterns = generateSamplePatterns();
          promises.push(persistenceManager.saveAnalysisResult(analysisData, patterns));
          
          // 進捗表示
          if (i % 20 === 0) {
            log(`進捗: ${i}/${testCount} (${(i/testCount*100).toFixed(1)}%)`, 'info');
          }
        }
        
        const results = await Promise.all(promises);
        const testTime = endTimer();
        
        const successCount = results.filter(r => r.success).length;
        const successRate = successCount / testCount * 100;
        
        const result = {
          success: successRate > 90,
          totalInserted: testCount,
          successfulInserted: successCount,
          successRate: successRate,
          testTime: testTime,
          averageTimePerRecord: testTime / testCount
        };
        
        performanceMetrics.push({
          test: 'bulkInsert',
          totalRecords: testCount,
          timeMs: testTime,
          recordsPerSecond: testCount / (testTime / 1000)
        });
        
        testResults.push({
          test: 'bulkInsert',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('performanceResults', result, result.success ? 'success' : 'warning');
        log(`大量データ挿入テスト完了: ${successCount}/${testCount}件成功 (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'warning');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('performanceResults', errorResult, 'error');
        log(`大量データ挿入テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 大量データ検索テスト
    async function testBulkQuery() {
      log('大量データ検索テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // 様々な検索条件でテスト
        const searchTests = [
          { name: '全件検索', criteria: {} },
          { name: '信頼度範囲検索', criteria: { confidenceRange: { min: 0.8, max: 1.0 } } },
          { name: '日付範囲検索', criteria: { dateRange: { start: Date.now() - 86400000, end: Date.now() } } },
          { name: '制限付き検索', criteria: { limit: 50 } }
        ];
        
        const results = [];
        
        for (const test of searchTests) {
          const searchStartTime = performance.now();
          const searchResult = await persistenceManager.searchAnalysisResults(test.criteria);
          const searchTime = performance.now() - searchStartTime;
          
          results.push({
            testName: test.name,
            success: searchResult.success,
            resultCount: searchResult.results?.length || 0,
            searchTime: searchTime
          });
          
          log(`${test.name}: ${searchResult.results?.length || 0}件 (${searchTime.toFixed(2)}ms)`, 'info');
        }
        
        const testTime = endTimer();
        const allSuccessful = results.every(r => r.success);
        
        const result = {
          success: allSuccessful,
          searchTests: results,
          totalTestTime: testTime,
          averageSearchTime: results.reduce((sum, r) => sum + r.searchTime, 0) / results.length
        };
        
        performanceMetrics.push({
          test: 'bulkQuery',
          totalQueries: results.length,
          timeMs: testTime,
          averageQueryTime: result.averageSearchTime
        });
        
        testResults.push({
          test: 'bulkQuery',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('performanceResults', result, result.success ? 'success' : 'warning');
        log(`大量データ検索テスト完了: ${results.length}種類の検索実行 (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'warning');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('performanceResults', errorResult, 'error');
        log(`大量データ検索テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // キャッシュ性能テスト
    async function testCachePerformance() {
      log('キャッシュ性能テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // テストデータ作成
        const analysisData = generateSampleAnalysisData(888);
        const patterns = generateSamplePatterns();
        const createResult = await persistenceManager.saveAnalysisResult(analysisData, patterns);
        
        if (!createResult.success) {
          throw new Error('キャッシュテスト用データ作成失敗');
        }
        
        const analysisId = createResult.analysisId;
        
        // 初回読み取り（キャッシュなし）
        const firstReadStart = performance.now();
        const firstRead = await persistenceManager.getAnalysisResult(analysisId);
        const firstReadTime = performance.now() - firstReadStart;
        
        // 2回目読み取り（キャッシュあり）
        const secondReadStart = performance.now();
        const secondRead = await persistenceManager.getAnalysisResult(analysisId);
        const secondReadTime = performance.now() - secondReadStart;
        
        const testTime = endTimer();
        const speedup = firstReadTime / secondReadTime;
        
        const result = {
          success: firstRead.success && secondRead.success,
          firstReadTime: firstReadTime,
          secondReadTime: secondReadTime,
          speedup: speedup,
          cacheEffective: speedup > 1.5,
          testTime: testTime
        };
        
        testResults.push({
          test: 'cachePerformance',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('performanceResults', result, result.success ? 'success' : 'warning');
        log(`キャッシュ性能テスト完了: ${speedup.toFixed(2)}倍高速化 (${testTime.toFixed(2)}ms)`, 
            result.cacheEffective ? 'success' : 'warning');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('performanceResults', errorResult, 'error');
        log(`キャッシュ性能テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // メモリ使用量テスト
    async function testMemoryUsage() {
      log('メモリ使用量テスト開始', 'info');
      startTimer();
      
      try {
        const initialMemory = performance.memory ? {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit
        } : null;
        
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // 大量データ作成
        const testCount = 50;
        const promises = [];
        
        for (let i = 0; i < testCount; i++) {
          const analysisData = generateSampleAnalysisData(i);
          const patterns = generateSamplePatterns();
          promises.push(persistenceManager.saveAnalysisResult(analysisData, patterns));
        }
        
        await Promise.all(promises);
        
        const finalMemory = performance.memory ? {
          used: performance.memory.usedJSHeapSize,
          total: performance.memory.totalJSHeapSize,
          limit: performance.memory.jsHeapSizeLimit
        } : null;
        
        const testTime = endTimer();
        
        const result = {
          success: true,
          initialMemory: initialMemory,
          finalMemory: finalMemory,
          memoryIncrease: finalMemory && initialMemory ? 
            finalMemory.used - initialMemory.used : null,
          testRecords: testCount,
          testTime: testTime,
          memoryPerRecord: finalMemory && initialMemory ? 
            (finalMemory.used - initialMemory.used) / testCount : null
        };
        
        testResults.push({
          test: 'memoryUsage',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('performanceResults', result, 'success');
        log(`メモリ使用量テスト完了: ${result.memoryIncrease ? 
          `${(result.memoryIncrease / 1024 / 1024).toFixed(2)}MB増加` : 
          'メモリ情報不明'} (${testTime.toFixed(2)}ms)`, 'info');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('performanceResults', errorResult, 'error');
        log(`メモリ使用量テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // パフォーマンス総合テスト
    async function runPerformanceTests() {
      log('パフォーマンス総合テスト開始', 'info');
      
      const results = {
        bulkInsert: await testBulkInsert(),
        bulkQuery: await testBulkQuery(),
        cachePerformance: await testCachePerformance(),
        memoryUsage: await testMemoryUsage()
      };
      
      const allSuccessful = Object.values(results).every(r => r.success);
      
      showResults('performanceResults', results, allSuccessful ? 'success' : 'warning');
      log(`パフォーマンス総合テスト結果: ${allSuccessful ? '全て成功' : '一部失敗'}`, 
          allSuccessful ? 'success' : 'warning');
      
      // パフォーマンスチャート更新
      updatePerformanceChart();
      
      return results;
    }
    
    // パフォーマンスチャート更新
    function updatePerformanceChart() {
      const chartDiv = document.getElementById('performanceChart');
      if (performanceMetrics.length === 0) {
        chartDiv.innerHTML = '<p>パフォーマンスデータがありません</p>';
        return;
      }
      
      let html = '<h3>📊 パフォーマンス指標</h3>';
      html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';
      
      performanceMetrics.forEach(metric => {
        html += `
          <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
            <h4>${metric.test}</h4>
            <p><strong>実行時間:</strong> ${metric.timeMs.toFixed(2)}ms</p>
            ${metric.totalRecords ? `<p><strong>レコード数:</strong> ${metric.totalRecords}</p>` : ''}
            ${metric.recordsPerSecond ? `<p><strong>1秒あたり:</strong> ${metric.recordsPerSecond.toFixed(2)}レコード</p>` : ''}
            ${metric.averageQueryTime ? `<p><strong>平均クエリ時間:</strong> ${metric.averageQueryTime.toFixed(2)}ms</p>` : ''}
          </div>
        `;
      });
      
      html += '</div>';
      chartDiv.innerHTML = html;
    }
    
    // データ暗号化テスト
    async function testDataEncryption() {
      log('データ暗号化テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const sensitiveData = [
          '田中太郎さんの個人情報',
          'メールアドレス: test@example.com',
          '住所: 東京都渋谷区',
          '電話番号: 090-1234-5678'
        ];
        
        const results = [];
        
        for (const data of sensitiveData) {
          const encrypted = await persistenceManager.encryptData(data);
          const decrypted = await persistenceManager.decryptData(encrypted);
          
          results.push({
            original: data,
            encrypted: encrypted,
            decrypted: decrypted,
            success: decrypted === data,
            encryptedLength: encrypted.length
          });
        }
        
        const testTime = endTimer();
        const allSuccessful = results.every(r => r.success);
        
        const result = {
          success: allSuccessful,
          testResults: results,
          testTime: testTime,
          encryptionEnabled: !!persistenceManager.encryptionKey
        };
        
        testResults.push({
          test: 'dataEncryption',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('securityResults', result, result.success ? 'success' : 'error');
        log(`データ暗号化テスト ${result.success ? '成功' : '失敗'}: ${results.length}件テスト (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('securityResults', errorResult, 'error');
        log(`データ暗号化テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // データ匿名化テスト
    async function testDataAnonymization() {
      log('データ匿名化テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const userData = {
          name: '田中太郎',
          email: 'tanaka@example.com',
          phone: '090-1234-5678',
          address: '東京都渋谷区1-2-3',
          age: 35,
          userId: 'user123',
          location: {
            prefecture: '東京都',
            city: '渋谷区'
          },
          ipAddress: '192.168.1.1'
        };
        
        const anonymized = persistenceManager.anonymizeUserData(userData);
        const testTime = endTimer();
        
        // 匿名化チェック
        const hasPersonalInfo = [
          'name', 'email', 'phone', 'address', 'ipAddress'
        ].some(field => anonymized.hasOwnProperty(field));
        
        const result = {
          success: !hasPersonalInfo,
          originalData: userData,
          anonymizedData: anonymized,
          removedFields: Object.keys(userData).filter(key => !anonymized.hasOwnProperty(key)),
          testTime: testTime
        };
        
        testResults.push({
          test: 'dataAnonymization',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('securityResults', result, result.success ? 'success' : 'error');
        log(`データ匿名化テスト ${result.success ? '成功' : '失敗'}: ${result.removedFields.length}項目削除 (${testTime.toFixed(2)}ms)`, 
            result.success ? 'success' : 'error');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('securityResults', errorResult, 'error');
        log(`データ匿名化テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // 自動削除テスト
    async function testAutoCleanup() {
      log('自動削除テスト開始', 'info');
      startTimer();
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // 手動で自動削除を実行
        await persistenceManager.performAutoCleanup();
        const testTime = endTimer();
        
        const stats = persistenceManager.getPerformanceStatistics();
        
        const result = {
          success: true,
          deletedRecords: stats.maintenance.deletedRecords,
          retentionDays: stats.maintenance.retentionDays,
          testTime: testTime,
          maintenanceInfo: stats.maintenance
        };
        
        testResults.push({
          test: 'autoCleanup',
          success: result.success,
          time: testTime,
          details: result
        });
        
        showResults('securityResults', result, 'success');
        log(`自動削除テスト完了: ${result.deletedRecords}件削除 (${testTime.toFixed(2)}ms)`, 'success');
        
        return result;
        
      } catch (error) {
        const testTime = endTimer();
        const errorResult = { success: false, error: error.message };
        
        showResults('securityResults', errorResult, 'error');
        log(`自動削除テスト失敗: ${error.message}`, 'error');
        
        return errorResult;
      }
    }
    
    // セキュリティ総合テスト
    async function runSecurityTests() {
      log('セキュリティ総合テスト開始', 'info');
      
      const results = {
        dataEncryption: await testDataEncryption(),
        dataAnonymization: await testDataAnonymization(),
        autoCleanup: await testAutoCleanup()
      };
      
      const allSuccessful = Object.values(results).every(r => r.success);
      
      showResults('securityResults', results, allSuccessful ? 'success' : 'warning');
      log(`セキュリティ総合テスト結果: ${allSuccessful ? '全て成功' : '一部失敗'}`, 
          allSuccessful ? 'success' : 'warning');
      
      return results;
    }
    
    // 統計表示
    async function showStatistics() {
      log('統計情報取得中', 'info');
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const stats = persistenceManager.getPerformanceStatistics();
        
        // 統計カード表示
        const statsGrid = document.getElementById('statsGrid');
        statsGrid.innerHTML = `
          <div class="stat-card">
            <h3>🗄️ データベース</h3>
            <div class="stat-value">${stats.database.name}</div>
            <p>バージョン: ${stats.database.version}</p>
            <p>初期化状態: ${stats.database.initialized ? '完了' : '未完了'}</p>
          </div>
          
          <div class="stat-card">
            <h3>⚡ 操作統計</h3>
            <div class="stat-value">${stats.operations.total}</div>
            <p>成功率: ${stats.operations.successRate.toFixed(1)}%</p>
            <p>平均時間: ${stats.operations.averageTime.toFixed(2)}ms</p>
          </div>
          
          <div class="stat-card">
            <h3>🔐 セキュリティ</h3>
            <div class="stat-value">${stats.security.encryptionEnabled ? '有効' : '無効'}</div>
            <p>暗号化レコード: ${stats.security.encryptedRecords}件</p>
          </div>
          
          <div class="stat-card">
            <h3>🧹 メンテナンス</h3>
            <div class="stat-value">${stats.maintenance.deletedRecords}</div>
            <p>削除されたレコード数</p>
            <p>保持期間: ${stats.maintenance.retentionDays}日</p>
          </div>
          
          <div class="stat-card">
            <h3>💾 キャッシュ</h3>
            <div class="stat-value">${stats.cache.currentSize}/${stats.cache.maxSize}</div>
            <p>キャッシュ使用率</p>
            <p>状態: ${stats.cache.enabled ? '有効' : '無効'}</p>
          </div>
          
          <div class="stat-card">
            <h3>🧪 テスト結果</h3>
            <div class="stat-value">${testResults.length}</div>
            <p>実行済みテスト数</p>
            <p>成功率: ${testResults.length > 0 ? 
              (testResults.filter(t => t.success).length / testResults.length * 100).toFixed(1) : 0}%</p>
          </div>
        `;
        
        showResults('monitoringResults', stats, 'success');
        log('統計情報表示完了', 'success');
        
      } catch (error) {
        log(`統計情報取得失敗: ${error.message}`, 'error');
      }
    }
    
    // データベース情報表示
    async function showDatabaseInfo() {
      log('データベース情報取得中', 'info');
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const stats = persistenceManager.getPerformanceStatistics();
        const info = {
          database: stats.database,
          schema: persistenceManager.dbSchema,
          config: {
            retentionDays: persistenceManager.dataRetentionDays,
            maxRecords: persistenceManager.maxRecords,
            batchSize: persistenceManager.batchSize,
            cacheEnabled: persistenceManager.cacheEnabled,
            maxCacheSize: persistenceManager.maxCacheSize
          }
        };
        
        showResults('monitoringResults', info, 'success');
        log('データベース情報表示完了', 'success');
        
      } catch (error) {
        showResults('monitoringResults', { error: error.message }, 'error');
        log(`データベース情報取得失敗: ${error.message}`, 'error');
      }
    }
    
    // 全データクリア
    async function clearAllData() {
      if (!confirm('全てのデータを削除しますか？この操作は取り消せません。')) {
        return;
      }
      
      log('全データクリア開始', 'warning');
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        // データベースを閉じて再初期化
        persistenceManager.close();
        
        // IndexedDBを削除
        const deleteRequest = indexedDB.deleteDatabase(persistenceManager.dbName);
        
        deleteRequest.onsuccess = async () => {
          log('データベース削除完了', 'success');
          
          // 再初期化
          persistenceManager = new DataPersistenceManager();
          await persistenceManager.initialize();
          
          // 統計リセット
          testResults.length = 0;
          performanceMetrics.length = 0;
          window.testAnalysisId = null;
          
          showResults('monitoringResults', { message: '全データクリア完了' }, 'success');
          log('全データクリア完了', 'success');
        };
        
        deleteRequest.onerror = () => {
          log(`データベース削除エラー: ${deleteRequest.error}`, 'error');
        };
        
      } catch (error) {
        log(`全データクリア失敗: ${error.message}`, 'error');
      }
    }
    
    // バックアップ作成
    async function createBackup() {
      log('バックアップ作成開始', 'info');
      
      try {
        if (!persistenceManager) {
          await testInitialization();
        }
        
        const backupResult = await persistenceManager.createBackup();
        
        if (backupResult.success) {
          // バックアップをダウンロード可能な形式で提供
          const backupJson = JSON.stringify(backupResult.backup, null, 2);
          const blob = new Blob([backupJson], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = `haqei_backup_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          showResults('monitoringResults', backupResult, 'success');
          log(`バックアップ作成完了: ${backupResult.totalRecords}件 (${backupResult.backupTime.toFixed(2)}ms)`, 'success');
        } else {
          showResults('monitoringResults', backupResult, 'error');
          log(`バックアップ作成失敗: ${backupResult.error}`, 'error');
        }
        
      } catch (error) {
        log(`バックアップ作成エラー: ${error.message}`, 'error');
      }
    }
    
    // ログクリア
    function clearLogs() {
      document.getElementById('testLogs').innerHTML = '';
      log('ログクリア完了', 'info');
    }
    
    // テスト結果エクスポート
    function exportTestResults() {
      const exportData = {
        timestamp: new Date().toISOString(),
        testResults: testResults,
        performanceMetrics: performanceMetrics,
        summary: {
          totalTests: testResults.length,
          successfulTests: testResults.filter(t => t.success).length,
          failedTests: testResults.filter(t => !t.success).length,
          totalTime: testResults.reduce((sum, t) => sum + t.time, 0)
        }
      };
      
      const json = JSON.stringify(exportData, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `haqei_test_results_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      log('テスト結果エクスポート完了', 'success');
    }
    
    // ページ読み込み時の初期化
    window.addEventListener('load', function() {
      log('DataPersistenceManager テストスイート開始', 'info');
      log('各テストボタンをクリックしてテストを実行してください', 'info');
    });
  </script>
</body>
</html>