<\!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAQEI OS Analyzer 計算ロジック検証</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff41; }
        .test-section { border: 1px solid #333; margin: 20px 0; padding: 15px; }
        .error { color: #ff4444; }
        .warning { color: #ffaa44; }
        .success { color: #44ff44; }
        pre { background: #2a2a2a; padding: 10px; overflow-x: auto; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #333; padding: 8px; text-align: left; }
        th { background: #333; }
    </style>
</head>
<body>
    <h1>🔍 HAQEI OS Analyzer 計算ロジック検証レポート</h1>
    
    <div class="test-section">
        <h2>1. buildUserVector() 検証</h2>
        <div id="vector-test"></div>
    </div>

    <div class="test-section">
        <h2>2. calculateTrigramEnergies() 検証</h2>
        <div id="trigram-test"></div>
    </div>

    <div class="test-section">
        <h2>3. Interface OS 0% 問題分析</h2>
        <div id="interface-test"></div>
    </div>

    <div class="test-section">
        <h2>4. 統計的分析結果</h2>
        <div id="statistical-test"></div>
    </div>

    <script>
        // テストデータ: 典型的な30問回答パターン
        const testAnswers = [
            // Q1-Q24: 価値観質問の回答例
            {questionNumber: 1, selectedOption: {scoring: {"乾_創造性": 3.0, "離_表現性": 1.5, "艮_安定性": -1.0}}},
            {questionNumber: 2, selectedOption: {scoring: {"乾_創造性": 3.0, "震_行動性": 2.0, "艮_安定性": -1.0}}},
            {questionNumber: 3, selectedOption: {scoring: {"乾_創造性": 3.0, "離_表現性": 1.5, "坤_受容性": -1.0}}},
            {questionNumber: 4, selectedOption: {scoring: {"震_行動性": 3.0, "乾_創造性": 1.0, "艮_安定性": -1.5}}},
            {questionNumber: 5, selectedOption: {scoring: {"震_行動性": 3.0, "乾_創造性": 1.5, "坤_受容性": -1.0}}},
            {questionNumber: 6, selectedOption: {scoring: {"震_行動性": 3.0, "乾_創造性": 2.0, "艮_安定性": -1.0}}},
            {questionNumber: 7, selectedOption: {scoring: {"坎_探求性": 3.0, "艮_安定性": 1.0, "震_行動性": -0.5}}},
            {questionNumber: 8, selectedOption: {scoring: {"坎_探求性": 3.0, "艮_安定性": 1.5, "震_行動性": -1.0}}},
            {questionNumber: 9, selectedOption: {scoring: {"坎_探求性": 3.0, "艮_安定性": 1.0, "震_行動性": -0.5}}},
            {questionNumber: 10, selectedOption: {scoring: {"艮_安定性": 3.0, "坤_受容性": 1.0, "乾_創造性": -1.5}}},
            {questionNumber: 11, selectedOption: {scoring: {"艮_安定性": 3.0, "坤_受容性": 1.5, "震_行動性": -0.5}}},
            {questionNumber: 12, selectedOption: {scoring: {"艮_安定性": 3.0, "坤_受容性": 1.0, "巽_適応性": -0.5}}},
            {questionNumber: 13, selectedOption: {scoring: {"坤_受容性": 3.0, "兌_調和性": 1.5, "震_行動性": -0.5}}},
            {questionNumber: 14, selectedOption: {scoring: {"坤_受容性": 3.0, "兌_調和性": 1.5, "震_行動性": -0.5}}},
            {questionNumber: 15, selectedOption: {scoring: {"坤_受容性": 3.0, "艮_安定性": 2.0, "震_行動性": -0.5}}},
            {questionNumber: 16, selectedOption: {scoring: {"巽_適応性": 3.0, "兌_調和性": 1.0, "艮_安定性": -0.5}}},
            {questionNumber: 17, selectedOption: {scoring: {"巽_適応性": 3.0, "兌_調和性": 2.0, "離_表現性": 0.5}}},
            {questionNumber: 18, selectedOption: {scoring: {"巽_適応性": 3.0, "震_行動性": 1.0, "艮_安定性": -0.5}}},
            {questionNumber: 19, selectedOption: {scoring: {"離_表現性": 3.0, "乾_創造性": 1.5, "坤_受容性": -0.5}}},
            {questionNumber: 20, selectedOption: {scoring: {"離_表現性": 3.0, "乾_創造性": 1.5, "坤_受容性": -0.5}}},
            {questionNumber: 21, selectedOption: {scoring: {"離_表現性": 3.0, "震_行動性": 1.0, "艮_安定性": -0.5}}},
            {questionNumber: 22, selectedOption: {scoring: {"兌_調和性": 3.0, "巽_適応性": 2.0, "震_行動性": -0.5}}},
            {questionNumber: 23, selectedOption: {scoring: {"兌_調和性": 3.0, "離_表現性": 1.5, "坎_探求性": -0.5}}},
            {questionNumber: 24, selectedOption: {scoring: {"兌_調和性": 3.0, "離_表現性": 1.0, "艮_安定性": 0.5}}},

            // Q25-Q30: シナリオ質問の回答例
            {questionNumber: 25, selectedOption: {scoring: {"兌_調和性": 3.0, "坤_受容性": 2.5, "坎_探求性": 1.0}}},
            {questionNumber: 26, selectedOption: {scoring: {"兌_調和性": 2.5, "坤_受容性": 2.0, "離_表現性": 1.5}}},
            {questionNumber: 27, selectedOption: {scoring: {"兌_調和性": 3.0, "坤_受容性": 2.0, "離_表現性": 1.0}}},
            {questionNumber: 28, selectedOption: {scoring: {"坎_探求性": 3.0, "艮_安定性": 2.0, "震_行動性": -0.5}}},
            {questionNumber: 29, selectedOption: {scoring: {"巽_適応性": 3.0, "坎_探求性": 2.0, "艮_安定性": 0.5}}},
            {questionNumber: 30, selectedOption: {scoring: {"兌_調和性": 3.0, "坤_受容性": 2.0, "艮_安定性": 1.0}}}
        ];

        // 1. buildUserVector() 検証
        function testBuildUserVector() {
            console.log("=== buildUserVector() テスト開始 ===");
            
            const worldviewAnswers = testAnswers.filter(a => a.questionNumber >= 1 && a.questionNumber <= 24);
            
            // Engine OS用のベクトル構築
            const vector = {
                乾_創造性: 0, 震_行動性: 0, 坎_探求性: 0, 艮_安定性: 0,
                坤_受容性: 0, 巽_適応性: 0, 離_表現性: 0, 兌_調和性: 0
            };
            
            worldviewAnswers.forEach(answer => {
                const option = answer.selectedOption;
                if (option && option.scoring) {
                    Object.entries(option.scoring).forEach(([dimension, score]) => {
                        if (vector.hasOwnProperty(dimension)) {
                            vector[dimension] += score;
                        }
                    });
                }
            });
            
            console.log("ユーザーベクトル:", vector);
            
            let html = "<h3>ユーザーベクトル構築結果</h3>";
            html += "<table><tr><th>次元</th><th>生スコア</th><th>問題点</th></tr>";
            
            let totalScore = 0;
            let minScore = Infinity;
            let maxScore = -Infinity;
            
            Object.entries(vector).forEach(([dim, score]) => {
                totalScore += score;
                minScore = Math.min(minScore, score);
                maxScore = Math.max(maxScore, score);
                
                const issues = [];
                if (score < 0) issues.push("負の値");
                if (score === 0) issues.push("ゼロ値");
                if (score > 50) issues.push("異常に高い");
                
                html += `<tr><td>${dim}</td><td>${score.toFixed(1)}</td><td class="${issues.length ? 'warning' : 'success'}">${issues.join(', ') || 'OK'}</td></tr>`;
            });
            
            html += "</table>";
            html += `<p><strong>統計サマリー:</strong></p>`;
            html += `<ul>`;
            html += `<li>合計スコア: ${totalScore.toFixed(1)}</li>`;
            html += `<li>平均スコア: ${(totalScore / 8).toFixed(1)}</li>`;
            html += `<li>最小値: ${minScore.toFixed(1)}</li>`;
            html += `<li>最大値: ${maxScore.toFixed(1)}</li>`;
            html += `<li>レンジ: ${(maxScore - minScore).toFixed(1)}</li>`;
            html += `</ul>`;
            
            // 問題点分析
            html += `<h4>🚨 検出された問題点:</h4>`;
            if (minScore < 0) {
                html += `<div class="error">• 負の値が存在（${minScore.toFixed(1)}） - スコアリング設計に問題</div>`;
            }
            if (maxScore - minScore > 30) {
                html += `<div class="warning">• 極端な分散（レンジ: ${(maxScore - minScore).toFixed(1)}） - バランス調整が必要</div>`;
            }
            
            document.getElementById('vector-test').innerHTML = html;
            return vector;
        }

        // 2. calculateTrigramEnergies() 検証
        function testCalculateTrigramEnergies(userVector) {
            console.log("=== calculateTrigramEnergies() テスト開始 ===");
            
            // 正統八卦マッピング
            const AUTHENTIC_TRIGRAM_MAPPING = {
                "乾_創造性": "乾",  "兌_調和性": "兌", "離_表現性": "離", "震_行動性": "震",
                "巽_適応性": "巽", "坎_探求性": "坎", "艮_安定性": "艮", "坤_受容性": "坤"
            };
            
            const rawEnergies = {};
            Object.entries(AUTHENTIC_TRIGRAM_MAPPING).forEach(([dimension, trigramName]) => {
                rawEnergies[trigramName] = userVector[dimension] || 0;
            });
            
            console.log("生三爻エネルギー:", rawEnergies);
            
            // HaQei動的正規化
            const maxEnergy = Math.max(...Object.values(rawEnergies));
            const normalizedEnergies = {};
            
            if (maxEnergy > 0) {
                Object.entries(rawEnergies).forEach(([trigram, energy]) => {
                    const normalized = (energy / maxEnergy) * 100;
                    normalizedEnergies[trigram] = Math.max(0, Math.min(100, normalized));
                });
            } else {
                Object.keys(rawEnergies).forEach(trigram => {
                    normalizedEnergies[trigram] = 12.5; // 100/8
                });
            }
            
            console.log("正規化三爻エネルギー:", normalizedEnergies);
            
            let html = "<h3>三爻エネルギー計算結果</h3>";
            html += "<table><tr><th>三爻</th><th>生値</th><th>正規化値</th><th>問題点</th></tr>";
            
            Object.entries(rawEnergies).forEach(([trigram, rawValue]) => {
                const normalized = normalizedEnergies[trigram];
                const issues = [];
                
                if (rawValue === 0) issues.push("生値ゼロ");
                if (normalized === 100) issues.push("最高値独占");
                if (normalized < 10) issues.push("極端に低い");
                
                html += `<tr><td>${trigram}</td><td>${rawValue.toFixed(1)}</td><td>${normalized.toFixed(1)}%</td><td class="${issues.length ? 'warning' : 'success'}">${issues.join(', ') || 'OK'}</td></tr>`;
            });
            
            html += "</table>";
            
            // 正規化の問題点
            html += `<h4>🚨 正規化処理の問題点:</h4>`;
            html += `<div class="error">• 最高値を100%とする正規化は相対的過ぎる - 絶対評価が困難</div>`;
            html += `<div class="warning">• 一つの次元だけ高いと、他が全て低く見える</div>`;
            html += `<div class="warning">• 30問で8次元を適切に測定できるか疑問（1次元あたり3.75問）</div>`;
            
            document.getElementById('trigram-test').innerHTML = html;
            return normalizedEnergies;
        }

        // 3. Interface OS 0% 問題分析
        function testInterfaceOSIssue() {
            console.log("=== Interface OS 0% 問題分析 ===");
            
            const scenarioAnswers = testAnswers.filter(a => a.questionNumber >= 25 && a.questionNumber <= 30);
            console.log("シナリオ回答:", scenarioAnswers);
            
            // Interface OS分析のシミュレーション
            const socialPatterns = {
                Q25_leadership: 0, Q26_interpersonal: 0, Q27_family: 0,
                Q28_emergency: 0, Q29_competition: 0, Q30_community: 0
            };
            
            // シナリオスコア計算（簡略版）
            scenarioAnswers.forEach((answer, index) => {
                const questionId = `Q${25 + index}`;
                // スコア計算ロジックの問題: scoring値の合計を使用している可能性
                const scores = Object.values(answer.selectedOption.scoring);
                const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
                
                switch (questionId) {
                    case 'Q25': socialPatterns.Q25_leadership = avgScore; break;
                    case 'Q26': socialPatterns.Q26_interpersonal = avgScore; break;
                    case 'Q27': socialPatterns.Q27_family = avgScore; break;
                    case 'Q28': socialPatterns.Q28_emergency = avgScore; break;
                    case 'Q29': socialPatterns.Q29_competition = avgScore; break;
                    case 'Q30': socialPatterns.Q30_community = avgScore; break;
                }
            });
            
            console.log("社会的パターン:", socialPatterns);
            
            // Interface Vector構築
            const interfaceVector = {
                "外向_主導性": 0, "外向_調和性": 0, "外向_表現性": 0, "外向_行動性": 0,
                "内向_適応性": 0, "内向_分析性": 0, "内向_安定性": 0, "内向_支援性": 0
            };
            
            // マッピングロジック（問題がある可能性）
            interfaceVector["外向_主導性"] = (socialPatterns.Q25_leadership * 0.5) + (socialPatterns.Q28_emergency * 0.3);
            interfaceVector["外向_調和性"] = (socialPatterns.Q26_interpersonal * 0.4) + (socialPatterns.Q30_community * 0.4);
            interfaceVector["外向_表現性"] = (socialPatterns.Q25_leadership * 0.3) + (socialPatterns.Q26_interpersonal * 0.3);
            interfaceVector["外向_行動性"] = (socialPatterns.Q25_leadership * 0.2) + (socialPatterns.Q28_emergency * 0.4);
            interfaceVector["内向_適応性"] = (socialPatterns.Q26_interpersonal * 0.3) + (socialPatterns.Q27_family * 0.4);
            interfaceVector["内向_分析性"] = (socialPatterns.Q28_emergency * 0.3) + (socialPatterns.Q29_competition * 0.3);
            interfaceVector["内向_安定性"] = (socialPatterns.Q27_family * 0.4) + (socialPatterns.Q30_community * 0.3);
            interfaceVector["内向_支援性"] = (socialPatterns.Q27_family * 0.3) + (socialPatterns.Q30_community * 0.3);
            
            // 正規化（0-1範囲）
            Object.keys(interfaceVector).forEach(key => {
                interfaceVector[key] = Math.max(0, Math.min(1, interfaceVector[key]));
            });
            
            console.log("Interface Vector:", interfaceVector);
            
            let html = "<h3>Interface OS 計算過程検証</h3>";
            html += "<h4>Step 1: 社会的パターン</h4>";
            html += "<table><tr><th>パターン</th><th>値</th><th>問題</th></tr>";
            
            Object.entries(socialPatterns).forEach(([pattern, value]) => {
                const issues = [];
                if (value === 0) issues.push("ゼロ値");
                if (Math.abs(value) < 0.1) issues.push("極小値");
                
                html += `<tr><td>${pattern}</td><td>${value.toFixed(2)}</td><td class="${issues.length ? 'warning' : 'success'}">${issues.join(', ') || 'OK'}</td></tr>`;
            });
            
            html += "</table>";
            html += "<h4>Step 2: Interface Vector</h4>";
            html += "<table><tr><th>次元</th><th>計算式</th><th>値</th><th>問題</th></tr>";
            
            Object.entries(interfaceVector).forEach(([dim, value]) => {
                const issues = [];
                if (value === 0) issues.push("ゼロ値");
                if (value > 0.8) issues.push("異常に高い");
                
                html += `<tr><td>${dim}</td><td>複合計算</td><td>${value.toFixed(3)}</td><td class="${issues.length ? 'warning' : 'success'}">${issues.join(', ') || 'OK'}</td></tr>`;
            });
            
            html += "</table>";
            
            html += `<h4>🚨 Interface OS 0% 問題の原因:</h4>`;
            html += `<div class="error">• シナリオ質問（Q25-Q30）がEngine OS用スコアリングを流用</div>`;
            html += `<div class="error">• Interface専用スコアリング体系が未実装</div>`;
            html += `<div class="error">• 8次元→8次元の複雑なマッピングで情報損失</div>`;
            html += `<div class="error">• 係数による計算で値が希薄化</div>`;
            
            document.getElementById('interface-test').innerHTML = html;
        }

        // 4. 統計的分析
        function testStatisticalValidation() {
            console.log("=== 統計的分析開始 ===");
            
            let html = "<h3>統計的妥当性分析</h3>";
            
            html += `<h4>🔍 設計上の問題点:</h4>`;
            html += `<div class="error"><strong>1. 質問数の不足</strong><br>`;
            html += `- 8次元測定に30問使用<br>`;
            html += `- 1次元あたり3.75問（統計的に不十分）<br>`;
            html += `- 信頼性確保には最低5-7問/次元必要</div>`;
            
            html += `<div class="error"><strong>2. スコアリング体系の矛盾</strong><br>`;
            html += `- Engine OS: 直接8次元スコアリング<br>`;
            html += `- Interface OS: 同じスコアを6パターン→8次元に変換<br>`;
            html += `- Safe Mode OS: また別の変換体系<br>`;
            html += `- 一貫性なし</div>`;
            
            html += `<div class="error"><strong>3. 正規化手法の問題</strong><br>`;
            html += `- 最高値を100%とする相対正規化<br>`;
            html += `- 絶対的評価が不可能<br>`;
            html += `- 個人内比較のみで個人間比較困難</div>`;
            
            html += `<div class="error"><strong>4. Interface OS特有の問題</strong><br>`;
            html += `- Q25-Q30でEngine OS用scoring使用<br>`;
            html += `- 複雑な係数マッピングで値希薄化<br>`;
            html += `- 0%になりやすい構造的欠陥</div>`;
            
            html += `<h4>📊 推奨改善策:</h4>`;
            html += `<div class="success"><strong>1. 質問設計の見直し</strong><br>`;
            html += `- 各OS専用の質問セット作成<br>`;
            html += `- Engine OS: Q1-Q24 (8次元 × 3問)<br>`;
            html += `- Interface OS: Q25-Q32 (社会的8次元 × 1問)<br>`;
            html += `- Safe Mode OS: Q33-Q40 (防御的8次元 × 1問)</div>`;
            
            html += `<div class="success"><strong>2. スコアリング統一</strong><br>`;
            html += `- 全OSで同一の8次元体系使用<br>`;
            html += `- 各次元-1.0〜+3.0の統一スケール<br>`;
            html += `- 負の値を含む設計で対比明確化</div>`;
            
            html += `<div class="success"><strong>3. 正規化改善</strong><br>`;
            html += `- Z-score正規化または min-max正規化<br>`;
            html += `- 絶対評価可能な基準値設定<br>`;
            html += `- 個人間比較可能な標準化</div>`;
            
            document.getElementById('statistical-test').innerHTML = html;
        }

        // テスト実行
        window.onload = function() {
            const vector = testBuildUserVector();
            const energies = testCalculateTrigramEnergies(vector);
            testInterfaceOSIssue();
            testStatisticalValidation();
            
            console.log("=== 検証完了 ===");
            console.log("主要問題:");
            console.log("1. Interface OS用のスコアリング体系が未実装");
            console.log("2. 30問で3つのOSを分離するには質問数不足");
            console.log("3. 相対正規化により絶対評価困難");
            console.log("4. Engine OSの値に依存してInterface/Safe Modeが決まる構造的問題");
        };
    </script>
</body>
</html>
EOF < /dev/null