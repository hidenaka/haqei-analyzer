<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAQEI Future Simulator パフォーマンス測定システム</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .test-controls {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .test-scenarios {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .scenario-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
        }
        
        .scenario-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .scenario-card h3 {
            color: #495057;
            margin-bottom: 10px;
        }
        
        .scenario-text {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.6;
            border-left: 4px solid #667eea;
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .results-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .results-header {
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid #667eea;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .metric-status {
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .status-excellent {
            background: #d4edda;
            color: #155724;
        }
        
        .status-good {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-danger {
            background: #f8d7da;
            color: #721c24;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #6c757d;
        }
        
        .detailed-results {
            margin-top: 30px;
        }
        
        .result-section {
            margin-bottom: 25px;
        }
        
        .result-section h3 {
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .result-table th,
        .result-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .result-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }
        
        .log-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-info {
            color: #0c5460;
            background: #d1ecf1;
        }
        
        .log-success {
            color: #155724;
            background: #d4edda;
        }
        
        .log-warning {
            color: #856404;
            background: #fff3cd;
        }
        
        .log-error {
            color: #721c24;
            background: #f8d7da;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .metric-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 HAQEI Future Simulator</h1>
            <p>パフォーマンス測定・ボトルネック分析システム</p>
        </div>
        
        <div class="test-controls">
            <div class="test-scenarios">
                <div class="scenario-card">
                    <h3>🟢 軽量テスト</h3>
                    <div class="scenario-text">「仕事の悩みがある」</div>
                </div>
                
                <div class="scenario-card">
                    <h3>🟡 中量テスト</h3>
                    <div class="scenario-text">「新しいプロジェクトが始まったが、チームメンバーとのコミュニケーションがうまくいかない。技術的な課題も多く、スケジュールも厳しい。どのように進めるべきか悩んでいる。」</div>
                </div>
                
                <div class="scenario-card">
                    <h3>🔴 重量テスト</h3>
                    <div class="scenario-text">「人生の転機に立っている。現在の職場では10年働いているが、最近やりがいを感じなくなってきた。家族を養う責任もあり、転職には大きなリスクが伴う。しかし、このままでは自分の成長が止まってしまう気がする。新しい分野に挑戦したい気持ちと、安定を求める気持ちで葛藤している。年齢的にも最後のチャンスかもしれない。どのような選択をすべきか、深く悩んでいる。」</div>
                </div>
            </div>
            
            <div class="control-buttons">
                <button class="btn btn-primary" onclick="runSingleTest()">単体テスト実行</button>
                <button class="btn btn-success" onclick="runComprehensiveTest()">包括的テスト実行</button>
                <button class="btn btn-secondary" onclick="runBenchmark()">ベンチマーク実行</button>
                <button class="btn btn-secondary" onclick="clearResults()">結果クリア</button>
            </div>
            
            <div class="progress-container hidden" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">テスト準備中...</div>
            </div>
        </div>
        
        <div class="results-container">
            <div class="results-header">
                <h2>📊 パフォーマンス測定結果</h2>
                <p>システム統合パフォーマンス分析レポート</p>
            </div>
            
            <div class="metric-grid" id="metricsGrid">
                <!-- メトリクスカードが動的に生成される -->
            </div>
            
            <div class="detailed-results">
                <div class="result-section">
                    <h3>🔍 詳細パフォーマンス分析</h3>
                    <div id="detailedAnalysis"></div>
                </div>
                
                <div class="result-section">
                    <h3>⚡ ボトルネック分析</h3>
                    <div id="bottleneckAnalysis"></div>
                </div>
                
                <div class="result-section">
                    <h3>💡 最適化提案</h3>
                    <div id="optimizationSuggestions"></div>
                </div>
                
                <div class="result-section">
                    <h3>📝 実行ログ</h3>
                    <div class="log-container" id="logContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // パフォーマンス測定システム
        class PerformanceAnalyzer {
            constructor() {
                this.metrics = {
                    totalProcessingTime: 0,
                    initializationTime: 0,
                    analysisTime: 0,
                    mappingTime: 0,
                    renderTime: 0,
                    memoryUsage: { initial: 0, peak: 0, final: 0 },
                    cpuUsage: [],
                    networkRequests: [],
                    errors: []
                };
                
                this.testScenarios = {
                    light: "仕事の悩みがある",
                    medium: "新しいプロジェクトが始まったが、チームメンバーとのコミュニケーションがうまくいかない。技術的な課題も多く、スケジュールも厳しい。どのように進めるべきか悩んでいる。",
                    heavy: "人生の転機に立っている。現在の職場では10年働いているが、最近やりがいを感じなくなってきた。家族を養う責任もあり、転職には大きなリスクが伴う。しかし、このままでは自分の成長が止まってしまう気がする。新しい分野に挑戦したい気持ちと、安定を求める気持ちで葛藤している。年齢的にも最後のチャンスかもしれない。どのような選択をすべきか、深く悩んでいる。"
                };
                
                this.performanceTargets = {
                    totalProcessingTime: 3000, // 3秒以内
                    initializationTime: 1000,  // 1秒以内
                    memoryUsage: 50 * 1024 * 1024, // 50MB以内
                    cpuUsagePeak: 80 // 80%以内
                };
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
            
            updateProgress(percentage, text) {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                progressContainer.classList.remove('hidden');
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = text;
                
                if (percentage >= 100) {
                    setTimeout(() => {
                        progressContainer.classList.add('hidden');
                    }, 1000);
                }
            }
            
            startMemoryMonitoring() {
                this.metrics.memoryUsage.initial = this.getCurrentMemoryUsage();
                this.memoryMonitorInterval = setInterval(() => {
                    const current = this.getCurrentMemoryUsage();
                    if (current > this.metrics.memoryUsage.peak) {
                        this.metrics.memoryUsage.peak = current;
                    }
                }, 100);
            }
            
            stopMemoryMonitoring() {
                if (this.memoryMonitorInterval) {
                    clearInterval(this.memoryMonitorInterval);
                }
                this.metrics.memoryUsage.final = this.getCurrentMemoryUsage();
            }
            
            getCurrentMemoryUsage() {
                if (performance.memory) {
                    return performance.memory.usedJSHeapSize;
                }
                return 0;
            }
            
            startCPUMonitoring() {
                this.cpuMonitorInterval = setInterval(() => {
                    // CPUモニタリングの簡易実装
                    const cpuUsage = this.estimateCPUUsage();
                    this.metrics.cpuUsage.push(cpuUsage);
                }, 100);
            }
            
            stopCPUMonitoring() {
                if (this.cpuMonitorInterval) {
                    clearInterval(this.cpuMonitorInterval);
                }
            }
            
            estimateCPUUsage() {
                // 簡易的なCPU使用率推定
                const start = performance.now();
                for (let i = 0; i < 10000; i++) {
                    Math.random();
                }
                const end = performance.now();
                return Math.min((end - start) * 10, 100);
            }
            
            async runSingleTest(scenario = 'medium') {
                this.log('単体テスト開始', 'info');
                this.updateProgress(10, 'テスト初期化中...');
                
                const testText = this.testScenarios[scenario];
                const results = await this.runPerformanceTest(testText);
                
                this.updateProgress(100, 'テスト完了');
                this.displayResults(results);
                this.log('単体テスト完了', 'success');
                
                return results;
            }
            
            async runComprehensiveTest() {
                this.log('包括的テスト開始', 'info');
                this.updateProgress(5, '包括的テスト準備中...');
                
                const results = [];
                const scenarios = ['light', 'medium', 'heavy'];
                
                for (let i = 0; i < scenarios.length; i++) {
                    const scenario = scenarios[i];
                    this.updateProgress(20 + (i * 25), `${scenario}テスト実行中...`);
                    
                    const testResult = await this.runPerformanceTest(this.testScenarios[scenario]);
                    testResult.scenario = scenario;
                    results.push(testResult);
                    
                    this.log(`${scenario}テスト完了: ${testResult.totalTime}ms`, 'success');
                }
                
                this.updateProgress(100, '包括的テスト完了');
                this.displayComprehensiveResults(results);
                this.log('包括的テスト完了', 'success');
                
                return results;
            }
            
            async runBenchmark() {
                this.log('ベンチマーク開始', 'info');
                this.updateProgress(10, 'ベンチマーク準備中...');
                
                const iterations = 5;
                const results = [];
                
                for (let i = 0; i < iterations; i++) {
                    this.updateProgress(20 + (i * 15), `ベンチマーク実行 ${i + 1}/${iterations}`);
                    
                    const result = await this.runPerformanceTest(this.testScenarios.medium);
                    result.iteration = i + 1;
                    results.push(result);
                    
                    // 短い休憩
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                this.updateProgress(100, 'ベンチマーク完了');
                this.displayBenchmarkResults(results);
                this.log('ベンチマーク完了', 'success');
                
                return results;
            }
            
            async runPerformanceTest(inputText) {
                const testResults = {
                    inputText: inputText,
                    totalTime: 0,
                    initTime: 0,
                    analysisTime: 0,
                    mappingTime: 0,
                    memoryUsage: {},
                    cpuMetrics: {},
                    errors: [],
                    success: false
                };
                
                const overallStart = performance.now();
                
                try {
                    // メモリとCPUモニタリング開始
                    this.startMemoryMonitoring();
                    this.startCPUMonitoring();
                    
                    // 1. エンジン初期化テスト
                    const initStart = performance.now();
                    await this.testEngineInitialization();
                    testResults.initTime = performance.now() - initStart;
                    
                    // 2. 状況分析テスト
                    const analysisStart = performance.now();
                    const situationalResult = await this.testSituationalAnalysis(inputText);
                    testResults.analysisTime = performance.now() - analysisStart;
                    
                    // 3. 易経マッピングテスト
                    const mappingStart = performance.now();
                    const mappingResult = await this.testHexagramMapping(situationalResult);
                    testResults.mappingTime = performance.now() - mappingStart;
                    
                    testResults.success = true;
                    
                } catch (error) {
                    this.log(`テストエラー: ${error.message}`, 'error');
                    testResults.errors.push({
                        message: error.message,
                        stack: error.stack,
                        timestamp: Date.now()
                    });
                } finally {
                    // モニタリング停止
                    this.stopMemoryMonitoring();
                    this.stopCPUMonitoring();
                    
                    testResults.totalTime = performance.now() - overallStart;
                    testResults.memoryUsage = { ...this.metrics.memoryUsage };
                    testResults.cpuMetrics = {
                        average: this.metrics.cpuUsage.length > 0 ? 
                            this.metrics.cpuUsage.reduce((a, b) => a + b, 0) / this.metrics.cpuUsage.length : 0,
                        peak: Math.max(...this.metrics.cpuUsage, 0),
                        samples: this.metrics.cpuUsage.length
                    };
                    
                    // メトリクスリセット
                    this.metrics.cpuUsage = [];
                }
                
                return testResults;
            }
            
            async testEngineInitialization() {
                this.log('エンジン初期化テスト開始', 'info');
                
                // AuthenticIChingEngine
                if (typeof AuthenticIChingEngine !== 'undefined') {
                    const authenticEngine = new AuthenticIChingEngine();
                    this.log('AuthenticIChingEngine初期化完了', 'success');
                } else {
                    throw new Error('AuthenticIChingEngine が見つかりません');
                }
                
                // SituationalContextEngine
                if (typeof SituationalContextEngine !== 'undefined') {
                    const situationalEngine = new SituationalContextEngine();
                    this.log('SituationalContextEngine初期化完了', 'success');
                } else {
                    throw new Error('SituationalContextEngine が見つかりません');
                }
                
                // HexagramMappingEngine
                if (typeof HexagramMappingEngine !== 'undefined') {
                    const mappingEngine = new HexagramMappingEngine();
                    await mappingEngine.initialize();
                    this.log('HexagramMappingEngine初期化完了', 'success');
                } else {
                    throw new Error('HexagramMappingEngine が見つかりません');
                }
            }
            
            async testSituationalAnalysis(inputText) {
                this.log('状況分析テスト開始', 'info');
                
                const situationalEngine = new SituationalContextEngine();
                const result = await situationalEngine.analyzeSituationalContext(inputText);
                
                if (result.confidence > 0.4) {
                    this.log(`状況分析完了: 信頼度 ${(result.confidence * 100).toFixed(1)}%`, 'success');
                } else {
                    this.log(`状況分析低信頼度: ${(result.confidence * 100).toFixed(1)}%`, 'warning');
                }
                
                return result;
            }
            
            async testHexagramMapping(situationalResult) {
                this.log('易経マッピングテスト開始', 'info');
                
                const mappingEngine = new HexagramMappingEngine();
                const result = await mappingEngine.mapSituationToHexagram(situationalResult);
                
                if (result.mappingConfidence > 0.7) {
                    this.log(`易経マッピング完了: 信頼度 ${(result.mappingConfidence * 100).toFixed(1)}%`, 'success');
                } else {
                    this.log(`易経マッピング低信頼度: ${(result.mappingConfidence * 100).toFixed(1)}%`, 'warning');
                }
                
                return result;
            }
            
            displayResults(results) {
                this.updateMetricsGrid(results);
                this.updateDetailedAnalysis(results);
                this.updateBottleneckAnalysis(results);
                this.updateOptimizationSuggestions(results);
            }
            
            displayComprehensiveResults(resultsList) {
                const avgResults = this.calculateAverageResults(resultsList);
                this.updateMetricsGrid(avgResults);
                this.updateComprehensiveAnalysis(resultsList);
                this.updateBottleneckAnalysis(avgResults);
                this.updateOptimizationSuggestions(avgResults);
            }
            
            displayBenchmarkResults(resultsList) {
                const benchmarkResults = this.calculateBenchmarkStats(resultsList);
                this.updateMetricsGrid(benchmarkResults);
                this.updateBenchmarkAnalysis(resultsList);
                this.updateBottleneckAnalysis(benchmarkResults);
                this.updateOptimizationSuggestions(benchmarkResults);
            }
            
            updateMetricsGrid(results) {
                const metricsGrid = document.getElementById('metricsGrid');
                metricsGrid.innerHTML = '';
                
                const metrics = [
                    {
                        label: '総合処理時間',
                        value: `${results.totalTime.toFixed(0)}ms`,
                        target: this.performanceTargets.totalProcessingTime,
                        current: results.totalTime
                    },
                    {
                        label: '初期化時間',
                        value: `${results.initTime.toFixed(0)}ms`,
                        target: this.performanceTargets.initializationTime,
                        current: results.initTime
                    },
                    {
                        label: '分析時間',
                        value: `${results.analysisTime.toFixed(0)}ms`,
                        target: 2000,
                        current: results.analysisTime
                    },
                    {
                        label: 'マッピング時間',
                        value: `${results.mappingTime.toFixed(0)}ms`,
                        target: 1000,
                        current: results.mappingTime
                    },
                    {
                        label: 'メモリ使用量',
                        value: this.formatMemorySize(results.memoryUsage.peak),
                        target: this.performanceTargets.memoryUsage,
                        current: results.memoryUsage.peak
                    },
                    {
                        label: 'CPU使用率ピーク',
                        value: `${results.cpuMetrics.peak.toFixed(1)}%`,
                        target: this.performanceTargets.cpuUsagePeak,
                        current: results.cpuMetrics.peak
                    }
                ];
                
                metrics.forEach(metric => {
                    const card = this.createMetricCard(metric);
                    metricsGrid.appendChild(card);
                });
            }
            
            createMetricCard(metric) {
                const card = document.createElement('div');
                card.className = 'metric-card';
                
                const status = this.getPerformanceStatus(metric.current, metric.target);
                const statusClass = this.getStatusClass(status);
                
                card.innerHTML = `
                    <div class="metric-value">${metric.value}</div>
                    <div class="metric-label">${metric.label}</div>
                    <div class="metric-status ${statusClass}">${status}</div>
                `;
                
                return card;
            }
            
            getPerformanceStatus(current, target) {
                const ratio = current / target;
                if (ratio <= 0.5) return '優秀';
                if (ratio <= 0.8) return '良好';
                if (ratio <= 1.0) return '許容範囲';
                return '改善必要';
            }
            
            getStatusClass(status) {
                switch (status) {
                    case '優秀': return 'status-excellent';
                    case '良好': return 'status-good';
                    case '許容範囲': return 'status-warning';
                    case '改善必要': return 'status-danger';
                    default: return 'status-warning';
                }
            }
            
            formatMemorySize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            updateDetailedAnalysis(results) {
                const container = document.getElementById('detailedAnalysis');
                
                const table = document.createElement('table');
                table.className = 'result-table';
                
                const rows = [
                    ['総合処理時間', `${results.totalTime.toFixed(2)}ms`],
                    ['初期化時間', `${results.initTime.toFixed(2)}ms`],
                    ['状況分析時間', `${results.analysisTime.toFixed(2)}ms`],
                    ['易経マッピング時間', `${results.mappingTime.toFixed(2)}ms`],
                    ['初期メモリ使用量', this.formatMemorySize(results.memoryUsage.initial)],
                    ['ピークメモリ使用量', this.formatMemorySize(results.memoryUsage.peak)],
                    ['最終メモリ使用量', this.formatMemorySize(results.memoryUsage.final)],
                    ['平均CPU使用率', `${results.cpuMetrics.average.toFixed(1)}%`],
                    ['ピークCPU使用率', `${results.cpuMetrics.peak.toFixed(1)}%`],
                    ['CPUサンプル数', `${results.cpuMetrics.samples}回`],
                    ['エラー数', `${results.errors.length}件`],
                    ['実行成功', results.success ? '✅ 成功' : '❌ 失敗']
                ];
                
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>項目</th>
                            <th>値</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `<tr><td>${row[0]}</td><td>${row[1]}</td></tr>`).join('')}
                    </tbody>
                `;
                
                container.innerHTML = '';
                container.appendChild(table);
            }
            
            updateBottleneckAnalysis(results) {
                const container = document.getElementById('bottleneckAnalysis');
                const bottlenecks = this.identifyBottlenecks(results);
                
                if (bottlenecks.length === 0) {
                    container.innerHTML = '<p class="status-excellent">ボトルネックは検出されませんでした。</p>';
                    return;
                }
                
                const list = document.createElement('ul');
                bottlenecks.forEach(bottleneck => {
                    const item = document.createElement('li');
                    item.innerHTML = `
                        <strong>${bottleneck.component}</strong>: ${bottleneck.issue}
                        <br><small>影響度: ${bottleneck.impact}</small>
                    `;
                    list.appendChild(item);
                });
                
                container.innerHTML = '<h4>検出されたボトルネック:</h4>';
                container.appendChild(list);
            }
            
            identifyBottlenecks(results) {
                const bottlenecks = [];
                
                // 処理時間ボトルネック
                if (results.totalTime > this.performanceTargets.totalProcessingTime) {
                    bottlenecks.push({
                        component: '総合処理時間',
                        issue: `目標値${this.performanceTargets.totalProcessingTime}msを超過`,
                        impact: '高'
                    });
                }
                
                // メモリ使用量ボトルネック
                if (results.memoryUsage.peak > this.performanceTargets.memoryUsage) {
                    bottlenecks.push({
                        component: 'メモリ使用量',
                        issue: `目標値${this.formatMemorySize(this.performanceTargets.memoryUsage)}を超過`,
                        impact: '中'
                    });
                }
                
                // CPU使用率ボトルネック
                if (results.cpuMetrics.peak > this.performanceTargets.cpuUsagePeak) {
                    bottlenecks.push({
                        component: 'CPU使用率',
                        issue: `目標値${this.performanceTargets.cpuUsagePeak}%を超過`,
                        impact: '中'
                    });
                }
                
                // エラーボトルネック
                if (results.errors.length > 0) {
                    bottlenecks.push({
                        component: 'エラー処理',
                        issue: `${results.errors.length}件のエラーが発生`,
                        impact: '高'
                    });
                }
                
                return bottlenecks;
            }
            
            updateOptimizationSuggestions(results) {
                const container = document.getElementById('optimizationSuggestions');
                const suggestions = this.generateOptimizationSuggestions(results);
                
                if (suggestions.length === 0) {
                    container.innerHTML = '<p class="status-excellent">現在のパフォーマンスは最適化されています。</p>';
                    return;
                }
                
                const list = document.createElement('ul');
                suggestions.forEach(suggestion => {
                    const item = document.createElement('li');
                    item.innerHTML = `
                        <strong>${suggestion.category}</strong>: ${suggestion.suggestion}
                        <br><small>期待効果: ${suggestion.expectedImpact}</small>
                    `;
                    list.appendChild(item);
                });
                
                container.innerHTML = '<h4>最適化提案:</h4>';
                container.appendChild(list);
            }
            
            generateOptimizationSuggestions(results) {
                const suggestions = [];
                
                // 処理時間最適化
                if (results.totalTime > this.performanceTargets.totalProcessingTime * 0.8) {
                    suggestions.push({
                        category: '処理時間',
                        suggestion: 'エンジンの並列処理化やキャッシュ機能の実装を検討',
                        expectedImpact: '20-30%の処理時間短縮'
                    });
                }
                
                // メモリ最適化
                if (results.memoryUsage.peak > this.performanceTargets.memoryUsage * 0.8) {
                    suggestions.push({
                        category: 'メモリ使用量',
                        suggestion: '不要なオブジェクトの解放やデータ構造の最適化',
                        expectedImpact: '10-20%のメモリ使用量削減'
                    });
                }
                
                // CPU最適化
                if (results.cpuMetrics.peak > this.performanceTargets.cpuUsagePeak * 0.8) {
                    suggestions.push({
                        category: 'CPU使用率',
                        suggestion: 'アルゴリズムの最適化やWeb Workerの活用',
                        expectedImpact: '15-25%のCPU負荷削減'
                    });
                }
                
                // 初期化最適化
                if (results.initTime > this.performanceTargets.initializationTime * 0.8) {
                    suggestions.push({
                        category: '初期化時間',
                        suggestion: '遅延初期化やデータの事前読み込み最適化',
                        expectedImpact: '30-40%の初期化時間短縮'
                    });
                }
                
                return suggestions;
            }
            
            calculateAverageResults(resultsList) {
                const avg = {
                    totalTime: 0,
                    initTime: 0,
                    analysisTime: 0,
                    mappingTime: 0,
                    memoryUsage: { initial: 0, peak: 0, final: 0 },
                    cpuMetrics: { average: 0, peak: 0, samples: 0 },
                    errors: [],
                    success: true
                };
                
                resultsList.forEach(result => {
                    avg.totalTime += result.totalTime;
                    avg.initTime += result.initTime;
                    avg.analysisTime += result.analysisTime;
                    avg.mappingTime += result.mappingTime;
                    avg.memoryUsage.initial += result.memoryUsage.initial;
                    avg.memoryUsage.peak += result.memoryUsage.peak;
                    avg.memoryUsage.final += result.memoryUsage.final;
                    avg.cpuMetrics.average += result.cpuMetrics.average;
                    avg.cpuMetrics.peak += result.cpuMetrics.peak;
                    avg.cpuMetrics.samples += result.cpuMetrics.samples;
                    avg.errors = avg.errors.concat(result.errors);
                    avg.success = avg.success && result.success;
                });
                
                const count = resultsList.length;
                avg.totalTime /= count;
                avg.initTime /= count;
                avg.analysisTime /= count;
                avg.mappingTime /= count;
                avg.memoryUsage.initial /= count;
                avg.memoryUsage.peak /= count;
                avg.memoryUsage.final /= count;
                avg.cpuMetrics.average /= count;
                avg.cpuMetrics.peak /= count;
                
                return avg;
            }
            
            calculateBenchmarkStats(resultsList) {
                const times = resultsList.map(r => r.totalTime);
                const memoryPeaks = resultsList.map(r => r.memoryUsage.peak);
                const cpuPeaks = resultsList.map(r => r.cpuMetrics.peak);
                
                return {
                    totalTime: this.calculateStats(times),
                    initTime: this.calculateStats(resultsList.map(r => r.initTime)),
                    analysisTime: this.calculateStats(resultsList.map(r => r.analysisTime)),
                    mappingTime: this.calculateStats(resultsList.map(r => r.mappingTime)),
                    memoryUsage: { 
                        initial: Math.min(...resultsList.map(r => r.memoryUsage.initial)),
                        peak: Math.max(...memoryPeaks),
                        final: Math.max(...resultsList.map(r => r.memoryUsage.final))
                    },
                    cpuMetrics: {
                        average: this.calculateStats(resultsList.map(r => r.cpuMetrics.average)),
                        peak: Math.max(...cpuPeaks),
                        samples: Math.max(...resultsList.map(r => r.cpuMetrics.samples))
                    },
                    errors: [].concat(...resultsList.map(r => r.errors)),
                    success: resultsList.every(r => r.success)
                };
            }
            
            calculateStats(values) {
                const sorted = values.sort((a, b) => a - b);
                return {
                    min: sorted[0],
                    max: sorted[sorted.length - 1],
                    avg: values.reduce((a, b) => a + b, 0) / values.length,
                    median: sorted[Math.floor(sorted.length / 2)],
                    std: this.calculateStandardDeviation(values)
                };
            }
            
            calculateStandardDeviation(values) {
                const avg = values.reduce((a, b) => a + b, 0) / values.length;
                const squareDiffs = values.map(value => Math.pow(value - avg, 2));
                const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / values.length;
                return Math.sqrt(avgSquareDiff);
            }
            
            updateComprehensiveAnalysis(resultsList) {
                const container = document.getElementById('detailedAnalysis');
                
                const scenarioTable = document.createElement('table');
                scenarioTable.className = 'result-table';
                
                const headers = ['シナリオ', '総合時間', 'メモリピーク', 'CPU平均', '成功'];
                const rows = resultsList.map(result => [
                    result.scenario,
                    `${result.totalTime.toFixed(0)}ms`,
                    this.formatMemorySize(result.memoryUsage.peak),
                    `${result.cpuMetrics.average.toFixed(1)}%`,
                    result.success ? '✅' : '❌'
                ]);
                
                scenarioTable.innerHTML = `
                    <thead>
                        <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}
                    </tbody>
                `;
                
                container.innerHTML = '<h4>シナリオ別結果:</h4>';
                container.appendChild(scenarioTable);
            }
            
            updateBenchmarkAnalysis(resultsList) {
                const container = document.getElementById('detailedAnalysis');
                
                const benchmarkTable = document.createElement('table');
                benchmarkTable.className = 'result-table';
                
                const headers = ['実行回', '総合時間', 'メモリピーク', 'CPU平均', '成功'];
                const rows = resultsList.map(result => [
                    `#${result.iteration}`,
                    `${result.totalTime.toFixed(0)}ms`,
                    this.formatMemorySize(result.memoryUsage.peak),
                    `${result.cpuMetrics.average.toFixed(1)}%`,
                    result.success ? '✅' : '❌'
                ]);
                
                benchmarkTable.innerHTML = `
                    <thead>
                        <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}
                    </tbody>
                `;
                
                const stats = this.calculateBenchmarkStats(resultsList);
                const statsInfo = document.createElement('div');
                statsInfo.innerHTML = `
                    <h4>統計情報:</h4>
                    <p><strong>平均実行時間:</strong> ${stats.totalTime.avg.toFixed(2)}ms (標準偏差: ${stats.totalTime.std.toFixed(2)}ms)</p>
                    <p><strong>最短実行時間:</strong> ${stats.totalTime.min.toFixed(2)}ms</p>
                    <p><strong>最長実行時間:</strong> ${stats.totalTime.max.toFixed(2)}ms</p>
                    <p><strong>中央値:</strong> ${stats.totalTime.median.toFixed(2)}ms</p>
                `;
                
                container.innerHTML = '<h4>ベンチマーク結果:</h4>';
                container.appendChild(benchmarkTable);
                container.appendChild(statsInfo);
            }
            
            clearResults() {
                document.getElementById('metricsGrid').innerHTML = '';
                document.getElementById('detailedAnalysis').innerHTML = '<p>測定結果がありません。テストを実行してください。</p>';
                document.getElementById('bottleneckAnalysis').innerHTML = '<p>分析結果がありません。</p>';
                document.getElementById('optimizationSuggestions').innerHTML = '<p>提案がありません。</p>';
                document.getElementById('logContainer').innerHTML = '';
                
                this.log('結果をクリアしました', 'info');
            }
        }
        
        // グローバルインスタンス
        const performanceAnalyzer = new PerformanceAnalyzer();
        
        // 必要なスクリプトファイルを動的に読み込み
        async function loadRequiredScripts() {
            const scripts = [
                '/public/js/core/AuthenticIChingEngine.js',
                '/public/js/pages/future-simulator/SituationalContextEngine.js',
                '/public/js/pages/future-simulator/HexagramMappingEngine.js'
            ];
            
            for (const script of scripts) {
                try {
                    await loadScript(script);
                    performanceAnalyzer.log(`スクリプト読み込み完了: ${script}`, 'success');
                } catch (error) {
                    performanceAnalyzer.log(`スクリプト読み込み失敗: ${script} - ${error.message}`, 'error');
                }
            }
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        // ボタンイベントハンドラ
        async function runSingleTest() {
            await performanceAnalyzer.runSingleTest();
        }
        
        async function runComprehensiveTest() {
            await performanceAnalyzer.runComprehensiveTest();
        }
        
        async function runBenchmark() {
            await performanceAnalyzer.runBenchmark();
        }
        
        function clearResults() {
            performanceAnalyzer.clearResults();
        }
        
        // ページ読み込み時の初期化
        window.addEventListener('load', async () => {
            performanceAnalyzer.log('パフォーマンス測定システム初期化開始', 'info');
            
            try {
                await loadRequiredScripts();
                performanceAnalyzer.log('システム初期化完了', 'success');
            } catch (error) {
                performanceAnalyzer.log(`初期化エラー: ${error.message}`, 'error');
            }
        });
    </script>
</body>
</html>