<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAQEI Future Simulator ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .test-controls {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .test-scenarios {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .scenario-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
        }
        
        .scenario-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .scenario-card h3 {
            color: #495057;
            margin-bottom: 10px;
        }
        
        .scenario-text {
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.6;
            border-left: 4px solid #667eea;
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .results-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .results-header {
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 15px;
            margin-bottom: 25px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid #667eea;
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        .metric-status {
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .status-excellent {
            background: #d4edda;
            color: #155724;
        }
        
        .status-good {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status-warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .status-danger {
            background: #f8d7da;
            color: #721c24;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #6c757d;
        }
        
        .detailed-results {
            margin-top: 30px;
        }
        
        .result-section {
            margin-bottom: 25px;
        }
        
        .result-section h3 {
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .result-table th,
        .result-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }
        
        .result-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }
        
        .log-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-info {
            color: #0c5460;
            background: #d1ecf1;
        }
        
        .log-success {
            color: #155724;
            background: #d4edda;
        }
        
        .log-warning {
            color: #856404;
            background: #fff3cd;
        }
        
        .log-error {
            color: #721c24;
            background: #f8d7da;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .control-buttons {
                flex-direction: column;
            }
            
            .metric-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ HAQEI Future Simulator</h1>
            <p>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šãƒ»ãƒœãƒˆãƒ«ãƒãƒƒã‚¯åˆ†æã‚·ã‚¹ãƒ†ãƒ </p>
        </div>
        
        <div class="test-controls">
            <div class="test-scenarios">
                <div class="scenario-card">
                    <h3>ğŸŸ¢ è»½é‡ãƒ†ã‚¹ãƒˆ</h3>
                    <div class="scenario-text">ã€Œä»•äº‹ã®æ‚©ã¿ãŒã‚ã‚‹ã€</div>
                </div>
                
                <div class="scenario-card">
                    <h3>ğŸŸ¡ ä¸­é‡ãƒ†ã‚¹ãƒˆ</h3>
                    <div class="scenario-text">ã€Œæ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒå§‹ã¾ã£ãŸãŒã€ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¨ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã†ã¾ãã„ã‹ãªã„ã€‚æŠ€è¡“çš„ãªèª²é¡Œã‚‚å¤šãã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å³ã—ã„ã€‚ã©ã®ã‚ˆã†ã«é€²ã‚ã‚‹ã¹ãã‹æ‚©ã‚“ã§ã„ã‚‹ã€‚ã€</div>
                </div>
                
                <div class="scenario-card">
                    <h3>ğŸ”´ é‡é‡ãƒ†ã‚¹ãƒˆ</h3>
                    <div class="scenario-text">ã€Œäººç”Ÿã®è»¢æ©Ÿã«ç«‹ã£ã¦ã„ã‚‹ã€‚ç¾åœ¨ã®è·å ´ã§ã¯10å¹´åƒã„ã¦ã„ã‚‹ãŒã€æœ€è¿‘ã‚„ã‚ŠãŒã„ã‚’æ„Ÿã˜ãªããªã£ã¦ããŸã€‚å®¶æ—ã‚’é¤Šã†è²¬ä»»ã‚‚ã‚ã‚Šã€è»¢è·ã«ã¯å¤§ããªãƒªã‚¹ã‚¯ãŒä¼´ã†ã€‚ã—ã‹ã—ã€ã“ã®ã¾ã¾ã§ã¯è‡ªåˆ†ã®æˆé•·ãŒæ­¢ã¾ã£ã¦ã—ã¾ã†æ°—ãŒã™ã‚‹ã€‚æ–°ã—ã„åˆ†é‡ã«æŒ‘æˆ¦ã—ãŸã„æ°—æŒã¡ã¨ã€å®‰å®šã‚’æ±‚ã‚ã‚‹æ°—æŒã¡ã§è‘›è—¤ã—ã¦ã„ã‚‹ã€‚å¹´é½¢çš„ã«ã‚‚æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã©ã®ã‚ˆã†ãªé¸æŠã‚’ã™ã¹ãã‹ã€æ·±ãæ‚©ã‚“ã§ã„ã‚‹ã€‚ã€</div>
                </div>
            </div>
            
            <div class="control-buttons">
                <button class="btn btn-primary" onclick="runSingleTest()">å˜ä½“ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="btn btn-success" onclick="runComprehensiveTest()">åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                <button class="btn btn-secondary" onclick="runBenchmark()">ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ</button>
                <button class="btn btn-secondary" onclick="clearResults()">çµæœã‚¯ãƒªã‚¢</button>
            </div>
            
            <div class="progress-container hidden" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">ãƒ†ã‚¹ãƒˆæº–å‚™ä¸­...</div>
            </div>
        </div>
        
        <div class="results-container">
            <div class="results-header">
                <h2>ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šçµæœ</h2>
                <p>ã‚·ã‚¹ãƒ†ãƒ çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æãƒ¬ãƒãƒ¼ãƒˆ</p>
            </div>
            
            <div class="metric-grid" id="metricsGrid">
                <!-- ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚«ãƒ¼ãƒ‰ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
            
            <div class="detailed-results">
                <div class="result-section">
                    <h3>ğŸ” è©³ç´°ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ</h3>
                    <div id="detailedAnalysis"></div>
                </div>
                
                <div class="result-section">
                    <h3>âš¡ ãƒœãƒˆãƒ«ãƒãƒƒã‚¯åˆ†æ</h3>
                    <div id="bottleneckAnalysis"></div>
                </div>
                
                <div class="result-section">
                    <h3>ğŸ’¡ æœ€é©åŒ–ææ¡ˆ</h3>
                    <div id="optimizationSuggestions"></div>
                </div>
                
                <div class="result-section">
                    <h3>ğŸ“ å®Ÿè¡Œãƒ­ã‚°</h3>
                    <div class="log-container" id="logContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã‚·ã‚¹ãƒ†ãƒ 
        class PerformanceAnalyzer {
            constructor() {
                this.metrics = {
                    totalProcessingTime: 0,
                    initializationTime: 0,
                    analysisTime: 0,
                    mappingTime: 0,
                    renderTime: 0,
                    memoryUsage: { initial: 0, peak: 0, final: 0 },
                    cpuUsage: [],
                    networkRequests: [],
                    errors: []
                };
                
                this.testScenarios = {
                    light: "ä»•äº‹ã®æ‚©ã¿ãŒã‚ã‚‹",
                    medium: "æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒå§‹ã¾ã£ãŸãŒã€ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã¨ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒã†ã¾ãã„ã‹ãªã„ã€‚æŠ€è¡“çš„ãªèª²é¡Œã‚‚å¤šãã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚å³ã—ã„ã€‚ã©ã®ã‚ˆã†ã«é€²ã‚ã‚‹ã¹ãã‹æ‚©ã‚“ã§ã„ã‚‹ã€‚",
                    heavy: "äººç”Ÿã®è»¢æ©Ÿã«ç«‹ã£ã¦ã„ã‚‹ã€‚ç¾åœ¨ã®è·å ´ã§ã¯10å¹´åƒã„ã¦ã„ã‚‹ãŒã€æœ€è¿‘ã‚„ã‚ŠãŒã„ã‚’æ„Ÿã˜ãªããªã£ã¦ããŸã€‚å®¶æ—ã‚’é¤Šã†è²¬ä»»ã‚‚ã‚ã‚Šã€è»¢è·ã«ã¯å¤§ããªãƒªã‚¹ã‚¯ãŒä¼´ã†ã€‚ã—ã‹ã—ã€ã“ã®ã¾ã¾ã§ã¯è‡ªåˆ†ã®æˆé•·ãŒæ­¢ã¾ã£ã¦ã—ã¾ã†æ°—ãŒã™ã‚‹ã€‚æ–°ã—ã„åˆ†é‡ã«æŒ‘æˆ¦ã—ãŸã„æ°—æŒã¡ã¨ã€å®‰å®šã‚’æ±‚ã‚ã‚‹æ°—æŒã¡ã§è‘›è—¤ã—ã¦ã„ã‚‹ã€‚å¹´é½¢çš„ã«ã‚‚æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¹ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã©ã®ã‚ˆã†ãªé¸æŠã‚’ã™ã¹ãã‹ã€æ·±ãæ‚©ã‚“ã§ã„ã‚‹ã€‚"
                };
                
                this.performanceTargets = {
                    totalProcessingTime: 3000, // 3ç§’ä»¥å†…
                    initializationTime: 1000,  // 1ç§’ä»¥å†…
                    memoryUsage: 50 * 1024 * 1024, // 50MBä»¥å†…
                    cpuUsagePeak: 80 // 80%ä»¥å†…
                };
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
            
            updateProgress(percentage, text) {
                const progressContainer = document.getElementById('progressContainer');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                progressContainer.classList.remove('hidden');
                progressFill.style.width = `${percentage}%`;
                progressText.textContent = text;
                
                if (percentage >= 100) {
                    setTimeout(() => {
                        progressContainer.classList.add('hidden');
                    }, 1000);
                }
            }
            
            startMemoryMonitoring() {
                this.metrics.memoryUsage.initial = this.getCurrentMemoryUsage();
                this.memoryMonitorInterval = setInterval(() => {
                    const current = this.getCurrentMemoryUsage();
                    if (current > this.metrics.memoryUsage.peak) {
                        this.metrics.memoryUsage.peak = current;
                    }
                }, 100);
            }
            
            stopMemoryMonitoring() {
                if (this.memoryMonitorInterval) {
                    clearInterval(this.memoryMonitorInterval);
                }
                this.metrics.memoryUsage.final = this.getCurrentMemoryUsage();
            }
            
            getCurrentMemoryUsage() {
                if (performance.memory) {
                    return performance.memory.usedJSHeapSize;
                }
                return 0;
            }
            
            startCPUMonitoring() {
                this.cpuMonitorInterval = setInterval(() => {
                    // CPUãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã®ç°¡æ˜“å®Ÿè£…
                    const cpuUsage = this.estimateCPUUsage();
                    this.metrics.cpuUsage.push(cpuUsage);
                }, 100);
            }
            
            stopCPUMonitoring() {
                if (this.cpuMonitorInterval) {
                    clearInterval(this.cpuMonitorInterval);
                }
            }
            
            estimateCPUUsage() {
                // ç°¡æ˜“çš„ãªCPUä½¿ç”¨ç‡æ¨å®š
                const start = performance.now();
                for (let i = 0; i < 10000; i++) {
                    Math.random();
                }
                const end = performance.now();
                return Math.min((end - start) * 10, 100);
            }
            
            async runSingleTest(scenario = 'medium') {
                this.log('å˜ä½“ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                this.updateProgress(10, 'ãƒ†ã‚¹ãƒˆåˆæœŸåŒ–ä¸­...');
                
                const testText = this.testScenarios[scenario];
                const results = await this.runPerformanceTest(testText);
                
                this.updateProgress(100, 'ãƒ†ã‚¹ãƒˆå®Œäº†');
                this.displayResults(results);
                this.log('å˜ä½“ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
                return results;
            }
            
            async runComprehensiveTest() {
                this.log('åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                this.updateProgress(5, 'åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆæº–å‚™ä¸­...');
                
                const results = [];
                const scenarios = ['light', 'medium', 'heavy'];
                
                for (let i = 0; i < scenarios.length; i++) {
                    const scenario = scenarios[i];
                    this.updateProgress(20 + (i * 25), `${scenario}ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...`);
                    
                    const testResult = await this.runPerformanceTest(this.testScenarios[scenario]);
                    testResult.scenario = scenario;
                    results.push(testResult);
                    
                    this.log(`${scenario}ãƒ†ã‚¹ãƒˆå®Œäº†: ${testResult.totalTime}ms`, 'success');
                }
                
                this.updateProgress(100, 'åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆå®Œäº†');
                this.displayComprehensiveResults(results);
                this.log('åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
                return results;
            }
            
            async runBenchmark() {
                this.log('ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹', 'info');
                this.updateProgress(10, 'ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æº–å‚™ä¸­...');
                
                const iterations = 5;
                const results = [];
                
                for (let i = 0; i < iterations; i++) {
                    this.updateProgress(20 + (i * 15), `ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ ${i + 1}/${iterations}`);
                    
                    const result = await this.runPerformanceTest(this.testScenarios.medium);
                    result.iteration = i + 1;
                    results.push(result);
                    
                    // çŸ­ã„ä¼‘æ†©
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                this.updateProgress(100, 'ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Œäº†');
                this.displayBenchmarkResults(results);
                this.log('ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Œäº†', 'success');
                
                return results;
            }
            
            async runPerformanceTest(inputText) {
                const testResults = {
                    inputText: inputText,
                    totalTime: 0,
                    initTime: 0,
                    analysisTime: 0,
                    mappingTime: 0,
                    memoryUsage: {},
                    cpuMetrics: {},
                    errors: [],
                    success: false
                };
                
                const overallStart = performance.now();
                
                try {
                    // ãƒ¡ãƒ¢ãƒªã¨CPUãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹
                    this.startMemoryMonitoring();
                    this.startCPUMonitoring();
                    
                    // 1. ã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ
                    const initStart = performance.now();
                    await this.testEngineInitialization();
                    testResults.initTime = performance.now() - initStart;
                    
                    // 2. çŠ¶æ³åˆ†æãƒ†ã‚¹ãƒˆ
                    const analysisStart = performance.now();
                    const situationalResult = await this.testSituationalAnalysis(inputText);
                    testResults.analysisTime = performance.now() - analysisStart;
                    
                    // 3. æ˜“çµŒãƒãƒƒãƒ”ãƒ³ã‚°ãƒ†ã‚¹ãƒˆ
                    const mappingStart = performance.now();
                    const mappingResult = await this.testHexagramMapping(situationalResult);
                    testResults.mappingTime = performance.now() - mappingStart;
                    
                    testResults.success = true;
                    
                } catch (error) {
                    this.log(`ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    testResults.errors.push({
                        message: error.message,
                        stack: error.stack,
                        timestamp: Date.now()
                    });
                } finally {
                    // ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°åœæ­¢
                    this.stopMemoryMonitoring();
                    this.stopCPUMonitoring();
                    
                    testResults.totalTime = performance.now() - overallStart;
                    testResults.memoryUsage = { ...this.metrics.memoryUsage };
                    testResults.cpuMetrics = {
                        average: this.metrics.cpuUsage.length > 0 ? 
                            this.metrics.cpuUsage.reduce((a, b) => a + b, 0) / this.metrics.cpuUsage.length : 0,
                        peak: Math.max(...this.metrics.cpuUsage, 0),
                        samples: this.metrics.cpuUsage.length
                    };
                    
                    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒªã‚»ãƒƒãƒˆ
                    this.metrics.cpuUsage = [];
                }
                
                return testResults;
            }
            
            async testEngineInitialization() {
                this.log('ã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                // AuthenticIChingEngine
                if (typeof AuthenticIChingEngine !== 'undefined') {
                    const authenticEngine = new AuthenticIChingEngine();
                    this.log('AuthenticIChingEngineåˆæœŸåŒ–å®Œäº†', 'success');
                } else {
                    throw new Error('AuthenticIChingEngine ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                // SituationalContextEngine
                if (typeof SituationalContextEngine !== 'undefined') {
                    const situationalEngine = new SituationalContextEngine();
                    this.log('SituationalContextEngineåˆæœŸåŒ–å®Œäº†', 'success');
                } else {
                    throw new Error('SituationalContextEngine ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                // HexagramMappingEngine
                if (typeof HexagramMappingEngine !== 'undefined') {
                    const mappingEngine = new HexagramMappingEngine();
                    await mappingEngine.initialize();
                    this.log('HexagramMappingEngineåˆæœŸåŒ–å®Œäº†', 'success');
                } else {
                    throw new Error('HexagramMappingEngine ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
            }
            
            async testSituationalAnalysis(inputText) {
                this.log('çŠ¶æ³åˆ†æãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const situationalEngine = new SituationalContextEngine();
                const result = await situationalEngine.analyzeSituationalContext(inputText);
                
                if (result.confidence > 0.4) {
                    this.log(`çŠ¶æ³åˆ†æå®Œäº†: ä¿¡é ¼åº¦ ${(result.confidence * 100).toFixed(1)}%`, 'success');
                } else {
                    this.log(`çŠ¶æ³åˆ†æä½ä¿¡é ¼åº¦: ${(result.confidence * 100).toFixed(1)}%`, 'warning');
                }
                
                return result;
            }
            
            async testHexagramMapping(situationalResult) {
                this.log('æ˜“çµŒãƒãƒƒãƒ”ãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                
                const mappingEngine = new HexagramMappingEngine();
                const result = await mappingEngine.mapSituationToHexagram(situationalResult);
                
                if (result.mappingConfidence > 0.7) {
                    this.log(`æ˜“çµŒãƒãƒƒãƒ”ãƒ³ã‚°å®Œäº†: ä¿¡é ¼åº¦ ${(result.mappingConfidence * 100).toFixed(1)}%`, 'success');
                } else {
                    this.log(`æ˜“çµŒãƒãƒƒãƒ”ãƒ³ã‚°ä½ä¿¡é ¼åº¦: ${(result.mappingConfidence * 100).toFixed(1)}%`, 'warning');
                }
                
                return result;
            }
            
            displayResults(results) {
                this.updateMetricsGrid(results);
                this.updateDetailedAnalysis(results);
                this.updateBottleneckAnalysis(results);
                this.updateOptimizationSuggestions(results);
            }
            
            displayComprehensiveResults(resultsList) {
                const avgResults = this.calculateAverageResults(resultsList);
                this.updateMetricsGrid(avgResults);
                this.updateComprehensiveAnalysis(resultsList);
                this.updateBottleneckAnalysis(avgResults);
                this.updateOptimizationSuggestions(avgResults);
            }
            
            displayBenchmarkResults(resultsList) {
                const benchmarkResults = this.calculateBenchmarkStats(resultsList);
                this.updateMetricsGrid(benchmarkResults);
                this.updateBenchmarkAnalysis(resultsList);
                this.updateBottleneckAnalysis(benchmarkResults);
                this.updateOptimizationSuggestions(benchmarkResults);
            }
            
            updateMetricsGrid(results) {
                const metricsGrid = document.getElementById('metricsGrid');
                metricsGrid.innerHTML = '';
                
                const metrics = [
                    {
                        label: 'ç·åˆå‡¦ç†æ™‚é–“',
                        value: `${results.totalTime.toFixed(0)}ms`,
                        target: this.performanceTargets.totalProcessingTime,
                        current: results.totalTime
                    },
                    {
                        label: 'åˆæœŸåŒ–æ™‚é–“',
                        value: `${results.initTime.toFixed(0)}ms`,
                        target: this.performanceTargets.initializationTime,
                        current: results.initTime
                    },
                    {
                        label: 'åˆ†ææ™‚é–“',
                        value: `${results.analysisTime.toFixed(0)}ms`,
                        target: 2000,
                        current: results.analysisTime
                    },
                    {
                        label: 'ãƒãƒƒãƒ”ãƒ³ã‚°æ™‚é–“',
                        value: `${results.mappingTime.toFixed(0)}ms`,
                        target: 1000,
                        current: results.mappingTime
                    },
                    {
                        label: 'ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡',
                        value: this.formatMemorySize(results.memoryUsage.peak),
                        target: this.performanceTargets.memoryUsage,
                        current: results.memoryUsage.peak
                    },
                    {
                        label: 'CPUä½¿ç”¨ç‡ãƒ”ãƒ¼ã‚¯',
                        value: `${results.cpuMetrics.peak.toFixed(1)}%`,
                        target: this.performanceTargets.cpuUsagePeak,
                        current: results.cpuMetrics.peak
                    }
                ];
                
                metrics.forEach(metric => {
                    const card = this.createMetricCard(metric);
                    metricsGrid.appendChild(card);
                });
            }
            
            createMetricCard(metric) {
                const card = document.createElement('div');
                card.className = 'metric-card';
                
                const status = this.getPerformanceStatus(metric.current, metric.target);
                const statusClass = this.getStatusClass(status);
                
                card.innerHTML = `
                    <div class="metric-value">${metric.value}</div>
                    <div class="metric-label">${metric.label}</div>
                    <div class="metric-status ${statusClass}">${status}</div>
                `;
                
                return card;
            }
            
            getPerformanceStatus(current, target) {
                const ratio = current / target;
                if (ratio <= 0.5) return 'å„ªç§€';
                if (ratio <= 0.8) return 'è‰¯å¥½';
                if (ratio <= 1.0) return 'è¨±å®¹ç¯„å›²';
                return 'æ”¹å–„å¿…è¦';
            }
            
            getStatusClass(status) {
                switch (status) {
                    case 'å„ªç§€': return 'status-excellent';
                    case 'è‰¯å¥½': return 'status-good';
                    case 'è¨±å®¹ç¯„å›²': return 'status-warning';
                    case 'æ”¹å–„å¿…è¦': return 'status-danger';
                    default: return 'status-warning';
                }
            }
            
            formatMemorySize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            updateDetailedAnalysis(results) {
                const container = document.getElementById('detailedAnalysis');
                
                const table = document.createElement('table');
                table.className = 'result-table';
                
                const rows = [
                    ['ç·åˆå‡¦ç†æ™‚é–“', `${results.totalTime.toFixed(2)}ms`],
                    ['åˆæœŸåŒ–æ™‚é–“', `${results.initTime.toFixed(2)}ms`],
                    ['çŠ¶æ³åˆ†ææ™‚é–“', `${results.analysisTime.toFixed(2)}ms`],
                    ['æ˜“çµŒãƒãƒƒãƒ”ãƒ³ã‚°æ™‚é–“', `${results.mappingTime.toFixed(2)}ms`],
                    ['åˆæœŸãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡', this.formatMemorySize(results.memoryUsage.initial)],
                    ['ãƒ”ãƒ¼ã‚¯ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡', this.formatMemorySize(results.memoryUsage.peak)],
                    ['æœ€çµ‚ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡', this.formatMemorySize(results.memoryUsage.final)],
                    ['å¹³å‡CPUä½¿ç”¨ç‡', `${results.cpuMetrics.average.toFixed(1)}%`],
                    ['ãƒ”ãƒ¼ã‚¯CPUä½¿ç”¨ç‡', `${results.cpuMetrics.peak.toFixed(1)}%`],
                    ['CPUã‚µãƒ³ãƒ—ãƒ«æ•°', `${results.cpuMetrics.samples}å›`],
                    ['ã‚¨ãƒ©ãƒ¼æ•°', `${results.errors.length}ä»¶`],
                    ['å®Ÿè¡ŒæˆåŠŸ', results.success ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—']
                ];
                
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>é …ç›®</th>
                            <th>å€¤</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `<tr><td>${row[0]}</td><td>${row[1]}</td></tr>`).join('')}
                    </tbody>
                `;
                
                container.innerHTML = '';
                container.appendChild(table);
            }
            
            updateBottleneckAnalysis(results) {
                const container = document.getElementById('bottleneckAnalysis');
                const bottlenecks = this.identifyBottlenecks(results);
                
                if (bottlenecks.length === 0) {
                    container.innerHTML = '<p class="status-excellent">ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚</p>';
                    return;
                }
                
                const list = document.createElement('ul');
                bottlenecks.forEach(bottleneck => {
                    const item = document.createElement('li');
                    item.innerHTML = `
                        <strong>${bottleneck.component}</strong>: ${bottleneck.issue}
                        <br><small>å½±éŸ¿åº¦: ${bottleneck.impact}</small>
                    `;
                    list.appendChild(item);
                });
                
                container.innerHTML = '<h4>æ¤œå‡ºã•ã‚ŒãŸãƒœãƒˆãƒ«ãƒãƒƒã‚¯:</h4>';
                container.appendChild(list);
            }
            
            identifyBottlenecks(results) {
                const bottlenecks = [];
                
                // å‡¦ç†æ™‚é–“ãƒœãƒˆãƒ«ãƒãƒƒã‚¯
                if (results.totalTime > this.performanceTargets.totalProcessingTime) {
                    bottlenecks.push({
                        component: 'ç·åˆå‡¦ç†æ™‚é–“',
                        issue: `ç›®æ¨™å€¤${this.performanceTargets.totalProcessingTime}msã‚’è¶…é`,
                        impact: 'é«˜'
                    });
                }
                
                // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒœãƒˆãƒ«ãƒãƒƒã‚¯
                if (results.memoryUsage.peak > this.performanceTargets.memoryUsage) {
                    bottlenecks.push({
                        component: 'ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡',
                        issue: `ç›®æ¨™å€¤${this.formatMemorySize(this.performanceTargets.memoryUsage)}ã‚’è¶…é`,
                        impact: 'ä¸­'
                    });
                }
                
                // CPUä½¿ç”¨ç‡ãƒœãƒˆãƒ«ãƒãƒƒã‚¯
                if (results.cpuMetrics.peak > this.performanceTargets.cpuUsagePeak) {
                    bottlenecks.push({
                        component: 'CPUä½¿ç”¨ç‡',
                        issue: `ç›®æ¨™å€¤${this.performanceTargets.cpuUsagePeak}%ã‚’è¶…é`,
                        impact: 'ä¸­'
                    });
                }
                
                // ã‚¨ãƒ©ãƒ¼ãƒœãƒˆãƒ«ãƒãƒƒã‚¯
                if (results.errors.length > 0) {
                    bottlenecks.push({
                        component: 'ã‚¨ãƒ©ãƒ¼å‡¦ç†',
                        issue: `${results.errors.length}ä»¶ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ`,
                        impact: 'é«˜'
                    });
                }
                
                return bottlenecks;
            }
            
            updateOptimizationSuggestions(results) {
                const container = document.getElementById('optimizationSuggestions');
                const suggestions = this.generateOptimizationSuggestions(results);
                
                if (suggestions.length === 0) {
                    container.innerHTML = '<p class="status-excellent">ç¾åœ¨ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯æœ€é©åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>';
                    return;
                }
                
                const list = document.createElement('ul');
                suggestions.forEach(suggestion => {
                    const item = document.createElement('li');
                    item.innerHTML = `
                        <strong>${suggestion.category}</strong>: ${suggestion.suggestion}
                        <br><small>æœŸå¾…åŠ¹æœ: ${suggestion.expectedImpact}</small>
                    `;
                    list.appendChild(item);
                });
                
                container.innerHTML = '<h4>æœ€é©åŒ–ææ¡ˆ:</h4>';
                container.appendChild(list);
            }
            
            generateOptimizationSuggestions(results) {
                const suggestions = [];
                
                // å‡¦ç†æ™‚é–“æœ€é©åŒ–
                if (results.totalTime > this.performanceTargets.totalProcessingTime * 0.8) {
                    suggestions.push({
                        category: 'å‡¦ç†æ™‚é–“',
                        suggestion: 'ã‚¨ãƒ³ã‚¸ãƒ³ã®ä¸¦åˆ—å‡¦ç†åŒ–ã‚„ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ã®å®Ÿè£…ã‚’æ¤œè¨',
                        expectedImpact: '20-30%ã®å‡¦ç†æ™‚é–“çŸ­ç¸®'
                    });
                }
                
                // ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–
                if (results.memoryUsage.peak > this.performanceTargets.memoryUsage * 0.8) {
                    suggestions.push({
                        category: 'ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡',
                        suggestion: 'ä¸è¦ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾ã‚„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®æœ€é©åŒ–',
                        expectedImpact: '10-20%ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å‰Šæ¸›'
                    });
                }
                
                // CPUæœ€é©åŒ–
                if (results.cpuMetrics.peak > this.performanceTargets.cpuUsagePeak * 0.8) {
                    suggestions.push({
                        category: 'CPUä½¿ç”¨ç‡',
                        suggestion: 'ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æœ€é©åŒ–ã‚„Web Workerã®æ´»ç”¨',
                        expectedImpact: '15-25%ã®CPUè² è·å‰Šæ¸›'
                    });
                }
                
                // åˆæœŸåŒ–æœ€é©åŒ–
                if (results.initTime > this.performanceTargets.initializationTime * 0.8) {
                    suggestions.push({
                        category: 'åˆæœŸåŒ–æ™‚é–“',
                        suggestion: 'é…å»¶åˆæœŸåŒ–ã‚„ãƒ‡ãƒ¼ã‚¿ã®äº‹å‰èª­ã¿è¾¼ã¿æœ€é©åŒ–',
                        expectedImpact: '30-40%ã®åˆæœŸåŒ–æ™‚é–“çŸ­ç¸®'
                    });
                }
                
                return suggestions;
            }
            
            calculateAverageResults(resultsList) {
                const avg = {
                    totalTime: 0,
                    initTime: 0,
                    analysisTime: 0,
                    mappingTime: 0,
                    memoryUsage: { initial: 0, peak: 0, final: 0 },
                    cpuMetrics: { average: 0, peak: 0, samples: 0 },
                    errors: [],
                    success: true
                };
                
                resultsList.forEach(result => {
                    avg.totalTime += result.totalTime;
                    avg.initTime += result.initTime;
                    avg.analysisTime += result.analysisTime;
                    avg.mappingTime += result.mappingTime;
                    avg.memoryUsage.initial += result.memoryUsage.initial;
                    avg.memoryUsage.peak += result.memoryUsage.peak;
                    avg.memoryUsage.final += result.memoryUsage.final;
                    avg.cpuMetrics.average += result.cpuMetrics.average;
                    avg.cpuMetrics.peak += result.cpuMetrics.peak;
                    avg.cpuMetrics.samples += result.cpuMetrics.samples;
                    avg.errors = avg.errors.concat(result.errors);
                    avg.success = avg.success && result.success;
                });
                
                const count = resultsList.length;
                avg.totalTime /= count;
                avg.initTime /= count;
                avg.analysisTime /= count;
                avg.mappingTime /= count;
                avg.memoryUsage.initial /= count;
                avg.memoryUsage.peak /= count;
                avg.memoryUsage.final /= count;
                avg.cpuMetrics.average /= count;
                avg.cpuMetrics.peak /= count;
                
                return avg;
            }
            
            calculateBenchmarkStats(resultsList) {
                const times = resultsList.map(r => r.totalTime);
                const memoryPeaks = resultsList.map(r => r.memoryUsage.peak);
                const cpuPeaks = resultsList.map(r => r.cpuMetrics.peak);
                
                return {
                    totalTime: this.calculateStats(times),
                    initTime: this.calculateStats(resultsList.map(r => r.initTime)),
                    analysisTime: this.calculateStats(resultsList.map(r => r.analysisTime)),
                    mappingTime: this.calculateStats(resultsList.map(r => r.mappingTime)),
                    memoryUsage: { 
                        initial: Math.min(...resultsList.map(r => r.memoryUsage.initial)),
                        peak: Math.max(...memoryPeaks),
                        final: Math.max(...resultsList.map(r => r.memoryUsage.final))
                    },
                    cpuMetrics: {
                        average: this.calculateStats(resultsList.map(r => r.cpuMetrics.average)),
                        peak: Math.max(...cpuPeaks),
                        samples: Math.max(...resultsList.map(r => r.cpuMetrics.samples))
                    },
                    errors: [].concat(...resultsList.map(r => r.errors)),
                    success: resultsList.every(r => r.success)
                };
            }
            
            calculateStats(values) {
                const sorted = values.sort((a, b) => a - b);
                return {
                    min: sorted[0],
                    max: sorted[sorted.length - 1],
                    avg: values.reduce((a, b) => a + b, 0) / values.length,
                    median: sorted[Math.floor(sorted.length / 2)],
                    std: this.calculateStandardDeviation(values)
                };
            }
            
            calculateStandardDeviation(values) {
                const avg = values.reduce((a, b) => a + b, 0) / values.length;
                const squareDiffs = values.map(value => Math.pow(value - avg, 2));
                const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / values.length;
                return Math.sqrt(avgSquareDiff);
            }
            
            updateComprehensiveAnalysis(resultsList) {
                const container = document.getElementById('detailedAnalysis');
                
                const scenarioTable = document.createElement('table');
                scenarioTable.className = 'result-table';
                
                const headers = ['ã‚·ãƒŠãƒªã‚ª', 'ç·åˆæ™‚é–“', 'ãƒ¡ãƒ¢ãƒªãƒ”ãƒ¼ã‚¯', 'CPUå¹³å‡', 'æˆåŠŸ'];
                const rows = resultsList.map(result => [
                    result.scenario,
                    `${result.totalTime.toFixed(0)}ms`,
                    this.formatMemorySize(result.memoryUsage.peak),
                    `${result.cpuMetrics.average.toFixed(1)}%`,
                    result.success ? 'âœ…' : 'âŒ'
                ]);
                
                scenarioTable.innerHTML = `
                    <thead>
                        <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}
                    </tbody>
                `;
                
                container.innerHTML = '<h4>ã‚·ãƒŠãƒªã‚ªåˆ¥çµæœ:</h4>';
                container.appendChild(scenarioTable);
            }
            
            updateBenchmarkAnalysis(resultsList) {
                const container = document.getElementById('detailedAnalysis');
                
                const benchmarkTable = document.createElement('table');
                benchmarkTable.className = 'result-table';
                
                const headers = ['å®Ÿè¡Œå›', 'ç·åˆæ™‚é–“', 'ãƒ¡ãƒ¢ãƒªãƒ”ãƒ¼ã‚¯', 'CPUå¹³å‡', 'æˆåŠŸ'];
                const rows = resultsList.map(result => [
                    `#${result.iteration}`,
                    `${result.totalTime.toFixed(0)}ms`,
                    this.formatMemorySize(result.memoryUsage.peak),
                    `${result.cpuMetrics.average.toFixed(1)}%`,
                    result.success ? 'âœ…' : 'âŒ'
                ]);
                
                benchmarkTable.innerHTML = `
                    <thead>
                        <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}
                    </tbody>
                `;
                
                const stats = this.calculateBenchmarkStats(resultsList);
                const statsInfo = document.createElement('div');
                statsInfo.innerHTML = `
                    <h4>çµ±è¨ˆæƒ…å ±:</h4>
                    <p><strong>å¹³å‡å®Ÿè¡Œæ™‚é–“:</strong> ${stats.totalTime.avg.toFixed(2)}ms (æ¨™æº–åå·®: ${stats.totalTime.std.toFixed(2)}ms)</p>
                    <p><strong>æœ€çŸ­å®Ÿè¡Œæ™‚é–“:</strong> ${stats.totalTime.min.toFixed(2)}ms</p>
                    <p><strong>æœ€é•·å®Ÿè¡Œæ™‚é–“:</strong> ${stats.totalTime.max.toFixed(2)}ms</p>
                    <p><strong>ä¸­å¤®å€¤:</strong> ${stats.totalTime.median.toFixed(2)}ms</p>
                `;
                
                container.innerHTML = '<h4>ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯çµæœ:</h4>';
                container.appendChild(benchmarkTable);
                container.appendChild(statsInfo);
            }
            
            clearResults() {
                document.getElementById('metricsGrid').innerHTML = '';
                document.getElementById('detailedAnalysis').innerHTML = '<p>æ¸¬å®šçµæœãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚</p>';
                document.getElementById('bottleneckAnalysis').innerHTML = '<p>åˆ†æçµæœãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
                document.getElementById('optimizationSuggestions').innerHTML = '<p>ææ¡ˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
                document.getElementById('logContainer').innerHTML = '';
                
                this.log('çµæœã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ', 'info');
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        const performanceAnalyzer = new PerformanceAnalyzer();
        
        // å¿…è¦ãªã‚¹ã‚¯ãƒªãƒ—ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‹•çš„ã«èª­ã¿è¾¼ã¿
        async function loadRequiredScripts() {
            const scripts = [
                '/public/js/core/AuthenticIChingEngine.js',
                '/public/js/pages/future-simulator/SituationalContextEngine.js',
                '/public/js/pages/future-simulator/HexagramMappingEngine.js'
            ];
            
            for (const script of scripts) {
                try {
                    await loadScript(script);
                    performanceAnalyzer.log(`ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿å®Œäº†: ${script}`, 'success');
                } catch (error) {
                    performanceAnalyzer.log(`ã‚¹ã‚¯ãƒªãƒ—ãƒˆèª­ã¿è¾¼ã¿å¤±æ•—: ${script} - ${error.message}`, 'error');
                }
            }
        }
        
        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
        async function runSingleTest() {
            await performanceAnalyzer.runSingleTest();
        }
        
        async function runComprehensiveTest() {
            await performanceAnalyzer.runComprehensiveTest();
        }
        
        async function runBenchmark() {
            await performanceAnalyzer.runBenchmark();
        }
        
        function clearResults() {
            performanceAnalyzer.clearResults();
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', async () => {
            performanceAnalyzer.log('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹', 'info');
            
            try {
                await loadRequiredScripts();
                performanceAnalyzer.log('ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†', 'success');
            } catch (error) {
                performanceAnalyzer.log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        });
    </script>
</body>
</html>