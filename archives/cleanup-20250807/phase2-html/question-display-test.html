<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS Analyzer 偶数番設問表示バグ テスト</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1e293b;
            color: #f1f5f9;
            font-family: Inter, sans-serif;
        }
        
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .test-header {
            background: rgba(30, 41, 59, 0.95);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(99, 102, 241, 0.3);
        }
        
        .test-controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .test-button {
            padding: 10px 15px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .test-button:hover {
            background: #2563eb;
        }
        
        .debug-info {
            background: rgba(51, 65, 85, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        
        .question-test-area {
            min-height: 400px;
            border: 2px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .visible-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #ef4444;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .visible-indicator.visible {
            background: #10b981;
        }

        /* 強制表示用スタイル */
        .force-visible {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>🔍 OS Analyzer 偶数番設問表示バグ検証テスト</h1>
            <p>偶数番設問（q2, q4, q6など）の表示問題を詳細に検証します。</p>
        </div>
        
        <div class="test-controls">
            <button class="test-button" onclick="testQuestion('q1')">q1 (奇数) テスト</button>
            <button class="test-button" onclick="testQuestion('q2')">q2 (偶数) テスト</button>
            <button class="test-button" onclick="testQuestion('q3')">q3 (奇数) テスト</button>
            <button class="test-button" onclick="testQuestion('q4')">q4 (偶数) テスト</button>
            <button class="test-button" onclick="testAllQuestions()">全設問順次テスト</button>
            <button class="test-button" onclick="clearDebugInfo()">ログクリア</button>
        </div>
        
        <div id="questions-container" class="question-test-area">
            <!-- VirtualQuestionFlow component will render here -->
        </div>
        
        <div id="debug-info" class="debug-info">デバッグ情報がここに表示されます...\n</div>
    </div>
    
    <div id="visible-indicator" class="visible-indicator">待機中</div>

    <!-- 必須スクリプト群（順序重要） -->
    <script src="./public/js/shared/core/BaseComponent.js"></script>
    <script src="./public/js/shared/core/MicroStorageManager.js"></script>
    <script src="./public/js/shared/core/MicroDataManager.js"></script>
    <script src="./public/js/shared/data/questions.js"></script>
    <script src="./public/js/os-analyzer/core/PrecompiledQuestions.js"></script>
    <script src="./public/js/os-analyzer/components/HaqeiQuestionElement.js"></script>
    <script src="./public/js/os-analyzer/components/VirtualQuestionFlow.js"></script>

    <script>
        let virtualFlow = null;
        let currentTestQuestion = null;
        
        // デバッグログ関数
        function logDebug(message) {
            const debugDiv = document.getElementById('debug-info');
            const timestamp = new Date().toLocaleTimeString();
            debugDiv.textContent += `[${timestamp}] ${message}\n`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
            console.log(`[DEBUG] ${message}`);
        }
        
        function clearDebugInfo() {
            document.getElementById('debug-info').textContent = 'ログクリア完了\n';
        }
        
        // 表示状態インジケーター更新
        function updateVisibilityIndicator(isVisible, questionId) {
            const indicator = document.getElementById('visible-indicator');
            if (isVisible) {
                indicator.textContent = `✅ ${questionId} 表示中`;
                indicator.className = 'visible-indicator visible';
            } else {
                indicator.textContent = `❌ ${questionId} 非表示`;
                indicator.className = 'visible-indicator';
            }
        }
        
        // 特定の設問をテスト
        function testQuestion(questionId) {
            logDebug(`=== ${questionId} テスト開始 ===`);
            currentTestQuestion = questionId;
            
            // 既存のフローを削除
            if (virtualFlow) {
                virtualFlow.cleanup();
            }
            
            // 新しいフローを作成
            virtualFlow = new VirtualQuestionFlow('questions-container', {
                storageManager: new MicroStorageManager(),
                onProgress: (progress) => {
                    logDebug(`Progress: ${progress.toFixed(1)}%`);
                },
                onComplete: (answers) => {
                    logDebug(`Complete: ${answers.length} answers`);
                }
            });
            
            // 初期化
            virtualFlow.init();
            
            // 特定の設問にジャンプ
            const questionIndex = virtualFlow.questions.findIndex(q => q.id === questionId);
            if (questionIndex >= 0) {
                virtualFlow.currentQuestionIndex = questionIndex;
                virtualFlow.updateVisibleRange();
                
                // 詳細な検証を実行
                setTimeout(() => {
                    validateQuestionDisplay(questionId, questionIndex);
                }, 100);
            } else {
                logDebug(`❌ Question ${questionId} not found`);
            }
        }
        
        // 設問表示状態の詳細検証
        function validateQuestionDisplay(questionId, questionIndex) {
            logDebug(`--- ${questionId} 表示状態検証 ---`);
            
            // 1. VirtualQuestionFlow の状態確認
            logDebug(`Current question index: ${virtualFlow.currentQuestionIndex}`);
            logDebug(`Active elements: ${virtualFlow.activeElements.size}`);
            logDebug(`Visible range: ${virtualFlow.visibleRange.start}-${virtualFlow.visibleRange.end}`);
            
            // 2. DOM要素の存在確認
            const viewport = document.querySelector('#questions-container #virtual-viewport');
            if (!viewport) {
                logDebug('❌ Virtual viewport not found');
                updateVisibilityIndicator(false, questionId);
                return;
            }
            
            logDebug(`Virtual viewport children: ${viewport.children.length}`);
            
            // 3. 該当設問要素の確認
            const questionElement = Array.from(viewport.children).find(el => 
                el.dataset.questionId === questionId
            );
            
            if (!questionElement) {
                logDebug(`❌ Question element ${questionId} not found in DOM`);
                updateVisibilityIndicator(false, questionId);
                return;
            }
            
            logDebug(`✅ Question element ${questionId} found`);
            
            // 4. スタイル状態の詳細確認
            const computedStyle = window.getComputedStyle(questionElement);
            const inlineStyle = questionElement.style;
            
            logDebug(`Computed styles:`);
            logDebug(`  display: ${computedStyle.display}`);
            logDebug(`  opacity: ${computedStyle.opacity}`);
            logDebug(`  visibility: ${computedStyle.visibility}`);
            logDebug(`  position: ${computedStyle.position}`);
            logDebug(`  z-index: ${computedStyle.zIndex}`);
            
            logDebug(`Inline styles:`);
            logDebug(`  display: ${inlineStyle.display}`);
            logDebug(`  opacity: ${inlineStyle.opacity}`);
            logDebug(`  visibility: ${inlineStyle.visibility}`);
            
            // 5. クラス状態確認
            logDebug(`Classes: ${questionElement.className}`);
            logDebug(`Has active-question class: ${questionElement.classList.contains('active-question')}`);
            
            // 6. 要素のサイズと位置確認
            const rect = questionElement.getBoundingClientRect();
            logDebug(`Dimensions: ${rect.width}x${rect.height}`);
            logDebug(`Position: (${rect.x}, ${rect.y})`);
            logDebug(`Is in viewport: ${rect.width > 0 && rect.height > 0}`);
            
            // 7. Shadow DOM 確認
            if (questionElement.shadowRoot) {
                const shadowContent = questionElement.shadowRoot.querySelector('.question-container');
                if (shadowContent) {
                    const shadowStyle = window.getComputedStyle(shadowContent);
                    logDebug(`Shadow DOM content display: ${shadowStyle.display}`);
                    logDebug(`Shadow DOM content opacity: ${shadowStyle.opacity}`);
                } else {
                    logDebug('❌ Shadow DOM content not found');
                }
            } else {
                logDebug('❌ No shadow root found');
            }
            
            // 8. 親要素の確認
            const parent = questionElement.parentElement;
            if (parent) {
                const parentStyle = window.getComputedStyle(parent);
                logDebug(`Parent display: ${parentStyle.display}`);
                logDebug(`Parent opacity: ${parentStyle.opacity}`);
            }
            
            // 9. 偶数/奇数判定
            const questionNum = parseInt(questionId.replace('q', ''));
            const isEven = questionNum % 2 === 0;
            logDebug(`Question number: ${questionNum} (${isEven ? '偶数' : '奇数'})`);
            
            // 10. 最終的な表示判定
            const isVisible = computedStyle.display !== 'none' && 
                             computedStyle.opacity !== '0' && 
                             computedStyle.visibility !== 'hidden' &&
                             rect.width > 0 && rect.height > 0;
            
            logDebug(`Final visibility determination: ${isVisible ? '✅ VISIBLE' : '❌ HIDDEN'}`);
            updateVisibilityIndicator(isVisible, questionId);
            
            // 11. 偶数番で非表示の場合、強制表示を試行
            if (isEven && !isVisible) {
                logDebug('🔧 偶数番設問が非表示 - 強制表示を試行');
                attemptForceDisplay(questionElement, questionId);
            }
            
            logDebug(`--- ${questionId} 検証完了 ---\n`);
        }
        
        // 強制表示の試行
        function attemptForceDisplay(element, questionId) {
            logDebug('強制表示処理開始...');
            
            // 1. インラインスタイルをリセット
            element.removeAttribute('style');
            
            // 2. 強制表示クラスを追加
            element.classList.add('force-visible');
            
            // 3. 直接スタイル設定
            element.style.setProperty('display', 'block', 'important');
            element.style.setProperty('opacity', '1', 'important');
            element.style.setProperty('visibility', 'visible', 'important');
            
            // 4. Shadow DOM も強制表示
            if (element.shadowRoot) {
                const shadowContent = element.shadowRoot.querySelector('.question-container');
                if (shadowContent) {
                    shadowContent.style.setProperty('display', 'block', 'important');
                    shadowContent.style.setProperty('opacity', '1', 'important');
                    shadowContent.style.setProperty('visibility', 'visible', 'important');
                }
            }
            
            // 5. 少し遅延してから再検証
            setTimeout(() => {
                const newStyle = window.getComputedStyle(element);
                const newRect = element.getBoundingClientRect();
                const nowVisible = newStyle.display !== 'none' && 
                                 newStyle.opacity !== '0' && 
                                 newRect.width > 0 && newRect.height > 0;
                
                logDebug(`強制表示後の状態: ${nowVisible ? '✅ SUCCESS' : '❌ FAILED'}`);
                if (nowVisible) {
                    logDebug(`New display: ${newStyle.display}, opacity: ${newStyle.opacity}`);
                    logDebug(`New dimensions: ${newRect.width}x${newRect.height}`);
                    updateVisibilityIndicator(true, questionId);
                }
            }, 50);
        }
        
        // 全設問を順次テスト
        function testAllQuestions() {
            logDebug('=== 全設問順次テスト開始 ===');
            
            if (!window.WORLDVIEW_QUESTIONS || !window.SCENARIO_QUESTIONS) {
                logDebug('❌ Question data not loaded');
                return;
            }
            
            const allQuestions = [...WORLDVIEW_QUESTIONS, ...SCENARIO_QUESTIONS];
            let currentIndex = 0;
            
            function testNext() {
                if (currentIndex >= allQuestions.length) {
                    logDebug('=== 全設問テスト完了 ===');
                    return;
                }
                
                const question = allQuestions[currentIndex];
                testQuestion(question.id);
                
                setTimeout(() => {
                    currentIndex++;
                    testNext();
                }, 2000); // 2秒間隔でテスト
            }
            
            testNext();
        }
        
        // 初期化
        window.addEventListener('load', () => {
            logDebug('テストページ初期化完了');
            logDebug('利用可能なコンポーネント:');
            logDebug(`- BaseComponent: ${typeof BaseComponent !== 'undefined'}`);
            logDebug(`- MicroStorageManager: ${typeof MicroStorageManager !== 'undefined'}`);
            logDebug(`- VirtualQuestionFlow: ${typeof VirtualQuestionFlow !== 'undefined'}`);
            logDebug(`- HaqeiQuestionElement: ${typeof HaqeiQuestionElement !== 'undefined'}`);
            logDebug(`- WORLDVIEW_QUESTIONS: ${typeof WORLDVIEW_QUESTIONS !== 'undefined'}`);
            logDebug(`- SCENARIO_QUESTIONS: ${typeof SCENARIO_QUESTIONS !== 'undefined'}`);
            
            if (typeof WORLDVIEW_QUESTIONS !== 'undefined' && typeof SCENARIO_QUESTIONS !== 'undefined') {
                const totalQuestions = WORLDVIEW_QUESTIONS.length + SCENARIO_QUESTIONS.length;
                logDebug(`読み込み済み設問数: ${totalQuestions}`);
                
                // 偶数番設問の一覧を表示
                const allQuestions = [...WORLDVIEW_QUESTIONS, ...SCENARIO_QUESTIONS];
                const evenQuestions = allQuestions.filter(q => {
                    const num = parseInt(q.id.replace('q', ''));
                    return num % 2 === 0;
                });
                logDebug(`偶数番設問: ${evenQuestions.map(q => q.id).join(', ')}`);
            }
            
            logDebug('テスト開始の準備完了。ボタンをクリックして検証を開始してください。');
        });
    </script>
</body>
</html>