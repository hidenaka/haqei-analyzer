<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Phase 1 ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¤œè¨¼</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            background: #1e1e1e; 
            color: #d4d4d4; 
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2 { color: #4ec9b0; }
        .section { 
            margin: 20px 0; 
            padding: 15px; 
            background: #2d2d30; 
            border-radius: 5px; 
        }
        .metric { 
            display: inline-block; 
            margin: 10px 20px 10px 0;
            padding: 5px 10px;
            background: #252526;
            border-radius: 3px;
        }
        .good { color: #4ec9b0; }
        .warning { color: #f48771; }
        .bad { color: #f14c4c; }
        .bar {
            display: inline-block;
            background: #007acc;
            height: 20px;
            margin-left: 10px;
            vertical-align: middle;
        }
        .position-stat {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        .position-label {
            width: 50px;
        }
        .position-count {
            width: 100px;
        }
        .progress {
            background: #252526;
            height: 30px;
            border-radius: 3px;
            margin: 10px 0;
            padding: 5px;
        }
        #status {
            color: #f48771;
            font-weight: bold;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #3c3c3c;
        }
        th {
            background: #252526;
            color: #4ec9b0;
        }
    </style>
</head>
<body>
    <h1>Phase 1 ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¤œè¨¼</h1>
    <div id="status">åˆæœŸåŒ–ä¸­...</div>
    <div class="progress">
        <div id="progressBar"></div>
    </div>
    
    <div id="results"></div>
    
    <script type="module">
        import { TextTo384LinesBridge } from './public/js/ai/TextTo384LinesBridge.js';
        
        async function loadTestData() {
            const response = await fetch('test-samples-200-categorized.json');
            return await response.json();
        }
        
        async function verifyBaseline() {
            const statusEl = document.getElementById('status');
            const resultsEl = document.getElementById('results');
            
            try {
                statusEl.textContent = 'ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­...';
                const testData = await loadTestData();
                
                statusEl.textContent = 'BridgeåˆæœŸåŒ–ä¸­...';
                const bridge = new TextTo384LinesBridge();
                await bridge.initialize();
                
                // çµæœåé›†
                const results = {
                    totalSamples: 0,
                    positionCounts: [0, 0, 0, 0, 0, 0, 0], // index 0ã¯æœªä½¿ç”¨
                    uniqueLines: new Set(),
                    categoryResults: {},
                    timestamp: new Date().toISOString()
                };
                
                let processedCount = 0;
                const totalSamples = Object.values(testData.samples).flat().length;
                
                // ã‚«ãƒ†ã‚´ãƒªåˆ¥ãƒ†ã‚¹ãƒˆ
                for (const [category, samples] of Object.entries(testData.samples)) {
                    statusEl.textContent = `ãƒ†ã‚¹ãƒˆä¸­: ${category} (${samples.length}ã‚µãƒ³ãƒ—ãƒ«)`;
                    
                    const categoryStats = {
                        total: samples.length,
                        positionDistribution: [0, 0, 0, 0, 0, 0, 0],
                        lines: []
                    };
                    
                    for (const text of samples) {
                        const result = await bridge.analyzeText(text);
                        const lineKey = `${result.hexagram_number}-${result.line_position}`;
                        
                        results.uniqueLines.add(lineKey);
                        results.positionCounts[result.line_position]++;
                        categoryStats.positionDistribution[result.line_position]++;
                        categoryStats.lines.push({
                            text: text.substring(0, 20) + '...',
                            hexagram: result.hexagram_number,
                            position: result.line_position,
                            line: lineKey
                        });
                        
                        results.totalSamples++;
                        processedCount++;
                        
                        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼æ›´æ–°
                        const progress = (processedCount / totalSamples * 100).toFixed(0);
                        document.getElementById('progressBar').style.width = progress + '%';
                    }
                    
                    results.categoryResults[category] = categoryStats;
                }
                
                // çµ±è¨ˆè¨ˆç®—
                const stats = calculateStatistics(results);
                
                // ãƒ¬ãƒãƒ¼ãƒˆè¡¨ç¤º
                displayReport(results, stats);
                
                statusEl.textContent = 'âœ… æ¤œè¨¼å®Œäº†';
                statusEl.className = 'good';
                
                // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ã‚‚å‡ºåŠ›
                console.log('æ¤œè¨¼çµæœ:', { results, stats });
                
            } catch (error) {
                statusEl.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + error.message;
                statusEl.className = 'bad';
                console.error(error);
            }
        }
        
        function calculateStatistics(results) {
            const total = results.totalSamples;
            const positions = results.positionCounts.slice(1); // index 0ã‚’é™¤å¤–
            
            // ä½ç½®åˆ¥ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸
            const positionPercentages = positions.map(count => 
                ((count / total) * 100).toFixed(2)
            );
            
            // ã‚«ãƒãƒ¼ç‡
            const coverageRate = ((results.uniqueLines.size / 384) * 100).toFixed(2);
            
            // 5çˆ»é¸æŠç‡
            const yao5Rate = ((results.positionCounts[5] / total) * 100).toFixed(2);
            
            // åã‚Šè¨ˆç®—
            const expectedCount = total / 6;
            const variance = positions.reduce((sum, count) => 
                sum + Math.pow(count - expectedCount, 2), 0) / 6;
            const stdDev = Math.sqrt(variance);
            const biasScore = (stdDev / expectedCount * 100).toFixed(2);
            
            // Ï‡Â²æ¤œå®š
            const chiSquare = positions.reduce((sum, count) => 
                sum + Math.pow(count - expectedCount, 2) / expectedCount, 0);
            
            return {
                coverageRate: parseFloat(coverageRate),
                uniqueLines: results.uniqueLines.size,
                yao5Rate: parseFloat(yao5Rate),
                positionPercentages: positionPercentages.map(p => parseFloat(p)),
                biasScore: parseFloat(biasScore),
                chiSquare: chiSquare.toFixed(2),
                maxPosition: positions.indexOf(Math.max(...positions)) + 1,
                minPosition: positions.indexOf(Math.min(...positions)) + 1
            };
        }
        
        function displayReport(results, stats) {
            const resultsEl = document.getElementById('results');
            
            // ä¸»è¦æŒ‡æ¨™
            let html = '<div class="section">';
            html += '<h2>ğŸ“Š ä¸»è¦æŒ‡æ¨™</h2>';
            
            // ã‚«ãƒãƒ¼ç‡
            const coverageClass = stats.coverageRate >= 10 ? 'good' : 
                                  stats.coverageRate >= 5 ? 'warning' : 'bad';
            html += `<div class="metric ${coverageClass}">
                ã‚«ãƒãƒ¼ç‡: ${stats.coverageRate}% (${stats.uniqueLines}/384çˆ»)
                â†’ ç›®æ¨™: 10-15%
            </div><br>`;
            
            // 5çˆ»é¸æŠç‡
            const yao5Class = stats.yao5Rate >= 5 ? 'good' : 
                             stats.yao5Rate >= 2 ? 'warning' : 'bad';
            html += `<div class="metric ${yao5Class}">
                5çˆ»é¸æŠç‡: ${stats.yao5Rate}%
                â†’ ç›®æ¨™: 5-10%
            </div><br>`;
            
            // ãƒ¦ãƒ‹ãƒ¼ã‚¯çˆ»æ•°
            const uniqueClass = stats.uniqueLines >= 40 ? 'good' : 
                               stats.uniqueLines >= 22 ? 'warning' : 'bad';
            html += `<div class="metric ${uniqueClass}">
                ãƒ¦ãƒ‹ãƒ¼ã‚¯çˆ»: ${stats.uniqueLines}å€‹
                â†’ ç›®æ¨™: 40-60å€‹
            </div><br>`;
            
            // åã‚Šã‚¹ã‚³ã‚¢
            html += `<div class="metric">
                åã‚Šã‚¹ã‚³ã‚¢: ${stats.biasScore}% (Ï‡Â²=${stats.chiSquare})
            </div>`;
            html += '</div>';
            
            // ä½ç½®åˆ¥åˆ†å¸ƒ
            html += '<div class="section">';
            html += '<h2>ğŸ“ˆ ä½ç½®åˆ¥åˆ†å¸ƒ</h2>';
            const positions = results.positionCounts.slice(1);
            positions.forEach((count, i) => {
                const percentage = stats.positionPercentages[i];
                const barWidth = percentage * 3;
                const posClass = i === 4 ? 'warning' : ''; // 5çˆ»ã‚’å¼·èª¿
                html += `<div class="position-stat ${posClass}">
                    <span class="position-label">${i + 1}çˆ»:</span>
                    <span class="position-count">${count}å€‹ (${percentage}%)</span>
                    <span class="bar" style="width: ${barWidth}px"></span>
                </div>`;
            });
            html += '</div>';
            
            // ã‚«ãƒ†ã‚´ãƒªåˆ¥çµæœ
            html += '<div class="section">';
            html += '<h2>ğŸ“‹ ã‚«ãƒ†ã‚´ãƒªåˆ¥5çˆ»é¸æŠç‡</h2>';
            html += '<table>';
            html += '<tr><th>ã‚«ãƒ†ã‚´ãƒª</th><th>ã‚µãƒ³ãƒ—ãƒ«æ•°</th><th>5çˆ»é¸æŠæ•°</th><th>é¸æŠç‡</th></tr>';
            
            for (const [category, data] of Object.entries(results.categoryResults)) {
                const yao5Count = data.positionDistribution[5];
                const rate = ((yao5Count / data.total) * 100).toFixed(1);
                const rateClass = parseFloat(rate) >= 5 ? 'good' : 
                                 parseFloat(rate) >= 2 ? 'warning' : 'bad';
                html += `<tr>
                    <td>${category}</td>
                    <td>${data.total}</td>
                    <td>${yao5Count}</td>
                    <td class="${rateClass}">${rate}%</td>
                </tr>`;
            }
            html += '</table>';
            html += '</div>';
            
            // é”æˆçŠ¶æ³
            const targetAchieved = 
                stats.coverageRate >= 10 && 
                stats.yao5Rate >= 5 && 
                stats.uniqueLines >= 40;
            
            html += '<div class="section">';
            if (targetAchieved) {
                html += '<h2 class="good">ğŸ‰ Phase 1ã®ç›®æ¨™ã‚’é”æˆã—ã¦ã„ã¾ã™ï¼</h2>';
            } else {
                html += '<h2 class="warning">âš ï¸ æ”¹å–„ãŒå¿…è¦ã§ã™</h2>';
                html += '<p>Day 2ä»¥é™ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:</p>';
                html += '<ul>';
                if (stats.yao5Rate < 5) {
                    html += '<li>5çˆ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ‹¡å¼µã¨é‡ã¿èª¿æ•´</li>';
                }
                if (stats.coverageRate < 10) {
                    html += '<li>æœªä½¿ç”¨çˆ»ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°å¼·åŒ–</li>';
                }
                if (stats.biasScore > 30) {
                    html += '<li>ä½ç½®åã‚Šã®æ˜¯æ­£</li>';
                }
                html += '</ul>';
            }
            html += '</div>';
            
            resultsEl.innerHTML = html;
        }
        
        // å®Ÿè¡Œ
        verifyBaseline();
    </script>
</body>
</html>