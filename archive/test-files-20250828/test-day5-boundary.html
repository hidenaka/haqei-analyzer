<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Day 5 - å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆï¼ˆTask 5-9ï¼‰</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            background: #1e1e1e; 
            color: #d4d4d4;
        }
        h1 { color: #4ec9b0; }
        h2 { color: #569cd6; }
        .test-group {
            background: #2d2d30;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .pass { color: #4ec9b0; }
        .fail { color: #f48771; }
        .warning { color: #dcdcaa; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #3c3c3c;
        }
        th { background: #252526; }
        .input-hex {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #9cdcfe;
        }
        .performance-metric {
            display: inline-block;
            padding: 5px 10px;
            background: #1a472a;
            border-radius: 3px;
            margin: 5px;
        }
    </style>
</head>
<body>
    <h1>Day 5 - å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆï¼ˆTask 5-9ï¼‰</h1>
    
    <div id="results"></div>
    
    <script type="module">
        import { TextTo384LinesBridge } from './public/js/ai/TextTo384LinesBridge.js';
        
        // å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        const boundaryTests = [
            // æœ€å°å€¤ãƒ†ã‚¹ãƒˆ
            { category: 'æœ€å°å€¤', text: '', label: 'ç©ºæ–‡å­—åˆ—' },
            { category: 'æœ€å°å€¤', text: ' ', label: 'åŠè§’ã‚¹ãƒšãƒ¼ã‚¹1æ–‡å­—' },
            { category: 'æœ€å°å€¤', text: 'ã€€', label: 'å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹1æ–‡å­—' },
            { category: 'æœ€å°å€¤', text: '\n', label: 'æ”¹è¡Œ1æ–‡å­—' },
            { category: 'æœ€å°å€¤', text: '\t', label: 'ã‚¿ãƒ–1æ–‡å­—' },
            
            // æœ€å¤§å€¤ãƒ†ã‚¹ãƒˆ
            { category: 'æœ€å¤§å€¤', text: 'ã‚'.repeat(500), label: '500æ–‡å­—ï¼ˆåŒä¸€æ–‡å­—ï¼‰' },
            { category: 'æœ€å¤§å€¤', text: 'ã‚ã„ã†ãˆãŠ'.repeat(100), label: '500æ–‡å­—ï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰' },
            { category: 'æœ€å¤§å€¤', text: 'æ¼¢å­—ç†Ÿèªæ–‡ç« '.repeat(125), label: '500æ–‡å­—ï¼ˆæ¼¢å­—ï¼‰' },
            
            // ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³
            { category: 'ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³', text: '0', label: 'æ•°å­—0' },
            { category: 'ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³', text: '00000', label: 'æ•°å­—0ã®é€£ç¶š' },
            { category: 'ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³', text: 'null', label: 'nullæ–‡å­—åˆ—' },
            { category: 'ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³', text: 'undefined', label: 'undefinedæ–‡å­—åˆ—' },
            { category: 'ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³', text: 'true', label: 'trueæ–‡å­—åˆ—' },
            { category: 'ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³', text: 'false', label: 'falseæ–‡å­—åˆ—' },
            
            // Unicodeå¢ƒç•Œ
            { category: 'Unicode', text: '\u0000', label: 'NULæ–‡å­—' },
            { category: 'Unicode', text: '\uFFFF', label: 'Unicodeæœ€å¤§å€¤' },
            { category: 'Unicode', text: 'ğŸ‘ğŸ»ğŸ‘ğŸ¼ğŸ‘ğŸ½ğŸ‘ğŸ¾ğŸ‘ğŸ¿', label: 'è‚Œè‰²ä¿®é£¾å­ä»˜ãçµµæ–‡å­—' },
            { category: 'Unicode', text: 'ğ ®·é‡å®¶', label: 'ã‚µãƒ­ã‚²ãƒ¼ãƒˆãƒšã‚¢æ–‡å­—' },
            
            // æ··åˆå¢ƒç•Œ
            { category: 'æ··åˆ', text: '\n\n\n\n\n', label: 'æ”¹è¡Œã®ã¿5å€‹' },
            { category: 'æ··åˆ', text: 'ã€€ã€€ã€€ã€€ã€€', label: 'å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã®ã¿5å€‹' },
            { category: 'æ··åˆ', text: '!!!!!!', label: 'è¨˜å·ã®ã¿' },
            { category: 'æ··åˆ', text: 'ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™ï¼', label: 'å…¨è§’æ•°å­—ã®ã¿' },
            { category: 'æ··åˆ', text: 'ï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ª', label: 'å…¨è§’è‹±å­—ã®ã¿' }
        ];
        
        async function runBoundaryTests() {
            const bridge = new TextTo384LinesBridge();
            await bridge.initialize();
            
            let html = '';
            const results = {
                total: 0,
                passed: 0,
                failed: 0,
                errors: [],
                performanceMetrics: {
                    totalTime: 0,
                    maxTime: 0,
                    minTime: Infinity
                }
            };
            
            // ã‚«ãƒ†ã‚´ãƒªã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const grouped = {};
            for (const test of boundaryTests) {
                if (!grouped[test.category]) {
                    grouped[test.category] = [];
                }
                grouped[test.category].push(test);
            }
            
            // ã‚«ãƒ†ã‚´ãƒªã”ã¨ã«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            for (const [category, tests] of Object.entries(grouped)) {
                html += `<div class="test-group">`;
                html += `<h2>${category}ãƒ†ã‚¹ãƒˆ</h2>`;
                html += '<table>';
                html += '<tr><th>ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹</th><th>å…¥åŠ›</th><th>å‡¦ç†æ™‚é–“</th><th>çµæœ</th><th>è©³ç´°</th></tr>';
                
                for (const test of tests) {
                    results.total++;
                    const startTime = performance.now();
                    
                    try {
                        const result = await bridge.analyzeText(test.text);
                        const endTime = performance.now();
                        const processingTime = endTime - startTime;
                        
                        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆæ›´æ–°
                        results.performanceMetrics.totalTime += processingTime;
                        results.performanceMetrics.maxTime = Math.max(results.performanceMetrics.maxTime, processingTime);
                        results.performanceMetrics.minTime = Math.min(results.performanceMetrics.minTime, processingTime);
                        
                        if (result && result.hexagram_number && result.line_position) {
                            results.passed++;
                            html += '<tr>';
                            html += `<td>${test.label}</td>`;
                            html += `<td class="input-hex">${displayInput(test.text)}</td>`;
                            html += `<td>${processingTime.toFixed(2)}ms</td>`;
                            html += `<td class="pass">âœ… æˆåŠŸ</td>`;
                            html += `<td>${result.hexagram_number}å¦${result.line_position}çˆ»</td>`;
                            html += '</tr>';
                        } else {
                            throw new Error('ä¸å®Œå…¨ãªçµæœ');
                        }
                    } catch (error) {
                        results.failed++;
                        results.errors.push({
                            test: test.label,
                            error: error.message
                        });
                        
                        html += '<tr>';
                        html += `<td>${test.label}</td>`;
                        html += `<td class="input-hex">${displayInput(test.text)}</td>`;
                        html += `<td>-</td>`;
                        html += `<td class="fail">âŒ å¤±æ•—</td>`;
                        html += `<td>${error.message}</td>`;
                        html += '</tr>';
                    }
                }
                
                html += '</table>';
                html += '</div>';
            }
            
            // ã‚µãƒãƒªãƒ¼
            const successRate = ((results.passed / results.total) * 100).toFixed(1);
            const avgTime = (results.performanceMetrics.totalTime / results.total).toFixed(2);
            
            let summaryHtml = '<div class="test-group">';
            summaryHtml += '<h2>ğŸ“Š å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼</h2>';
            
            // æˆåŠŸç‡
            const rateClass = successRate >= 95 ? 'pass' : successRate >= 90 ? 'warning' : 'fail';
            summaryHtml += `<p class="${rateClass}" style="font-size: 1.5em;">æˆåŠŸç‡: ${successRate}% (${results.passed}/${results.total})</p>`;
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹
            summaryHtml += '<h3>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™</h3>';
            summaryHtml += '<div>';
            summaryHtml += `<span class="performance-metric">å¹³å‡å‡¦ç†æ™‚é–“: ${avgTime}ms</span>`;
            summaryHtml += `<span class="performance-metric">æœ€å¤§å‡¦ç†æ™‚é–“: ${results.performanceMetrics.maxTime.toFixed(2)}ms</span>`;
            summaryHtml += `<span class="performance-metric">æœ€å°å‡¦ç†æ™‚é–“: ${results.performanceMetrics.minTime.toFixed(2)}ms</span>`;
            summaryHtml += '</div>';
            
            // ã‚¨ãƒ©ãƒ¼ã‚µãƒãƒªãƒ¼
            if (results.errors.length > 0) {
                summaryHtml += '<h3>ã‚¨ãƒ©ãƒ¼è©³ç´°</h3>';
                summaryHtml += '<ul>';
                for (const err of results.errors) {
                    summaryHtml += `<li class="fail">${err.test}: ${err.error}</li>`;
                }
                summaryHtml += '</ul>';
            }
            
            // æ”¹å–„è©•ä¾¡
            summaryHtml += '<h3>Day 5 å¢ƒç•Œå€¤å‡¦ç†ã®è©•ä¾¡</h3>';
            if (successRate >= 95) {
                summaryHtml += '<p class="pass">âœ… å¢ƒç•Œå€¤å‡¦ç†ã¯éå¸¸ã«å®‰å®šã—ã¦ã„ã¾ã™ã€‚ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹å¯¾å¿œãŒæˆåŠŸã—ã¾ã—ãŸã€‚</p>';
            } else if (successRate >= 90) {
                summaryHtml += '<p class="warning">âš ï¸ å¢ƒç•Œå€¤å‡¦ç†ã¯æ¦‚ã­è‰¯å¥½ã§ã™ãŒã€ä¸€éƒ¨æ”¹å–„ã®ä½™åœ°ãŒã‚ã‚Šã¾ã™ã€‚</p>';
            } else {
                summaryHtml += '<p class="fail">âŒ å¢ƒç•Œå€¤å‡¦ç†ã«ã¾ã å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚è¿½åŠ ã®æ”¹å–„ãŒå¿…è¦ã§ã™ã€‚</p>';
            }
            
            summaryHtml += '</div>';
            
            document.getElementById('results').innerHTML = summaryHtml + html;
        }
        
        function displayInput(text) {
            if (text === '') return '[ç©ºæ–‡å­—åˆ—]';
            if (text === ' ') return '[åŠè§’ã‚¹ãƒšãƒ¼ã‚¹]';
            if (text === 'ã€€') return '[å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹]';
            if (text === '\n') return '[æ”¹è¡Œ]';
            if (text === '\t') return '[ã‚¿ãƒ–]';
            if (text === '\u0000') return '[NUL]';
            if (text === '\uFFFF') return '[U+FFFF]';
            
            // é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã¯çœç•¥
            if (text.length > 20) {
                return text.substring(0, 10) + '...' + text.substring(text.length - 10) + ` (${text.length}æ–‡å­—)`;
            }
            
            return text;
        }
        
        runBoundaryTests();
    </script>
</body>
</html>