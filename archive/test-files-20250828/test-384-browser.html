<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>384çˆ»ã‚·ã‚¹ãƒ†ãƒ å“è³ªãƒ†ã‚¹ãƒˆ</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px; 
            max-width: 1200px; 
            margin: 0 auto;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .pass { color: green; font-weight: bold; }
        .fail { color: red; font-weight: bold; }
        .warning { color: orange; }
        #results { white-space: pre-wrap; }
        button { 
            padding: 10px 20px; 
            font-size: 16px; 
            cursor: pointer;
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1>ğŸ”¬ 384çˆ»ã‚·ã‚¹ãƒ†ãƒ å“è³ªãƒ†ã‚¹ãƒˆ</h1>
    
    <div class="test-section">
        <h2>ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</h2>
        <button onclick="runAllTests()">å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
        <button onclick="runConsistencyTest()">ä¸€è²«æ€§ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="runDistributionTest()">åˆ†å¸ƒãƒ†ã‚¹ãƒˆ (100ã‚µãƒ³ãƒ—ãƒ«)</button>
        <button onclick="runSemanticTest()">æ„å‘³çš„å¦¥å½“æ€§ãƒ†ã‚¹ãƒˆ</button>
    </div>

    <div id="results" class="test-section">
        <h2>çµæœ</h2>
        <pre id="output">ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„...</pre>
    </div>

    <!-- Scripts -->
    <script src="/public/js/lib/localforage.min.js"></script>
    <script src="/public/js/ai/TextTo384LinesBridge.js"></script>
    <script src="/public/assets/H384H64database.js"></script>
    
    <script>
        let bridge;
        const output = document.getElementById('output');
        
        function log(msg, type = '') {
            const timestamp = new Date().toLocaleTimeString();
            let className = '';
            if (type === 'pass') className = 'pass';
            else if (type === 'fail') className = 'fail';
            else if (type === 'warning') className = 'warning';
            
            output.innerHTML += `<span class="${className}">[${timestamp}] ${msg}</span>\n`;
        }

        function clear() {
            output.innerHTML = '';
        }

        async function initBridge() {
            if (!bridge) {
                log('Initializing TextTo384LinesBridge...');
                bridge = new TextTo384LinesBridge();
                await bridge.initialize();
                log('Bridge initialized', 'pass');
            }
        }

        async function runConsistencyTest() {
            clear();
            await initBridge();
            
            log('=== ä¸€è²«æ€§ãƒ†ã‚¹ãƒˆ ===');
            const testTexts = [
                'æ–°ã—ã„ãƒ“ã‚¸ãƒã‚¹ã‚’å§‹ã‚ãŸã„',
                'äººé–“é–¢ä¿‚ã§æ‚©ã‚“ã§ã„ã‚‹',
                'ã‚­ãƒ£ãƒªã‚¢ã®è»¢æ›æœŸã«ã„ã‚‹',
                'ãƒªãƒ¼ãƒ€ãƒ¼ã¨ã—ã¦ã®è²¬ä»»ã‚’æ„Ÿã˜ã‚‹',
                'æ±ºæ–­ã«è¿·ã£ã¦ã„ã‚‹'
            ];
            
            let allPassed = true;
            
            for (const text of testTexts) {
                const results = [];
                for (let i = 0; i < 3; i++) {
                    const result = await bridge.analyzeTextToSpecificLine(text);
                    results.push(result?.line_384_id || 0);
                }
                
                const consistent = results.every(r => r === results[0]);
                const status = consistent ? 'pass' : 'fail';
                log(`"${text.substring(0, 20)}..." -> [${results.join(', ')}] ${consistent ? 'âœ…' : 'âŒ'}`, status);
                
                if (!consistent) allPassed = false;
            }
            
            log(`\nç·åˆçµæœ: ${allPassed ? 'âœ… åˆæ ¼' : 'âŒ ä¸åˆæ ¼'}`, allPassed ? 'pass' : 'fail');
        }

        async function runDistributionTest() {
            clear();
            await initBridge();
            
            log('=== åˆ†å¸ƒãƒ†ã‚¹ãƒˆ (100ã‚µãƒ³ãƒ—ãƒ«) ===');
            
            const themes = ['äº‹æ¥­', 'æ‹æ„›', 'å¥åº·', 'å­¦ç¿’', 'å¤‰åŒ–', 'æ±ºæ–­', 'æˆé•·', 'è²¡é‹', 'å®¶æ—', 'ä»•äº‹'];
            const modifiers = ['æ–°ã—ã„', 'å›°é›£ãª', 'é †èª¿ãª', 'åœæ»ã—ãŸ', 'æ€¥é€Ÿãª', 'æ…é‡ãª', 'é‡è¦ãª', 'å¾®å¦™ãª', 'å¤§ããª', 'å°ã•ãª'];
            
            const texts = [];
            themes.forEach(theme => {
                modifiers.forEach(modifier => {
                    texts.push(`${modifier}${theme}ã«ã¤ã„ã¦è€ƒãˆã¦ã„ã‚‹`);
                });
            });
            
            const lineDistribution = new Map();
            const positionDistribution = new Array(6).fill(0);
            
            log(`Testing ${texts.length} samples...`);
            
            for (const text of texts) {
                const result = await bridge.analyzeTextToSpecificLine(text);
                if (result && result.line_384_id) {
                    const lineId = result.line_384_id;
                    lineDistribution.set(lineId, (lineDistribution.get(lineId) || 0) + 1);
                    const position = ((lineId - 1) % 6) + 1;
                    positionDistribution[position - 1]++;
                }
            }
            
            const uniqueLines = lineDistribution.size;
            const maxFrequency = Math.max(...lineDistribution.values());
            const coverage = (uniqueLines / 384 * 100).toFixed(1);
            
            log(`\nğŸ“Š çµæœ:`);
            log(`ãƒ¦ãƒ‹ãƒ¼ã‚¯çˆ»æ•°: ${uniqueLines}/384 (ã‚«ãƒãƒ¼ç‡: ${coverage}%)`);
            log(`æœ€å¤§é »åº¦: ${maxFrequency}å›`);
            
            log(`\nçˆ»ä½ç½®åˆ†å¸ƒ:`);
            positionDistribution.forEach((count, i) => {
                const percent = (count / texts.length * 100).toFixed(1);
                const bar = 'â–ˆ'.repeat(Math.round(count / 2));
                const status = percent === '0.0' ? 'fail' : percent < '5' ? 'warning' : '';
                log(`  ${i+1}çˆ»: ${count} (${percent}%) ${bar}`, status);
            });
            
            // 5çˆ»ãƒã‚§ãƒƒã‚¯
            const fiveYaoPercent = (positionDistribution[4] / texts.length * 100).toFixed(1);
            if (fiveYaoPercent === '0.0') {
                log('\nâš ï¸ è­¦å‘Š: 5çˆ»ãŒä¸€åº¦ã‚‚é¸ã°ã‚Œã¦ã„ã¾ã›ã‚“ï¼', 'fail');
            } else {
                log(`\nâœ… 5çˆ»: ${fiveYaoPercent}%`, 'pass');
            }
            
            // åˆ¤å®š
            const passed = uniqueLines >= 20 && maxFrequency <= 10 && positionDistribution[4] > 0;
            log(`\nç·åˆåˆ¤å®š: ${passed ? 'âœ… åˆæ ¼' : 'âŒ ä¸åˆæ ¼'}`, passed ? 'pass' : 'fail');
        }

        async function runSemanticTest() {
            clear();
            await initBridge();
            
            log('=== æ„å‘³çš„å¦¥å½“æ€§ãƒ†ã‚¹ãƒˆ ===');
            
            const testCases = [
                { text: 'å§‹ã¾ã‚Šã®æ®µéšã«ã„ã‚‹', expectedPositions: [1, 2], description: 'åˆçˆ»ã¾ãŸã¯äºŒçˆ»' },
                { text: 'æ–°ã—ã„ã“ã¨ã‚’å§‹ã‚ãŸã„', expectedPositions: [1, 2], description: 'åˆçˆ»ã¾ãŸã¯äºŒçˆ»' },
                { text: 'å›°é›£ã«ç›´é¢ã—ã¦ã„ã‚‹', expectedPositions: [3, 4], description: 'ä¸‰çˆ»ã¾ãŸã¯å››çˆ»' },
                { text: 'å²è·¯ã«ç«‹ã£ã¦ã„ã‚‹', expectedPositions: [3, 4], description: 'ä¸‰çˆ»ã¾ãŸã¯å››çˆ»' },
                { text: 'ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ã‚’ç™ºæ®ã™ã‚‹', expectedPositions: [5], description: 'äº”çˆ»' },
                { text: 'é‡è¦ãªæ±ºå®šã‚’ä¸‹ã™ç«‹å ´ã«ã„ã‚‹', expectedPositions: [5], description: 'äº”çˆ»' },
                { text: 'å®Œæˆã«å‘ã‹ã£ã¦ã„ã‚‹', expectedPositions: [6], description: 'ä¸Šçˆ»' },
                { text: 'çµ‚ã‚ã‚ŠãŒè¿‘ã¥ã„ã¦ã„ã‚‹', expectedPositions: [6], description: 'ä¸Šçˆ»' }
            ];
            
            let passCount = 0;
            
            for (const testCase of testCases) {
                const result = await bridge.analyzeTextToSpecificLine(testCase.text);
                if (result && result.line_384_id) {
                    const position = ((result.line_384_id - 1) % 6) + 1;
                    const matched = testCase.expectedPositions.includes(position);
                    
                    const status = matched ? 'pass' : 'fail';
                    log(`"${testCase.text}" -> ${position}çˆ» (æœŸå¾…: ${testCase.description}) ${matched ? 'âœ…' : 'âŒ'}`, status);
                    
                    if (matched) passCount++;
                }
            }
            
            const passRate = (passCount / testCases.length * 100).toFixed(1);
            const passed = passCount >= testCases.length * 0.6; // 60%ä»¥ä¸Šã§åˆæ ¼
            
            log(`\nåˆæ ¼ç‡: ${passRate}% (${passCount}/${testCases.length})`);
            log(`ç·åˆåˆ¤å®š: ${passed ? 'âœ… åˆæ ¼' : 'âŒ ä¸åˆæ ¼'}`, passed ? 'pass' : 'fail');
        }

        async function runAllTests() {
            clear();
            log('=== å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ ===\n');
            
            await runConsistencyTest();
            log('\n' + '='.repeat(50) + '\n');
            
            await runDistributionTest();
            log('\n' + '='.repeat(50) + '\n');
            
            await runSemanticTest();
            
            log('\n' + '='.repeat(50));
            log('å…¨ãƒ†ã‚¹ãƒˆå®Œäº†', 'pass');
        }
    </script>
</body>
</html>