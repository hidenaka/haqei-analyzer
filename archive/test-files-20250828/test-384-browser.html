<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>384爻システム品質テスト</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px; 
            max-width: 1200px; 
            margin: 0 auto;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .pass { color: green; font-weight: bold; }
        .fail { color: red; font-weight: bold; }
        .warning { color: orange; }
        #results { white-space: pre-wrap; }
        button { 
            padding: 10px 20px; 
            font-size: 16px; 
            cursor: pointer;
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1>🔬 384爻システム品質テスト</h1>
    
    <div class="test-section">
        <h2>テスト実行</h2>
        <button onclick="runAllTests()">全テスト実行</button>
        <button onclick="runConsistencyTest()">一貫性テスト</button>
        <button onclick="runDistributionTest()">分布テスト (100サンプル)</button>
        <button onclick="runSemanticTest()">意味的妥当性テスト</button>
    </div>

    <div id="results" class="test-section">
        <h2>結果</h2>
        <pre id="output">テストを実行してください...</pre>
    </div>

    <!-- Scripts -->
    <script src="/public/js/lib/localforage.min.js"></script>
    <script src="/public/js/ai/TextTo384LinesBridge.js"></script>
    <script src="/public/assets/H384H64database.js"></script>
    
    <script>
        let bridge;
        const output = document.getElementById('output');
        
        function log(msg, type = '') {
            const timestamp = new Date().toLocaleTimeString();
            let className = '';
            if (type === 'pass') className = 'pass';
            else if (type === 'fail') className = 'fail';
            else if (type === 'warning') className = 'warning';
            
            output.innerHTML += `<span class="${className}">[${timestamp}] ${msg}</span>\n`;
        }

        function clear() {
            output.innerHTML = '';
        }

        async function initBridge() {
            if (!bridge) {
                log('Initializing TextTo384LinesBridge...');
                bridge = new TextTo384LinesBridge();
                await bridge.initialize();
                log('Bridge initialized', 'pass');
            }
        }

        async function runConsistencyTest() {
            clear();
            await initBridge();
            
            log('=== 一貫性テスト ===');
            const testTexts = [
                '新しいビジネスを始めたい',
                '人間関係で悩んでいる',
                'キャリアの転換期にいる',
                'リーダーとしての責任を感じる',
                '決断に迷っている'
            ];
            
            let allPassed = true;
            
            for (const text of testTexts) {
                const results = [];
                for (let i = 0; i < 3; i++) {
                    const result = await bridge.analyzeTextToSpecificLine(text);
                    results.push(result?.line_384_id || 0);
                }
                
                const consistent = results.every(r => r === results[0]);
                const status = consistent ? 'pass' : 'fail';
                log(`"${text.substring(0, 20)}..." -> [${results.join(', ')}] ${consistent ? '✅' : '❌'}`, status);
                
                if (!consistent) allPassed = false;
            }
            
            log(`\n総合結果: ${allPassed ? '✅ 合格' : '❌ 不合格'}`, allPassed ? 'pass' : 'fail');
        }

        async function runDistributionTest() {
            clear();
            await initBridge();
            
            log('=== 分布テスト (100サンプル) ===');
            
            const themes = ['事業', '恋愛', '健康', '学習', '変化', '決断', '成長', '財運', '家族', '仕事'];
            const modifiers = ['新しい', '困難な', '順調な', '停滞した', '急速な', '慎重な', '重要な', '微妙な', '大きな', '小さな'];
            
            const texts = [];
            themes.forEach(theme => {
                modifiers.forEach(modifier => {
                    texts.push(`${modifier}${theme}について考えている`);
                });
            });
            
            const lineDistribution = new Map();
            const positionDistribution = new Array(6).fill(0);
            
            log(`Testing ${texts.length} samples...`);
            
            for (const text of texts) {
                const result = await bridge.analyzeTextToSpecificLine(text);
                if (result && result.line_384_id) {
                    const lineId = result.line_384_id;
                    lineDistribution.set(lineId, (lineDistribution.get(lineId) || 0) + 1);
                    const position = ((lineId - 1) % 6) + 1;
                    positionDistribution[position - 1]++;
                }
            }
            
            const uniqueLines = lineDistribution.size;
            const maxFrequency = Math.max(...lineDistribution.values());
            const coverage = (uniqueLines / 384 * 100).toFixed(1);
            
            log(`\n📊 結果:`);
            log(`ユニーク爻数: ${uniqueLines}/384 (カバー率: ${coverage}%)`);
            log(`最大頻度: ${maxFrequency}回`);
            
            log(`\n爻位置分布:`);
            positionDistribution.forEach((count, i) => {
                const percent = (count / texts.length * 100).toFixed(1);
                const bar = '█'.repeat(Math.round(count / 2));
                const status = percent === '0.0' ? 'fail' : percent < '5' ? 'warning' : '';
                log(`  ${i+1}爻: ${count} (${percent}%) ${bar}`, status);
            });
            
            // 5爻チェック
            const fiveYaoPercent = (positionDistribution[4] / texts.length * 100).toFixed(1);
            if (fiveYaoPercent === '0.0') {
                log('\n⚠️ 警告: 5爻が一度も選ばれていません！', 'fail');
            } else {
                log(`\n✅ 5爻: ${fiveYaoPercent}%`, 'pass');
            }
            
            // 判定
            const passed = uniqueLines >= 20 && maxFrequency <= 10 && positionDistribution[4] > 0;
            log(`\n総合判定: ${passed ? '✅ 合格' : '❌ 不合格'}`, passed ? 'pass' : 'fail');
        }

        async function runSemanticTest() {
            clear();
            await initBridge();
            
            log('=== 意味的妥当性テスト ===');
            
            const testCases = [
                { text: '始まりの段階にいる', expectedPositions: [1, 2], description: '初爻または二爻' },
                { text: '新しいことを始めたい', expectedPositions: [1, 2], description: '初爻または二爻' },
                { text: '困難に直面している', expectedPositions: [3, 4], description: '三爻または四爻' },
                { text: '岐路に立っている', expectedPositions: [3, 4], description: '三爻または四爻' },
                { text: 'リーダーシップを発揮する', expectedPositions: [5], description: '五爻' },
                { text: '重要な決定を下す立場にいる', expectedPositions: [5], description: '五爻' },
                { text: '完成に向かっている', expectedPositions: [6], description: '上爻' },
                { text: '終わりが近づいている', expectedPositions: [6], description: '上爻' }
            ];
            
            let passCount = 0;
            
            for (const testCase of testCases) {
                const result = await bridge.analyzeTextToSpecificLine(testCase.text);
                if (result && result.line_384_id) {
                    const position = ((result.line_384_id - 1) % 6) + 1;
                    const matched = testCase.expectedPositions.includes(position);
                    
                    const status = matched ? 'pass' : 'fail';
                    log(`"${testCase.text}" -> ${position}爻 (期待: ${testCase.description}) ${matched ? '✅' : '❌'}`, status);
                    
                    if (matched) passCount++;
                }
            }
            
            const passRate = (passCount / testCases.length * 100).toFixed(1);
            const passed = passCount >= testCases.length * 0.6; // 60%以上で合格
            
            log(`\n合格率: ${passRate}% (${passCount}/${testCases.length})`);
            log(`総合判定: ${passed ? '✅ 合格' : '❌ 不合格'}`, passed ? 'pass' : 'fail');
        }

        async function runAllTests() {
            clear();
            log('=== 全テスト実行 ===\n');
            
            await runConsistencyTest();
            log('\n' + '='.repeat(50) + '\n');
            
            await runDistributionTest();
            log('\n' + '='.repeat(50) + '\n');
            
            await runSemanticTest();
            
            log('\n' + '='.repeat(50));
            log('全テスト完了', 'pass');
        }
    </script>
</body>
</html>