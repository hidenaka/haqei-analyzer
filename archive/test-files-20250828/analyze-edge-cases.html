<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Day 5 - ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹åˆ†æ</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            background: #1e1e1e; 
            color: #d4d4d4;
        }
        h1 { color: #4ec9b0; }
        h2 { color: #569cd6; }
        .test-case {
            background: #2d2d30;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .error { color: #f48771; }
        .success { color: #4ec9b0; }
        .warning { color: #dcdcaa; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border: 1px solid #3c3c3c;
        }
        th { background: #252526; }
        .input-sample {
            font-family: monospace;
            background: #1e1e1e;
            padding: 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>Day 5 - ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹åˆ†æ</h1>
    
    <div id="results"></div>
    
    <script type="module">
        import { TextTo384LinesBridge } from './public/js/ai/TextTo384LinesBridge.js';
        
        async function analyzeEdgeCases() {
            const bridge = new TextTo384LinesBridge();
            await bridge.initialize();
            
            // ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆã‚µãƒ³ãƒ—ãƒ«
            const edgeCases = {
                shortText: [
                    { text: "æ„›", category: "è¶…çŸ­æ–‡(1æ–‡å­—)" },
                    { text: "å‹ã¤", category: "çŸ­æ–‡(2æ–‡å­—)" },
                    { text: "é ‘å¼µã‚‹", category: "çŸ­æ–‡(3æ–‡å­—)" },
                    { text: "ä»Šæ—¥", category: "çŸ­æ–‡(2æ–‡å­—ãƒ»æ™‚é–“)" },
                    { text: "ç§", category: "çŸ­æ–‡(1æ–‡å­—ãƒ»ä¸»èª)" }
                ],
                longText: [
                    { text: "ä»Šæ—¥ã¯å¤©æ°—ãŒè‰¯ã„ã®ã§ã€å‹äººãŸã¡ã¨ä¸€ç·’ã«å…¬åœ’ã§ãƒ”ã‚¯ãƒ‹ãƒƒã‚¯ã‚’ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚ãŠå¼å½“ã‚’ä½œã£ã¦ã€ãƒ¬ã‚¸ãƒ£ãƒ¼ã‚·ãƒ¼ãƒˆã‚’æŒã£ã¦ã€æ¥½ã—ã„æ™‚é–“ã‚’éã”ã™äºˆå®šã§ã™ã€‚", category: "é•·æ–‡(70æ–‡å­—)" },
                    { text: "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç· ã‚åˆ‡ã‚ŠãŒè¿‘ã¥ã„ã¦ã„ã‚‹ãŸã‚ã€ãƒãƒ¼ãƒ å…¨å“¡ã§å”åŠ›ã—ã¦ä½œæ¥­ã‚’é€²ã‚ã¦ã„ã¾ã™ã€‚å“è³ªã‚’ç¶­æŒã—ãªãŒã‚‰åŠ¹ç‡çš„ã«é€²ã‚ã‚‹ã“ã¨ãŒé‡è¦ã§ã€å®šæœŸçš„ãªãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã§é€²æ—ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚", category: "é•·æ–‡(85æ–‡å­—)" }
                ],
                specialChars: [
                    { text: "é ‘å¼µã‚‹ğŸ’ª", category: "çµµæ–‡å­—æ··åœ¨" },
                    { text: "ã‚„ã£ãŸã€œ(^o^)/", category: "é¡”æ–‡å­—æ··åœ¨" },
                    { text: "Helloä¸–ç•Œï¼", category: "è‹±èªæ··åœ¨" },
                    { text: "å£²ä¸Šâ†‘30%é”æˆ", category: "è¨˜å·ãƒ»æ•°å­—æ··åœ¨" },
                    { text: "â˜…é‡è¦â˜…", category: "è¨˜å·ä½¿ç”¨" }
                ],
                ambiguous: [
                    { text: "ã‚ã‚Œ", category: "æ›–æ˜§ï¼ˆæŒ‡ç¤ºèªï¼‰" },
                    { text: "ãªã‚“ã‹", category: "æ›–æ˜§ï¼ˆä¸æ˜ç­ï¼‰" },
                    { text: "ã†ãƒ¼ã‚“", category: "æ›–æ˜§ï¼ˆæ„Ÿå˜†è©ï¼‰" },
                    { text: "ã¾ã‚ã¾ã‚", category: "æ›–æ˜§ï¼ˆç¨‹åº¦ï¼‰" },
                    { text: "ãã‚“ãªæ„Ÿã˜", category: "æ›–æ˜§ï¼ˆè¡¨ç¾ï¼‰" }
                ],
                boundary: [
                    { text: "", category: "ç©ºæ–‡å­—åˆ—" },
                    { text: "ã€€", category: "å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã®ã¿" },
                    { text: "\n\n", category: "æ”¹è¡Œã®ã¿" },
                    { text: "ã‚" + "ã„".repeat(200), category: "è¶…é•·æ–‡(201æ–‡å­—)" },
                    { text: "123456789", category: "æ•°å­—ã®ã¿" }
                ]
            };
            
            let html = '';
            const results = {};
            
            // å„ã‚«ãƒ†ã‚´ãƒªã®ãƒ†ã‚¹ãƒˆ
            for (const [category, samples] of Object.entries(edgeCases)) {
                html += `<div class="test-case">`;
                html += `<h2>${getCategoryName(category)}</h2>`;
                html += '<table>';
                html += '<tr><th>å…¥åŠ›</th><th>ã‚«ãƒ†ã‚´ãƒª</th><th>çµæœ</th><th>ã‚¨ãƒ©ãƒ¼</th></tr>';
                
                results[category] = {
                    total: 0,
                    success: 0,
                    errors: []
                };
                
                for (const sample of samples) {
                    try {
                        const result = await bridge.analyzeText(sample.text || "");
                        results[category].total++;
                        
                        if (result && result.hexagram_number && result.line_position) {
                            results[category].success++;
                            html += '<tr>';
                            html += `<td class="input-sample">${escapeHtml(sample.text)}</td>`;
                            html += `<td>${sample.category}</td>`;
                            html += `<td class="success">âœ… ${result.hexagram_number}å¦${result.line_position}çˆ»</td>`;
                            html += '<td>-</td>';
                            html += '</tr>';
                        } else {
                            throw new Error('ä¸å®Œå…¨ãªçµæœ');
                        }
                    } catch (error) {
                        results[category].errors.push({
                            sample: sample.text,
                            error: error.message
                        });
                        
                        html += '<tr>';
                        html += `<td class="input-sample">${escapeHtml(sample.text)}</td>`;
                        html += `<td>${sample.category}</td>`;
                        html += '<td class="error">âŒ ã‚¨ãƒ©ãƒ¼</td>';
                        html += `<td class="error">${error.message}</td>`;
                        html += '</tr>';
                    }
                }
                
                html += '</table>';
                
                // ã‚«ãƒ†ã‚´ãƒªã‚µãƒãƒªãƒ¼
                const successRate = ((results[category].success / results[category].total) * 100).toFixed(1);
                const statusClass = successRate >= 90 ? 'success' : successRate >= 70 ? 'warning' : 'error';
                html += `<p class="${statusClass}">æˆåŠŸç‡: ${successRate}% (${results[category].success}/${results[category].total})</p>`;
                
                if (results[category].errors.length > 0) {
                    html += '<p class="error">ã‚¨ãƒ©ãƒ¼è©³ç´°:</p>';
                    html += '<ul>';
                    for (const err of results[category].errors) {
                        html += `<li>"${escapeHtml(err.sample)}": ${err.error}</li>`;
                    }
                    html += '</ul>';
                }
                
                html += '</div>';
            }
            
            // ç·åˆè©•ä¾¡
            html += '<div class="test-case">';
            html += '<h2>ğŸ“Š ç·åˆè©•ä¾¡</h2>';
            
            let totalTests = 0;
            let totalSuccess = 0;
            
            for (const cat of Object.values(results)) {
                totalTests += cat.total;
                totalSuccess += cat.success;
            }
            
            const overallRate = ((totalSuccess / totalTests) * 100).toFixed(1);
            const overallClass = overallRate >= 90 ? 'success' : overallRate >= 70 ? 'warning' : 'error';
            
            html += `<p class="${overallClass}" style="font-size: 1.5em;">ç·åˆæˆåŠŸç‡: ${overallRate}% (${totalSuccess}/${totalTests})</p>`;
            
            html += '<h3>æ”¹å–„ãŒå¿…è¦ãªé ˜åŸŸ</h3>';
            html += '<ul>';
            for (const [category, data] of Object.entries(results)) {
                const rate = (data.success / data.total) * 100;
                if (rate < 90) {
                    html += `<li class="warning">${getCategoryName(category)}: ${rate.toFixed(1)}%</li>`;
                }
            }
            html += '</ul>';
            
            html += '</div>';
            
            document.getElementById('results').innerHTML = html;
        }
        
        function getCategoryName(key) {
            const names = {
                shortText: 'çŸ­æ–‡å‡¦ç†',
                longText: 'é•·æ–‡å‡¦ç†',
                specialChars: 'ç‰¹æ®Šæ–‡å­—ãƒ»è¨˜å·',
                ambiguous: 'æ›–æ˜§å…¥åŠ›',
                boundary: 'å¢ƒç•Œå€¤'
            };
            return names[key] || key;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        analyzeEdgeCases();
    </script>
</body>
</html>