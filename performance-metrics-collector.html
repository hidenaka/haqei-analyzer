<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Metrics Collector - OS Analyzer</title>
    
    <!-- ä¾å­˜é–¢ä¿‚ -->
    <script src="js/PerformanceOptimizer.js"></script>
    
    <style>
        :root {
            --primary: #6366f1;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --bg-dark: #0f172a;
            --text: #e2e8f0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            padding: 2rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .metric-card h3 {
            color: var(--primary);
            margin-bottom: 1rem;
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: 700;
            margin: 0.5rem 0;
        }
        
        .metric-label {
            color: #94a3b8;
            font-size: 0.875rem;
        }
        
        .status-good { color: var(--success); }
        .status-warning { color: var(--warning); }
        .status-bad { color: var(--error); }
        
        .chart-container {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        canvas {
            max-height: 300px;
        }
        
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }
        
        button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .test-results {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid rgba(99, 102, 241, 0.1);
        }
        
        .test-item:last-child {
            border-bottom: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(99, 102, 241, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s ease;
        }
        
        .recommendation {
            background: rgba(99, 102, 241, 0.1);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 4px;
        }
        
        .timestamp {
            text-align: center;
            color: #64748b;
            margin-top: 2rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ Performance Metrics Collector</h1>
        
        <div class="controls">
            <button onclick="collector.startCollection()">è¨ˆæ¸¬é–‹å§‹</button>
            <button onclick="collector.runLoadTest()">è² è·ãƒ†ã‚¹ãƒˆ</button>
            <button onclick="collector.runMemoryTest()">ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆ</button>
            <button onclick="collector.generateReport()">ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</button>
            <button onclick="collector.clearMetrics()">ã‚¯ãƒªã‚¢</button>
        </div>
        
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>ğŸ“Š ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆ</h3>
                <div class="metric-value" id="fps">0</div>
                <div class="metric-label">fps</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="fps-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <h3>âš¡ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚é–“</h3>
                <div class="metric-value" id="render-time">0</div>
                <div class="metric-label">ms</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="render-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <h3>ğŸ’¾ ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡</h3>
                <div class="metric-value" id="memory">0</div>
                <div class="metric-label">MB</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="memory-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <h3>ğŸ¯ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡</h3>
                <div class="metric-value" id="cache-hit">0</div>
                <div class="metric-label">%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="cache-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <h3>ğŸ“ˆ è¨ˆç®—å‡¦ç†æ™‚é–“</h3>
                <div class="metric-value" id="calc-time">0</div>
                <div class="metric-label">ms</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="calc-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="metric-card">
                <h3>ğŸ”„ DOMæ›´æ–°å›æ•°</h3>
                <div class="metric-value" id="dom-updates">0</div>
                <div class="metric-label">å›/ç§’</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="dom-bar" style="width: 0%"></div>
                </div>
            </div>
        </div>
        
        <div class="chart-container">
            <h3>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹</h3>
            <canvas id="performance-chart"></canvas>
        </div>
        
        <div class="test-results" id="test-results">
            <h3>ğŸ§ª ãƒ†ã‚¹ãƒˆçµæœ</h3>
            <div id="test-items">
                <!-- ãƒ†ã‚¹ãƒˆçµæœãŒå‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹ -->
            </div>
        </div>
        
        <div id="recommendations" class="test-results">
            <h3>ğŸ’¡ æ”¹å–„ææ¡ˆ</h3>
            <!-- æ”¹å–„ææ¡ˆãŒå‹•çš„ã«è¿½åŠ ã•ã‚Œã‚‹ -->
        </div>
        
        <div class="timestamp" id="timestamp">
            æœ€çµ‚æ›´æ–°: -
        </div>
    </div>
    
    <script>
        class PerformanceMetricsCollector {
            constructor() {
                this.metrics = {
                    fps: [],
                    renderTime: [],
                    memory: [],
                    cacheHits: 0,
                    cacheMisses: 0,
                    calcTime: [],
                    domUpdates: 0
                };
                
                this.isCollecting = false;
                this.startTime = null;
                this.frameCount = 0;
                this.lastFrameTime = performance.now();
                
                // Chart.jsãŒã‚ã‚Œã°åˆæœŸåŒ–
                this.chart = null;
                if (typeof Chart !== 'undefined') {
                    this.initChart();
                }
                
                // PerformanceOptimizeråˆæœŸåŒ–
                if (typeof PerformanceOptimizer !== 'undefined') {
                    this.optimizer = new PerformanceOptimizer();
                }
            }
            
            startCollection() {
                if (this.isCollecting) {
                    this.stopCollection();
                    return;
                }
                
                this.isCollecting = true;
                this.startTime = performance.now();
                
                // FPSæ¸¬å®šé–‹å§‹
                this.measureFPS();
                
                // ãƒ¡ãƒ¢ãƒªç›£è¦–é–‹å§‹
                this.monitorMemory();
                
                // DOMç›£è¦–é–‹å§‹
                this.monitorDOM();
                
                // ãƒ¡ãƒˆãƒªã‚¯ã‚¹æ›´æ–°
                this.updateInterval = setInterval(() => {
                    this.updateMetrics();
                }, 100);
                
                console.log('ğŸ“Š Performance collection started');
            }
            
            stopCollection() {
                this.isCollecting = false;
                clearInterval(this.updateInterval);
                console.log('â¹ï¸ Performance collection stopped');
            }
            
            measureFPS() {
                if (!this.isCollecting) return;
                
                const currentTime = performance.now();
                const delta = currentTime - this.lastFrameTime;
                
                if (delta >= 1000) {
                    const fps = Math.round((this.frameCount * 1000) / delta);
                    this.metrics.fps.push(fps);
                    
                    // æœ€å¤§100ã‚¨ãƒ³ãƒˆãƒª
                    if (this.metrics.fps.length > 100) {
                        this.metrics.fps.shift();
                    }
                    
                    this.frameCount = 0;
                    this.lastFrameTime = currentTime;
                }
                
                this.frameCount++;
                
                if (this.isCollecting) {
                    requestAnimationFrame(() => this.measureFPS());
                }
            }
            
            monitorMemory() {
                if (!performance.memory) return;
                
                const memoryInterval = setInterval(() => {
                    if (!this.isCollecting) {
                        clearInterval(memoryInterval);
                        return;
                    }
                    
                    const usedMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    this.metrics.memory.push(usedMB);
                    
                    if (this.metrics.memory.length > 100) {
                        this.metrics.memory.shift();
                    }
                }, 1000);
            }
            
            monitorDOM() {
                let domUpdateCount = 0;
                const observer = new MutationObserver(() => {
                    domUpdateCount++;
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true
                });
                
                setInterval(() => {
                    if (!this.isCollecting) {
                        observer.disconnect();
                        return;
                    }
                    
                    this.metrics.domUpdates = domUpdateCount;
                    domUpdateCount = 0;
                }, 1000);
            }
            
            async runLoadTest() {
                console.log('ğŸ”¥ Starting load test...');
                const results = [];
                
                // 1. å¤§é‡ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ†ã‚¹ãƒˆ
                const dataTest = await this.testDataProcessing();
                results.push(dataTest);
                
                // 2. ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°è² è·ãƒ†ã‚¹ãƒˆ
                const renderTest = await this.testRendering();
                results.push(renderTest);
                
                // 3. è¨ˆç®—è² è·ãƒ†ã‚¹ãƒˆ
                const calcTest = await this.testCalculation();
                results.push(calcTest);
                
                // 4. ã‚­ãƒ£ãƒƒã‚·ãƒ¥åŠ¹ç‡ãƒ†ã‚¹ãƒˆ
                const cacheTest = await this.testCache();
                results.push(cacheTest);
                
                this.displayTestResults(results);
                return results;
            }
            
            async testDataProcessing() {
                const startTime = performance.now();
                const testData = [];
                
                // 1000å€‹ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
                for (let i = 0; i < 1000; i++) {
                    testData.push({
                        id: i,
                        value: Math.random() * 100,
                        nested: {
                            data: Array(100).fill(0).map(() => Math.random())
                        }
                    });
                }
                
                // ãƒ‡ãƒ¼ã‚¿å‡¦ç†
                const processed = testData.map(item => ({
                    ...item,
                    processed: item.value * 2,
                    sum: item.nested.data.reduce((a, b) => a + b, 0)
                }));
                
                const duration = performance.now() - startTime;
                
                return {
                    name: 'ãƒ‡ãƒ¼ã‚¿å‡¦ç†',
                    duration: duration.toFixed(2),
                    items: processed.length,
                    status: duration < 100 ? 'good' : duration < 500 ? 'warning' : 'bad'
                };
            }
            
            async testRendering() {
                const startTime = performance.now();
                const container = document.createElement('div');
                container.style.display = 'none';
                document.body.appendChild(container);
                
                // 1000è¦ç´ ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                for (let i = 0; i < 1000; i++) {
                    const element = document.createElement('div');
                    element.className = 'test-element';
                    element.textContent = `Test ${i}`;
                    element.style.padding = '10px';
                    element.style.margin = '5px';
                    element.style.background = `hsl(${i % 360}, 70%, 50%)`;
                    container.appendChild(element);
                }
                
                // å¼·åˆ¶ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
                container.offsetHeight;
                
                const duration = performance.now() - startTime;
                document.body.removeChild(container);
                
                return {
                    name: 'ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°',
                    duration: duration.toFixed(2),
                    elements: 1000,
                    status: duration < 50 ? 'good' : duration < 200 ? 'warning' : 'bad'
                };
            }
            
            async testCalculation() {
                const startTime = performance.now();
                let result = 0;
                
                // é‡ã„è¨ˆç®—å‡¦ç†
                for (let i = 0; i < 1000000; i++) {
                    result += Math.sqrt(i) * Math.sin(i);
                }
                
                const duration = performance.now() - startTime;
                
                return {
                    name: 'è¨ˆç®—å‡¦ç†',
                    duration: duration.toFixed(2),
                    operations: 1000000,
                    status: duration < 100 ? 'good' : duration < 300 ? 'warning' : 'bad'
                };
            }
            
            async testCache() {
                if (!this.optimizer) {
                    return {
                        name: 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥',
                        duration: 0,
                        hitRate: 0,
                        status: 'warning'
                    };
                }
                
                const testData = { id: 1, value: Math.random() };
                const key = 'test-cache';
                
                // åˆå›ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã—ï¼‰
                const start1 = performance.now();
                this.optimizer.optimizeCalculation(() => {
                    let sum = 0;
                    for (let i = 0; i < 100000; i++) {
                        sum += Math.sqrt(i);
                    }
                    return sum;
                }, key, testData);
                const uncached = performance.now() - start1;
                
                // 2å›ç›®ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚ã‚Šï¼‰
                const start2 = performance.now();
                this.optimizer.optimizeCalculation(() => {
                    let sum = 0;
                    for (let i = 0; i < 100000; i++) {
                        sum += Math.sqrt(i);
                    }
                    return sum;
                }, key, testData);
                const cached = performance.now() - start2;
                
                const hitRate = ((uncached - cached) / uncached * 100).toFixed(1);
                this.metrics.cacheHits++;
                
                return {
                    name: 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥',
                    uncached: uncached.toFixed(2),
                    cached: cached.toFixed(2),
                    hitRate: hitRate,
                    status: hitRate > 80 ? 'good' : hitRate > 50 ? 'warning' : 'bad'
                };
            }
            
            async runMemoryTest() {
                console.log('ğŸ’¾ Starting memory test...');
                
                if (!performance.memory) {
                    alert('Memory API is not available in this browser');
                    return;
                }
                
                const results = [];
                const baseline = performance.memory.usedJSHeapSize;
                
                // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆ
                const leakTest = await this.testMemoryLeak();
                results.push(leakTest);
                
                // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
                const gcTest = await this.testGarbageCollection();
                results.push(gcTest);
                
                this.displayTestResults(results);
                return results;
            }
            
            async testMemoryLeak() {
                const arrays = [];
                const startMemory = performance.memory.usedJSHeapSize;
                
                // ãƒ¡ãƒ¢ãƒªã‚’æ„å›³çš„ã«ä½¿ç”¨
                for (let i = 0; i < 100; i++) {
                    arrays.push(new Array(10000).fill(Math.random()));
                }
                
                const peakMemory = performance.memory.usedJSHeapSize;
                
                // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                arrays.length = 0;
                
                // GCå¾…æ©Ÿ
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const finalMemory = performance.memory.usedJSHeapSize;
                const leaked = finalMemory - startMemory;
                
                return {
                    name: 'ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯',
                    start: (startMemory / 1048576).toFixed(2) + ' MB',
                    peak: (peakMemory / 1048576).toFixed(2) + ' MB',
                    final: (finalMemory / 1048576).toFixed(2) + ' MB',
                    leaked: (leaked / 1048576).toFixed(2) + ' MB',
                    status: leaked < 1048576 ? 'good' : leaked < 5242880 ? 'warning' : 'bad'
                };
            }
            
            async testGarbageCollection() {
                const measurements = [];
                
                for (let i = 0; i < 5; i++) {
                    // å¤§é‡ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
                    let objects = [];
                    for (let j = 0; j < 10000; j++) {
                        objects.push({
                            id: j,
                            data: new Array(100).fill(Math.random())
                        });
                    }
                    
                    const beforeGC = performance.memory.usedJSHeapSize;
                    
                    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè§£æ”¾
                    objects = null;
                    
                    // GCå¾…æ©Ÿ
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const afterGC = performance.memory.usedJSHeapSize;
                    const collected = beforeGC - afterGC;
                    
                    measurements.push(collected);
                }
                
                const avgCollected = measurements.reduce((a, b) => a + b, 0) / measurements.length;
                
                return {
                    name: 'GCåŠ¹ç‡',
                    avgCollected: (avgCollected / 1048576).toFixed(2) + ' MB',
                    measurements: measurements.length,
                    status: avgCollected > 0 ? 'good' : 'bad'
                };
            }
            
            updateMetrics() {
                // FPS
                const currentFPS = this.metrics.fps[this.metrics.fps.length - 1] || 0;
                document.getElementById('fps').textContent = currentFPS;
                document.getElementById('fps-bar').style.width = `${Math.min(100, currentFPS * 100 / 60)}%`;
                this.setStatusColor('fps', currentFPS >= 30 ? 'good' : currentFPS >= 15 ? 'warning' : 'bad');
                
                // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚é–“
                const avgRenderTime = this.getAverage(this.metrics.renderTime);
                document.getElementById('render-time').textContent = avgRenderTime.toFixed(1);
                document.getElementById('render-bar').style.width = `${Math.min(100, avgRenderTime * 100 / 16)}%`;
                this.setStatusColor('render-time', avgRenderTime <= 16 ? 'good' : avgRenderTime <= 33 ? 'warning' : 'bad');
                
                // ãƒ¡ãƒ¢ãƒª
                const currentMemory = this.metrics.memory[this.metrics.memory.length - 1] || 0;
                document.getElementById('memory').textContent = currentMemory;
                document.getElementById('memory-bar').style.width = `${Math.min(100, currentMemory * 100 / 500)}%`;
                this.setStatusColor('memory', currentMemory <= 100 ? 'good' : currentMemory <= 300 ? 'warning' : 'bad');
                
                // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡
                const totalCache = this.metrics.cacheHits + this.metrics.cacheMisses;
                const hitRate = totalCache > 0 ? (this.metrics.cacheHits / totalCache * 100) : 0;
                document.getElementById('cache-hit').textContent = hitRate.toFixed(1);
                document.getElementById('cache-bar').style.width = `${hitRate}%`;
                this.setStatusColor('cache-hit', hitRate >= 80 ? 'good' : hitRate >= 50 ? 'warning' : 'bad');
                
                // è¨ˆç®—æ™‚é–“
                const avgCalcTime = this.getAverage(this.metrics.calcTime);
                document.getElementById('calc-time').textContent = avgCalcTime.toFixed(1);
                document.getElementById('calc-bar').style.width = `${Math.min(100, avgCalcTime * 100 / 100)}%`;
                this.setStatusColor('calc-time', avgCalcTime <= 50 ? 'good' : avgCalcTime <= 100 ? 'warning' : 'bad');
                
                // DOMæ›´æ–°
                document.getElementById('dom-updates').textContent = this.metrics.domUpdates;
                document.getElementById('dom-bar').style.width = `${Math.min(100, this.metrics.domUpdates * 100 / 100)}%`;
                this.setStatusColor('dom-updates', this.metrics.domUpdates <= 30 ? 'good' : this.metrics.domUpdates <= 60 ? 'warning' : 'bad');
                
                // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æ›´æ–°
                document.getElementById('timestamp').textContent = `æœ€çµ‚æ›´æ–°: ${new Date().toLocaleTimeString('ja-JP')}`;
                
                // ãƒãƒ£ãƒ¼ãƒˆæ›´æ–°
                if (this.chart && this.isCollecting) {
                    this.updateChart();
                }
            }
            
            getAverage(array) {
                if (array.length === 0) return 0;
                return array.reduce((a, b) => a + b, 0) / array.length;
            }
            
            setStatusColor(elementId, status) {
                const element = document.getElementById(elementId);
                element.classList.remove('status-good', 'status-warning', 'status-bad');
                element.classList.add(`status-${status}`);
            }
            
            displayTestResults(results) {
                const container = document.getElementById('test-items');
                container.innerHTML = '';
                
                results.forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'test-item';
                    item.innerHTML = `
                        <span>${result.name}</span>
                        <span class="status-${result.status}">
                            ${result.duration ? result.duration + ' ms' : result.hitRate ? result.hitRate + '%' : '-'}
                        </span>
                    `;
                    container.appendChild(item);
                });
            }
            
            generateReport() {
                const report = {
                    timestamp: new Date().toISOString(),
                    metrics: {
                        avgFPS: this.getAverage(this.metrics.fps),
                        avgRenderTime: this.getAverage(this.metrics.renderTime),
                        avgMemory: this.getAverage(this.metrics.memory),
                        cacheHitRate: this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) * 100,
                        avgCalcTime: this.getAverage(this.metrics.calcTime),
                        avgDOMUpdates: this.metrics.domUpdates
                    },
                    recommendations: []
                };
                
                // æ”¹å–„ææ¡ˆç”Ÿæˆ
                if (report.metrics.avgFPS < 30) {
                    report.recommendations.push('ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆãŒä½ä¸‹ã—ã¦ã„ã¾ã™ã€‚ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ€é©åŒ–ã—ã¦ãã ã•ã„ã€‚');
                }
                
                if (report.metrics.avgRenderTime > 16) {
                    report.recommendations.push('ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚é–“ãŒ16msã‚’è¶…ãˆã¦ã„ã¾ã™ã€‚DOMæ“ä½œã‚’æœ€é©åŒ–ã—ã¦ãã ã•ã„ã€‚');
                }
                
                if (report.metrics.avgMemory > 200) {
                    report.recommendations.push('ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ããªã£ã¦ã„ã¾ã™ã€‚ä¸è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¦ãã ã•ã„ã€‚');
                }
                
                if (report.metrics.cacheHitRate < 70) {
                    report.recommendations.push('ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ãŒä½ã„ã§ã™ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚');
                }
                
                // æ”¹å–„ææ¡ˆè¡¨ç¤º
                const recContainer = document.getElementById('recommendations');
                recContainer.innerHTML = '<h3>ğŸ’¡ æ”¹å–„ææ¡ˆ</h3>';
                
                if (report.recommendations.length === 0) {
                    recContainer.innerHTML += '<div class="recommendation">âœ… ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯è‰¯å¥½ã§ã™ï¼</div>';
                } else {
                    report.recommendations.forEach(rec => {
                        recContainer.innerHTML += `<div class="recommendation">${rec}</div>`;
                    });
                }
                
                // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
                console.log('ğŸ“Š Performance Report:', report);
                
                // JSONå½¢å¼ã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `performance-report-${Date.now()}.json`;
                a.click();
                
                return report;
            }
            
            clearMetrics() {
                this.metrics = {
                    fps: [],
                    renderTime: [],
                    memory: [],
                    cacheHits: 0,
                    cacheMisses: 0,
                    calcTime: [],
                    domUpdates: 0
                };
                
                // UIæ›´æ–°
                this.updateMetrics();
                
                // ãƒ†ã‚¹ãƒˆçµæœã‚¯ãƒªã‚¢
                document.getElementById('test-items').innerHTML = '';
                document.getElementById('recommendations').innerHTML = '<h3>ğŸ’¡ æ”¹å–„ææ¡ˆ</h3>';
                
                console.log('ğŸ—‘ï¸ Metrics cleared');
            }
            
            initChart() {
                // Chart.jså®Ÿè£…ï¼ˆçœç•¥ï¼‰
                console.log('ğŸ“ˆ Chart initialized');
            }
            
            updateChart() {
                // ãƒãƒ£ãƒ¼ãƒˆæ›´æ–°ï¼ˆçœç•¥ï¼‰
            }
        }
        
        // CollectoråˆæœŸåŒ–
        const collector = new PerformanceMetricsCollector();
        
        // è‡ªå‹•é–‹å§‹
        collector.startCollection();
    </script>
</body>
</html>