<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HaQei マルチバース・アナライザー</title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>易</text></svg>"
    />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-annotation/1.4.0/chartjs-plugin-annotation.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", "Noto Sans JP", sans-serif;
      }
      .brand-text {
        background: -webkit-linear-gradient(45deg, #a5b4fc, #e0e7ff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }
      .card {
        transition: all 0.3s ease-in-out;
        cursor: pointer;
      }
      .card:hover,
      .card.highlighted {
        transform: scale(1.03);
        box-shadow: 0 0 30px rgba(165, 180, 252, 0.4);
      }
      .rank-badge {
        font-size: 0.75rem;
        font-weight: bold;
        padding: 2px 8px;
        border-radius: 9999px;
        line-height: 1;
      }
      .rank-s,
      .rank-a,
      .rank-b,
      .rank-c {
        background-color: rgba(74, 222, 128, 0.2);
        color: #86efac;
        border: 1px solid #4ade80;
      }
      .rank-d,
      .rank-e,
      .rank-f,
      .rank-g {
        background-color: rgba(248, 113, 113, 0.2);
        color: #fca5a5;
        border: 1px solid #f87171;
      }
      .rank-h {
        background-color: rgba(185, 28, 28, 0.2);
        color: #fca5a5;
        border: 1px solid #dc2626;
      }
      .toggle-label {
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid transparent;
        transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
      }
      .toggle-label:hover,
      .toggle-label.highlighted {
        transform: scale(1.1);
      }
      .toggle-legend {
        width: 12px;
        height: 12px;
        border-radius: 2px;
        margin-right: 6px;
      }
      .modal-overlay {
        transition: opacity 0.3s ease;
      }
      .modal-content {
        transition: transform 0.3s ease;
      }
      .eval-label {
        display: inline-block;
        padding: 2px 10px;
        border-radius: 9999px;
        font-size: 0.8rem;
        font-weight: 600;
        margin-left: 10px;
      }
      .trend-badge {
        font-size: 0.75rem;
        font-weight: 600;
        padding: 3px 10px;
        border-radius: 6px;
        width: 100%;
        text-align: center;
      }
      .trend-up {
        background-color: rgba(52, 211, 153, 0.2);
        color: #6ee7b7;
        border: 1px solid #34d399;
      }
      .trend-invest {
        background-color: rgba(96, 165, 250, 0.2);
        color: #93c5fd;
        border: 1px solid #60a5fa;
      }
      .trend-stable {
        background-color: rgba(209, 213, 219, 0.2);
        color: #d1d5db;
        border: 1px solid #9ca3af;
      }
      .trend-stagnate {
        background-color: rgba(251, 191, 36, 0.2);
        color: #fcd34d;
        border: 1px solid #fbbf24;
      }
      .trend-down {
        background-color: rgba(248, 113, 113, 0.2);
        color: #fca5a5;
        border: 1px solid #f87171;
      }
      .trend-risk-mgmt {
        background-color: rgba(167, 139, 250, 0.2);
        color: #c4b5fd;
        border: 1px solid #a78bfa;
      }
      .trend-recovery {
        background-color: rgba(34, 197, 94, 0.2);
        color: #86efac;
        border: 1px solid #4ade80;
      }
      .yong-yao-step {
        background: linear-gradient(
          145deg,
          rgba(55, 48, 163, 0.2),
          rgba(129, 140, 248, 0.1)
        );
        border: 1px solid #a5b4fc;
        border-radius: 0.75rem;
        box-shadow: 0 0 20px rgba(165, 180, 252, 0.2);
        margin-top: 1rem;
        margin-bottom: 1rem;
      }
      .yong-yao-transition {
        background-color: rgba(253, 224, 71, 0.1);
        border: 1px solid rgba(253, 224, 71, 0.4);
        color: #fde047;
      }
      .yong-yao-title-icon {
        color: #fde047;
        font-size: 1.1em;
        margin-left: 0.5rem;
        text-shadow: 0 0 10px #facc15;
      }
      .diff-up {
        color: #6ee7b7;
      }
      .diff-down {
        color: #fca5a5;
      }
      .diff-zero {
        color: #9ca3af;
      }
      .full-text {
        white-space: normal;
        overflow: visible;
        text-overflow: clip;
      }
      #aiReasoningContainer {
        border-left: 3px solid #a5b4fc;
        background: rgba(165, 180, 252, 0.05);
      }
      .deep-dive-btn {
        background: linear-gradient(
          145deg,
          rgba(253, 224, 71, 0.8),
          rgba(251, 146, 60, 0.8)
        );
        color: #111827;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(253, 224, 71, 0.2);
      }
      .deep-dive-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(253, 191, 36, 0.4);
      }
      .future-contents-reveal {
        opacity: 1 !important;
      }
      .ai-recommended {
        transform: scale(1.03);
        box-shadow: 0 0 35px rgba(74, 222, 128, 0.5),
          0 0 0 3px rgba(74, 222, 128, 0.6);
        border-color: rgba(74, 222, 128, 0.6) !important;
      }
      .dimmed-by-choice {
        opacity: 0.4;
        transform: scale(0.98);
      }
    </style>
    <script src="./js/koudo_shishin_database.js"></script>
    <script src="./js/ai_theme_database.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/build/kuromoji.js"></script>
  </head>
  <body class="bg-gray-900 text-gray-200 min-h-screen p-4 sm:p-6">
    <div
      class="w-full max-w-7xl mx-auto bg-gray-800 shadow-2xl rounded-2xl p-6 sm:p-8"
    >
      <header class="text-center mb-8 relative">
        <a href="./" class="inline-block">
          <h1 class="text-3xl sm:text-4xl font-bold brand-text tracking-wider">
            HaQei
          </h1>
          <p class="text-gray-400 mt-2 text-lg">マルチバース・アナライザー</p>
        </a>
        <button
          id="helpBtn"
          class="absolute top-0 right-0 p-2 text-gray-400 hover:text-white transition-colors"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.79 4 4 0 .863-.27 1.66-.744 2.25l-2.536 2.39c-.832.786-1.464 1.49-1.464 2.36h.001M12 18h.01"
            />
          </svg>
        </button>
      </header>

      <div class="bg-gray-900/50 p-6 rounded-xl mb-4">
        <h2 class="text-lg font-bold text-indigo-300 mb-3">
          1. AIによる状況推測
        </h2>
        <div
          class="border border-gray-700 rounded-lg p-4 mb-4 text-sm text-gray-300 space-y-3"
        >
          <p class="text-base font-bold text-center text-indigo-300">
            AIへの最高の「呪文」は、あなたの「ありのままの言葉」です
          </p>
          <p class="text-xs text-center text-gray-400">
            未来分岐図の精度を高める、たった一つの秘訣
          </p>
          <p>
            これから、あなたの現状と課題をAIに入力していただきます。その際、どうか<strong>「上手な文章を書こう」としないでください。</strong>AIは、整えられた文章よりも、あなたの<strong>「生の言葉」</strong>を求めています。
          </p>
          <p>
            箇条書きでも、心のつぶやきでも、誰かに愚痴をこぼすような言葉でも構いません。他人に見せるための文章ではなく、<strong>あなた自身のための「思考のメモ」</strong>として、リラックスして入力してください。
          </p>
          <p>
            なぜなら、AIはあなたが選ぶ一つ一つの単語、表現の揺れ、感情のニュアンスから、あなただけの「思考のクセ」や「心の動き」を読み取るからです。
          </p>
          <div class="pt-2">
            <p class="font-bold text-gray-200">【入力のヒント】</p>
            <div
              class="mt-2 p-3 rounded-lg bg-red-900/20 border border-red-800/50"
            >
              <p class="font-bold">悪い例 ❌</p>
              <p class="text-xs italic mt-1">
                「新規プロジェクトのマネジメントにおいて、人的リソースの不足がボトルネックとなり、計画に遅延が生じています。」
              </p>
              <p class="text-xs text-gray-400 mt-1">
                （これでは、AIは一般的なビジネス課題としてしか分析できません）
              </p>
            </div>
            <div
              class="mt-2 p-3 rounded-lg bg-emerald-900/20 border border-emerald-800/50"
            >
              <p class="font-bold">良い例 ⭕</p>
              <p class="text-xs italic mt-1">
                「新しい仕事、マジで人足りてない！Aさんは頑張ってくれてるけど、Bさんは全然やる気ないし…。このままだと絶対間に合わない。どうすりゃいいんだ…。焦る。」
              </p>
              <p class="text-xs text-gray-400 mt-1">
                （この方が、あなたの感情、人間関係への認識、切迫感が伝わり、よりパーソナライズされた分析が可能になります）
              </p>
            </div>
          </div>
          <p class="font-bold text-center pt-2">
            あなたの「ありのままの言葉」こそが、あなただけの未来を読み解く、最も強力な鍵となります。<br />どうぞ、あなたの心をそのまま、AIにぶつけてみてください。
          </p>
        </div>
        <textarea
          id="worryInput"
          class="bg-gray-700 border border-gray-600 text-white text-base rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-full p-3 mb-4"
          rows="4"
          placeholder="ここにあなたの「生の言葉」を入力してください..."
        ></textarea>
        <button
            id="aiGuessBtn"
            class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300 flex items-center justify-center gap-2"
          >
            <svg class="animate-spin h-5 w-5 text-white hidden" id="loadingSpinner" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <svg
              id="originalIcon"
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6"
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              <path
                fill-rule="evenodd"
                d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z"
                clip-rule="evenodd"
              />
            </svg>
            <span id="buttonText">AIに状況を推測させる</span>
          </button>
      </div>

      <div class="bg-gray-900/50 p-6 rounded-xl mb-8 space-y-4">
    
    <details class="group">
        <summary class="text-sm text-center text-indigo-400 hover:text-indigo-300 cursor-pointer transition-colors">
            または、状況卦と爻を手動で指定して予測する
        </summary>
        <div class="mt-4 pt-4 border-t border-gray-700 flex flex-col sm:flex-row items-center justify-center gap-4">
            <div>
                <label for="hexagramInput" class="block text-sm font-medium text-gray-300 mb-1">状況卦（番号または名前）</label>
                <input type="text" id="hexagramInput" list="hexagram-names" class="bg-gray-700 border border-gray-600 text-white text-lg rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-full p-3 text-center" placeholder="例: 3">
            </div>
            <div>
                <label for="lineInput" class="block text-sm font-medium text-gray-300 mb-1">現在の爻（1～6）</label>
                <input type="number" id="lineInput" min="1" max="6" class="bg-gray-700 border border-gray-600 text-white text-lg rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-full p-3 text-center" placeholder="例: 1">
            </div>
            <button id="manualAnalyzeBtn" class="w-full sm:w-auto mt-4 sm:mt-0 sm:self-end bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-lg text-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                予測実行
            </button>
        </div>
    </details>

    <div class="pt-4 border-t border-gray-700 text-center">
        <label class="flex items-center justify-center cursor-pointer">
            <input type="checkbox" id="agreementCheckbox" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500">
            <span class="ml-2 text-sm text-gray-400">
                <a href="/terms.html" target="_blank" class="underline hover:text-white">利用規約</a>および<a href="/privacy.html" target="_blank" class="underline hover:text-white">プライバシーポリシー</a>に同意します
            </span>
        </label>
    </div>
</div>

      <div id="resultArea" class="hidden">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 items-start mb-12">
          <div class="lg:col-span-1">
            <h2 class="text-2xl font-bold mb-4 text-center text-indigo-300">
              分析サマリー
            </h2>
            <div
                id="summaryCard"
                class="p-4 rounded-lg border border-gray-600/50 bg-gray-900/30"
              >
                <div
                  class="bg-yellow-400/10 border-l-4 border-yellow-400 p-3 rounded-md"
                >
                  <h4
                    id="currentTitle"
                    class="text-lg font-semibold text-yellow-300"
                  ></h4>
                  <p
                    id="currentKeywords"
                    class="text-sm text-yellow-200 mt-1"
                  ></p>
                  <p id="currentSummary" class="text-gray-300 mt-2 text-sm"></p>
                </div>
                <div class="mt-4 pt-4 border-t border-gray-700/50">
                  <h4 class="font-bold text-gray-300">現在地の総合評価</h4>
                  <div class="flex items-baseline">
                    <p id="currentScore" class="text-3xl font-bold"></p>
                    <span id="currentScoreLabel"></span>
                  </div>
                  <p id="currentScoreDesc" class="text-xs"></p>
                </div>
                <div class="mt-4 pt-4 border-t border-gray-700/50">
                  <h4 class="font-bold text-gray-300">
                    今回の変化のしやすさ (移行コスト)
                  </h4>
                  <div class="flex items-baseline">
                    <p id="transitionCost" class="text-3xl font-bold"></p>
                    <span id="transitionCostLabel"></span>
                  </div>
                  <p id="transitionCostDesc" class="text-xs"></p>
                </div>
                <div class="mt-4 pt-4 border-t border-gray-700/50">
                  <div class="flex items-center justify-between mb-2">
                    <h4 class="font-bold text-gray-300">現在地のグラフ</h4>
                    <button
                      id="paramHelpBtn"
                      class="text-yellow-400 hover:text-yellow-300 text-xl cursor-pointer"
                      title="グラフの見方"
                    >
                      <span
                        style="
                          display: inline-block;
                          transform: translateY(-2px);
                        "
                      >
                        ⭐️
                      </span>
                    </button>
                  </div>
                  <div
                    class="relative"
                    style="height: 150px; padding-left: 5px"
                  >
                    <canvas id="currentStateBarChart"></canvas>
                  </div>
                </div>
                <div id="firstActionContainer" class="mt-4"></div>
              </div>
            </div>
          <div class="lg:col-span-2 bg-gray-900/50 p-6 rounded-xl">
            <h2 class="text-2xl font-bold mb-4 text-center text-indigo-300">
              未来分岐グラフ：総合評価の推移
            </h2>
            <div
              id="aiReasoningContainer"
              class="mb-4 p-4 rounded-lg hidden"
            ></div>
            <div class="relative" style="height: 400px">
              <canvas id="summaryChart"></canvas>
            </div>
            <div
              id="chartToggles"
              class="grid grid-cols-2 md:grid-cols-4 gap-3 mt-4"
            ></div>
          </div>
        </div>

        <div id="revealButtonContainer" class="text-center mt-8 hidden">
          <button
            id="revealButton"
            class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300 transform hover:scale-105 shadow-lg"
          >
            未来への選択肢と、8つの全シナリオを見る
          </button>
        </div>

        <div
          id="futureContentsWrapper"
          class="hidden opacity-0 transition-opacity duration-1000"
        >
          <div id="futureChoiceContainer" class="my-12">
            <h2 class="text-2xl font-bold mb-6 text-center text-indigo-300">
              最初の選択：あなたはどちらの道を選ぶか？
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div
                id="choiceCardShin"
                data-choice="stagnate"
                class="card p-6 rounded-xl border-2 border-transparent transition-all duration-300 bg-gray-900/50 hover:border-teal-500 hover:shadow-lg hover:shadow-teal-500/10"
              ></div>
              <div
                id="choiceCardHen"
                data-choice="change"
                class="card p-6 rounded-xl border-2 border-transparent transition-all duration-300 bg-gray-900/50 hover:border-purple-500 hover:shadow-lg hover:shadow-purple-500/10"
              ></div>
            </div>
          </div>

          <div>
            <h2 class="text-2xl font-bold mb-2 text-center text-indigo-300">
              8つの未来シナリオ
            </h2>
            <p
              id="aiRecommendationMessage"
              class="text-center text-amber-300 mb-6 hidden"
            ></p>
            <div
              id="detailCardsContainer"
              class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-6"
            ></div>
          </div>
        </div>
      </div>

      <div id="initialMessage" class="text-center py-12">
        <p class="text-xl text-gray-500">
          まずは、あなたの「ありのままの言葉」を、<br />上のテキストボックスに入力してください。
        </p>
      </div>
    </div>

    <div
      id="modalContainer"
      class="fixed inset-0 z-50 flex items-center justify-center hidden"
    >
      <div
        id="modalOverlay"
        class="absolute inset-0 bg-black/70 modal-overlay opacity-0"
      ></div>
      <div
        id="modalContent"
        class="modal-content bg-gray-800 rounded-2xl shadow-2xl w-full max-w-2xl max-h-[80vh] overflow-y-auto p-8 relative transform scale-95"
      >
        <button
          id="modalCloseBtn"
          class="absolute top-4 right-4 text-gray-400 hover:text-white"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-6 w-6"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"
            />
          </svg>
        </button>
        <div id="modalBody"></div>
      </div>
    </div>

    <datalist id="hexagram-names"></datalist>

    <script type="module">
      // --- グローバル変数 ---
      let kuromojiTokenizer = null;
      let HAQEI_DATA = null;
      let H64_DATA = null;
      let H384_DATA = null;
      let summaryChartInstance = null;
      let currentStateBarChartInstance = null;
      let currentAnalysisData = {};

      // --- アプリケーション初期化とイベントリスナー設定 ---
      async function initializeApp() {
    const aiGuessBtn = document.getElementById("aiGuessBtn");
    const manualAnalyzeBtn = document.getElementById("manualAnalyzeBtn");

    const showLoadingState = (message) => {
        // AI推測ボタンの表示を更新
        const spinner = document.getElementById('loadingSpinner');
        const originalIcon = document.getElementById('originalIcon');
        const buttonText = document.getElementById('buttonText');
        
        if(spinner && originalIcon && buttonText) {
            spinner.classList.remove('hidden');
            originalIcon.classList.add('hidden');
            buttonText.textContent = message;
        } else {
            aiGuessBtn.innerHTML = message;
        }
        
        aiGuessBtn.disabled = true;
        manualAnalyzeBtn.disabled = true;
        manualAnalyzeBtn.textContent = message;
    };
        showLoadingState("辞書データ読込中...");

        try {
          // kuromojiとAPIデータの読み込みを並列実行
          const tokenizerPromise = new Promise((resolve, reject) => {
            kuromoji.builder({ dicPath: "./dict/" }).build((err, tokenizer) => {
              if (err) {
                console.error("Kuromojiのビルドに失敗:", err);
                return reject(err);
              }
              kuromojiTokenizer = tokenizer;
              resolve();
            });
          });

          const fetchDataPromise = fetch("/api/data").then((res) => {
            if (!res.ok) throw new Error(`APIエラー: ${res.status}`);
            return res.json();
          });

          // 両方のプロミスが完了するのを待つ
          const [apiData] = await Promise.all([
            fetchDataPromise,
            tokenizerPromise,
          ]);

          HAQEI_DATA = apiData.HAQEI_DATA;
          H64_DATA = HAQEI_DATA.H64_DATA;
          H384_DATA = HAQEI_DATA["384"];

          setupDatalist();

          // ボタンを有効化
          const spinner = document.getElementById('loadingSpinner');
        const originalIcon = document.getElementById('originalIcon');
        const buttonText = document.getElementById('buttonText');
        
        if(spinner && originalIcon && buttonText) {
            spinner.classList.add('hidden');
            originalIcon.classList.remove('hidden');
            buttonText.textContent = 'AIに状況を推測させる';
        }
        
        aiGuessBtn.disabled = false;
        manualAnalyzeBtn.disabled = false;
        manualAnalyzeBtn.textContent = "予測実行";
        // ▲▲▲ 置き換えはここまで ▲▲▲

          console.log("アプリケーションの初期化が完了しました。");
        } catch (error) {
          console.error("データの初期化に失敗しました:", error);
          showModal(
            `<h2 class="text-2xl font-bold text-red-400 mb-4">初期化エラー</h2><p>アプリケーションの起動に必要なデータを読み込めませんでした。ページを再読み込みするか、開発者に連絡してください。</p><p class="mt-2 text-sm text-gray-500">${error.message}</p>`
          );
          showLoadingState("読込失敗");
        }
      }

      function setupDatalist() {
        if (H64_DATA && H64_DATA.length > 0) {
          const datalist = document.getElementById("hexagram-names");
          H64_DATA.forEach((hex) => {
            const option = document.createElement("option");
            option.value = hex.名前;
            datalist.appendChild(option);
          });
        }
      }

     document.addEventListener("DOMContentLoaded", () => {
    initializeApp();

    // --- 同意チェックとボタンのイベントリスナー設定 ---
    const agreementCheckbox = document.getElementById('agreementCheckbox');
    const aiGuessBtn = document.getElementById('aiGuessBtn');
    const manualAnalyzeBtn = document.getElementById('manualAnalyzeBtn');

    // 「AIに推測させる」ボタンのクリック処理
    aiGuessBtn.addEventListener("click", () => {
        if (!agreementCheckbox.checked) {
            alert('利用規約とプライバシーポリシーに同意してください。');
            return; // 同意がなければ中断
        }
        handleAiGuess(); // 同意があれば実行
    });

    // 「手動で予測実行」ボタンのクリック処理
    manualAnalyzeBtn.addEventListener("click", () => {
        if (!agreementCheckbox.checked) {
            alert('利用規約とプライバシーポリシーに同意してください。');
            return; // 同意がなければ中断
        }
        handleAnalysis(); // 同意があれば実行
    });

    // --- その他のイベントリスナー ---
    document.getElementById("modalOverlay").addEventListener("click", hideModal);
    document.getElementById("modalCloseBtn").addEventListener("click", hideModal);
    document.getElementById("helpBtn").addEventListener("click", showHelpModal);
    
    document.body.addEventListener("click", function (event) {
        const paramHelpBtn = event.target.closest("#paramHelpBtn");
        if (paramHelpBtn) {
            showParameterHelpModal();
            return;
        }
        const deepDiveBtn = event.target.closest(".deep-dive-btn");
        if (deepDiveBtn) {
            handleDeepDiveClick(event);
            return;
        }
    });

    restoreState();
});
      function handleGoToReportClick(event) {
        event.preventDefault();

        if (
          !currentAnalysisData.worry ||
          !currentAnalysisData.paths ||
          currentAnalysisData.paths.length === 0
        ) {
          showModal(
            `<h2 class="text-2xl font-bold text-yellow-400 mb-4">エラー</h2><p>まだ分析が実行されていません。先に「予測実行」ボタンを押して、分析を完了させてください。</p>`
          );
          return;
        }

        localStorage.setItem(
          "proFutureReportData",
          JSON.stringify(currentAnalysisData)
        );

        window.location.href = event.currentTarget.href;
      }

      async function handleAiGuess() {
    // 同意チェックはボタンのイベントリスナーに移動したので、ここでは不要
    
    const worryText = document.getElementById("worryInput").value.trim();
    if (!isInputSufficient(worryText).isValid) {
        showModal(`<h2 class="text-2xl font-bold text-yellow-400 mb-4">入力内容のご確認</h2><p>あなたの状況をより深く理解するために、もう少し詳しく教えていただけますでしょうか。</p>`);
        return;
    }

    const aiGuessBtn = document.getElementById("aiGuessBtn");
    const spinner = document.getElementById('loadingSpinner');
    const originalIcon = document.getElementById('originalIcon');
    const buttonText = document.getElementById('buttonText');

    // ローディング表示を開始
    aiGuessBtn.disabled = true;
    spinner.classList.remove('hidden');
    originalIcon.classList.add('hidden');
    buttonText.textContent = 'AIが解析中...';

    try {
        const result = await callAIAssistant(worryText, H384_DATA, window.futureThemeMap);
        if (result) {
            document.getElementById("hexagramInput").value = result.卦番号;
            document.getElementById("lineInput").value = result.爻番号;
            handleAnalysis(result.卦番号, result.爻番号, result.根拠, result.解説);
        } else {
            showModal(`<h2 class="text-2xl font-bold text-red-400 mb-4">AI推測エラー</h2><p>状況に合致する卦を見つけられませんでした。表現を変えて再度お試しください。</p>`);
        }
    } catch (error) {
        console.error("AI推測処理でエラー:", error);
        showModal(`<h2 class="text-2xl font-bold text-red-400 mb-4">AI推測エラー</h2><p>AIによる推測処理中にエラーが発生しました。</p><p class="mt-2 text-sm text-gray-500">${error.message}</p>`);
    } finally {
        // ローディング表示を終了し、ボタンを元の状態に戻す
        aiGuessBtn.disabled = false;
        spinner.classList.add('hidden');
        originalIcon.classList.remove('hidden');
        buttonText.textContent = 'AIに状況を推測させる';
    }
}

      function isInputSufficient(text) {
        if (text.length < 10) {
          return {
            isValid: false,
            message:
              "入力された内容が短すぎます。10文字以上で入力してください。",
          };
        }
        if (!kuromojiTokenizer) {
          return {
            isValid: false,
            message:
              "AIの言語解析エンジンの準備ができていません。少し待ってから再度お試しください。",
          };
        }
        const tokens = kuromojiTokenizer.tokenize(text);
        const meaningfulPos = ["名詞", "動詞", "形容詞"];
        const meaningfulWordCount = tokens.filter((token) => {
          return (
            meaningfulPos.includes(token.pos) &&
            token.pos_detail_1 !== "非自立" &&
            token.pos_detail_1 !== "接尾" &&
            token.pos_detail_1 !== "数"
          );
        }).length;
        if (meaningfulWordCount < 3) {
          return {
            isValid: false,
            message:
              "文章に含まれる具体的な単語（名詞、動詞、形容詞）が少ないようです。",
          };
        }
        return { isValid: true, message: "" };
      }

      function extractWords(text) {
        if (!kuromojiTokenizer || !text) return [];
        const tokens = kuromojiTokenizer.tokenize(text);
        const targetPos = ["名詞", "動詞", "形容詞"];
        const words = tokens
          .filter(
            (token) =>
              targetPos.includes(token.pos) &&
              token.pos_detail_1 !== "非自立" &&
              token.pos_detail_1 !== "接尾" &&
              token.surface_form.length > 1
          )
          .map((token) => token.basic_form);
        return [...new Set(words)];
      }

      async function callAIAssistant(worryText, h384Data, futureThemeMap) {
        if (!kuromojiTokenizer) {
          showModal(
            `<h2 class="text-2xl font-bold text-yellow-400 mb-4">AI準備中</h2><p>AIの言語解析エンジンの準備がまだ完了していません。</p>`
          );
          return null;
        }

        function determinePersona(text) {
          const trimmedText = text.trim();
          const strongFirstPersonPattern = /^(私|僕|自分|俺|うち)(は|が)/;
          if (strongFirstPersonPattern.test(trimmedText))
            return { isFirstPerson: true };
          const thirdPersonPattern =
            /彼|彼女|友人|知人|同僚|上司|部下|クライアント|あの人|[ぁ-んァ-ヶー一-龠々]+さん/;
          if (thirdPersonPattern.test(trimmedText))
            return { isFirstPerson: false };
          const bystanderPattern =
            /(ですかね|ですよね|らしい|とのこと|だそうだ|でしょうか)\s*[。？]?$/;
          if (bystanderPattern.test(trimmedText))
            return { isFirstPerson: false };
          const firstPersonPattern = /私|僕|自分|俺|うち/;
          if (firstPersonPattern.test(trimmedText))
            return { isFirstPerson: true };
          return { isFirstPerson: false };
        }

        const { isFirstPerson } = determinePersona(worryText);
        const subject = isFirstPerson ? "あなた" : "その方";
        const subjectPossessive = isFirstPerson ? "あなたの" : "その方の";

        const SCORE_WEIGHTS = {
          POSITIVE_KEYWORD: 30,
          EXISTING_KEYWORD: 10,
          GENERAL_WORD_SIMILARITY: 15,
          NEGATIVE_KEYWORD_PENALTY: -20,
        };

        let bestMatch = {
          score: -Infinity,
          line: null,
          matchedWords: [],
          reasonKeywords: [],
        };
        const lineMap = ["初", "二", "三", "四", "五", "上"];
        const worryWords = extractWords(worryText);

        h384Data.forEach((lineData) => {
          const themeData = futureThemeMap[lineData.通し番号];
          if (!themeData) return;
          let currentScore = 0;
          let reasonKeywords = [];
          let currentMatchedWords = [];
          if (
            themeData.positive_keywords &&
            Array.isArray(themeData.positive_keywords)
          ) {
            themeData.positive_keywords.forEach((keywordGroup) => {
              const foundKw = keywordGroup.find(
                (kw) => worryText.includes(kw) || worryWords.includes(kw)
              );
              if (foundKw) {
                currentScore += SCORE_WEIGHTS.POSITIVE_KEYWORD;
                reasonKeywords.push(keywordGroup[0]);
                if (worryText.includes(foundKw)) {
                  currentMatchedWords.push(foundKw);
                }
              }
            });
          }
          if (lineData.キーワード) {
            const keywords = lineData.キーワード.split(/、|,/);
            keywords.forEach((kw) => {
              if (worryText.includes(kw.trim())) {
                currentScore += SCORE_WEIGHTS.EXISTING_KEYWORD;
              }
            });
          }
          if (lineData.現代解釈の要約 && worryWords.length > 0) {
            const summaryWords = extractWords(lineData.現代解釈の要約);
            const commonWords = worryWords.filter((word) =>
              summaryWords.includes(word)
            );
            if (commonWords.length > 0) {
              const unionSize = new Set([...worryWords, ...summaryWords]).size;
              const similarity =
                unionSize > 0 ? commonWords.length / unionSize : 0;
              currentScore +=
                similarity * SCORE_WEIGHTS.GENERAL_WORD_SIMILARITY;
            }
          }
          if (
            themeData.negative_keywords &&
            Array.isArray(themeData.negative_keywords)
          ) {
            themeData.negative_keywords.forEach((keywordGroup) => {
              if (
                keywordGroup.some(
                  (kw) => worryText.includes(kw) || worryWords.includes(kw)
                )
              ) {
                currentScore += SCORE_WEIGHTS.NEGATIVE_KEYWORD_PENALTY;
              }
            });
          }
          if (currentScore > bestMatch.score) {
            bestMatch = {
              score: currentScore,
              line: lineData,
              matchedWords: [...new Set(currentMatchedWords)],
              reasonKeywords: [...new Set(reasonKeywords)],
            };
          }
        });

        if (bestMatch.line) {
          const { line, matchedWords, reasonKeywords } = bestMatch;
          const lineNum = lineMap.findIndex((l) => line.爻.includes(l)) + 1;
          let quote = "";
          if (matchedWords.length > 0) {
            const quoteWords = matchedWords.slice(0, 3).map((w) => `「${w}」`);
            quote = `${quoteWords.join(
              "、"
            )}といった言葉に、特に強い共鳴が見られました。`;
          } else {
            quote = "お話いただいた内容全体から、";
          }
          let mainTheme = "";
          if (reasonKeywords.length > 0) {
            mainTheme = reasonKeywords.join("、");
          }
          else {
            mainTheme = `${line["親となる卦"]} ${line.爻}の持つテーマ`;
          }
          const reasoning = `AIの推測: ${subjectPossessive}ご相談の状況は、<strong>${line["親となる卦"]} ${line.爻}</strong>の持つ<strong>「${mainTheme}」</strong>というテーマと強く結びついていると判断しました。`;
          let interpretation;
          const summary = line.現代解釈の要約 || "（解釈データなし）";
          if (line.通し番号 === 231) {
            interpretation = `これは文字通りの「撤退」を意味するのではなく、${subject}が感じている<strong>内面的な抵抗（＝足踏み状態）</strong>を指している可能性があります。無理やり進もうとするとエネルギーを消耗するだけで、結果に繋がりにくい時期であることを示唆しています。`;
          } else if (matchedWords.length > 0) {
            interpretation = `${subject}が使われた<strong>${matchedWords
              .map((w) => `「${w}」`)
              .join(
                "や"
              )}</strong>という言葉は、この爻が持つ<strong>「${summary}」</strong>というテーマの核心に、まさに触れていると言えるでしょう。`;
          } else {
            interpretation = `この爻が示す<strong>「${summary}」</strong>という状況が、現在の${subjectPossessive}心境と深く関わっていると判断しました。`;
          }
          let closingStatement = "";
          const targetName = `${line["親となる卦"]} ${line.爻}`;
          const guidelineData =
            typeof window.koudoShishinData !== "undefined"
              ? window.koudoShishinData.find((item) => item.name === targetName)
              : null;
          if (guidelineData) {
            closingStatement = `
                                  <div class="mt-4 pt-4 border-t border-gray-600/50">
                                      <p class="text-sm text-gray-300 mb-3">この状況に対して、HaQeiは2つの異なるアプローチを提示します。</p>
                                      <div class="space-y-3">
                                          <div class="p-3 rounded-lg bg-teal-900/40 border border-teal-700/60">
                                              <p class="font-bold text-teal-300">【進】テーマを深化させる道</p>
                                              <p class="text-xs text-gray-300 mt-1">${guidelineData.shin}</p>
                                          </div>
                                          <div class="p-3 rounded-lg bg-purple-900/40 border border-purple-700/60">
                                              <p class="font-bold text-purple-300">【変】状況を転換する道</p>
                                              <p class="text-xs text-gray-300 mt-1">${guidelineData.hen}</p>
                                          </div>
                                      </div>
                                      <p class="text-sm text-gray-300 mt-3">今のテーマで道を進むか、あるいは状況を変化させる行動をするかが、今の${subjectPossessive}にとっての重要なテーマとなるでしょう。</p>
                                  </div>`;
          } else {
            closingStatement = `<p class="mt-4 text-sm text-gray-400">この爻の視点から現状を見つめ直すことが、新たな気づきを得るための鍵となるかもしれません。</p>`;
          }
          const explanation = `<div class="space-y-2">${interpretation} ${closingStatement}</div>`;
          return {
            卦番号: line.卦番号,
            爻番号: lineNum,
            根拠: reasoning,
            解説: explanation,
          };
        }
        return null;
      }

      function handleAnalysis(
        hexNum = null,
        lineNum = null,
        reasoning = null,
        explanation = null
      ) {
        if (!HAQEI_DATA) {
          showModal(
            `<h2 class="text-2xl font-bold text-yellow-400 mb-4">データ読込中</h2><p>まだデータの準備が完了していません。もうしばらくお待ちください。</p>`
          );
          return;
        }

        let hexagramNumber = hexNum;
        let lineNumber = lineNum;

        if (hexagramNumber === null || lineNumber === null) {
          const hexagramInput = document
            .getElementById("hexagramInput")
            .value.trim();
          lineNumber = parseInt(document.getElementById("lineInput").value);
          let parsedHexNum = parseInt(hexagramInput);
          if (isNaN(parsedHexNum)) {
            const foundHex = H64_DATA.find((h) => h.名前 === hexagramInput);
            hexagramNumber = foundHex ? foundHex.卦番号 : null;
          } else {
            hexagramNumber = parsedHexNum;
          }
        }

        if (
          !hexagramNumber ||
          isNaN(lineNumber) ||
          !H384_DATA ||
          H384_DATA.length === 0
        ) {
          showModal(
            `<h2 class="text-2xl font-bold text-red-400 mb-4">入力エラー</h2><p>有効な卦と爻を入力してください。</p>`
          );
          return;
        }

        const allPaths = generateAllPaths(hexagramNumber, lineNumber);
        if (allPaths.length === 0) {
          showModal(
            `<h2 class="text-2xl font-bold text-red-400 mb-4">分析エラー</h2><p>未来予測パスを生成できませんでした。入力値またはデータを確認してください。</p>`
          );
          return;
        }
        const sortedPaths = allPaths.sort(
          (a, b) => b[3].S7_総合評価スコア - a[3].S7_総合評価スコア
        );

        const worryText = document.getElementById("worryInput").value.trim();
        // グローバル変数にデータを格納
        currentAnalysisData = { worry: worryText, paths: sortedPaths };

        updateUI(sortedPaths, reasoning, explanation);
      }

      function updateUI(sortedPaths, reasoning = null, explanation = null) {
        // 1. 分析データをグローバル変数に保存
        const worryText = document.getElementById("worryInput").value;
        currentAnalysisData = {
          worry: worryText,
          paths: sortedPaths,
        };

        // 2. UIの基本表示を更新
        document.getElementById("initialMessage").classList.add("hidden");
        document.getElementById("resultArea").classList.remove("hidden");

        const reasoningContainer = document.getElementById(
          "aiReasoningContainer"
        );
        if (reasoning) {
          reasoningContainer.innerHTML = `<p class="text-sm text-green-200">${reasoning}</p><p class="text-xs text-gray-400 mt-2">${
            explanation || ""
          }</p>`;
          reasoningContainer.classList.remove("hidden");
        } else {
          reasoningContainer.classList.add("hidden");
          reasoningContainer.innerHTML = "";
        }

        // 3. サマリーカード等の即時表示UIを更新
        const startState = sortedPaths[0][0];
        currentAnalysisData.startState = startState;
        document.getElementById(
          "currentTitle"
        ).innerText = `現在地: ${startState["親となる卦"]} ${startState.爻}`;
        document.getElementById("currentKeywords").innerText = `テーマ: ${
          startState.キーワード || ""
        }`;
        document.getElementById("currentSummary").innerText =
          startState.現代解釈の要約;
        const currentScore = startState.S7_総合評価スコア;
        const scoreEval = getScoreEvaluation(currentScore);
        document.getElementById(
          "currentScore"
        ).innerText = `${currentScore} 点`;
        const scoreLabel = document.getElementById("currentScoreLabel");
        scoreLabel.innerText = scoreEval.label;
        scoreLabel.className = `eval-label ${scoreEval.colorClass}`;
        document.getElementById(
          "currentScoreDesc"
        ).innerText = `※ ${scoreEval.desc}`;
        const transitionCost = 100 - (startState.S6_変動性スコア || 50);
        const costEval = getTransitionCostEvaluation(transitionCost);
        document.getElementById(
          "transitionCost"
        ).innerText = `${transitionCost} 点`;
        const costLabel = document.getElementById("transitionCostLabel");
        costLabel.innerText = costEval.label;
        costLabel.className = `eval-label ${costEval.colorClass}`;
        document.getElementById(
          "transitionCostDesc"
        ).innerText = `※ ${costEval.desc}`;
        document.getElementById("summaryCard").onclick = () =>
          showCurrentStateModal(startState);
        renderCurrentStateBarChart(startState);
        const actionContainer = document.getElementById("firstActionContainer");
        const shoDenData = HAQEI_DATA.bible?.sho_den?.[startState.通し番号];
        if (shoDenData) {
          actionContainer.innerHTML = `<div class="mt-4 pt-4 border-t border-yellow-400/30"><h4 class="font-bold text-yellow-300 mb-3 flex items-center">易経・小象伝が示す「現状の理由」 (HaQei現代解釈)</h4><div class="space-y-3 p-3 rounded-lg bg-gray-800/50"><p class="font-bold text-gray-200">${shoDenData.title}</p><p class="text-xs text-gray-300 mt-1 full-text">${shoDenData.reason}</p></div></div>`;
        } else {
          actionContainer.innerHTML = "";
        }

        // --- ▼▼▼ 【改造ポイント】段階的表示の仕掛け ▼▼▼ ---
        const futureContentsWrapper = document.getElementById(
          "futureContentsWrapper"
        );
        const revealButtonContainer = document.getElementById(
          "revealButtonContainer"
        );
        const revealButton = document.getElementById("revealButton");

        // まずは未来シナリオの「箱」を隠します
        futureContentsWrapper.classList.add("hidden", "opacity-0");
        futureContentsWrapper.classList.remove("future-contents-reveal");

        // 「未来を見る」ボタンを表示します
        revealButtonContainer.classList.remove("hidden");
        revealButton.style.display = "inline-block";

        // ボタンがクリックされたら、箱をフワッと表示する一度きりの仕掛けです
        const revealHandler = () => {
          futureContentsWrapper.classList.remove("hidden");
          setTimeout(() => {
            futureContentsWrapper.classList.add("future-contents-reveal");
            futureContentsWrapper.scrollIntoView({
              behavior: "smooth",
              block: "start",
            });
          }, 100);
          revealButton.style.display = "none";
        };
        revealButton.removeEventListener("click", revealHandler); // 念のため古い仕掛けを解除
        revealButton.addEventListener("click", revealHandler, { once: true }); // 一度押したらおしまい

        // 4. 残りのUI（ただし非表示状態）を描画します
        const choiceCardShin = document.getElementById("choiceCardShin");
        const choiceCardHen = document.getElementById("choiceCardHen");
        const firstStepShin = getNextState(startState, "stagnate");
        const firstStepHen = getNextState(startState, "change");

        const createChoiceCardHTML = (state, choiceType) => {
          if (!state) return "";
          const startStateData = sortedPaths[0][0];
          let title = "";
          let choiceDescription = "";
          const color = choiceType === "shin" ? "teal" : "purple";
          if (choiceType === "shin") {
            title = "【進】テーマを深化させる";
            choiceDescription = `現在のテーマである<strong>「${
              startStateData.キーワード || "現状"
            }」</strong>を維持し、自然な変化の先にある未来を探ります。`;
          } else {
            title = "【変】状況を転換する";
            choiceDescription = `現在のテーマである<strong>「${
              startStateData.キーワード || "現状"
            }」</strong>にあえて変化を加え、全く新しい可能性を模索します。`;
          }
          return `<h3 class="text-lg font-bold text-${color}-300 flex items-center mb-3">${title}</h3><p class="text-sm text-gray-300 mb-4">${choiceDescription}</p><div class="p-3 rounded-lg bg-gray-800/50 text-xs"><p class="font-semibold text-gray-300">→ この選択に続く4つの未来シナリオが下にハイライトされます</p></div>`;
        };

        if (firstStepShin && firstStepHen) {
          choiceCardShin.innerHTML = createChoiceCardHTML(
            firstStepShin,
            "shin"
          );
          choiceCardHen.innerHTML = createChoiceCardHTML(firstStepHen, "hen");
        }

        renderSummaryChart(sortedPaths);
        renderDetailCards(sortedPaths);
        renderChartToggles(sortedPaths);
        setupInteraction(sortedPaths);
      }

      function getScoreEvaluation(score) {
        if (score >= 80)
          return {
            label: "Excellent",
            colorClass: "bg-green-500 text-white",
            desc: "非常に良い状況です。",
          };
        if (score >= 60)
          return {
            label: "Good",
            colorClass: "bg-emerald-500 text-white",
            desc: "良い状況です。チャンスを活かしましょう。",
          };
        if (score >= 40)
          return {
            label: "Average",
            colorClass: "bg-yellow-500 text-white",
            desc: "平均的な状況。油断は禁物です。",
          };
        if (score >= 20)
          return {
            label: "Poor",
            colorClass: "bg-orange-500 text-white",
            desc: "厳しい状況。慎重な判断が必要です。",
          };
        return {
          label: "Critical",
          colorClass: "bg-red-600 text-white",
          desc: "極めて危険な状況。抜本的な対策が必要です。",
        };
      }

      function getTransitionCostEvaluation(cost) {
        if (cost <= 20)
          return {
            label: "絶好機",
            colorClass: "bg-sky-500 text-white",
            desc: "極めて変化しやすい絶好のチャンス期間です。",
          };
        if (cost <= 40)
          return {
            label: "好機",
            colorClass: "bg-teal-500 text-white",
            desc: "変化を起こしやすい好機です。",
          };
        if (cost <= 60)
          return {
            label: "普通",
            colorClass: "bg-gray-500 text-white",
            desc: "変化には相応のエネルギーが必要です。",
          };
        if (cost <= 80)
          return {
            label: "困難",
            colorClass: "bg-rose-500 text-white",
            desc: "変化は困難。現状維持も視野に。",
          };
        return {
          label: "膠着",
          colorClass: "bg-zinc-700 text-white",
          desc: "変化は極めて困難。今は動くべき時ではありません。",
        };
      }

      function renderCurrentStateBarChart(state) {
        if (currentStateBarChartInstance) {
          currentStateBarChartInstance.destroy();
        }
        const ctx = document
          .getElementById("currentStateBarChart")
          .getContext("2d");
        if (!ctx) return;

        const data = [
          state.S1_基本スコア,
          state.S2_ポテンシャル,
          state.S3_安定性スコア,
          Math.abs(state.S4_リスク),
          state.S6_変動性スコア,
        ];
        const colors = [
          "rgba(96, 165, 250, 0.8)",
          "rgba(52, 211, 153, 0.8)",
          "rgba(167, 139, 250, 0.8)",
          "rgba(248, 113, 113, 0.8)",
          "rgba(251, 191, 36, 0.8)",
        ];

        currentStateBarChartInstance = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["基本", "潜在力", "安定性", "リスク", "変動性"],
            datasets: [
              {
                data: data,
                backgroundColor: colors,
                borderWidth: 0,
                barPercentage: 0.8,
                categoryPercentage: 0.9,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: "y",
            scales: {
              x: {
                display: true,
                min: 0,
                max: 100,
                grid: { color: "rgba(255, 255, 255, 0.1)" },
                ticks: { color: "#9ca3af", font: { size: 10 } },
              },
              y: {
                grid: { display: false, drawBorder: false },
                ticks: { color: "#e5e7eb", font: { size: 12, weight: "500" } },
              },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                enabled: true,
                callbacks: {
                  label: function (context) {
                    let label = context.dataset.label || "";
                    if (label) {
                      label += ": ";
                    }
                    if (context.parsed.x !== null) {
                      label += context.parsed.x;
                    }
                    return label;
                  },
                },
              },
            },
          },
        });
      }

      function evaluateSpiralProgress(currentState, futureState) {
        const changes = {
          sogo: futureState.S7_総合評価スコア - currentState.S7_総合評価スコア,
          antei: futureState.S3_安定性スコア - currentState.S3_安定性スコア,
          senzai: futureState.S2_ポテンシャル - currentState.S2_ポテンシャル,
          risk: currentState.S4_リスク - futureState.S4_リスク,
        };
        const EXCELLENT_SCORE_THRESHOLD = 75,
          SOGO_LARGE_UP_THRESHOLD = 15,
          SOGO_UP_THRESHOLD = 5,
          SOGO_STAGNATE_THRESHOLD = -2,
          SENZAI_LARGE_UP_THRESHOLD = 10,
          ANTEI_UP_THRESHOLD = 5,
          RISK_LARGE_DOWN_THRESHOLD = 10,
          STAGNATE_THRESHOLD = 2;
        if (changes.sogo >= SOGO_LARGE_UP_THRESHOLD)
          return futureState.S7_総合評価スコア >= EXCELLENT_SCORE_THRESHOLD
            ? {
                trend: "飛躍的成長",
                message:
                  "素晴らしい飛躍です！状況が劇的に好転し、高評価の領域に到達しました。",
                colorClass: "trend-up",
              }
            : {
                trend: "急回復",
                message:
                  "危機的状況から急速に回復しています。大きな前進ですが、まだ道半ばです。",
                colorClass: "trend-recovery",
              };
        if (changes.sogo >= SOGO_UP_THRESHOLD) {
          if (changes.antei >= 0)
            return {
              trend: "安定的成長",
              message: "理想的な進歩です。着実に階段を上っています。",
              colorClass: "trend-up",
            };
          if (changes.senzai > 0)
            return {
              trend: "発展的成長",
              message: "良い成長です。将来の可能性を広げながら前進しています。",
              colorClass: "trend-invest",
            };
          return {
            trend: "成長",
            message:
              "状況は好転しています。安定性も意識すると更に良いでしょう。",
            colorClass: "trend-up",
          };
        }
        if (changes.sogo > SOGO_STAGNATE_THRESHOLD) {
          if (changes.senzai >= SENZAI_LARGE_UP_THRESHOLD)
            return {
              trend: "未来への投資",
              message:
                "未来への良い投資ができています。次のステップで大きく飛躍する可能性があります。",
              colorClass: "trend-invest",
            };
          if (changes.antei >= ANTEI_UP_THRESHOLD && changes.risk >= 0)
            return {
              trend: "良い停滞",
              message:
                "賢明な停滞です。次の一歩のための安全な足場を固めています。",
              colorClass: "trend-stable",
            };
          if (
            Math.abs(changes.sogo) < STAGNATE_THRESHOLD &&
            Math.abs(changes.antei) < STAGNATE_THRESHOLD
          )
            return {
              trend: "注意すべき停滞",
              message:
                "状況が停滞しています。新しい視点や行動のきっかけを探す時期かもしれません。",
              colorClass: "trend-stagnate",
            };
        }
        if (changes.risk >= RISK_LARGE_DOWN_THRESHOLD)
          return {
            trend: "戦略的下降",
            message:
              "賢明なリスク管理です。大きな問題を回避するための戦略的な一歩です。",
            colorClass: "trend-risk-mgmt",
          };
        if (changes.risk < 0)
          return {
            trend: "危険な下降",
            message:
              "注意が必要です。状況が悪化する可能性があります。原因を見直すべきです。",
            colorClass: "trend-down",
          };
        return {
          trend: "下降傾向",
          message:
            "状況が少し後退しています。原因を分析し、次の手を考えましょう。",
          colorClass: "trend-down",
        };
      }

      function renderSummaryChart(sortedPaths) {
        if (summaryChartInstance) summaryChartInstance.destroy();
        const ctx = document.getElementById("summaryChart").getContext("2d");
        const topColors = ["#4ade80", "#2dd4bf", "#60a5fa", "#a5b4fc"];
        const bottomColors = ["#fde047", "#fb923c", "#f87171", "#ef4444"];
        const currentScore = sortedPaths[0][0].S7_総合評価スコア;

        const datasets = sortedPaths.map((path, index) => {
          const isTop = index < 4;
          const color = isTop ? topColors[index] : bottomColors[index - 4];
          return {
            label: `シナリオ ${index + 1}`,
            data: path.map((p) => p.S7_総合評価スコア),
            borderColor: color,
            originalBorderColor: color,
            borderWidth: isTop ? 3.5 : 1.5,
            originalBorderWidth: isTop ? 3.5 : 1.5,
            tension: 0.1,
            pointRadius: 4,
            pointBackgroundColor: "white",
            originalPointBackgroundColor: "white",
            pointHoverRadius: 6,
          };
        });

        summaryChartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels: ["現在地", "フェーズ1", "フェーズ2", "フェーズ3"],
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                min: 0,
                max: 100,
                ticks: { color: "#9ca3af" },
                grid: { color: "rgba(255, 255, 255, 0.1)" },
              },
              x: {
                ticks: { color: "#9ca3af" },
                grid: { color: "rgba(255, 255, 255, 0.1)" },
              },
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                mode: "index",
                intersect: false,
                callbacks: {
                  label: function (context) {
                    return null; // ラベル本体を非表示にする
                  },
                },
              },
              annotation: {
                annotations: {
                  currentScoreLine: {
                    type: "line",
                    yMin: currentScore,
                    yMax: currentScore,
                    borderColor: "rgb(253, 224, 71)",
                    borderWidth: 2,
                    borderDash: [6, 6],
                    label: {
                      content: "現在地のスコア",
                      enabled: true,
                      position: "end",
                      backgroundColor: "rgba(253, 224, 71, 0.8)",
                      color: "black",
                      font: { size: 10 },
                    },
                  },
                },
              },
            },
          },
        });
      }

      function highlightScenario(index) {
        if (summaryChartInstance) {
          summaryChartInstance.data.datasets.forEach((dataset, i) => {
            if (i === index) {
              dataset.borderWidth = 5;
              dataset.borderColor = dataset.originalBorderColor;
              dataset.pointBackgroundColor =
                dataset.originalPointBackgroundColor;
            } else {
              dataset.borderWidth = 1;
              dataset.borderColor = "rgba(107, 114, 128, 0.5)";
              dataset.pointBackgroundColor = "rgba(107, 114, 128, 0.5)";
            }
          });
          summaryChartInstance.update("none");
        }
        document.querySelectorAll(".card, .toggle-label").forEach((el) => {
          el.classList.remove("highlighted");
        });
        document.getElementById(`card-${index}`)?.classList.add("highlighted");
        document
          .querySelector(`.toggle-label[data-index='${index}']`)
          ?.classList.add("highlighted");
      }

      function resetChartHighlights() {
        if (summaryChartInstance) {
          summaryChartInstance.data.datasets.forEach((dataset) => {
            dataset.borderWidth = dataset.originalBorderWidth;
            dataset.borderColor = dataset.originalBorderColor;
            dataset.pointBackgroundColor = dataset.originalPointBackgroundColor;
          });
          summaryChartInstance.update("none");
        }
        document.querySelectorAll(".card, .toggle-label").forEach((el) => {
          el.classList.remove("highlighted");
        });
      }

      function highlightMultipleScenarios(choiceType, sortedPaths) {
        if (summaryChartInstance) {
          summaryChartInstance.data.datasets.forEach((dataset, i) => {
            if (i < sortedPaths.length) {
              const pathChoice = sortedPaths[i][1]?.choice;
              if (pathChoice === choiceType) {
                dataset.borderWidth = dataset.originalBorderWidth;
                dataset.borderColor = dataset.originalBorderColor;
                dataset.pointBackgroundColor =
                  dataset.originalPointBackgroundColor;
              } else {
                dataset.borderWidth = 1;
                dataset.borderColor = "rgba(107, 114, 128, 0.5)";
                dataset.pointBackgroundColor = "rgba(107, 114, 128, 0.5)";
              }
            } else {
              dataset.borderWidth = 1;
              dataset.borderColor = "rgba(107, 114, 128, 0.5)";
              dataset.pointBackgroundColor = "rgba(107, 114, 128, 0.5)";
            }
          });
          summaryChartInstance.update("none");
        }
      }

      function renderDetailCards(sortedPaths) {
        const container = document.getElementById("detailCardsContainer");
        container.innerHTML = "";
        const rankLabels = ["S", "A", "B", "C", "D", "E", "F", "H"];
        // --- ▼▼▼ 【改造ポイント】AIのおすすめメッセージを表示 ▼▼▼ ---
        const recommendationMessageEl = document.getElementById(
          "aiRecommendationMessage"
        );
        recommendationMessageEl.innerHTML = `AIの分析では、<strong class="text-green-300">シナリオ1（Sランク）</strong>があなたの課題解決と成長に最も貢献する可能性があります。<br class="hidden sm:block">まずはこちらの物語から読んでみませんか？`;
        recommendationMessageEl.classList.remove("hidden");

        // 手順1: まず、全てのカードのHTML要素をDOMに一括で追加します
        sortedPaths.forEach((path, index) => {
          const finalState = path[path.length - 1];
          const overallTrend = evaluateSpiralProgress(path[0], path[3]);
          const firstStepTrend = evaluateSpiralProgress(path[0], path[1]);
          const card = document.createElement("div");
          const rankClass = `rank-${rankLabels[index].toLowerCase()}`;

          // --- ▼▼▼ 【改造ポイント】一番おすすめのカードに目印をつけます ▼▼▼ ---
          const isRecommended = index === 0;
          card.id = `card-${index}`;
          card.className = `card relative bg-gray-900/50 p-4 rounded-xl border-2 border-transparent flex flex-col ${
            isRecommended ? "ai-recommended" : ""
          }`;

          card.dataset.index = index;
          card.addEventListener("click", (e) => {
            if (e.target.closest(".deep-dive-btn")) return;
            showScenarioModal(path, index, overallTrend, firstStepTrend);
          });

          const pathHistory = path
            .slice(1)
            .map((p) => (p.choice === "change" ? "変" : "進"))
            .join(" → ");
          const finalStateTitle = `${finalState["親となる卦"]} ${finalState.爻}`;

          // --- ▼▼▼ 【改造ポイント】おすすめカードにキラキラバッジを追加 ▼▼▼ ---
          const badgeHtml = isRecommended
            ? `<div class="absolute top-2.5 right-2.5 bg-green-400 text-gray-900 text-xs font-bold px-3 py-1 rounded-full shadow-lg z-10">✨ AI推奨</div>`
            : "";

          card.innerHTML = `${badgeHtml}<div class="flex items-start justify-between mb-2"><h3 class="text-md font-bold text-gray-300">シナリオ ${
            index + 1
          }</h3><span class="rank-badge ${rankClass}">${
            rankLabels[index]
          }</span></div><div class="text-xs text-gray-500 mb-3" style="min-height: 1em;">経路: ${pathHistory}</div><div class="grid grid-cols-2 gap-2 mb-3 text-center"><div><p class="text-[10px] text-gray-400 mb-1 font-semibold">全体トレンド</p><div class="trend-badge ${
            overallTrend.colorClass
          }" title="${overallTrend.message}">${
            overallTrend.trend
          }</div></div><div><p class="text-[10px] text-gray-400 mb-1 font-semibold">初期ステップ</p><div class="trend-badge ${
            firstStepTrend.colorClass
          }" title="${firstStepTrend.message}">${
            firstStepTrend.trend
          }</div></div></div><p class="text-lg font-semibold text-indigo-300">${finalStateTitle}</p><div class="my-3" style="height: 110px; padding-left: 5px;"><canvas id="miniChart-${index}"></canvas></div><p class="text-xs text-gray-400 mt-1 mb-4 flex-grow">${
            finalState.現代解釈の要約
          }</p>
          <div class="mt-auto pt-4 border-t border-gray-700/50">
              <a href="professional_report.html" 
                  class="deep-dive-btn inline-block w-full text-center font-bold py-2 px-4 rounded-lg text-sm"
                  data-hexagram-id="${finalState.卦番号}"
                  data-hexagram-name="${finalState["親となる卦"]}"
                  data-scenario-index="${index}">
                  AIでこの未来を深掘り分析する
              </a>
          </div>`;
          container.appendChild(card);
        });

        // 手順2: 全てのカードがDOMに追加された後で、各ミニグラフを描画します
        // この時点では、`miniChart-X`というIDを持つcanvasは確実にページ上に存在します
        sortedPaths.forEach((path, index) => {
          const finalState = path[path.length - 1];
          renderMiniBarChart(index, finalState);
        });
      }

      function renderMiniBarChart(index, state) {
        const ctx = document
          .getElementById(`miniChart-${index}`)
          .getContext("2d");
        const data = [
          state.S1_基本スコア,
          state.S2_ポテンシャル,
          state.S3_安定性スコア,
          Math.abs(state.S4_リスク),
          state.S6_変動性スコア,
        ];
        const colors = [
          "rgba(96, 165, 250, 0.7)",
          "rgba(52, 211, 153, 0.7)",
          "rgba(167, 139, 250, 0.7)",
          "rgba(248, 113, 113, 0.7)",
          "rgba(251, 191, 36, 0.7)",
        ];
        new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["基本", "潜在力", "安定性", "リスク", "変動性"],
            datasets: [
              {
                data: data,
                backgroundColor: colors,
                borderWidth: 0,
                barPercentage: 0.8,
                categoryPercentage: 0.9,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: "y",
            scales: {
              x: { display: false, min: 0, max: 100 },
              y: {
                grid: { display: false, drawBorder: false },
                ticks: { color: "#9ca3af", font: { size: 10 } },
              },
            },
            plugins: {
              legend: { display: false },
              tooltip: { enabled: false },
            },
          },
        });
      }

      function renderChartToggles(sortedPaths) {
        const container = document.getElementById("chartToggles");
        container.innerHTML = "";

        const getScenarioSummary = (path) => {
          const route = path
            .slice(1)
            .map((p) => (p.choice === "change" ? "変" : "進"));
          const routeText = route.join("→");
          const summaries = {
            "進→進→進": "信じた道を、まっすぐ進んでいく未来",
            "進→進→変": "じっくり育てたチカラを、新しい世界で試す未来",
            "進→変→進": "寄り道で得たヒントで、本来の道を豊かにする未来",
            "進→変→変": "変化の波を乗りこなし、軽やかに進んでいく未来",
            "変→進→進":
              "新しい世界に飛び込み、そこを「自分の居場所」にする未来",
            "変→進→変": "ひとつの場所に安住せず、自由に可能性を試す未来",
            "変→変→進": "試行錯誤の旅を経て、「これだ」と思える道に出会う未来",
            "変→変→変": "常識を塗り替え、新しい時代を切り拓いていく未来",
          };
          return summaries[routeText] || "カスタム経路";
        };

        sortedPaths.forEach((path, index) => {
          const color =
            summaryChartInstance.data.datasets[index].originalBorderColor;
          const finalScore = path[path.length - 1].S7_総合評価スコア;
          const scenarioSummary = getScenarioSummary(path);

          const legendItem = document.createElement("div");

          legendItem.className =
            "toggle-label text-xs p-2 rounded-lg bg-gray-800/50 border border-gray-700/50 w-full flex-col h-full";
          legendItem.dataset.index = index;
          legendItem.title = `シナリオ ${index + 1}: ${path
            .slice(1)
            .map((p) => (p.choice === "change" ? "変" : "進"))
            .join("→")}`;

          legendItem.innerHTML = `
        <div class="flex items-center w-full mb-1">
          <span class="toggle-legend" style="background-color: ${color};"></span>
          <span class="font-bold text-gray-200">シナリオ ${
            index + 1
          } (${finalScore}点)</span>
        </div>
        <span class="text-gray-400 text-[10px] w-full text-left">${scenarioSummary}</span>
      `;

          const overallTrend = evaluateSpiralProgress(path[0], path[3]);
          const firstStepTrend = evaluateSpiralProgress(path[0], path[1]);

          legendItem.addEventListener("click", () => {
            showScenarioModal(path, index, overallTrend, firstStepTrend);
          });

          container.appendChild(legendItem);
        });
      }

      function showModal(content) {
        document.getElementById("modalBody").innerHTML = content;
        const modalContainer = document.getElementById("modalContainer");
        modalContainer.classList.remove("hidden");
        document.body.style.overflow = "hidden";
        setTimeout(() => {
          document.getElementById("modalOverlay").classList.remove("opacity-0");
          document.getElementById("modalContent").classList.remove("scale-95");
        }, 10);
      }

      function showScenarioModal(path, index, overallTrend, firstStepTrend) {
        const rankLabels = ["S", "A", "B", "C", "D", "E", "F", "H"];
        const rankClass = `rank-${rankLabels[index].toLowerCase()}`;
        let trendHtml = "";
        if (firstStepTrend && firstStepTrend.trend === "危険な下降") {
          trendHtml = `<div class="p-3 rounded-lg mb-4 bg-red-900/80 border border-red-600 text-sm"><p class="font-bold text-red-200">【注意】最初のステップは危険な下降です</p><p class="text-xs text-gray-200 mt-1">このシナリオは「${overallTrend.trend}」を目指しますが、初期段階で状況が大きく悪化するリスクを伴います。</p></div>`;
        } else {
          trendHtml = `<div class="p-3 rounded-lg mb-4 ${overallTrend.colorClass}"><h3 class="font-bold text-lg">${overallTrend.trend}</h3><p class="text-sm mt-1">${overallTrend.message}</p></div>`;
        }
        let modalContentHtml = `<div class="flex items-center justify-between mb-4"><h2 class="text-2xl font-bold text-indigo-300">シナリオ ${
          index + 1
        } の詳細</h2><span class="rank-badge ${rankClass} text-lg">${
          rankLabels[index]
        }</span></div>${trendHtml}`;

        const getScoreDiffHtml = (currentScore, prevScore) => {
          if (typeof prevScore !== "number") return "";
          const diff = Math.round((currentScore - prevScore) * 10) / 10;
          let icon = "";
          let colorClass = "diff-zero";
          if (diff > 0) {
            icon = "▲";
            colorClass = "diff-up";
          } else if (diff < 0) {
            icon = "▼";
            colorClass = "diff-down";
          } else {
            return `<span class="ml-2 text-xs w-10 text-center ${colorClass}">±0</span>`;
          }
          return `<span class="ml-2 text-xs w-10 text-left flex items-center ${colorClass}">${icon}${Math.abs(
            diff
          )}</span>`;
        };

        path.forEach((step, stepIndex) => {
          const phaseLabels = ["現在地", "フェーズ1", "フェーズ2", "フェーズ3"];
          const isYongYao = step.爻 === "用九" || step.爻 === "用六";
          const previousStep = stepIndex > 0 ? path[stepIndex - 1] : null;
          const stepWrapperClass = isYongYao ? "yong-yao-step" : "";
          const stepTitleIcon = isYongYao
            ? '<span class="yong-yao-title-icon">☯</span>'
            : "";

          const s1_diff = getScoreDiffHtml(
            step.S1_基本スコア,
            previousStep?.S1_基本スコア
          );
          const s2_diff = getScoreDiffHtml(
            step.S2_ポテンシャル,
            previousStep?.S2_ポテンシャル
          );
          const s3_diff = getScoreDiffHtml(
            step.S3_安定性スコア,
            previousStep?.S3_安定性スコア
          );
          const s4_diff = getScoreDiffHtml(
            step.S4_リスク,
            previousStep?.S4_リスク
          );
          const s6_diff = getScoreDiffHtml(
            step.S6_変動性スコア,
            previousStep?.S6_変動性スコア
          );
          const s7_diff = getScoreDiffHtml(
            step.S7_総合評価スコア,
            previousStep?.S7_総合評価スコア
          );

          let guidelineHtml = "";
          if (stepIndex < path.length - 1) {
            const nextStep = path[stepIndex + 1];

            const targetName = `${step["親となる卦"]} ${step.爻}`;
            const normalizedTargetName = `${step["親となる卦"]} ${step.爻}`
              .replace(/\s+/g, " ")
              .trim();

            const guidelineData =
              typeof window.koudoShishinData !== "undefined"
                ? window.koudoShishinData.find(
                    (item) =>
                      item.name.replace(/\s+/g, " ").trim() === targetName
                  )
                : null;

            let actionGuidelineTitle = "",
              actionGuidelineText = "",
              bgColor = "";

            if (guidelineData) {
              if (nextStep.choice === "change") {
                actionGuidelineTitle = `<p class="font-bold text-purple-300">行動指針【変】：状況を転換する</p>`;
                actionGuidelineText = `<p class="text-xs text-gray-300 mt-1">${guidelineData.hen}</p>`;
                bgColor = "bg-purple-900/40 border border-purple-700/60";
              } else {
                actionGuidelineTitle = `<p class="font-bold text-teal-300">行動指針【進】：テーマを深化させる</p>`;
                actionGuidelineText = `<p class="text-xs text-gray-300 mt-1">${guidelineData.shin}</p>`;
                bgColor = "bg-teal-900/40 border border-teal-700/60";
              }
            } else {
              actionGuidelineTitle = `<p class="font-bold text-yellow-400">行動指針</p>`;
              actionGuidelineText = `<p class="text-xs text-gray-500 mt-1">（行動指針データが見つかりませんでした。）</p>`;
              bgColor = "bg-gray-700/50 border border-gray-600";
            }
            guidelineHtml = `<div class="mt-4 pt-4 border-t border-gray-700/50"><div class="p-3 rounded-lg text-sm ${bgColor}">${actionGuidelineTitle}${actionGuidelineText}</div></div>`;
          }

          modalContentHtml += `
        <div class="py-4 px-4 border-b border-gray-700 last:border-b-0 ${stepWrapperClass}">
          <h4 class="text-lg font-semibold text-gray-100 flex items-center">${
            phaseLabels[stepIndex]
          }: ${step["親となる卦"]} ${step.爻} ${stepTitleIcon}</h4>
          <p class="text-sm text-yellow-300 my-1">テーマ: ${
            step.キーワード || ""
          }</p>
          <p class="text-xs text-gray-400 mt-1">${step.現代解釈の要約}</p>
          <div class="mt-4 grid grid-cols-2 sm:grid-cols-2 gap-x-4 gap-y-1 text-xs">
            <div class="flex justify-between items-center"><span class="text-gray-400">基本:</span><div class="flex items-center"><span class="font-mono w-6 text-right">${
              step.S1_基本スコア
            }</span>${s1_diff}</div></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">ポテンシャル:</span><div class="flex items-center"><span class="font-mono w-6 text-right">${
              step.S2_ポテンシャル
            }</span>${s2_diff}</div></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">安定性:</span><div class="flex items-center"><span class="font-mono w-6 text-right">${
              step.S3_安定性スコア
            }</span>${s3_diff}</div></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">リスク:</span><div class="flex items-center"><span class="font-mono w-6 text-right text-red-400">${
              step.S4_リスク
            }</span>${s4_diff}</div></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">変動性:</span><div class="flex items-center"><span class="font-mono w-6 text-right">${
              step.S6_変動性スコア
            }</span>${s6_diff}</div></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">主体性:</span><span>${
              step.S5_主体性
            }</span></div>
            <div class="col-span-full flex justify-between items-center font-bold border-t border-gray-600 pt-2 mt-2">
              <span class="text-gray-300">総合評価:</span>
              <div class="flex items-center">
                <span class="font-mono text-lg text-indigo-300">${
                  step.S7_総合評価スコア
                }</span>
                ${s7_diff.replace("text-xs", "text-sm").replace("w-10", "w-12")}
              </div>
            </div>
          </div>
          ${guidelineHtml}
        </div>
      `;
        });

        showModal(modalContentHtml);
      }

      function showCurrentStateModal(state) {
        const scoreEval = getScoreEvaluation(state.S7_総合評価スコア);
        const costEval = getTransitionCostEvaluation(100 - state.S6_変動性スコア);

        const modalContent = `
          <h2 class="text-2xl font-bold text-indigo-300 mb-4">現在地の詳細分析</h2>
          <div class="space-y-4">
            <div>
              <h3 class="text-xl font-semibold text-yellow-300">現在地: ${state["親となる卦"]} ${state.爻}</h3>
              <p class="text-sm text-yellow-200 mt-1">テーマ: ${state.キーワード || ""}</p>
              <p class="text-gray-300 mt-2 text-sm">${state.現代解釈の要約}</p>
            </div>
            <div class="border-t border-gray-700/50 pt-4">
              <h4 class="font-bold text-gray-300">総合評価</h4>
              <div class="flex items-baseline">
                <p class="text-3xl font-bold">${state.S7_総合評価スコア} 点</p>
                <span class="eval-label ${scoreEval.colorClass}">${scoreEval.label}</span>
              </div>
              <p class="text-xs">※ ${scoreEval.desc}</p>
            </div>
            <div class="border-t border-gray-700/50 pt-4">
              <h4 class="font-bold text-gray-300">変化のしやすさ (移行コスト)</h4>
              <div class="flex items-baseline">
                <p class="text-3xl font-bold">${100 - state.S6_変動性スコア} 点</p>
                <span class="eval-label ${costEval.colorClass}">${costEval.label}</span>
              </div>
              <p class="text-xs">※ ${costEval.desc}</p>
            </div>
            <div class="border-t border-gray-700/50 pt-4">
              <h4 class="font-bold text-gray-300">詳細パラメータ</h4>
              <ul class="text-sm text-gray-400 space-y-1 mt-2">
                <li>基本スコア: ${state.S1_基本スコア}</li>
                <li>ポテンシャル: ${state.S2_ポテンシャル}</li>
                <li>安定性スコア: ${state.S3_安定性スコア}</li>
                <li>リスク: ${state.S4_リスク}</li>
                <li>変動性スコア: ${state.S6_変動性スコア}</li>
                <li>主体性: ${state.S5_主体性}</li>
              </ul>
            </div>
          </div>
        `;
        showModal(modalContent);
      }

      function hideModal() {
        const modalContainer = document.getElementById("modalContainer");
        document.getElementById("modalOverlay").classList.add("opacity-0");
        document.getElementById("modalContent").classList.add("scale-95");
        setTimeout(() => {
          modalContainer.classList.add("hidden");
          document.body.style.overflow = "auto";
        }, 300);
      }

      function showHelpModal() {
        const helpContent = `
          <h2 class="text-2xl font-bold text-indigo-300 mb-4">HaQei マルチバース・アナライザーとは？</h2>
          <div class="prose-custom space-y-4">
            <p>「HaQei（ハケイ）」は、古代中国の知恵である「易経」と、現代のデータ分析・AI技術を融合させた、全く新しい未来予測ツールです。</p>
            <p>あなたの「今」の状況を易経の「卦（か）」と「爻（こう）」に照らし合わせ、そこから導き出される8つの異なる未来の可能性を「マルチバース（多次元宇宙）」として可視化します。</p>
            <p>単なる占いではなく、各未来シナリオが持つ「スコア」や「トレンド」、そして「行動指針」を通じて、あなたがより良い未来を選択するための「羅針盤」となることを目指しています。</p>
            <h3 class="text-xl font-bold text-yellow-300 mt-6 mb-2">使い方</h3>
            <ol class="list-decimal list-inside space-y-2">
              <li><strong>あなたの状況を入力:</strong> テキストボックスに、今抱えている悩みや課題、状況を自由に記述してください。AIがあなたの言葉から最適な「卦」と「爻」を推測します。</li>
              <li><strong>未来分岐グラフ:</strong> AIが推測した「現在地」から、8つの異なる未来シナリオがどのように展開していくかをグラフで確認できます。各シナリオの最終的な「総合評価スコア」や「トレンド」が一目で分かります。</li>
              <li><strong>シナリオ詳細:</strong> 気になるシナリオをクリックすると、その未来に至るまでの詳細なステップ、各フェーズでの状況、そして具体的な「行動指針」が表示されます。</li>
              <li><strong>プロレポート:</strong> より詳細なAIによる物語形式のレポートは、有料版で提供されます。</li>
            </ol>
            <h3 class="text-xl font-bold text-yellow-300 mt-6 mb-2">易経とは？</h3>
            <p>易経は、約3000年前に成立したとされる中国最古の古典の一つで、森羅万象の変化の法則を説いたものです。64の「卦」と384の「爻」によって、あらゆる状況とそれに伴う変化のパターンが示されています。HaQeiは、この普遍的な知恵を現代の文脈に落とし込み、あなたの意思決定をサポートします。</p>
          </div>
        `;
        showModal(helpContent);
      }

      function showParameterHelpModal() {
        const helpContent = `
          <h2 class="text-2xl font-bold text-indigo-300 mb-6">グラフの見方</h2>
          <div class="prose-custom space-y-4">
            <p>グラフは、あなたの現在の状況と、そこから展開する未来の各フェーズにおける「総合評価スコア」の推移を示しています。</p>
            <h3 class="text-xl font-bold text-yellow-300 mt-6 mb-2">スコアの意味</h3>
            <ul class="list-disc list-inside space-y-2">
              <li><strong>基本スコア:</strong> あなたの現状の基盤となるエネルギーや安定性を示します。</li>
              <li><strong>ポテンシャル:</strong> 今後の成長や発展の可能性を示します。</li>
              <li><strong>安定性スコア:</strong> 状況の安定度、外部からの影響の受けにくさを示します。</li>
              <li><strong>リスク:</strong> 潜在的な問題や困難の度合いを示します。スコアが高いほどリスクも高いです。</li>
              <li><strong>変動性スコア:</strong> 状況が変化しやすい度合いを示します。スコアが高いほど、あなたの行動が結果に繋がりやすいです。</li>
              <li><strong>主体性:</strong> その状況において、あなたが能動的に動くべきか、受動的に待つべきかを示します。</li>
              <li><strong>総合評価スコア:</strong> 上記の要素を総合した、現在の状況または未来のフェーズの全体的な評価です。</li>
            </ul>
            <h3 class="text-xl font-bold text-yellow-300 mt-6 mb-2">トレンドの意味</h3>
            <p>各シナリオのカードに表示される「全体トレンド」と「初期ステップ」は、そのシナリオがどのような変化の傾向を持つかを示します。</p>
            <ul class="list-disc list-inside space-y-2">
              <li><strong>飛躍的成長 / 急回復:</strong> 状況が劇的に好転し、大きくスコアが上昇する傾向です。</li>
              <li><strong>安定的成長 / 発展的成長 / 成長:</strong> 着実にスコアが上昇し、良い方向へ進む傾向です。</li>
              <li><strong>未来への投資 / 良い停滞:</strong> スコアは大きく変動しないものの、将来のための準備や基盤固めが進む傾向です。</li>
              <li><strong>注意すべき停滞:</strong> スコアが停滞し、状況が膠着している傾向です。新たな行動が必要かもしれません。</li>
              <li><strong>戦略的下降:</strong> 一時的にスコアが下がるものの、リスクを回避したり、長期的な利益のための戦略的な下降です。</li>
              <li><strong>危険な下降 / 下降傾向:</strong> 状況が悪化し、スコアが下降する傾向です。注意が必要です。</li>
            </ul>
          </div>
        `;
        showModal(helpContent);
      }

      function generateAllPaths(hexagramNumber, lineNumber) {
        const startState = H384_DATA.find(
          (d) => d.卦番号 === hexagramNumber && d.爻番号 === lineNumber
        );
        if (!startState) return [];

        const paths = [];
        const choices = ["stagnate", "change"];

        // 3フェーズの全ての組み合わせを生成
        for (const c1 of choices) {
          for (const c2 of choices) {
            for (const c3 of choices) {
              const path = [startState];
              let currentState = startState;

              // フェーズ1
              const nextState1 = getNextState(currentState, c1);
              if (!nextState1) continue;
              path.push({ ...nextState1, choice: c1 });
              currentState = nextState1;

              // フェーズ2
              const nextState2 = getNextState(currentState, c2);
              if (!nextState2) continue;
              path.push({ ...nextState2, choice: c2 });
              currentState = nextState2;

              // フェーズ3
              const nextState3 = getNextState(currentState, c3);
              if (!nextState3) continue;
              path.push({ ...nextState3, choice: c3 });

              paths.push(path);
            }
          }
        }
        return paths;
      }

      function getNextState(currentState, choice) {
        const currentHexagram = currentState.卦番号;
        const currentLine = currentState.爻番号;

        let nextHexagramId;
        let nextLineNumber;

        if (choice === "stagnate") {
          // 「進」の場合：現在の卦の次の爻へ
          if (currentLine < 6) {
            nextHexagramId = currentHexagram;
            nextLineNumber = currentLine + 1;
          } else {
            // 6爻の場合は、その卦の「用九」または「用六」へ
            const yongYao = H384_DATA.find(
              (d) =>
                d.卦番号 === currentHexagram &&
                (d.爻 === "用九" || d.爻 === "用六")
            );
            if (yongYao) {
              nextHexagramId = yongYao.卦番号;
              nextLineNumber = yongYao.爻番号;
            } else {
              return null; // 用爻データがない場合はパスを生成しない
            }
          }
        } else if (choice === "change") {
          // 「変」の場合：変爻した卦の初爻へ
          const changedHexagramData = HAQEI_DATA.H64_DATA.find(
            (h) => h.卦番号 === currentHexagram
          );
          if (!changedHexagramData) return null;

          const changedHexagramId = changedHexagramData[
            `変爻${currentLine}卦番号`
          ];
          if (!changedHexagramId) return null;

          nextHexagramId = changedHexagramId;
          nextLineNumber = 1; // 変爻した卦の初爻
        } else {
          return null; // 不明な選択
        }

        return H384_DATA.find(
          (d) => d.卦番号 === nextHexagramId && d.爻番号 === nextLineNumber
        );
      }

      function setupInteraction(sortedPaths) {
        const choiceCardShin = document.getElementById("choiceCardShin");
        const choiceCardHen = document.getElementById("choiceCardHen");
        const detailCards = document.querySelectorAll("#detailCardsContainer .card");

        const resetAllHighlights = () => {
          resetChartHighlights();
          detailCards.forEach(card => {
            card.classList.remove("dimmed-by-choice");
            card.classList.remove("ai-recommended"); // AI推奨もリセット
          });
          document.getElementById("aiRecommendationMessage").classList.remove("hidden"); // AI推奨メッセージも再表示
        };

        choiceCardShin.addEventListener("click", () => {
          highlightMultipleScenarios("stagnate", sortedPaths);
          detailCards.forEach(card => {
            const index = parseInt(card.dataset.index);
            const pathChoice = sortedPaths[index][1]?.choice;
            if (pathChoice !== "stagnate") {
              card.classList.add("dimmed-by-choice");
            } else {
              card.classList.remove("dimmed-by-choice");
            }
            card.classList.remove("ai-recommended"); // 選択時はAI推奨を解除
          });
          document.getElementById("aiRecommendationMessage").classList.add("hidden"); // AI推奨メッセージを非表示
        });

        choiceCardHen.addEventListener("click", () => {
          highlightMultipleScenarios("change", sortedPaths);
          detailCards.forEach(card => {
            const index = parseInt(card.dataset.index);
            const pathChoice = sortedPaths[index][1]?.choice;
            if (pathChoice !== "change") {
              card.classList.add("dimmed-by-choice");
            } else {
              card.classList.remove("dimmed-by-choice");
            }
            card.classList.remove("ai-recommended"); // 選択時はAI推奨を解除
          });
          document.getElementById("aiRecommendationMessage").classList.add("hidden"); // AI推奨メッセージを非表示
        });

        // カードやトグルからマウスが離れたらハイライトをリセット
        document.getElementById("detailCardsContainer").addEventListener("mouseleave", resetAllHighlights);
        document.getElementById("chartToggles").addEventListener("mouseleave", resetAllHighlights);

        // 各カードにマウスオーバーイベントを追加
        detailCards.forEach(card => {
          card.addEventListener("mouseenter", () => {
            const index = parseInt(card.dataset.index);
            highlightScenario(index);
          });
        });

        // 各トグルにマウスオーバーイベントを追加
        document.querySelectorAll(".toggle-label").forEach(toggle => {
          toggle.addEventListener("mouseenter", () => {
            const index = parseInt(toggle.dataset.index);
            highlightScenario(index);
          });
        });

        // Deep Diveボタンのイベントリスナー
        document.querySelectorAll(".deep-dive-btn").forEach(button => {
          button.addEventListener("click", handleGoToReportClick);
        });
      }

    </script>
  </body>
</html>