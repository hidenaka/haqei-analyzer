/**\n * CodeSplitter.js - Advanced Code Splitting Utility\n * \n * Phase 2 Optimization: Runtime code analysis and splitting\n * Identifies and manages code that can be split for better loading\n * \n * Features:\n * - Dead code detection\n * - Duplicate code identification  \n * - Dynamic import optimization\n * - Module dependency analysis\n */\n\nclass CodeSplitter {\n  constructor(options = {}) {\n    this.options = {\n      enableAnalysis: true,\n      enableSplitting: true,\n      enableOptimization: true,\n      analysisDepth: 'medium', // light, medium, deep\n      splitThreshold: 50 * 1024, // 50KB\n      ...options\n    };\n    \n    // Analysis results\n    this.analysis = {\n      modules: new Map(),\n      dependencies: new Map(),\n      duplicates: [],\n      deadCode: [],\n      opportunities: []\n    };\n    \n    // Splitting strategies\n    this.strategies = {\n      byFeature: this.splitByFeature.bind(this),\n      byRoute: this.splitByRoute.bind(this),\n      bySize: this.splitBySize.bind(this),\n      byUsage: this.splitByUsage.bind(this)\n    };\n    \n    // Performance tracking\n    this.metrics = {\n      analysisTime: 0,\n      splitsIdentified: 0,\n      potentialSavings: 0,\n      optimizationScore: 0\n    };\n    \n    console.log('✂️ CodeSplitter initialized - Advanced splitting analysis ready');\n  }\n  \n  /**\n   * Analyze current codebase for splitting opportunities\n   */\n  async analyzeCodebase() {\n    const startTime = performance.now();\n    console.log('🔍 Analyzing codebase for splitting opportunities...');\n    \n    try {\n      // Step 1: Analyze loaded modules\n      await this.analyzeLoadedModules();\n      \n      // Step 2: Build dependency graph\n      this.buildDependencyGraph();\n      \n      // Step 3: Identify splitting opportunities\n      this.identifySplittingOpportunities();\n      \n      // Step 4: Calculate optimization potential\n      this.calculateOptimizationPotential();\n      \n      const analysisTime = performance.now() - startTime;\n      this.metrics.analysisTime = analysisTime;\n      \n      console.log(`✅ Codebase analysis complete in ${analysisTime.toFixed(0)}ms`);\n      return this.generateAnalysisReport();\n      \n    } catch (error) {\n      console.error('❌ Codebase analysis failed:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Analyze currently loaded modules\n   */\n  async analyzeLoadedModules() {\n    const scripts = document.querySelectorAll('script[src]');\n    const dynamicModules = window.moduleLoader ? \n      Array.from(window.moduleLoader.loadedModules.keys()) : [];\n    \n    // Analyze static scripts\n    scripts.forEach(script => {\n      this.analyzeScript(script.src);\n    });\n    \n    // Analyze dynamic modules\n    dynamicModules.forEach(modulePath => {\n      this.analyzeModule(modulePath);\n    });\n    \n    console.log(`📊 Analyzed ${scripts.length} static scripts and ${dynamicModules.length} dynamic modules`);\n  }\n  \n  /**\n   * Analyze individual script\n   */\n  analyzeScript(scriptUrl) {\n    const moduleInfo = {\n      url: scriptUrl,\n      type: 'static',\n      size: 0,\n      dependencies: [],\n      exports: [],\n      functions: [],\n      classes: [],\n      splitOpportunities: []\n    };\n    \n    // Estimate size and analyze content if possible\n    this.estimateModuleSize(moduleInfo);\n    this.identifyModuleType(moduleInfo);\n    \n    this.analysis.modules.set(scriptUrl, moduleInfo);\n  }\n  \n  /**\n   * Analyze dynamic module\n   */\n  analyzeModule(modulePath) {\n    const moduleInfo = {\n      url: modulePath,\n      type: 'dynamic',\n      size: 0,\n      dependencies: [],\n      exports: [],\n      functions: [],\n      classes: [],\n      splitOpportunities: []\n    };\n    \n    // Get module data from ModuleLoader if available\n    if (window.moduleLoader && window.moduleLoader.loadedModules.has(modulePath)) {\n      const moduleData = window.moduleLoader.loadedModules.get(modulePath);\n      moduleInfo.size = moduleData.estimatedSize || 0;\n      moduleInfo.loadTime = moduleData.loadTime || 0;\n    }\n    \n    this.identifyModuleType(moduleInfo);\n    this.analysis.modules.set(modulePath, moduleInfo);\n  }\n  \n  /**\n   * Estimate module size\n   */\n  estimateModuleSize(moduleInfo) {\n    // Use Performance API if available\n    const resourceEntries = performance.getEntriesByName(moduleInfo.url);\n    if (resourceEntries.length > 0) {\n      const entry = resourceEntries[0];\n      moduleInfo.size = entry.transferSize || entry.encodedBodySize || 0;\n      moduleInfo.loadTime = entry.duration || 0;\n    }\n  }\n  \n  /**\n   * Identify module type and characteristics\n   */\n  identifyModuleType(moduleInfo) {\n    const url = moduleInfo.url;\n    \n    // Categorize by URL patterns\n    if (url.includes('/lib/')) {\n      moduleInfo.category = 'library';\n      moduleInfo.splitPriority = 'high'; // Libraries are good candidates\n    } else if (url.includes('/components/')) {\n      moduleInfo.category = 'component';\n      moduleInfo.splitPriority = 'medium';\n    } else if (url.includes('/core/')) {\n      moduleInfo.category = 'core';\n      moduleInfo.splitPriority = 'low'; // Core modules usually needed early\n    } else if (url.includes('/data/')) {\n      moduleInfo.category = 'data';\n      moduleInfo.splitPriority = 'high'; // Data can often be lazy loaded\n    } else if (url.includes('/utils/')) {\n      moduleInfo.category = 'utility';\n      moduleInfo.splitPriority = 'medium';\n    } else {\n      moduleInfo.category = 'unknown';\n      moduleInfo.splitPriority = 'low';\n    }\n    \n    // Size-based priority adjustment\n    if (moduleInfo.size > this.options.splitThreshold) {\n      moduleInfo.splitPriority = 'high';\n    }\n  }\n  \n  /**\n   * Build dependency graph\n   */\n  buildDependencyGraph() {\n    console.log('🕸️ Building dependency graph...');\n    \n    this.analysis.modules.forEach((moduleInfo, modulePath) => {\n      // Analyze dependencies based on common patterns\n      const dependencies = this.extractDependencies(moduleInfo);\n      this.analysis.dependencies.set(modulePath, dependencies);\n    });\n  }\n  \n  /**\n   * Extract dependencies from module\n   */\n  extractDependencies(moduleInfo) {\n    const dependencies = [];\n    \n    // Common dependency patterns in HAQEI codebase\n    const dependencyPatterns = {\n      'BaseComponent': ['/js/shared/core/BaseComponent.js'],\n      'StorageManager': ['/js/shared/core/StorageManager.js', '/js/shared/core/MicroStorageManager.js'],\n      'DataManager': ['/js/shared/core/DataManager.js'],\n      'Calculator': ['/js/os-analyzer/core/Calculator.js'],\n      'Chart': ['/js/lib/chart.min.js'],\n      'VirtualQuestionFlow': [\n        '/js/os-analyzer/components/VirtualQuestionFlow-core.js',\n        '/js/os-analyzer/components/VirtualQuestionFlow-renderer.js'\n      ]\n    };\n    \n    // Check for dependency patterns in URL\n    Object.entries(dependencyPatterns).forEach(([pattern, deps]) => {\n      if (moduleInfo.url.includes(pattern) || \n          moduleInfo.category === pattern.toLowerCase()) {\n        dependencies.push(...deps);\n      }\n    });\n    \n    return [...new Set(dependencies)]; // Remove duplicates\n  }\n  \n  /**\n   * Identify splitting opportunities\n   */\n  identifySplittingOpportunities() {\n    console.log('🎯 Identifying splitting opportunities...');\n    \n    const opportunities = [];\n    \n    this.analysis.modules.forEach((moduleInfo, modulePath) => {\n      // Strategy 1: Split by feature\n      const featureOpportunities = this.strategies.byFeature(moduleInfo);\n      opportunities.push(...featureOpportunities);\n      \n      // Strategy 2: Split by size\n      const sizeOpportunities = this.strategies.bySize(moduleInfo);\n      opportunities.push(...sizeOpportunities);\n      \n      // Strategy 3: Split by usage patterns\n      const usageOpportunities = this.strategies.byUsage(moduleInfo);\n      opportunities.push(...usageOpportunities);\n    });\n    \n    // Deduplicate and prioritize\n    this.analysis.opportunities = this.prioritizeOpportunities(opportunities);\n    this.metrics.splitsIdentified = this.analysis.opportunities.length;\n  }\n  \n  /**\n   * Split by feature strategy\n   */\n  splitByFeature(moduleInfo) {\n    const opportunities = [];\n    \n    // Identify feature-based splitting opportunities\n    const featurePatterns = {\n      'help-system': {\n        trigger: 'onDemand',\n        priority: 'high',\n        estimatedSaving: '400KB'\n      },\n      'chart': {\n        trigger: 'onResults',\n        priority: 'high', \n        estimatedSaving: '200KB'\n      },\n      'analysis-engine': {\n        trigger: 'onAnalysis',\n        priority: 'medium',\n        estimatedSaving: '800KB'\n      },\n      'visualization': {\n        trigger: 'onResults',\n        priority: 'medium',\n        estimatedSaving: '300KB'\n      }\n    };\n    \n    Object.entries(featurePatterns).forEach(([feature, config]) => {\n      if (moduleInfo.url.includes(feature) || \n          moduleInfo.category === feature) {\n        opportunities.push({\n          type: 'feature',\n          module: moduleInfo.url,\n          feature,\n          ...config,\n          currentSize: moduleInfo.size\n        });\n      }\n    });\n    \n    return opportunities;\n  }\n  \n  /**\n   * Split by size strategy\n   */\n  splitBySize(moduleInfo) {\n    const opportunities = [];\n    \n    if (moduleInfo.size > this.options.splitThreshold) {\n      opportunities.push({\n        type: 'size',\n        module: moduleInfo.url,\n        reason: 'Large module',\n        currentSize: moduleInfo.size,\n        priority: moduleInfo.size > 100 * 1024 ? 'high' : 'medium',\n        strategy: 'chunk-splitting',\n        estimatedSaving: Math.floor(moduleInfo.size * 0.6) + 'B'\n      });\n    }\n    \n    return opportunities;\n  }\n  \n  /**\n   * Split by usage strategy\n   */\n  splitByUsage(moduleInfo) {\n    const opportunities = [];\n    \n    // Identify rarely used modules\n    const usagePatterns = {\n      'debug': 'development-only',\n      'test': 'development-only', \n      'admin': 'admin-only',\n      'advanced': 'power-user',\n      'experimental': 'optional'\n    };\n    \n    Object.entries(usagePatterns).forEach(([pattern, usage]) => {\n      if (moduleInfo.url.includes(pattern)) {\n        opportunities.push({\n          type: 'usage',\n          module: moduleInfo.url,\n          usage,\n          priority: 'high',\n          strategy: 'conditional-loading',\n          currentSize: moduleInfo.size,\n          estimatedSaving: moduleInfo.size + 'B'\n        });\n      }\n    });\n    \n    return opportunities;\n  }\n  \n  /**\n   * Prioritize splitting opportunities\n   */\n  prioritizeOpportunities(opportunities) {\n    return opportunities\n      .filter(opp => opp.currentSize > 1024) // Only meaningful sizes\n      .sort((a, b) => {\n        // Sort by priority and potential savings\n        const priorityOrder = { high: 3, medium: 2, low: 1 };\n        const aPriority = priorityOrder[a.priority] || 0;\n        const bPriority = priorityOrder[b.priority] || 0;\n        \n        if (aPriority !== bPriority) {\n          return bPriority - aPriority;\n        }\n        \n        // Secondary sort by size\n        return b.currentSize - a.currentSize;\n      })\n      .slice(0, 20); // Keep top 20 opportunities\n  }\n  \n  /**\n   * Calculate optimization potential\n   */\n  calculateOptimizationPotential() {\n    let totalSavings = 0;\n    let totalSize = 0;\n    \n    this.analysis.modules.forEach((moduleInfo) => {\n      totalSize += moduleInfo.size;\n    });\n    \n    this.analysis.opportunities.forEach((opportunity) => {\n      const savingStr = opportunity.estimatedSaving;\n      const saving = parseInt(savingStr) || 0;\n      totalSavings += saving;\n    });\n    \n    this.metrics.potentialSavings = totalSavings;\n    this.metrics.optimizationScore = totalSize > 0 ? \n      Math.min(100, (totalSavings / totalSize * 100)) : 0;\n  }\n  \n  /**\n   * Generate analysis report\n   */\n  generateAnalysisReport() {\n    const report = {\n      summary: {\n        modulesAnalyzed: this.analysis.modules.size,\n        splittingOpportunities: this.analysis.opportunities.length,\n        potentialSavings: this.formatBytes(this.metrics.potentialSavings),\n        optimizationScore: this.metrics.optimizationScore.toFixed(1) + '%'\n      },\n      opportunities: this.analysis.opportunities.map(opp => ({\n        ...opp,\n        currentSize: this.formatBytes(opp.currentSize),\n        estimatedSaving: this.formatBytes(parseInt(opp.estimatedSaving) || 0)\n      })),\n      recommendations: this.generateRecommendations(),\n      metrics: this.metrics\n    };\n    \n    console.log('📊 Code Splitting Analysis Report:');\n    console.log('=' .repeat(50));\n    console.log(`📦 Modules Analyzed: ${report.summary.modulesAnalyzed}`);\n    console.log(`✂️ Splitting Opportunities: ${report.summary.splittingOpportunities}`);\n    console.log(`💾 Potential Savings: ${report.summary.potentialSavings}`);\n    console.log(`🎯 Optimization Score: ${report.summary.optimizationScore}`);\n    \n    if (report.opportunities.length > 0) {\n      console.log('\\n🎯 Top Opportunities:');\n      report.opportunities.slice(0, 5).forEach((opp, i) => {\n        console.log(`${i + 1}. ${opp.module} (${opp.currentSize} → save ${opp.estimatedSaving})`);\n      });\n    }\n    \n    console.log('=' .repeat(50));\n    \n    return report;\n  }\n  \n  /**\n   * Generate recommendations\n   */\n  generateRecommendations() {\n    const recommendations = [];\n    \n    // High-impact opportunities\n    const highImpact = this.analysis.opportunities.filter(opp => \n      opp.priority === 'high' && opp.currentSize > 50 * 1024\n    );\n    \n    if (highImpact.length > 0) {\n      recommendations.push({\n        type: 'high-impact',\n        message: `${highImpact.length} high-impact splitting opportunities identified`,\n        action: 'Implement dynamic imports for these modules first',\n        modules: highImpact.map(opp => opp.module)\n      });\n    }\n    \n    // Library splitting\n    const libraries = this.analysis.opportunities.filter(opp => \n      opp.module.includes('/lib/')\n    );\n    \n    if (libraries.length > 0) {\n      recommendations.push({\n        type: 'library-splitting',\n        message: 'Third-party libraries can be lazy loaded',\n        action: 'Move chart.js and other libraries to results bundle',\n        modules: libraries.map(opp => opp.module)\n      });\n    }\n    \n    // Feature-based splitting\n    const features = this.analysis.opportunities.filter(opp => \n      opp.type === 'feature'\n    );\n    \n    if (features.length > 0) {\n      recommendations.push({\n        type: 'feature-splitting',\n        message: 'Feature-based code splitting opportunities',\n        action: 'Implement lazy loading for optional features',\n        features: [...new Set(features.map(opp => opp.feature))]\n      });\n    }\n    \n    return recommendations;\n  }\n  \n  /**\n   * Format bytes for display\n   */\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n  \n  /**\n   * Export analysis data\n   */\n  exportAnalysis() {\n    return {\n      analysis: {\n        modules: Array.from(this.analysis.modules.entries()),\n        dependencies: Array.from(this.analysis.dependencies.entries()),\n        opportunities: this.analysis.opportunities\n      },\n      metrics: this.metrics,\n      timestamp: Date.now()\n    };\n  }\n}\n\n// Global initialization\nif (!window.codeSplitter) {\n  window.codeSplitter = new CodeSplitter({\n    enableAnalysis: true,\n    splitThreshold: 50 * 1024\n  });\n  \n  console.log('🎯 Global CodeSplitter initialized');\n  \n  // Debug functions\n  window.analyzeCodeSplitting = () => window.codeSplitter.analyzeCodebase();\n  window.getCodeSplittingReport = () => window.codeSplitter.generateAnalysisReport();\n}\n\n// Export for ES6 modules\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = CodeSplitter;\n}\n