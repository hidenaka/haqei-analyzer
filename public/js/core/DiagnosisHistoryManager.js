// DiagnosisHistoryManager.js - Ë®∫Êñ≠Â±•Ê≠¥ÁÆ°ÁêÜÊ©üËÉΩ
// HaQei Analyzer - Diagnosis History Management System

class DiagnosisHistoryManager {
    constructor(options = {}) {
        this.options = {
            maxHistoryCount: 10,
            retentionDays: 90,
            keyPrefix: 'haqei_history_',
            enableComparison: true,
            enableTrends: true,
            autoCleanup: true,
            encryptData: false,
            ...options
        };
        
        this.storageKey = this.options.keyPrefix + 'records';
        this.metadataKey = this.options.keyPrefix + 'metadata';
        
        if (this.options.autoCleanup) {
            this.initializeCleanupScheduler();
        }
    }

    /**
     * Ë®∫Êñ≠ÁµêÊûú„ÇíÂ±•Ê≠¥„Å´‰øùÂ≠ò
     * @param {Object} analysisResult - ÂàÜÊûêÁµêÊûú
     * @param {Object} metadata - „É°„Çø„Éá„Éº„Çø
     * @returns {string} Â±•Ê≠¥„É¨„Ç≥„Éº„ÉâID
     */
    saveToHistory(analysisResult, metadata = {}) {
        try {
            const recordId = this.generateRecordId();
            const timestamp = Date.now();
            
            const record = {
                id: recordId,
                timestamp: timestamp,
                date: new Date(timestamp).toISOString(),
                analysisResult: this.sanitizeAnalysisResult(analysisResult),
                metadata: {
                    version: '1.0',
                    userAgent: navigator.userAgent,
                    screenResolution: `${screen.width}x${screen.height}`,
                    language: navigator.language,
                    ...this.sanitizeMetadata(metadata)
                },
                summary: this.generateSummary(analysisResult)
            };

            // ÊöóÂè∑Âåñ„Ç™„Éó„Ç∑„Éß„É≥
            if (this.options.encryptData) {
                record.analysisResult = this.encryptData(record.analysisResult);
            }

            // Êó¢Â≠ò„ÅÆÂ±•Ê≠¥„ÇíÂèñÂæó
            const history = this.getHistory();
            
            // Êñ∞„Åó„ÅÑ„É¨„Ç≥„Éº„Éâ„ÇíËøΩÂä†
            history.unshift(record);
            
            // ÊúÄÂ§ß‰ª∂Êï∞Âà∂Èôê
            if (history.length > this.options.maxHistoryCount) {
                history.splice(this.options.maxHistoryCount);
            }

            // ‰øùÂ≠ò
            localStorage.setItem(this.storageKey, JSON.stringify(history));
            
            // „É°„Çø„Éá„Éº„Çø„ÇíÊõ¥Êñ∞
            this.updateMetadata(recordId);
            
            console.log("‚úÖ Diagnosis saved to history:", recordId);
            return recordId;
            
        } catch (error) {
            console.error("‚ùå Failed to save to history:", error);
            throw error;
        }
    }

    /**
     * Â±•Ê≠¥„ÇíÂèñÂæó
     * @returns {Array} Â±•Ê≠¥„É¨„Ç≥„Éº„Éâ„ÅÆÈÖçÂàó
     */
    getHistory() {
        try {
            const historyData = localStorage.getItem(this.storageKey);
            if (!historyData) return [];
            
            const history = JSON.parse(historyData);
            
            // ÊúüÈôêÂàá„Çå„É¨„Ç≥„Éº„Éâ„ÇíÈô§Âéª
            const cutoffDate = Date.now() - (this.options.retentionDays * 24 * 60 * 60 * 1000);
            const validHistory = history.filter(record => record.timestamp > cutoffDate);
            
            // Âæ©Âè∑Âåñ„Ç™„Éó„Ç∑„Éß„É≥
            if (this.options.encryptData) {
                validHistory.forEach(record => {
                    record.analysisResult = this.decryptData(record.analysisResult);
                });
            }
            
            return validHistory;
            
        } catch (error) {
            console.error("‚ùå Failed to get history:", error);
            return [];
        }
    }

    /**
     * ÁâπÂÆö„ÅÆÂ±•Ê≠¥„É¨„Ç≥„Éº„Éâ„ÇíÂèñÂæó
     * @param {string} recordId - „É¨„Ç≥„Éº„ÉâID
     * @returns {Object|null} Â±•Ê≠¥„É¨„Ç≥„Éº„Éâ
     */
    getRecord(recordId) {
        const history = this.getHistory();
        return history.find(record => record.id === recordId) || null;
    }

    /**
     * Â±•Ê≠¥„É¨„Ç≥„Éº„Éâ„ÇíÂâäÈô§
     * @param {string} recordId - „É¨„Ç≥„Éº„ÉâID
     * @returns {boolean} ÂâäÈô§ÊàêÂäüÂèØÂê¶
     */
    deleteRecord(recordId) {
        try {
            const history = this.getHistory();
            const filteredHistory = history.filter(record => record.id !== recordId);
            
            localStorage.setItem(this.storageKey, JSON.stringify(filteredHistory));
            this.updateMetadata();
            
            console.log("üóëÔ∏è History record deleted:", recordId);
            return true;
            
        } catch (error) {
            console.error("‚ùå Failed to delete record:", error);
            return false;
        }
    }

    /**
     * Â±•Ê≠¥„ÇíÂÖ®„Å¶ÂâäÈô§
     */
    clearHistory() {
        try {
            localStorage.removeItem(this.storageKey);
            localStorage.removeItem(this.metadataKey);
            
            console.log("üóëÔ∏è All history cleared");
            return true;
            
        } catch (error) {
            console.error("‚ùå Failed to clear history:", error);
            return false;
        }
    }

    /**
     * Ë®∫Êñ≠ÁµêÊûú„ÅÆÊØîËºÉ
     * @param {string} recordId1 - ÊØîËºÉÂÖÉ„É¨„Ç≥„Éº„ÉâID
     * @param {string} recordId2 - ÊØîËºÉÂÖà„É¨„Ç≥„Éº„ÉâID
     * @returns {Object} ÊØîËºÉÁµêÊûú
     */
    compareResults(recordId1, recordId2) {
        if (!this.options.enableComparison) {
            throw new Error('Comparison feature is disabled');
        }

        const record1 = this.getRecord(recordId1);
        const record2 = this.getRecord(recordId2);
        
        if (!record1 || !record2) {
            throw new Error('One or both records not found');
        }

        return {
            record1: {
                id: record1.id,
                date: record1.date,
                summary: record1.summary
            },
            record2: {
                id: record2.id,
                date: record2.date,
                summary: record2.summary
            },
            comparison: {
                timeDifference: this.calculateTimeDifference(record1.timestamp, record2.timestamp),
                consistencyChange: this.compareConsistencyScores(record1.analysisResult, record2.analysisResult),
                osChanges: this.compareOSChanges(record1.analysisResult, record2.analysisResult),
                keyInsights: this.generateComparisonInsights(record1.analysisResult, record2.analysisResult)
            }
        };
    }

    /**
     * „Éà„É¨„É≥„ÉâÂàÜÊûê
     * @param {number} periodDays - ÂàÜÊûêÊúüÈñìÔºàÊó•Êï∞Ôºâ
     * @returns {Object} „Éà„É¨„É≥„ÉâÂàÜÊûêÁµêÊûú
     */
    analyzeTrends(periodDays = 30) {
        if (!this.options.enableTrends) {
            throw new Error('Trends feature is disabled');
        }

        const history = this.getHistory();
        const cutoffDate = Date.now() - (periodDays * 24 * 60 * 60 * 1000);
        const recentHistory = history.filter(record => record.timestamp > cutoffDate);
        
        if (recentHistory.length < 2) {
            return {
                message: 'ÂçÅÂàÜ„Å™„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇÊúÄ‰Ωé2Âõû„ÅÆË®∫Êñ≠ÁµêÊûú„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ',
                dataPoints: recentHistory.length
            };
        }

        return {
            period: `${periodDays}Êó•Èñì`,
            dataPoints: recentHistory.length,
            consistencyTrend: this.analyzeConsistencyTrend(recentHistory),
            osStabilityTrend: this.analyzeOSStabilityTrend(recentHistory),
            insights: this.generateTrendInsights(recentHistory),
            recommendations: this.generateTrendRecommendations(recentHistory)
        };
    }

    /**
     * ÂÜçË®∫Êñ≠„É™„É≥„ÇØ„ÇíÁîüÊàê
     * @param {string} recordId - ÂèÇÁÖß„Åô„ÇãÂ±•Ê≠¥„É¨„Ç≥„Éº„ÉâID
     * @returns {string} ÂÜçË®∫Êñ≠URL
     */
    generateRetestLink(recordId = null) {
        const baseUrl = window.location.origin + window.location.pathname;
        const params = new URLSearchParams();
        
        params.set('action', 'retest');
        if (recordId) {
            params.set('reference', recordId);
        }
        params.set('timestamp', Date.now().toString());
        
        return `${baseUrl}?${params.toString()}`;
    }

    /**
     * Â±•Ê≠¥Áµ±Ë®à„ÇíÂèñÂæó
     */
    getStatistics() {
        const history = this.getHistory();
        const metadata = this.getMetadata();
        
        if (history.length === 0) {
            return {
                totalDiagnoses: 0,
                firstDiagnosis: null,
                lastDiagnosis: null,
                averageInterval: null,
                mostCommonOS: null
            };
        }

        const timestamps = history.map(record => record.timestamp).sort((a, b) => a - b);
        const intervals = [];
        for (let i = 1; i < timestamps.length; i++) {
            intervals.push(timestamps[i] - timestamps[i-1]);
        }

        return {
            totalDiagnoses: history.length,
            firstDiagnosis: new Date(timestamps[0]),
            lastDiagnosis: new Date(timestamps[timestamps.length - 1]),
            averageInterval: intervals.length > 0 ? 
                Math.round(intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length / (24 * 60 * 60 * 1000)) : null,
            mostCommonOS: this.findMostCommonOS(history),
            storageUsed: this.calculateStorageUsage(),
            metadata: metadata
        };
    }

    /**
     * „Éá„Éº„Çø„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà
     * @param {string} format - „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂΩ¢Âºè ('json', 'csv')
     * @returns {Object} „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÁµêÊûú
     */
    exportData(format = 'json') {
        const history = this.getHistory();
        const statistics = this.getStatistics();
        
        const exportData = {
            metadata: {
                exportDate: new Date().toISOString(),
                version: '1.0',
                recordCount: history.length
            },
            statistics: statistics,
            records: history
        };

        switch (format) {
            case 'json':
                return {
                    success: true,
                    data: JSON.stringify(exportData, null, 2),
                    filename: `haqei_history_${new Date().toISOString().slice(0, 10)}.json`,
                    mimeType: 'application/json'
                };
                
            case 'csv':
                return {
                    success: true,
                    data: this.convertToCSV(history),
                    filename: `haqei_history_${new Date().toISOString().slice(0, 10)}.csv`,
                    mimeType: 'text/csv'
                };
                
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
    }

    /**
     * „Éá„Éº„Çø„Çí„Ç§„É≥„Éù„Éº„Éà
     * @param {string} data - „Ç§„É≥„Éù„Éº„Éà„Éá„Éº„Çø
     * @param {string} format - „Éá„Éº„ÇøÂΩ¢Âºè
     * @returns {Object} „Ç§„É≥„Éù„Éº„ÉàÁµêÊûú
     */
    importData(data, format = 'json') {
        try {
            let importedRecords = [];
            
            switch (format) {
                case 'json':
                    const jsonData = JSON.parse(data);
                    importedRecords = jsonData.records || [];
                    break;
                    
                default:
                    throw new Error(`Unsupported import format: ${format}`);
            }

            // „Éá„Éº„Çø„ÅÆÊ§úË®º
            const validRecords = importedRecords.filter(record => 
                record.id && record.timestamp && record.analysisResult
            );

            // Êó¢Â≠ò„ÅÆÂ±•Ê≠¥„Å®„Éû„Éº„Ç∏
            const existingHistory = this.getHistory();
            const existingIds = new Set(existingHistory.map(record => record.id));
            
            const newRecords = validRecords.filter(record => !existingIds.has(record.id));
            const mergedHistory = [...existingHistory, ...newRecords];
            
            // Êó•ÊôÇÈ†Ü„Åß„ÇΩ„Éº„Éà
            mergedHistory.sort((a, b) => b.timestamp - a.timestamp);
            
            // ÊúÄÂ§ß‰ª∂Êï∞Âà∂Èôê
            if (mergedHistory.length > this.options.maxHistoryCount) {
                mergedHistory.splice(this.options.maxHistoryCount);
            }

            // ‰øùÂ≠ò
            localStorage.setItem(this.storageKey, JSON.stringify(mergedHistory));
            this.updateMetadata();
            
            return {
                success: true,
                importedCount: newRecords.length,
                skippedCount: validRecords.length - newRecords.length,
                totalCount: mergedHistory.length
            };
            
        } catch (error) {
            console.error("‚ùå Failed to import data:", error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    // === „Éó„É©„Ç§„Éô„Éº„Éà„É°„ÇΩ„ÉÉ„Éâ ===

    /**
     * „É¨„Ç≥„Éº„ÉâID„ÇíÁîüÊàê
     */
    generateRecordId() {
        const timestamp = Date.now().toString(36);
        const random = Math.random().toString(36).substring(2);
        return `${timestamp}-${random}`;
    }

    /**
     * ÂàÜÊûêÁµêÊûú„Çí„Çµ„Éã„Çø„Ç§„Ç∫
     */
    sanitizeAnalysisResult(result) {
        // ÂÄã‰∫∫ÊÉÖÂ†±„ÇíÈô§Âéª
        const sanitized = JSON.parse(JSON.stringify(result));
        
        // Èô§ÂéªÂØæË±°„Ç≠„Éº
        const sensitiveKeys = ['userInfo', 'personalData', 'ip', 'sessionId'];
        
        const removeSensitiveData = (obj) => {
            if (typeof obj !== 'object' || obj === null) return;
            
            Object.keys(obj).forEach(key => {
                if (sensitiveKeys.includes(key)) {
                    delete obj[key];
                } else if (typeof obj[key] === 'object') {
                    removeSensitiveData(obj[key]);
                }
            });
        };
        
        removeSensitiveData(sanitized);
        return sanitized;
    }

    /**
     * „É°„Çø„Éá„Éº„Çø„Çí„Çµ„Éã„Çø„Ç§„Ç∫
     */
    sanitizeMetadata(metadata) {
        const safe = {};
        const allowedKeys = ['title', 'notes', 'tags', 'category'];
        
        allowedKeys.forEach(key => {
            if (metadata[key]) {
                safe[key] = metadata[key];
            }
        });
        
        return safe;
    }

    /**
     * „Çµ„Éû„É™„Éº„ÇíÁîüÊàê
     */
    generateSummary(analysisResult) {
        const engineOS = analysisResult.engineOS?.hexagramInfo?.name || '‰∏çÊòé';
        const interfaceOS = analysisResult.interfaceOS?.hexagramInfo?.name || '‰∏çÊòé';
        const safeModeOS = analysisResult.safeModeOS?.hexagramInfo?.name || '‰∏çÊòé';
        const consistency = Math.round((analysisResult.consistencyScore?.overall || 0) * 100);
        
        return {
            engineOS,
            interfaceOS,
            safeModeOS,
            consistencyScore: consistency,
            shortDescription: `${engineOS} | ${interfaceOS} | ${safeModeOS} (‰∏ÄË≤´ÊÄß: ${consistency}%)`
        };
    }

    /**
     * „É°„Çø„Éá„Éº„Çø„ÇíÊõ¥Êñ∞
     */
    updateMetadata(newRecordId = null) {
        const metadata = {
            lastUpdated: Date.now(),
            recordCount: this.getHistory().length,
            version: '1.0'
        };
        
        if (newRecordId) {
            metadata.lastRecordId = newRecordId;
        }
        
        localStorage.setItem(this.metadataKey, JSON.stringify(metadata));
    }

    /**
     * „É°„Çø„Éá„Éº„Çø„ÇíÂèñÂæó
     */
    getMetadata() {
        try {
            const data = localStorage.getItem(this.metadataKey);
            return data ? JSON.parse(data) : {};
        } catch (error) {
            return {};
        }
    }

    /**
     * ÊôÇÈñìÂ∑Æ„ÇíË®àÁÆó
     */
    calculateTimeDifference(timestamp1, timestamp2) {
        const diffMs = Math.abs(timestamp1 - timestamp2);
        const diffDays = Math.floor(diffMs / (24 * 60 * 60 * 1000));
        const diffHours = Math.floor((diffMs % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
        
        if (diffDays > 0) {
            return `${diffDays}Êó•${diffHours}ÊôÇÈñì`;
        } else {
            return `${diffHours}ÊôÇÈñì`;
        }
    }

    /**
     * ‰∏ÄË≤´ÊÄß„Çπ„Ç≥„Ç¢„ÇíÊØîËºÉ
     */
    compareConsistencyScores(result1, result2) {
        const score1 = (result1.consistencyScore?.overall || 0) * 100;
        const score2 = (result2.consistencyScore?.overall || 0) * 100;
        const difference = score2 - score1;
        
        return {
            previous: Math.round(score1),
            current: Math.round(score2),
            difference: Math.round(difference),
            trend: difference > 5 ? 'improved' : difference < -5 ? 'declined' : 'stable'
        };
    }

    /**
     * OSÂ§âÂåñ„ÇíÊØîËºÉ
     */
    compareOSChanges(result1, result2) {
        const os1 = {
            engine: result1.engineOS?.hexagramInfo?.name || '‰∏çÊòé',
            interface: result1.interfaceOS?.hexagramInfo?.name || '‰∏çÊòé',
            safeMode: result1.safeModeOS?.hexagramInfo?.name || '‰∏çÊòé'
        };
        
        const os2 = {
            engine: result2.engineOS?.hexagramInfo?.name || '‰∏çÊòé',
            interface: result2.interfaceOS?.hexagramInfo?.name || '‰∏çÊòé',
            safeMode: result2.safeModeOS?.hexagramInfo?.name || '‰∏çÊòé'
        };
        
        return {
            engine: { changed: os1.engine !== os2.engine, from: os1.engine, to: os2.engine },
            interface: { changed: os1.interface !== os2.interface, from: os1.interface, to: os2.interface },
            safeMode: { changed: os1.safeMode !== os2.safeMode, from: os1.safeMode, to: os2.safeMode }
        };
    }

    /**
     * ÊØîËºÉÊ¥ûÂØü„ÇíÁîüÊàê
     */
    generateComparisonInsights(result1, result2) {
        const insights = [];
        
        const consistencyComparison = this.compareConsistencyScores(result1, result2);
        if (consistencyComparison.trend === 'improved') {
            insights.push('‰∫∫Ê†º„ÅÆ‰∏ÄË≤´ÊÄß„ÅåÂêë‰∏ä„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂÜÖÈù¢„Å®Â§ñÈù¢„ÅÆË™øÂíå„ÅåÈÄ≤„Çì„Åß„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
        } else if (consistencyComparison.trend === 'declined') {
            insights.push('‰∫∫Ê†º„ÅÆ‰∏ÄË≤´ÊÄß„Åå‰Ωé‰∏ã„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÊñ∞„Åó„ÅÑÁí∞Â¢É„ÇÑÂ§âÂåñ„Å´ÈÅ©Âøú„Åó„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
        } else {
            insights.push('‰∫∫Ê†º„ÅÆ‰∏ÄË≤´ÊÄß„ÅØÂÆâÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ');
        }
        
        const osChanges = this.compareOSChanges(result1, result2);
        const changedCount = Object.values(osChanges).filter(change => change.changed).length;
        
        if (changedCount === 0) {
            insights.push('„Åô„Åπ„Å¶„ÅÆOS„ÅåÂÆâÂÆö„Åó„Å¶„Åä„Çä„ÄÅ‰∫∫Ê†ºÊßãÈÄ†„Å´Â§ß„Åç„Å™Â§âÂåñ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
        } else if (changedCount === 1) {
            insights.push('‰∏ÄÈÉ®„ÅÆOS„Å´Â§âÂåñ„ÅåË¶ã„Çâ„Çå„Åæ„Åô„ÄÇÊÆµÈöéÁöÑ„Å™ÊàêÈï∑„ÇÑÈÅ©Âøú„ÅÆÈÅéÁ®ã„Å´„ÅÇ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
        } else {
            insights.push('Ë§áÊï∞„ÅÆOS„Å´Â§âÂåñ„ÅåË¶ã„Çâ„Çå„Åæ„Åô„ÄÇÂ§ß„Åç„Å™‰∫∫Áîü„ÅÆÂ§âÂåñ„ÇÑÊàêÈï∑Êúü„Å´„ÅÇ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
        }
        
        return insights;
    }

    /**
     * ‰∏ÄË≤´ÊÄß„Éà„É¨„É≥„Éâ„ÇíÂàÜÊûê
     */
    analyzeConsistencyTrend(history) {
        const scores = history.map(record => 
            (record.analysisResult.consistencyScore?.overall || 0) * 100
        ).reverse(); // Âè§„ÅÑÈ†Ü„Å´‰∏¶„Å≥Êõø„Åà
        
        if (scores.length < 2) return null;
        
        const trend = scores[scores.length - 1] - scores[0];
        const volatility = this.calculateVolatility(scores);
        
        return {
            scores: scores,
            overallTrend: trend > 5 ? 'improving' : trend < -5 ? 'declining' : 'stable',
            trendValue: Math.round(trend),
            volatility: Math.round(volatility),
            currentScore: Math.round(scores[scores.length - 1])
        };
    }

    /**
     * OSÂÆâÂÆöÊÄß„Éà„É¨„É≥„Éâ„ÇíÂàÜÊûê
     */
    analyzeOSStabilityTrend(history) {
        const osSequences = {
            engine: history.map(r => r.analysisResult.engineOS?.hexagramInfo?.name).reverse(),
            interface: history.map(r => r.analysisResult.interfaceOS?.hexagramInfo?.name).reverse(),
            safeMode: history.map(r => r.analysisResult.safeModeOS?.hexagramInfo?.name).reverse()
        };
        
        const stability = {};
        Object.keys(osSequences).forEach(osType => {
            const sequence = osSequences[osType];
            const changes = sequence.slice(1).filter((os, index) => os !== sequence[index]);
            stability[osType] = {
                changeCount: changes.length,
                stabilityRate: sequence.length > 1 ? (sequence.length - changes.length) / sequence.length : 1,
                currentOS: sequence[sequence.length - 1]
            };
        });
        
        return stability;
    }

    /**
     * „Éú„É©„ÉÜ„Ç£„É™„ÉÜ„Ç£„ÇíË®àÁÆó
     */
    calculateVolatility(values) {
        if (values.length < 2) return 0;
        
        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
        
        return Math.sqrt(variance);
    }

    /**
     * ÊúÄÈ†ªOS „ÇíÊ§úÂá∫
     */
    findMostCommonOS(history) {
        const osCount = {};
        
        history.forEach(record => {
            const engineOS = record.analysisResult.engineOS?.hexagramInfo?.name;
            const interfaceOS = record.analysisResult.interfaceOS?.hexagramInfo?.name;
            const safeModeOS = record.analysisResult.safeModeOS?.hexagramInfo?.name;
            
            [engineOS, interfaceOS, safeModeOS].forEach(os => {
                if (os) {
                    osCount[os] = (osCount[os] || 0) + 1;
                }
            });
        });
        
        const mostCommon = Object.entries(osCount).sort((a, b) => b[1] - a[1])[0];
        return mostCommon ? { name: mostCommon[0], count: mostCommon[1] } : null;
    }

    /**
     * „Çπ„Éà„É¨„Éº„Ç∏‰ΩøÁî®Èáè„ÇíË®àÁÆó
     */
    calculateStorageUsage() {
        const historyData = localStorage.getItem(this.storageKey) || '';
        const metadataData = localStorage.getItem(this.metadataKey) || '';
        
        return {
            bytes: historyData.length + metadataData.length,
            kb: Math.round((historyData.length + metadataData.length) / 1024 * 100) / 100
        };
    }

    /**
     * CSV„Å´Â§âÊèõ
     */
    convertToCSV(history) {
        const headers = [
            'ID', 'Êó•ÊôÇ', '„Ç®„É≥„Ç∏„É≥OS', '„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„ÇπOS', '„Çª„Éº„Éï„É¢„Éº„ÉâOS', '‰∏ÄË≤´ÊÄß„Çπ„Ç≥„Ç¢'
        ];
        
        const rows = history.map(record => [
            record.id,
            new Date(record.timestamp).toLocaleString('ja-JP'),
            record.summary.engineOS,
            record.summary.interfaceOS,
            record.summary.safeModeOS,
            record.summary.consistencyScore
        ]);
        
        return [headers, ...rows].map(row => 
            row.map(cell => `"${cell}"`).join(',')
        ).join('\n');
    }

    /**
     * Á∞°ÊòìÊöóÂè∑Âåñ
     */
    encryptData(data) {
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÈÅ©Âàá„Å™ÊöóÂè∑Âåñ„É©„Ç§„Éñ„É©„É™„Çí‰ΩøÁî®
        return btoa(JSON.stringify(data));
    }

    /**
     * Á∞°ÊòìÂæ©Âè∑Âåñ
     */
    decryptData(encryptedData) {
        try {
            return JSON.parse(atob(encryptedData));
        } catch (error) {
            console.error("‚ùå Failed to decrypt data:", error);
            return null;
        }
    }

    /**
     * „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Çπ„Ç±„Ç∏„É•„Éº„É©„Éº„ÇíÂàùÊúüÂåñ
     */
    initializeCleanupScheduler() {
        // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ„Å´„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆüË°å
        this.cleanupExpiredRecords();
        
        // ÂÆöÊúüÁöÑ„Å™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÔºà6ÊôÇÈñì„Åî„Å®Ôºâ
        this.cleanupInterval = setInterval(() => {
            this.cleanupExpiredRecords();
        }, 6 * 60 * 60 * 1000);
    }

    /**
     * ÊúüÈôêÂàá„Çå„É¨„Ç≥„Éº„Éâ„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
     */
    cleanupExpiredRecords() {
        try {
            const history = this.getHistory();
            const originalCount = history.length;
            
            // getHistory()„ÅØÊó¢„Å´ÊúüÈôêÂàá„Çå„ÇíÈô§ÂéªÊ∏à„Åø
            if (originalCount > history.length) {
                localStorage.setItem(this.storageKey, JSON.stringify(history));
                this.updateMetadata();
                
                console.log(`üßπ Cleaned up ${originalCount - history.length} expired records`);
            }
            
        } catch (error) {
            console.error("‚ùå Failed to cleanup expired records:", error);
        }
    }

    /**
     * „Éà„É¨„É≥„ÉâÊ¥ûÂØü„ÇíÁîüÊàê
     */
    generateTrendInsights(history) {
        const insights = [];
        
        const consistencyTrend = this.analyzeConsistencyTrend(history);
        if (consistencyTrend) {
            if (consistencyTrend.overallTrend === 'improving') {
                insights.push('‰∏ÄË≤´ÊÄß„Çπ„Ç≥„Ç¢„Åå‰∏äÊòáÂÇæÂêë„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇËá™Â∑±ÁêÜËß£„ÅåÊ∑±„Åæ„Å£„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
            } else if (consistencyTrend.overallTrend === 'declining') {
                insights.push('‰∏ÄË≤´ÊÄß„Çπ„Ç≥„Ç¢„Åå‰∏ãÈôçÂÇæÂêë„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇÊñ∞„Åó„ÅÑÊåëÊà¶„ÇÑÂ§âÂåñ„ÅÆÊôÇÊúü„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ');
            }
            
            if (consistencyTrend.volatility > 15) {
                insights.push('‰∏ÄË≤´ÊÄß„Çπ„Ç≥„Ç¢„ÅÆÂ§âÂãï„ÅåÂ§ß„Åç„ÅÑ„Åß„Åô„ÄÇ‰∏çÂÆâÂÆö„Å™ÊôÇÊúü„ÇÑÈÅéÊ∏°Êúü„Å´„ÅÇ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
            }
        }
        
        return insights;
    }

    /**
     * „Éà„É¨„É≥„ÉâÊé®Â•®‰∫ãÈ†Ö„ÇíÁîüÊàê
     */
    generateTrendRecommendations(history) {
        const recommendations = [];
        
        const consistencyTrend = this.analyzeConsistencyTrend(history);
        const stabilityTrend = this.analyzeOSStabilityTrend(history);
        
        if (consistencyTrend?.overallTrend === 'declining') {
            recommendations.push('‰∏ÄË≤´ÊÄß„ÅÆ‰Ωé‰∏ã„ÅåË¶ã„Çâ„Çå„Åæ„Åô„ÄÇËá™Â∑±ÁêÜËß£„ÇíÊ∑±„ÇÅ„ÇãÊôÇÈñì„ÇíË®≠„Åë„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ');
        }
        
        const unstableOSCount = Object.values(stabilityTrend).filter(
            stability => stability.stabilityRate < 0.7
        ).length;
        
        if (unstableOSCount > 1) {
            recommendations.push('Ë§áÊï∞„ÅÆOS„Å´Â§âÂåñ„ÅåË¶ã„Çâ„Çå„Åæ„Åô„ÄÇÂ§âÂåñ„ÇíÂèó„ÅëÂÖ•„Çå„Å§„Å§„ÄÅÊ†∏„Å®„Å™„Çã‰æ°ÂÄ§Ë¶≥„ÇíË¶ã„Å§„ÇÅÁõ¥„Åó„Å¶„Åø„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }
        
        if (history.length >= 5) {
            recommendations.push('ÂÆöÊúüÁöÑ„Å™Ë®∫Êñ≠„ÇíÁ∂ôÁ∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åì„ÅÆË™øÂ≠ê„ÅßËá™Â∑±ÊàêÈï∑„ÅÆË®òÈå≤„ÇíÁ∂ö„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }
        
        return recommendations;
    }

    /**
     * „Ç∑„Çπ„ÉÜ„É†Á†¥Ê£Ñ
     */
    destroy() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
        }
        console.log("üìä DiagnosisHistoryManager destroyed");
    }
}

export default DiagnosisHistoryManager;