/**
 * HAQEI v4.3.1 „Éñ„É©„Ç¶„Ç∂‰∫íÊèõÊÄß‰øùË®º„Ç∑„Çπ„ÉÜ„É†
 * Safari/FirefoxÂØæÂøú + Ê±∫ÂÆöË´ñÁöÑÂãï‰Ωú„ÅÆ‰øùË®º
 */

console.log('üì± BrowserCompatibility.js Loading...');

(function(global) {
    'use strict';

    class BrowserCompatibilityManager {
        constructor() {
            this.browserInfo = this.detectBrowser();
            this.compatibilityIssues = [];
            this.fixesApplied = [];
            
            console.log(`üåê Browser detected: ${this.browserInfo.name} ${this.browserInfo.version}`);
        }

        /**
         * „Éñ„É©„Ç¶„Ç∂Ê§úÂá∫
         */
        detectBrowser() {
            const ua = navigator.userAgent;
            let name = 'Unknown';
            let version = 'Unknown';

            if (ua.includes('Chrome') && !ua.includes('Edg')) {
                name = 'Chrome';
                const match = ua.match(/Chrome\/(\d+)/);
                version = match ? match[1] : 'Unknown';
            } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                name = 'Safari';
                const match = ua.match(/Version\/(\d+)/);
                version = match ? match[1] : 'Unknown';
            } else if (ua.includes('Firefox')) {
                name = 'Firefox';
                const match = ua.match(/Firefox\/(\d+)/);
                version = match ? match[1] : 'Unknown';
            } else if (ua.includes('Edg')) {
                name = 'Edge';
                const match = ua.match(/Edg\/(\d+)/);
                version = match ? match[1] : 'Unknown';
            }

            return {
                name: name,
                version: version,
                userAgent: ua,
                platform: navigator.platform,
                language: navigator.language
            };
        }

        /**
         * ‰∫íÊèõÊÄßÂïèÈ°å„ÅÆÂàùÊúüÂåñ„Å®‰øÆÊ≠£
         */
        initializeCompatibility() {
            console.log('üîß Browser compatibility initialization...');

            // 1. Êó•Êú¨Ë™û„ÇΩ„Éº„ÉàÂõ∫ÂÆö
            this.setupStableJapaneseSort();

            // 2. IMEÁ¢∫ÂÆö„Ç§„Éô„É≥„ÉàÂØæÂøú
            this.setupIMEHandling();

            // 3. „Çø„Ç§„Éû„ÉºÂàÜËß£ËÉΩÂ∑ÆÂØæÂøú
            this.setupTimerStabilization();

            // 4. „Éï„Ç©„É≥„Éà„ÉªCSS‰∫íÊèõÊÄß
            this.setupFontCompatibility();

            // 5. Event handlingÁµ±‰∏Ä
            this.setupEventHandling();

            // 6. LocalStorage‰∫íÊèõÊÄß
            this.setupStorageCompatibility();

            console.log(`‚úÖ Browser compatibility initialized: ${this.fixesApplied.length} fixes applied`);
            return this.compatibilityIssues.length === 0;
        }

        /**
         * 1. Êó•Êú¨Ë™û„ÇΩ„Éº„ÉàÂÆâÂÆöÂåñ
         */
        setupStableJapaneseSort() {
            try {
                // Intl.Collator„ÅÆÁµ±‰∏ÄË®≠ÂÆö
                global.createStableCollator = function() {
                    return new Intl.Collator('ja-JP', {
                        usage: 'sort',
                        sensitivity: 'base',
                        numeric: true,
                        ignorePunctuation: false
                    });
                };

                // ÂÆâÂÆö„ÇΩ„Éº„ÉàÈñ¢Êï∞
                global.stableSort = function(array, compareFunction) {
                    const collator = global.createStableCollator();
                    
                    // ÂÖÉ„ÅÆÈÖçÂàó„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí‰øùÊåÅ„Åó„Å¶ÂÆâÂÆö„ÇΩ„Éº„Éà
                    const indexed = array.map((item, index) => ({ item, index }));
                    
                    indexed.sort((a, b) => {
                        const result = compareFunction ? 
                                     compareFunction(a.item, b.item) : 
                                     collator.compare(a.item, b.item);
                        
                        // ÂêåÂÄ§„ÅÆÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÈ†Ü„ÇíÁ∂≠ÊåÅÔºàÂÆâÂÆö„ÇΩ„Éº„ÉàÔºâ
                        return result !== 0 ? result : a.index - b.index;
                    });
                    
                    return indexed.map(wrapped => wrapped.item);
                };

                this.fixesApplied.push('StableJapaneseSort');
                console.log('‚úÖ Japanese collation stabilized');

            } catch (error) {
                this.compatibilityIssues.push(`Japanese sort setup failed: ${error.message}`);
                console.warn('‚ö†Ô∏è Japanese sort fallback to default');
            }
        }

        /**
         * 2. IMEÁ¢∫ÂÆö„Ç§„Éô„É≥„ÉàÁµ±‰∏ÄÂá¶ÁêÜ
         */
        setupIMEHandling() {
            try {
                // IMEÂØæÂøú„ÅÆÁµ±‰∏ÄÂÖ•Âäõ„Éè„É≥„Éâ„É©
                global.createIMEAwareListener = function(element, callback) {
                    let isComposing = false;
                    let pendingValue = '';

                    // Êó•Êú¨Ë™ûÂÖ•ÂäõÈñãÂßã
                    element.addEventListener('compositionstart', (e) => {
                        isComposing = true;
                        console.log('üáØüáµ IME composition started');
                    });

                    // Êó•Êú¨Ë™ûÂÖ•Âäõ‰∏≠
                    element.addEventListener('compositionupdate', (e) => {
                        pendingValue = e.data || '';
                    });

                    // Êó•Êú¨Ë™ûÂÖ•ÂäõÁ¢∫ÂÆö
                    element.addEventListener('compositionend', (e) => {
                        isComposing = false;
                        pendingValue = e.data || element.value;
                        console.log('üáØüáµ IME composition ended:', pendingValue);
                        
                        // Á¢∫ÂÆöÂæå„Å´ÂÆüÈöõ„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÂÆüË°å
                        setTimeout(() => {
                            if (callback && typeof callback === 'function') {
                                callback(pendingValue);
                            }
                        }, 10); // ÂæÆÂ∞èÈÅÖÂª∂„Åß„Éñ„É©„Ç¶„Ç∂Â∑Æ„ÇíÂê∏Âèé
                    });

                    // ÈÄöÂ∏∏„ÅÆÂÖ•ÂäõÔºàIMEÊú™‰ΩøÁî®ÊôÇÔºâ
                    element.addEventListener('input', (e) => {
                        if (!isComposing) {
                            if (callback && typeof callback === 'function') {
                                callback(e.target.value);
                            }
                        }
                    });

                    return {
                        isComposing: () => isComposing,
                        getPendingValue: () => pendingValue
                    };
                };

                this.fixesApplied.push('IMEHandling');
                console.log('‚úÖ IME handling unified');

            } catch (error) {
                this.compatibilityIssues.push(`IME setup failed: ${error.message}`);
            }
        }

        /**
         * 3. „Çø„Ç§„Éû„ÉºÂàÜËß£ËÉΩÁµ±‰∏Ä
         */
        setupTimerStabilization() {
            try {
                // Ê±∫ÂÆöË´ñÁöÑ„Çø„Ç§„É†„Çπ„Çø„É≥„ÉóÁîüÊàê
                let sequenceCounter = 0;
                
                global.getDeterministicTimestamp = function() {
                    // Date.now()„ÅÆ1msÂçò‰Ωç + „Ç∑„Éº„Ç±„É≥„ÇπÁï™Âè∑„Åß‰∏ÄÊÑèÊÄß‰øùË®º
                    const baseTime = Math.floor(Date.now() / 100) * 100; // 100msÂçò‰Ωç„Åß‰∏∏„ÇÅ„Çã
                    const sequence = (sequenceCounter++) % 1000;
                    return baseTime + sequence;
                };

                // Ê±∫ÂÆöË´ñÁöÑÈÅÖÂª∂
                global.deterministicDelay = function(milliseconds) {
                    return new Promise(resolve => {
                        // „Éñ„É©„Ç¶„Ç∂Èñì„ÅÆ„Çø„Ç§„Éû„ÉºÁ≤æÂ∫¶Â∑Æ„ÇíÂê∏Âèé
                        const adjustedDelay = Math.max(milliseconds, 16); // ÊúÄÂ∞è16ms
                        setTimeout(resolve, adjustedDelay);
                    });
                };

                this.fixesApplied.push('TimerStabilization');
                console.log('‚úÖ Timer resolution stabilized');

            } catch (error) {
                this.compatibilityIssues.push(`Timer setup failed: ${error.message}`);
            }
        }

        /**
         * 4. „Éï„Ç©„É≥„Éà„ÉªCSS‰∫íÊèõÊÄß
         */
        setupFontCompatibility() {
            try {
                // CSSÂ§âÊï∞„Åß„Éï„Ç©„É≥„ÉàÁµ±‰∏Ä
                const style = document.createElement('style');
                style.textContent = `
                    :root {
                        --haqei-font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Noto Sans CJK JP', sans-serif;
                        --haqei-font-size-base: 16px;
                        --haqei-line-height: 1.6;
                    }
                    
                    .haqei-text {
                        font-family: var(--haqei-font-family);
                        font-size: var(--haqei-font-size-base);
                        line-height: var(--haqei-line-height);
                        word-break: keep-all;
                        overflow-wrap: break-word;
                    }
                    
                    /* Safari specific fixes */
                    @supports (-webkit-appearance: none) {
                        .haqei-button {
                            -webkit-appearance: none;
                            border-radius: 6px;
                        }
                        .haqei-input {
                            -webkit-appearance: none;
                        }
                    }
                    
                    /* Firefox specific fixes */
                    @-moz-document url-prefix() {
                        .haqei-input {
                            box-sizing: border-box;
                        }
                    }
                `;
                document.head.appendChild(style);

                this.fixesApplied.push('FontCompatibility');
                console.log('‚úÖ Font compatibility applied');

            } catch (error) {
                this.compatibilityIssues.push(`Font setup failed: ${error.message}`);
            }
        }

        /**
         * 5. „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É™„É≥„Ç∞Áµ±‰∏Ä
         */
        setupEventHandling() {
            try {
                // Áµ±‰∏Ä„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
                global.addUnifiedEventListener = function(element, eventType, handler, options = {}) {
                    const unifiedHandler = function(event) {
                        // „Ç§„Éô„É≥„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÊ≠£Ë¶èÂåñ
                        const normalizedEvent = {
                            type: event.type,
                            target: event.target,
                            currentTarget: event.currentTarget,
                            value: event.target ? event.target.value : undefined,
                            preventDefault: () => event.preventDefault(),
                            stopPropagation: () => event.stopPropagation(),
                            originalEvent: event
                        };

                        // „Éñ„É©„Ç¶„Ç∂Âõ∫Êúâ„ÅÆÊåôÂãï„ÇíÁµ±‰∏Ä
                        if (eventType === 'click') {
                            // „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÈò≤Ê≠¢
                            if (element._lastClickTime && Date.now() - element._lastClickTime < 300) {
                                return;
                            }
                            element._lastClickTime = Date.now();
                        }

                        handler(normalizedEvent);
                    };

                    element.addEventListener(eventType, unifiedHandler, options);
                    return unifiedHandler;
                };

                this.fixesApplied.push('EventHandling');
                console.log('‚úÖ Event handling unified');

            } catch (error) {
                this.compatibilityIssues.push(`Event setup failed: ${error.message}`);
            }
        }

        /**
         * 6. LocalStorage‰∫íÊèõÊÄß
         */
        setupStorageCompatibility() {
            try {
                // localStorageÂÆâÂÖ®„Å™„É©„ÉÉ„Éë„Éº
                global.safeLocalStorage = {
                    setItem: function(key, value) {
                        try {
                            const serialized = JSON.stringify({
                                value: value,
                                timestamp: Date.now(),
                                version: 'v4.3.1'
                            });
                            localStorage.setItem(key, serialized);
                            return true;
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è localStorage.setItem failed: ${error.message}`);
                            return false;
                        }
                    },
                    
                    getItem: function(key) {
                        try {
                            const stored = localStorage.getItem(key);
                            if (!stored) return null;
                            
                            const parsed = JSON.parse(stored);
                            
                            // 24ÊôÇÈñì‰ª•‰∏äÂè§„ÅÑ„Éá„Éº„Çø„ÅØÂâäÈô§
                            if (Date.now() - parsed.timestamp > 24 * 60 * 60 * 1000) {
                                localStorage.removeItem(key);
                                return null;
                            }
                            
                            return parsed.value;
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è localStorage.getItem failed: ${error.message}`);
                            localStorage.removeItem(key); // Á†¥Êêç„Éá„Éº„ÇøÂâäÈô§
                            return null;
                        }
                    },
                    
                    removeItem: function(key) {
                        try {
                            localStorage.removeItem(key);
                            return true;
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è localStorage.removeItem failed: ${error.message}`);
                            return false;
                        }
                    }
                };

                this.fixesApplied.push('StorageCompatibility');
                console.log('‚úÖ Storage compatibility ensured');

            } catch (error) {
                this.compatibilityIssues.push(`Storage setup failed: ${error.message}`);
            }
        }

        /**
         * ‰∫íÊèõÊÄß„É¨„Éù„Éº„ÉàÁîüÊàê
         */
        generateCompatibilityReport() {
            return {
                browserInfo: this.browserInfo,
                compatibilityIssues: this.compatibilityIssues,
                fixesApplied: this.fixesApplied,
                timestamp: new Date().toISOString(),
                isCompatible: this.compatibilityIssues.length === 0
            };
        }

        /**
         * ÂÆüË°åÊôÇ‰∫íÊèõÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
         */
        checkRuntimeCompatibility() {
            const checks = [
                {
                    name: 'Intl.Collator',
                    test: () => typeof Intl !== 'undefined' && typeof Intl.Collator !== 'undefined'
                },
                {
                    name: 'localStorage',
                    test: () => typeof Storage !== 'undefined' && typeof localStorage !== 'undefined'
                },
                {
                    name: 'WebCrypto',
                    test: () => typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined'
                },
                {
                    name: 'Promise',
                    test: () => typeof Promise !== 'undefined'
                },
                {
                    name: 'EventTarget',
                    test: () => typeof EventTarget !== 'undefined'
                }
            ];

            const results = checks.map(check => ({
                name: check.name,
                supported: check.test(),
                required: true
            }));

            const unsupported = results.filter(r => r.required && !r.supported);
            
            if (unsupported.length > 0) {
                console.warn('‚ö†Ô∏è Unsupported features:', unsupported.map(r => r.name).join(', '));
                this.compatibilityIssues.push(...unsupported.map(r => `${r.name} not supported`));
            }

            return {
                allSupported: unsupported.length === 0,
                results: results
            };
        }
    }

    // „Ç∞„É≠„Éº„Éê„É´ÁôªÈå≤
    if (typeof global !== 'undefined') {
        global.BrowserCompatibilityManager = BrowserCompatibilityManager;
        
        // Ëá™ÂãïÂàùÊúüÂåñ
        global.browserCompatibility = new BrowserCompatibilityManager();
        
        // DOMContentLoadedÊôÇ„Å´ÂàùÊúüÂåñ
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                global.browserCompatibility.initializeCompatibility();
                global.browserCompatibility.checkRuntimeCompatibility();
            });
        } else {
            // Êó¢„Å´Ë™≠„ÅøËæº„ÅøÊ∏à„Åø„ÅÆÂ†¥Âêà
            global.browserCompatibility.initializeCompatibility();
            global.browserCompatibility.checkRuntimeCompatibility();
        }
    }

    console.log('‚úÖ BrowserCompatibilityManager loaded');

})(typeof window !== 'undefined' ? window : this);