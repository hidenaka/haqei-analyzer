/**
 * HUD Manager - „Éò„ÉÉ„Éâ„Ç¢„ÉÉ„Éó„Éá„Ç£„Çπ„Éó„É¨„Ç§ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
 * 
 * Ê©üËÉΩ:
 * - „É™„Ç¢„É´„Çø„Ç§„É†„É°„Éà„É™„ÇØ„ÇπË°®Á§∫
 * - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ
 * - „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖãË°®Á§∫
 * - ÂàÜÊûêÁµêÊûú„ÅÆÂèØË¶ñÂåñ
 * 
 * @author HAQEI System Architect
 * @date 2025-08-28
 * @version 1.0.0
 */

class HUDManager {
    constructor(options = {}) {
        this.version = "1.0.0-hud-manager";
        this.initialized = false;
        this.visible = false;
        
        // „É°„Éà„É™„ÇØ„Çπ„Éá„Éº„Çø
        this.metrics = {
            analysisTime: [],
            confidence: [],
            linesEvaluated: [],
            cacheHits: 0,
            totalRequests: 0,
            selectedLines: [],
            dataSource: 'Unknown',
            parseMode: 'Unknown',
            determinismRate: 100,
            lastUpdate: null
        };
        
        // HUDË¶ÅÁ¥†
        this.hudElement = null;
        this.metricsPanel = null;
        
        // Ë®≠ÂÆö
        this.config = {
            updateInterval: 1000, // 1ÁßíÈñìÈöî„ÅßÊõ¥Êñ∞
            maxHistorySize: 100,  // ÊúÄÂ§ßÂ±•Ê≠¥„Çµ„Ç§„Ç∫
            autoHide: false,      // Ëá™ÂãïÈùûË°®Á§∫
            position: 'top-right' // Ë°®Á§∫‰ΩçÁΩÆ
        };
        
        this.init();
    }
    
    /**
     * HUDManager„ÅÆÂàùÊúüÂåñ
     */
    init() {
        try {
            this.createHUDElements();
            this.setupEventListeners();
            this.startUpdateLoop();
            this.initialized = true;
            console.log('üéØ HUDManager initialized successfully');
        } catch (error) {
            console.error('‚ùå HUDManager initialization failed:', error);
        }
    }
    
    /**
     * HUDË¶ÅÁ¥†„ÅÆ‰ΩúÊàê
     */
    createHUDElements() {
        // „É°„Ç§„É≥HUDË¶ÅÁ¥†
        this.hudElement = document.createElement('div');
        this.hudElement.id = 'hud-manager';
        this.hudElement.className = 'hud-container';
        this.hudElement.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 5px;
            z-index: 10000;
            min-width: 250px;
            max-width: 350px;
            border: 1px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            display: none;
        `;
        
        // „É°„Éà„É™„ÇØ„Çπ„Éë„Éç„É´
        this.metricsPanel = document.createElement('div');
        this.metricsPanel.className = 'metrics-panel';
        this.metricsPanel.innerHTML = this.generateMetricsHTML();
        
        this.hudElement.appendChild(this.metricsPanel);
        document.body.appendChild(this.hudElement);
        
        // „Éà„Ç∞„É´„Éú„Çø„É≥
        this.createToggleButton();
    }
    
    /**
     * „Éà„Ç∞„É´„Éú„Çø„É≥„ÅÆ‰ΩúÊàê
     */
    createToggleButton() {
        const toggleButton = document.createElement('button');
        toggleButton.id = 'hud-toggle';
        toggleButton.innerHTML = 'üìä';
        toggleButton.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 16px;
            cursor: pointer;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        `;
        
        toggleButton.addEventListener('click', () => this.toggle());
        document.body.appendChild(toggleButton);
    }
    
    /**
     * „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅÆË®≠ÂÆö
     */
    setupEventListeners() {
        // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà (Ctrl+H)
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.key === 'h') {
                event.preventDefault();
                this.toggle();
            }
        });
    }
    
    /**
     * Êõ¥Êñ∞„É´„Éº„Éó„ÅÆÈñãÂßã
     */
    startUpdateLoop() {
        setInterval(() => {
            if (this.visible) {
                this.updateDisplay();
            }
        }, this.config.updateInterval);
    }
    
    /**
     * „É°„Éà„É™„ÇØ„Çπ„ÅÆÊõ¥Êñ∞
     * @param {Object} data - „É°„Éà„É™„ÇØ„Çπ„Éá„Éº„Çø
     */
    updateMetrics(data) {
        try {
            const timestamp = Date.now();
            
            // ÂàÜÊûêÊôÇÈñì„ÅÆË®òÈå≤
            if (data.analysisTime !== undefined) {
                this.metrics.analysisTime.push({
                    value: data.analysisTime,
                    timestamp: timestamp
                });
                this.trimHistory('analysisTime');
            }
            
            // ‰ø°È†ºÂ∫¶„ÅÆË®òÈå≤
            if (data.confidence !== undefined) {
                this.metrics.confidence.push({
                    value: data.confidence,
                    timestamp: timestamp
                });
                this.trimHistory('confidence');
            }
            
            // Ë©ï‰æ°Ë°åÊï∞„ÅÆË®òÈå≤
            if (data.linesEvaluated !== undefined) {
                this.metrics.linesEvaluated.push({
                    value: data.linesEvaluated,
                    timestamp: timestamp
                });
                this.trimHistory('linesEvaluated');
            }
            
            // ÈÅ∏Êäû„Åï„Çå„ÅüË°å„ÅÆË®òÈå≤
            if (data.selectedLineId !== undefined) {
                this.metrics.selectedLines.push({
                    lineId: data.selectedLineId,
                    timestamp: timestamp
                });
                this.trimHistory('selectedLines');
            }

            // „Éá„Éº„Çø„ÇΩ„Éº„Çπ„ÅÆÊõ¥Êñ∞
            if (data.dataSource !== undefined) {
                this.metrics.dataSource = data.dataSource;
            }

            // Ëß£Êûê„É¢„Éº„Éâ„ÅÆÊõ¥Êñ∞
            if (data.parseMode !== undefined) {
                this.metrics.parseMode = data.parseMode;
            }

            // Ê±∫ÂÆöË´ñÁéá„ÅÆÊõ¥Êñ∞
            if (data.determinismRate !== undefined) {
                this.metrics.determinismRate = data.determinismRate;
            }

            // „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„Éà/Á∑è„É™„ÇØ„Ç®„Çπ„ÉàÊï∞„ÅÆÊõ¥Êñ∞
            this.metrics.totalRequests++;
            if (data.fromCache) {
                this.metrics.cacheHits++;
            }
            
            this.metrics.lastUpdate = timestamp;
            
            // Âç≥Â∫ß„Å´Ë°®Á§∫„ÇíÊõ¥Êñ∞
            if (this.visible) {
                this.updateDisplay();
            }
            
        } catch (error) {
            console.error('‚ùå HUDManager updateMetrics error:', error);
        }
    }
    
    /**
     * Â±•Ê≠¥„Éá„Éº„Çø„ÅÆ„Éà„É™„Éü„É≥„Ç∞
     * @param {string} metricName - „É°„Éà„É™„ÇØ„ÇπÂêç
     */
    trimHistory(metricName) {
        const history = this.metrics[metricName];
        if (Array.isArray(history) && history.length > this.config.maxHistorySize) {
            this.metrics[metricName] = history.slice(-this.config.maxHistorySize);
        }
    }
    
    /**
     * Ë°®Á§∫„ÅÆÊõ¥Êñ∞
     */
    updateDisplay() {
        if (!this.metricsPanel) return;
        
        this.metricsPanel.innerHTML = this.generateMetricsHTML();
    }
    
    /**
     * „É°„Éà„É™„ÇØ„ÇπHTML„ÅÆÁîüÊàê
     * @returns {string} HTMLÊñáÂ≠óÂàó
     */
    generateMetricsHTML() {
        const stats = this.calculateStats();
        
        return `
            <div class="hud-header">
                <h3 style="margin: 0 0 10px 0; color: #00ff00; font-size: 14px;">üìä HUD Metrics</h3>
                <div style="font-size: 10px; color: #888;">Last Update: ${this.formatTime(this.metrics.lastUpdate)}</div>
            </div>
            
            <div class="metrics-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 10px 0;">
                <div class="metric-item">
                    <div style="color: #888; font-size: 10px;">Analysis Time</div>
                    <div style="color: ${stats.analysisTime.p95 > 45 ? '#ff6666' : '#00ff00'}; font-weight: bold;">${stats.analysisTime.avg.toFixed(1)}ms</div>
                    <div style="color: #666; font-size: 9px;">P50: ${stats.analysisTime.p50.toFixed(1)} P95: ${stats.analysisTime.p95.toFixed(1)} P99: ${stats.analysisTime.p99.toFixed(1)}</div>
                </div>
                
                <div class="metric-item">
                    <div style="color: #888; font-size: 10px;">Confidence</div>
                    <div style="color: #00ff00; font-weight: bold;">${stats.confidence.avg.toFixed(1)}%</div>
                    <div style="color: #666; font-size: 9px;">Range: ${stats.confidence.min.toFixed(1)}-${stats.confidence.max.toFixed(1)}</div>
                </div>
                
                <div class="metric-item">
                    <div style="color: #888; font-size: 10px;">Cache Hit Rate</div>
                    <div style="color: #00ff00; font-weight: bold;">${stats.cacheHitRate.toFixed(1)}%</div>
                    <div style="color: #666; font-size: 9px;">${this.metrics.cacheHits}/${this.metrics.totalRequests}</div>
                </div>
                
                <div class="metric-item">
                    <div style="color: #888; font-size: 10px;">Lines Evaluated</div>
                    <div style="color: #00ff00; font-weight: bold;">${stats.linesEvaluated.avg.toFixed(0)}</div>
                    <div style="color: #666; font-size: 9px;">Max: ${stats.linesEvaluated.max}</div>
                </div>
                
                <div class="metric-item">
                    <div style="color: #888; font-size: 10px;">Data Source</div>
                    <div style="color: #00ff00; font-weight: bold;">${this.metrics.dataSource}</div>
                    <div style="color: #666; font-size: 9px;">Parse: ${this.metrics.parseMode}</div>
                </div>
                
                <div class="metric-item">
                    <div style="color: #888; font-size: 10px;">Determinism</div>
                    <div style="color: ${this.metrics.determinismRate === 100 ? '#00ff00' : '#ffaa00'}; font-weight: bold;">${this.metrics.determinismRate.toFixed(1)}%</div>
                    <div style="color: #666; font-size: 9px;">Reproducibility</div>
                </div>
            </div>
            
            <div class="recent-activity" style="margin-top: 10px; border-top: 1px solid #333; padding-top: 8px;">
                <div style="color: #888; font-size: 10px; margin-bottom: 5px;">Recent Selections</div>
                <div style="font-size: 9px; color: #666; max-height: 60px; overflow-y: auto;">
                    ${this.getRecentSelections()}
                </div>
            </div>
        `;
    }
    
    /**
     * Áµ±Ë®à„ÅÆË®àÁÆó
     * @returns {Object} Áµ±Ë®à„Éá„Éº„Çø
     */
    calculateStats() {
        const stats = {
            analysisTime: { avg: 0, p50: 0, p95: 0, p99: 0, min: 0, max: 0 },
            confidence: { avg: 0, min: 0, max: 0 },
            linesEvaluated: { avg: 0, min: 0, max: 0 },
            cacheHitRate: 0
        };
        
        // ÂàÜÊûêÊôÇÈñì„ÅÆÁµ±Ë®à
        if (this.metrics.analysisTime.length > 0) {
            const times = this.metrics.analysisTime.map(item => item.value);
            stats.analysisTime.avg = times.reduce((a, b) => a + b, 0) / times.length;
            stats.analysisTime.min = Math.min(...times);
            stats.analysisTime.max = Math.max(...times);
            
            const sortedTimes = times.sort((a, b) => a - b);
            const p50Index = Math.floor(sortedTimes.length * 0.5);
            const p95Index = Math.floor(sortedTimes.length * 0.95);
            const p99Index = Math.floor(sortedTimes.length * 0.99);
            stats.analysisTime.p50 = sortedTimes[p50Index] || 0;
            stats.analysisTime.p95 = sortedTimes[p95Index] || 0;
            stats.analysisTime.p99 = sortedTimes[p99Index] || 0;
        }
        
        // ‰ø°È†ºÂ∫¶„ÅÆÁµ±Ë®à
        if (this.metrics.confidence.length > 0) {
            const confidences = this.metrics.confidence.map(item => item.value);
            stats.confidence.avg = confidences.reduce((a, b) => a + b, 0) / confidences.length;
            stats.confidence.min = Math.min(...confidences);
            stats.confidence.max = Math.max(...confidences);
        }
        
        // Ë©ï‰æ°Ë°åÊï∞„ÅÆÁµ±Ë®à
        if (this.metrics.linesEvaluated.length > 0) {
            const lines = this.metrics.linesEvaluated.map(item => item.value);
            stats.linesEvaluated.avg = lines.reduce((a, b) => a + b, 0) / lines.length;
            stats.linesEvaluated.min = Math.min(...lines);
            stats.linesEvaluated.max = Math.max(...lines);
        }
        
        // „Ç≠„É£„ÉÉ„Ç∑„É•„Éí„ÉÉ„ÉàÁéá
        if (this.metrics.totalRequests > 0) {
            stats.cacheHitRate = (this.metrics.cacheHits / this.metrics.totalRequests) * 100;
        }
        
        return stats;
    }
    
    /**
     * ÊúÄËøë„ÅÆÈÅ∏ÊäûÂ±•Ê≠¥„ÇíÂèñÂæó
     * @returns {string} HTMLÊñáÂ≠óÂàó
     */
    getRecentSelections() {
        const recent = this.metrics.selectedLines.slice(-5).reverse();
        if (recent.length === 0) {
            return '<div style="color: #666;">No recent selections</div>';
        }
        
        return recent.map(item => {
            const time = new Date(item.timestamp).toLocaleTimeString();
            return `<div>${time}: Line ${item.lineId}</div>`;
        }).join('');
    }
    
    /**
     * ÊôÇÂàª„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
     * @param {number} timestamp - „Çø„Ç§„É†„Çπ„Çø„É≥„Éó
     * @returns {string} „Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åï„Çå„ÅüÊôÇÂàª
     */
    formatTime(timestamp) {
        if (!timestamp) return 'Never';
        return new Date(timestamp).toLocaleTimeString();
    }
    
    /**
     * HUD„ÅÆË°®Á§∫/ÈùûË°®Á§∫Âàá„ÇäÊõø„Åà
     */
    toggle() {
        this.visible = !this.visible;
        if (this.hudElement) {
            this.hudElement.style.display = this.visible ? 'block' : 'none';
        }
        
        if (this.visible) {
            this.updateDisplay();
        }
    }
    
    /**
     * HUD„ÅÆË°®Á§∫
     */
    show() {
        this.visible = true;
        if (this.hudElement) {
            this.hudElement.style.display = 'block';
            this.updateDisplay();
        }
    }
    
    /**
     * HUD„ÇíÈùûË°®Á§∫„Å´„Åô„Çã
     */
    hide() {
        this.visible = false;
        if (this.hudElement) {
            this.hudElement.style.display = 'none';
        }
    }
    
    /**
     * „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É¢„Éº„Éâ„ÅÆË°®Á§∫
     * @param {boolean} enabled - „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É¢„Éº„Éâ„ÅÆÊúâÂäπ/ÁÑ°Âäπ
     */
    showFallbackMode(enabled = true) {
        if (enabled) {
            this.updateMetrics({
                analysisTime: 0,
                confidence: 0,
                linesEvaluated: 0,
                fromCache: false,
                selectedLineId: null,
                fallbackMode: true
            });
            this.show();
        }
    }
    
    /**
     * „É°„Éà„É™„ÇØ„Çπ„ÅÆ„É™„Çª„ÉÉ„Éà
     */
    resetMetrics() {
        this.metrics = {
            analysisTime: [],
            confidence: [],
            linesEvaluated: [],
            cacheHits: 0,
            totalRequests: 0,
            selectedLines: [],
            lastUpdate: null
        };
        
        if (this.visible) {
            this.updateDisplay();
        }
    }
    
    /**
     * „É°„Éà„É™„ÇØ„Çπ„Éá„Éº„Çø„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà
     * @returns {Object} „É°„Éà„É™„ÇØ„Çπ„Éá„Éº„Çø
     */
    exportMetrics() {
        return {
            ...this.metrics,
            stats: this.calculateStats(),
            exportTime: Date.now()
        };
    }
    
    /**
     * HUDManager„ÅÆÁ†¥Ê£Ñ
     */
    destroy() {
        if (this.hudElement) {
            this.hudElement.remove();
        }
        
        const toggleButton = document.getElementById('hud-toggle');
        if (toggleButton) {
            toggleButton.remove();
        }
        
        this.initialized = false;
        console.log('üéØ HUDManager destroyed');
    }
}

// „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰ΩúÊàê
if (typeof window !== 'undefined') {
    // Ëá™ÂãïÂàùÊúüÂåñÔºàDOMContentLoadedÂæåÔºâ
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            if (!window.hudManager) {
                window.hudManager = new HUDManager();
            }
        });
    } else {
        // Êó¢„Å´DOM„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
        if (!window.hudManager) {
            window.hudManager = new HUDManager();
        }
    }
}

// Node.jsÁí∞Â¢É„Åß„ÅÆÂØæÂøú
if (typeof module !== 'undefined' && module.exports) {
    module.exports = HUDManager;
}