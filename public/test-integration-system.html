<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAQEI統合システムテスト - 包括的検証</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin: 30px 0;
            padding: 25px;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            background: #f8fafc;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        
        .test-section h2 {
            color: #2d3748;
            border-bottom: 3px solid #4299e1;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .test-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        button {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(66, 153, 225, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(66, 153, 225, 0.4);
        }
        
        button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .test-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 15px;
            transition: border-color 0.3s ease;
        }
        
        .test-input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }
        
        .results {
            background: #1a202c;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .success { color: #68d391; }
        .error { color: #fc8181; }
        .warning { color: #f6e05e; }
        .info { color: #63b3ed; }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #4299e1;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 5px;
        }
        
        .metric-label {
            color: #718096;
            font-size: 14px;
        }
        
        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 8px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #4299e1, #3182ce);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-ready { background: #68d391; }
        .status-running { background: #f6e05e; animation: pulse 1s infinite; }
        .status-error { background: #fc8181; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .test-scenario {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #4299e1;
        }
        
        .bunenjin-integration {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }
        
        .philosophy-note {
            font-style: italic;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌟 HAQEI統合システム包括的テスト</h1>
        
        <!-- システム初期化 -->
        <div class="test-section">
            <h2>🔧 システム初期化・健全性確認</h2>
            <div class="test-controls">
                <button onclick="initializeSystem()">システム初期化</button>
                <button onclick="checkSystemHealth()">健全性確認</button>
                <button onclick="runDiagnostics()">診断実行</button>
            </div>
            <div id="system-status" class="results">システム初期化待ち...</div>
        </div>
        
        <!-- 統合機能テスト -->
        <div class="test-section">
            <h2>🎯 統合機能精度テスト</h2>
            <textarea 
                id="user-input" 
                class="test-input" 
                placeholder="悩みを入力してください（例：仕事でプレッシャーを感じています。どうすれば良いでしょうか？）"
                rows="3">仕事でプレッシャーを感じています。明日までにプロジェクトを完成させなければならず、不安で眠れません。</textarea>
            
            <div class="test-controls">
                <button onclick="testIntegratedAnalysis()">統合分析実行</button>
                <button onclick="testAccuracy()">精度検証</button>
                <button onclick="testPatternCalculation()">7変化パターン検証</button>
                <button onclick="testMetaphorQuality()">メタファー品質検証</button>
            </div>
            
            <div id="integration-results" class="results">統合テスト結果がここに表示されます...</div>
        </div>
        
        <!-- パフォーマンステスト -->
        <div class="test-section">
            <h2>⚡ パフォーマンス・速度テスト</h2>
            <div class="test-controls">
                <button onclick="testResponseTime()">応答時間テスト</button>
                <button onclick="testConcurrentExecution()">同時実行テスト</button>
                <button onclick="testMemoryUsage()">メモリ使用量テスト</button>
                <button onclick="testCacheEfficiency()">キャッシュ効率テスト</button>
            </div>
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="response-time">--</div>
                    <div class="metric-label">平均応答時間 (ms)</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="response-time-progress" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-value" id="success-rate">--</div>
                    <div class="metric-label">成功率 (%)</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="success-rate-progress" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-value" id="cache-hit-rate">--</div>
                    <div class="metric-label">キャッシュヒット率 (%)</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="cache-progress" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="metric-card">
                    <div class="metric-value" id="memory-usage">--</div>
                    <div class="metric-label">メモリ使用量 (MB)</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="memory-progress" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            
            <div id="performance-results" class="results">パフォーマンステスト結果がここに表示されます...</div>
        </div>
        
        <!-- エラー処理テスト -->
        <div class="test-section">
            <h2>🛠️ エラー処理・フォールバック機能テスト</h2>
            <div class="test-controls">
                <button onclick="testErrorHandling()">エラー処理テスト</button>
                <button onclick="testFallbackScenarios()">フォールバック機能テスト</button>
                <button onclick="testEdgeCases()">エッジケーステスト</button>
                <button onclick="testComponentFailures()">コンポーネント失敗テスト</button>
            </div>
            
            <div id="error-handling-results" class="results">エラー処理テスト結果がここに表示されます...</div>
        </div>
        
        <!-- bunenjin哲学統合テスト -->
        <div class="bunenjin-integration">
            <h2>🧘 bunenjin哲学統合テスト</h2>
            <div class="test-controls">
                <button onclick="testBunenjinIntegration()">哲学統合確認</button>
                <button onclick="testMultipleViews()">複数視点テスト</button>
                <button onclick="testParadoxHandling()">矛盾許容テスト</button>
                <button onclick="testTripleOSIntegration()">Triple OS統合テスト</button>
            </div>
            
            <div class="philosophy-note">
                bunenjin哲学：複数の視点を同時に保持し、矛盾する解釈も受け入れることで、より豊かな理解を得る
            </div>
            
            <div id="bunenjin-results" class="results">bunenjin哲学統合テスト結果がここに表示されます...</div>
        </div>
        
        <!-- 包括的テスト実行 -->
        <div class="test-section">
            <h2>🏆 包括的統合テスト実行</h2>
            <div class="test-controls">
                <button onclick="runComprehensiveTests()" style="background: linear-gradient(135deg, #38a169, #2f855a); font-size: 16px; padding: 15px 30px;">
                    全体統合テスト実行
                </button>
                <button onclick="generateTestReport()">テストレポート生成</button>
                <button onclick="clearResults()">結果クリア</button>
            </div>
            
            <div class="test-scenario">
                <strong>包括的テストシナリオ:</strong>
                <ol>
                    <li>システム初期化と健全性確認</li>
                    <li>基本機能テスト（悩み分類・パターン計算・メタファー生成）</li>
                    <li>パフォーマンステスト（応答時間・同時実行・メモリ効率）</li>
                    <li>エラー処理・フォールバック機能テスト</li>
                    <li>精度・品質テスト（各コンポーネント統合精度）</li>
                    <li>bunenjin哲学統合テスト</li>
                    <li>システム統合テスト（データ整合性・コンポーネント連携）</li>
                </ol>
            </div>
            
            <div id="comprehensive-results" class="results">包括的テスト結果がここに表示されます...</div>
        </div>
    </div>

    <!-- コンポーネント読み込み -->
    <script src="js/core/ConcernClassifier.js"></script>
    <script src="js/core/AdaptiveDisplayManager.js"></script>
    <script src="js/core/AdaptiveIChingEngine.js"></script>
    <script src="js/pages/future-simulator/ComprehensiveTransformationPatterns.js"></script>
    <script src="js/pages/future-simulator/EnhancedMetaphorEngine.js"></script>
    <script src="js/core/IntegratedTransformationOrchestrator.js"></script>
    <script src="js/core/IntegrationTestSuite.js"></script>

    <script>
        // グローバル変数
        let orchestrator = null;
        let testSuite = null;
        let testResults = {};

        // システム初期化
        async function initializeSystem() {
            const statusElement = document.getElementById('system-status');
            statusElement.innerHTML = '<span class="info">🔄 システム初期化中...</span>';
            
            try {
                // オーケストレーター初期化
                orchestrator = new IntegratedTransformationOrchestrator();
                
                // テストスイート初期化
                testSuite = new IntegrationTestSuite();
                
                // 初期化完了まで待機
                let attempts = 0;
                while (orchestrator.systemStatus === 'initializing' && attempts < 100) {
                    await sleep(50);
                    attempts++;
                }
                
                const systemHealth = orchestrator.systemHealth;
                
                statusElement.innerHTML = `
                    <span class="success">✅ システム初期化完了</span><br>
                    <span class="info">📊 システム状態: ${orchestrator.systemStatus}</span><br>
                    <span class="info">🔧 コンポーネント状態:</span><br>
                    ${Object.entries(systemHealth).map(([component, status]) => 
                        `  - ${component}: <span class="${status === true ? 'success' : status === 'fallback' ? 'warning' : 'error'}">${status}</span>`
                    ).join('<br>')}
                `;
                
            } catch (error) {
                statusElement.innerHTML = `<span class="error">❌ 初期化エラー: ${error.message}</span>`;
            }
        }

        // システム健全性確認
        async function checkSystemHealth() {
            const statusElement = document.getElementById('system-status');
            
            if (!orchestrator) {
                statusElement.innerHTML = '<span class="warning">⚠️ システムが初期化されていません</span>';
                return;
            }
            
            try {
                const diagnostics = await orchestrator.runSystemDiagnostics();
                
                statusElement.innerHTML = `
                    <span class="success">🔍 システム診断結果</span><br>
                    <span class="info">総合健全性: <span class="${diagnostics.overallHealth === 'healthy' ? 'success' : diagnostics.overallHealth === 'degraded' ? 'warning' : 'error'}">${diagnostics.overallHealth}</span></span><br>
                    <span class="info">平均応答時間: ${diagnostics.performance?.averageResponseTime?.toFixed(2) || 'N/A'}ms</span><br>
                    <span class="info">成功率: ${(diagnostics.performance?.successRate * 100)?.toFixed(1) || 'N/A'}%</span><br>
                    <span class="info">キャッシュヒット率: ${(diagnostics.performance?.cacheHitRate * 100)?.toFixed(1) || 'N/A'}%</span><br>
                    ${diagnostics.recommendations?.length > 0 ? 
                        `<span class="warning">📋 推奨事項:</span><br>${diagnostics.recommendations.map(r => `  - ${r}`).join('<br>')}` : 
                        '<span class="success">📋 推奨事項: なし（良好）</span>'
                    }
                `;
                
            } catch (error) {
                statusElement.innerHTML = `<span class="error">❌ 診断エラー: ${error.message}</span>`;
            }
        }

        // 診断実行
        async function runDiagnostics() {
            await checkSystemHealth();
        }

        // 統合分析テスト
        async function testIntegratedAnalysis() {
            const resultsElement = document.getElementById('integration-results');
            const userInput = document.getElementById('user-input').value.trim();
            
            if (!userInput) {
                resultsElement.innerHTML = '<span class="warning">⚠️ 入力テキストを入力してください</span>';
                return;
            }
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 統合分析実行中...</span>';
            
            try {
                const startTime = performance.now();
                
                const testInput = {
                    userInput: userInput,
                    userProfile: { experienceLevel: '初心者' },
                    emotionalContext: { intensity: 0.7, primary: 'anxiety' },
                    contextualAnalysis: { confidence: 0.8 }
                };
                
                const result = await orchestrator.executeIntegratedTransformation(testInput);
                const responseTime = performance.now() - startTime;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 統合分析完了 (${responseTime.toFixed(2)}ms)</span><br><br>
                    <span class="info">📊 分析結果:</span><br>
                    <span class="info">悩みの種類: ${result.concernAnalysis?.nature?.primary || result.contextAnalysis?.concernType || 'N/A'}</span><br>
                    <span class="info">緊急度: ${result.concernAnalysis?.urgency?.level || result.contextAnalysis?.urgencyLevel || 'N/A'}</span><br>
                    <span class="info">信頼度: ${(result.qualityMetrics?.overallScore || result.qualityAssessment?.overallScore || 0.7).toFixed(2)}</span><br><br>
                    
                    <span class="info">🎭 主要メタファー:</span><br>
                    <span class="success">${result.primaryMetaphor?.essence || result.integratedContent?.primaryInsight?.essence || 'メタファー生成中...'}</span><br><br>
                    
                    <span class="info">🧘 bunenjin統合:</span><br>
                    <span class="info">複数視点数: ${result.bunenjinIntegration?.multipleViews?.perspectives?.length || result.integratedContent?.bunenjinWisdom?.multipleViews?.perspectives?.length || 0}</span><br>
                    <span class="info">Triple OS統合: ${result.bunenjinIntegration?.tripleOSIntegration ? '✅' : result.integratedContent?.bunenjinWisdom?.tripleOSIntegration ? '✅' : '❌'}</span><br><br>
                    
                    <span class="info">⚡ システム性能:</span><br>
                    <span class="success">応答時間: ${responseTime.toFixed(2)}ms (目標: 1000ms以内)</span><br>
                    <span class="${responseTime <= 1000 ? 'success' : 'warning'}">性能評価: ${responseTime <= 1000 ? 'A (優秀)' : responseTime <= 1500 ? 'B (良好)' : 'C (要改善)'}</span>
                `;
                
                // メトリクス更新
                updateMetric('response-time', responseTime.toFixed(0), (1000 - Math.min(responseTime, 1000)) / 1000 * 100);
                updateMetric('success-rate', '100', 100);
                
            } catch (error) {
                const responseTime = performance.now() - startTime;
                resultsElement.innerHTML = `
                    <span class="error">❌ 統合分析エラー (${responseTime.toFixed(2)}ms)</span><br>
                    <span class="error">エラー詳細: ${error.message}</span><br>
                    <span class="warning">フォールバック機能が動作する可能性があります</span>
                `;
                
                updateMetric('success-rate', '0', 0);
            }
        }

        // 精度検証テスト
        async function testAccuracy() {
            if (!testSuite) {
                document.getElementById('integration-results').innerHTML = '<span class="error">❌ テストスイートが初期化されていません</span>';
                return;
            }
            
            const resultsElement = document.getElementById('integration-results');
            resultsElement.innerHTML = '<span class="info">🔄 精度検証実行中...</span>';
            
            try {
                // 精度テストを実行
                await testSuite.runAccuracyTests();
                
                const accuracyResults = testSuite.testResults.testSuites.Accuracy;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 精度検証完了</span><br><br>
                    <span class="info">📊 精度テスト結果:</span><br>
                    <span class="info">実行テスト数: ${accuracyResults?.tests?.length || 0}</span><br>
                    <span class="info">成功: ${accuracyResults?.passed || 0}</span><br>
                    <span class="info">失敗: ${accuracyResults?.failed || 0}</span><br>
                    <span class="success">成功率: ${accuracyResults ? (accuracyResults.passed / (accuracyResults.passed + accuracyResults.failed) * 100).toFixed(1) : 0}%</span><br><br>
                    
                    <span class="info">🎯 品質基準達成状況:</span><br>
                    <span class="info">悩み分類精度: ${accuracyResults?.passed >= 1 ? '✅ 達成' : '❌ 要改善'}</span><br>
                    <span class="info">パターン計算精度: ${accuracyResults?.passed >= 2 ? '✅ 達成' : '❌ 要改善'}</span><br>
                    <span class="info">メタファー品質: ${accuracyResults?.passed >= 3 ? '✅ 達成' : '❌ 要改善'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ 精度検証エラー: ${error.message}</span>`;
            }
        }

        // 7変化パターン検証
        async function testPatternCalculation() {
            const resultsElement = document.getElementById('integration-results');
            
            if (!orchestrator || !orchestrator.components.patternEngine) {
                resultsElement.innerHTML = '<span class="error">❌ パターンエンジンが利用できません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 7変化パターン検証中...</span>';
            
            try {
                const testInput = {
                    hexagram: 1,
                    changingLines: [1, 4],
                    userType: 'free',
                    context: { urgency: 'high', importance: 'high' }
                };
                
                const patternResult = await orchestrator.components.patternEngine.calculateAllPatterns(testInput);
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 7変化パターン検証完了</span><br><br>
                    <span class="info">📊 パターン計算結果:</span><br>
                    <span class="info">計算されたパターン数: ${patternResult.patterns?.length || 0}</span><br>
                    <span class="info">表示可能パターン数: ${patternResult.patterns?.filter(p => p.displayInFree)?.length || 0}</span><br>
                    <span class="info">隠されたパターン数: ${(patternResult.patterns?.length || 0) - (patternResult.patterns?.filter(p => p.displayInFree)?.length || 0)}</span><br><br>
                    
                    <span class="info">🎯 パターン詳細:</span><br>
                    ${patternResult.patterns?.map(p => 
                        `<span class="${p.displayInFree ? 'success' : 'warning'}">- ${p.name} (${p.pattern}): ${p.displayInFree ? '表示' : '非表示'}</span>`
                    ).join('<br>') || '<span class="warning">パターン情報なし</span>'}<br><br>
                    
                    <span class="info">⚡ パフォーマンス:</span><br>
                    <span class="success">信頼度: ${(patternResult.confidence || 0.8).toFixed(2)}</span><br>
                    <span class="info">フォールバック: ${patternResult.fallback ? '❌ 使用' : '✅ 未使用'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ パターン検証エラー: ${error.message}</span>`;
            }
        }

        // メタファー品質検証
        async function testMetaphorQuality() {
            const resultsElement = document.getElementById('integration-results');
            
            if (!orchestrator || !orchestrator.components.metaphorEngine) {
                resultsElement.innerHTML = '<span class="error">❌ メタファーエンジンが利用できません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 メタファー品質検証中...</span>';
            
            try {
                const testInput = {
                    userInput: '仕事でプレッシャーを感じています',
                    userProfile: { experienceLevel: '初心者' },
                    contextType: 'work',
                    hexagram: 1,
                    changingLines: [1],
                    patterns: []
                };
                
                const metaphorResult = await orchestrator.components.metaphorEngine.generateEnhancedMetaphor(testInput);
                
                resultsElement.innerHTML = `
                    <span class="success">✅ メタファー品質検証完了</span><br><br>
                    <span class="info">📊 メタファー生成結果:</span><br>
                    <span class="success">主要メタファー: "${metaphorResult.primaryMetaphor?.essence || 'N/A'}"</span><br>
                    <span class="info">品質グレード: ${metaphorResult.qualityMetrics?.overallGrade || 'N/A'}</span><br>
                    <span class="info">洞察深度: ${(metaphorResult.qualityMetrics?.insightDepth || 0).toFixed(2)}</span><br>
                    <span class="info">独創性: ${(metaphorResult.qualityMetrics?.originalityScore || 0).toFixed(2)}</span><br>
                    <span class="info">感情共鳴: ${(metaphorResult.qualityMetrics?.emotionalResonance || 0).toFixed(2)}</span><br><br>
                    
                    <span class="info">🎭 利用可能メタファー:</span><br>
                    ${Object.keys(metaphorResult.availableMetaphors || {}).map(key => 
                        `<span class="success">- ${key}: 生成済み</span>`
                    ).join('<br>') || '<span class="warning">メタファー情報なし</span>'}<br><br>
                    
                    <span class="info">💎 プレミアム機能:</span><br>
                    <span class="info">隠されたメタファー数: ${Object.keys(metaphorResult.premiumMetaphors || {}).length}</span><br>
                    <span class="warning">フォールバック: ${metaphorResult.fallback ? '❌ 使用' : '✅ 未使用'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ メタファー検証エラー: ${error.message}</span>`;
            }
        }

        // 応答時間テスト
        async function testResponseTime() {
            const resultsElement = document.getElementById('performance-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 応答時間テスト実行中...</span>';
            
            try {
                const testInput = {
                    userInput: '仕事のストレスで困っています',
                    userProfile: { experienceLevel: '初心者' },
                    emotionalContext: { intensity: 0.6, primary: 'stress' },
                    contextualAnalysis: { confidence: 0.7 }
                };
                
                const iterations = 5;
                const responseTimes = [];
                
                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    await orchestrator.executeIntegratedTransformation(testInput);
                    const responseTime = performance.now() - startTime;
                    responseTimes.push(responseTime);
                    
                    resultsElement.innerHTML = `<span class="info">🔄 応答時間テスト実行中... (${i + 1}/${iterations})</span>`;
                }
                
                const averageTime = responseTimes.reduce((sum, time) => sum + time, 0) / iterations;
                const maxTime = Math.max(...responseTimes);
                const minTime = Math.min(...responseTimes);
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 応答時間テスト完了</span><br><br>
                    <span class="info">📊 応答時間統計 (${iterations}回実行):</span><br>
                    <span class="success">平均時間: ${averageTime.toFixed(2)}ms</span><br>
                    <span class="info">最大時間: ${maxTime.toFixed(2)}ms</span><br>
                    <span class="info">最小時間: ${minTime.toFixed(2)}ms</span><br><br>
                    
                    <span class="info">🎯 性能評価:</span><br>
                    <span class="${averageTime <= 1000 ? 'success' : 'warning'}">目標達成: ${averageTime <= 1000 ? '✅ 1秒以内達成' : '❌ 1秒超過'}</span><br>
                    <span class="info">性能グレード: ${averageTime <= 500 ? 'A+' : averageTime <= 1000 ? 'A' : averageTime <= 1500 ? 'B' : 'C'}</span>
                `;
                
                // メトリクス更新
                updateMetric('response-time', averageTime.toFixed(0), Math.max(0, (1000 - averageTime) / 1000 * 100));
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ 応答時間テストエラー: ${error.message}</span>`;
            }
        }

        // 同時実行テスト
        async function testConcurrentExecution() {
            const resultsElement = document.getElementById('performance-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 同時実行テスト実行中...</span>';
            
            try {
                const testInput = {
                    userInput: '人生について考えています',
                    userProfile: { experienceLevel: '中級者' },
                    emotionalContext: { intensity: 0.5, primary: 'contemplative' },
                    contextualAnalysis: { confidence: 0.8 }
                };
                
                const concurrentRequests = 8;
                const startTime = performance.now();
                
                // 同時リクエスト実行
                const promises = Array.from({ length: concurrentRequests }, () =>
                    orchestrator.executeIntegratedTransformation(testInput)
                );
                
                const results = await Promise.allSettled(promises);
                const totalTime = performance.now() - startTime;
                
                const successful = results.filter(r => r.status === 'fulfilled').length;
                const failed = results.filter(r => r.status === 'rejected').length;
                const successRate = (successful / concurrentRequests) * 100;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 同時実行テスト完了</span><br><br>
                    <span class="info">📊 同時実行統計:</span><br>
                    <span class="info">同時リクエスト数: ${concurrentRequests}</span><br>
                    <span class="success">成功: ${successful}件</span><br>
                    <span class="error">失敗: ${failed}件</span><br>
                    <span class="success">成功率: ${successRate.toFixed(1)}%</span><br>
                    <span class="info">総実行時間: ${totalTime.toFixed(2)}ms</span><br>
                    <span class="info">リクエスト当たり平均: ${(totalTime / concurrentRequests).toFixed(2)}ms</span><br><br>
                    
                    <span class="info">🎯 性能評価:</span><br>
                    <span class="${successRate >= 90 ? 'success' : 'warning'}">成功率評価: ${successRate >= 90 ? '✅ 優秀' : successRate >= 80 ? '⚠️ 良好' : '❌ 要改善'}</span><br>
                    <span class="${totalTime <= 2000 ? 'success' : 'warning'}">同時実行性能: ${totalTime <= 2000 ? '✅ 高速' : '⚠️ 改善余地あり'}</span>
                `;
                
                // メトリクス更新
                updateMetric('success-rate', successRate.toFixed(1), successRate);
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ 同時実行テストエラー: ${error.message}</span>`;
                updateMetric('success-rate', '0', 0);
            }
        }

        // メモリ使用量テスト
        async function testMemoryUsage() {
            const resultsElement = document.getElementById('performance-results');
            
            resultsElement.innerHTML = '<span class="info">🔄 メモリ使用量テスト実行中...</span>';
            
            try {
                const initialMemory = estimateMemoryUsage();
                
                const testInput = {
                    userInput: 'メモリテスト用入力',
                    userProfile: { experienceLevel: '初心者' },
                    emotionalContext: { intensity: 0.5, primary: 'neutral' },
                    contextualAnalysis: { confidence: 0.7 }
                };
                
                const iterations = 50;
                
                for (let i = 0; i < iterations; i++) {
                    if (orchestrator) {
                        await orchestrator.executeIntegratedTransformation(testInput);
                    }
                    
                    if (i % 10 === 0) {
                        resultsElement.innerHTML = `<span class="info">🔄 メモリ使用量テスト実行中... (${i}/${iterations})</span>`;
                    }
                }
                
                const finalMemory = estimateMemoryUsage();
                const memoryGrowth = finalMemory - initialMemory;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ メモリ使用量テスト完了</span><br><br>
                    <span class="info">📊 メモリ使用統計 (${iterations}回実行):</span><br>
                    <span class="info">初期メモリ: ${initialMemory.toFixed(2)}MB</span><br>
                    <span class="info">最終メモリ: ${finalMemory.toFixed(2)}MB</span><br>
                    <span class="success">メモリ増加: ${memoryGrowth.toFixed(2)}MB</span><br><br>
                    
                    <span class="info">🎯 メモリ効率評価:</span><br>
                    <span class="${memoryGrowth <= 10 ? 'success' : 'warning'}">メモリリーク: ${memoryGrowth <= 10 ? '✅ なし' : '⚠️ 可能性あり'}</span><br>
                    <span class="info">キャッシュサイズ: ${orchestrator?.integratedCache?.size || 0}エントリ</span>
                `;
                
                // メトリクス更新
                updateMetric('memory-usage', finalMemory.toFixed(1), Math.min(finalMemory / 50 * 100, 100));
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ メモリテストエラー: ${error.message}</span>`;
            }
        }

        // キャッシュ効率テスト
        async function testCacheEfficiency() {
            const resultsElement = document.getElementById('performance-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 キャッシュ効率テスト実行中...</span>';
            
            try {
                // キャッシュクリア
                orchestrator.integratedCache.clear();
                
                const testInput = {
                    userInput: 'キャッシュテスト用入力',
                    userProfile: { experienceLevel: '初心者' },
                    emotionalContext: { intensity: 0.5, primary: 'neutral' },
                    contextualAnalysis: { confidence: 0.7 }
                };
                
                const iterations = 20;
                const responseTimes = [];
                
                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    await orchestrator.executeIntegratedTransformation(testInput);
                    const responseTime = performance.now() - startTime;
                    responseTimes.push(responseTime);
                }
                
                const averageTime = responseTimes.reduce((sum, time) => sum + time, 0) / iterations;
                const cacheHitRate = orchestrator.performanceMetrics.cacheHitRate;
                const cacheSize = orchestrator.integratedCache.size;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ キャッシュ効率テスト完了</span><br><br>
                    <span class="info">📊 キャッシュ統計 (${iterations}回実行):</span><br>
                    <span class="success">キャッシュヒット率: ${(cacheHitRate * 100).toFixed(1)}%</span><br>
                    <span class="info">平均応答時間: ${averageTime.toFixed(2)}ms</span><br>
                    <span class="info">キャッシュサイズ: ${cacheSize}エントリ</span><br><br>
                    
                    <span class="info">🎯 キャッシュ効率評価:</span><br>
                    <span class="${cacheHitRate >= 0.7 ? 'success' : 'warning'}">効率性: ${cacheHitRate >= 0.7 ? '✅ 高効率' : '⚠️ 改善余地あり'}</span><br>
                    <span class="${averageTime <= 500 ? 'success' : 'warning'}">キャッシュ速度: ${averageTime <= 500 ? '✅ 高速' : '⚠️ 標準'}</span>
                `;
                
                // メトリクス更新
                updateMetric('cache-hit-rate', (cacheHitRate * 100).toFixed(1), cacheHitRate * 100);
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ キャッシュテストエラー: ${error.message}</span>`;
            }
        }

        // エラー処理テスト
        async function testErrorHandling() {
            const resultsElement = document.getElementById('error-handling-results');
            
            resultsElement.innerHTML = '<span class="info">🔄 エラー処理テスト実行中...</span>';
            
            try {
                const errorScenarios = [
                    { name: '空入力', input: { userInput: '', userProfile: null } },
                    { name: '無効データ', input: { userInput: null, userProfile: undefined } },
                    { name: '長すぎる入力', input: { userInput: 'あ'.repeat(3000), userProfile: {} } }
                ];
                
                let totalTests = 0;
                let handledErrors = 0;
                const results = [];
                
                for (const scenario of errorScenarios) {
                    totalTests++;
                    
                    try {
                        if (orchestrator) {
                            await orchestrator.executeIntegratedTransformation(scenario.input);
                            results.push(`${scenario.name}: ✅ 正常処理`);
                        } else {
                            results.push(`${scenario.name}: ⚠️ システム未初期化`);
                        }
                    } catch (error) {
                        if (error.message.includes('検証エラー') || error.message.includes('ValidationError')) {
                            handledErrors++;
                            results.push(`${scenario.name}: ✅ 適切にエラー処理`);
                        } else {
                            results.push(`${scenario.name}: ❌ 予期しないエラー: ${error.message}`);
                        }
                    }
                }
                
                const errorHandlingRate = (handledErrors / totalTests) * 100;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ エラー処理テスト完了</span><br><br>
                    <span class="info">📊 エラー処理統計:</span><br>
                    <span class="info">テストシナリオ数: ${totalTests}</span><br>
                    <span class="success">適切に処理されたエラー: ${handledErrors}</span><br>
                    <span class="success">エラー処理率: ${errorHandlingRate.toFixed(1)}%</span><br><br>
                    
                    <span class="info">🛠️ シナリオ別結果:</span><br>
                    ${results.map(r => `<span class="${r.includes('✅') ? 'success' : r.includes('⚠️') ? 'warning' : 'error'}">${r}</span>`).join('<br>')}<br><br>
                    
                    <span class="info">🎯 エラー処理評価:</span><br>
                    <span class="${errorHandlingRate >= 80 ? 'success' : 'warning'}">処理能力: ${errorHandlingRate >= 80 ? '✅ 優秀' : '⚠️ 要改善'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ エラー処理テスト自体でエラー: ${error.message}</span>`;
            }
        }

        // フォールバック機能テスト
        async function testFallbackScenarios() {
            const resultsElement = document.getElementById('error-handling-results');
            
            resultsElement.innerHTML = '<span class="info">🔄 フォールバック機能テスト実行中...</span>';
            
            try {
                if (!orchestrator) {
                    resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                    return;
                }
                
                // コンポーネント失敗シミュレーション
                const originalConcernClassifier = orchestrator.components.concernClassifier;
                
                // コンポーネントを意図的に無効化
                orchestrator.components.concernClassifier = null;
                
                const testInput = {
                    userInput: 'フォールバックテスト',
                    userProfile: { experienceLevel: '初心者' },
                    emotionalContext: { intensity: 0.5, primary: 'neutral' },
                    contextualAnalysis: { confidence: 0.7 }
                };
                
                const result = await orchestrator.executeIntegratedTransformation(testInput);
                
                // コンポーネントを復元
                orchestrator.components.concernClassifier = originalConcernClassifier;
                
                const hasFallback = result.systemInfo?.fallbackMode || result.fallback || 
                                   (result.concernAnalysis && result.concernAnalysis.componentStatus === 'fallback');
                
                resultsElement.innerHTML = `
                    <span class="success">✅ フォールバック機能テスト完了</span><br><br>
                    <span class="info">📊 フォールバック動作確認:</span><br>
                    <span class="${hasFallback ? 'success' : 'warning'}">フォールバック動作: ${hasFallback ? '✅ 正常動作' : '⚠️ 検出されず'}</span><br>
                    <span class="info">結果取得: ${result ? '✅ 成功' : '❌ 失敗'}</span><br>
                    <span class="info">エラー回避: ${result && !result.error ? '✅ 成功' : '❌ エラー発生'}</span><br><br>
                    
                    <span class="info">🛡️ フォールバック内容:</span><br>
                    <span class="info">基本メタファー: ${result.primaryMetaphor?.essence ? '✅ 提供' : '❌ なし'}</span><br>
                    <span class="info">統合コンテンツ: ${result.integratedContent ? '✅ 提供' : '❌ なし'}</span><br>
                    <span class="info">システム情報: ${result.systemInfo ? '✅ 提供' : '❌ なし'}</span><br><br>
                    
                    <span class="info">🎯 フォールバック評価:</span><br>
                    <span class="${hasFallback && result ? 'success' : 'warning'}">信頼性: ${hasFallback && result ? '✅ 高い' : '⚠️ 要改善'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ フォールバックテストエラー: ${error.message}</span>`;
            }
        }

        // エッジケーステスト
        async function testEdgeCases() {
            const resultsElement = document.getElementById('error-handling-results');
            
            resultsElement.innerHTML = '<span class="info">🔄 エッジケーステスト実行中...</span>';
            
            const edgeCases = [
                { name: '特殊文字', input: '!@#$%^&*()_+{}|:<>?[]\\;\'\",./' },
                { name: '数字のみ', input: '1234567890' },
                { name: '混合言語', input: 'Hello こんにちは 안녕하세요 你好' },
                { name: '絵文字', input: '😀😃😄😁😆😊🙂' },
                { name: '空白文字', input: '   \t\n\r   ' }
            ];
            
            let totalTests = 0;
            let successfulTests = 0;
            const results = [];
            
            for (const edgeCase of edgeCases) {
                totalTests++;
                
                try {
                    const testInput = {
                        userInput: edgeCase.input,
                        userProfile: { experienceLevel: '初心者' },
                        emotionalContext: { intensity: 0.5, primary: 'neutral' },
                        contextualAnalysis: { confidence: 0.7 }
                    };
                    
                    if (orchestrator) {
                        const result = await orchestrator.executeIntegratedTransformation(testInput);
                        
                        if (result && (result.primaryMetaphor || result.integratedContent)) {
                            successfulTests++;
                            results.push(`${edgeCase.name}: ✅ 正常処理`);
                        } else {
                            results.push(`${edgeCase.name}: ⚠️ 結果不完全`);
                        }
                    } else {
                        results.push(`${edgeCase.name}: ❌ システム未初期化`);
                    }
                    
                } catch (error) {
                    if (error.message.includes('検証エラー')) {
                        successfulTests++;
                        results.push(`${edgeCase.name}: ✅ 適切に拒否`);
                    } else {
                        results.push(`${edgeCase.name}: ❌ エラー: ${error.message.substring(0, 50)}`);
                    }
                }
            }
            
            const successRate = (successfulTests / totalTests) * 100;
            
            resultsElement.innerHTML = `
                <span class="success">✅ エッジケーステスト完了</span><br><br>
                <span class="info">📊 エッジケース統計:</span><br>
                <span class="info">テストケース数: ${totalTests}</span><br>
                <span class="success">適切に処理: ${successfulTests}</span><br>
                <span class="success">成功率: ${successRate.toFixed(1)}%</span><br><br>
                
                <span class="info">🧪 ケース別結果:</span><br>
                ${results.map(r => `<span class="${r.includes('✅') ? 'success' : r.includes('⚠️') ? 'warning' : 'error'}">${r}</span>`).join('<br>')}<br><br>
                
                <span class="info">🎯 エッジケース対応評価:</span><br>
                <span class="${successRate >= 80 ? 'success' : 'warning'}">堅牢性: ${successRate >= 80 ? '✅ 高い' : '⚠️ 要改善'}</span>
            `;
        }

        // コンポーネント失敗テスト
        async function testComponentFailures() {
            const resultsElement = document.getElementById('error-handling-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 コンポーネント失敗テスト実行中...</span>';
            
            const components = ['concernClassifier', 'patternEngine', 'metaphorEngine', 'displayManager'];
            const results = [];
            let successfulRecoveries = 0;
            
            for (const componentName of components) {
                try {
                    // コンポーネントを一時的に無効化
                    const originalComponent = orchestrator.components[componentName];
                    orchestrator.components[componentName] = null;
                    
                    const testInput = {
                        userInput: `${componentName}失敗テスト`,
                        userProfile: { experienceLevel: '初心者' },
                        emotionalContext: { intensity: 0.5, primary: 'neutral' },
                        contextualAnalysis: { confidence: 0.7 }
                    };
                    
                    const result = await orchestrator.executeIntegratedTransformation(testInput);
                    
                    // コンポーネントを復元
                    orchestrator.components[componentName] = originalComponent;
                    
                    if (result && (result.primaryMetaphor || result.integratedContent)) {
                        successfulRecoveries++;
                        results.push(`${componentName}: ✅ フォールバック成功`);
                    } else {
                        results.push(`${componentName}: ❌ 復旧失敗`);
                    }
                    
                } catch (error) {
                    results.push(`${componentName}: ❌ エラー: ${error.message.substring(0, 30)}`);
                }
            }
            
            const recoveryRate = (successfulRecoveries / components.length) * 100;
            
            resultsElement.innerHTML = `
                <span class="success">✅ コンポーネント失敗テスト完了</span><br><br>
                <span class="info">📊 コンポーネント復旧統計:</span><br>
                <span class="info">テスト対象: ${components.length}コンポーネント</span><br>
                <span class="success">復旧成功: ${successfulRecoveries}</span><br>
                <span class="success">復旧率: ${recoveryRate.toFixed(1)}%</span><br><br>
                
                <span class="info">🔧 コンポーネント別結果:</span><br>
                ${results.map(r => `<span class="${r.includes('✅') ? 'success' : 'error'}">${r}</span>`).join('<br>')}<br><br>
                
                <span class="info">🎯 システム耐障害性評価:</span><br>
                <span class="${recoveryRate >= 75 ? 'success' : 'warning'}">耐障害性: ${recoveryRate >= 75 ? '✅ 高い' : '⚠️ 要改善'}</span>
            `;
        }

        // bunenjin哲学統合テスト
        async function testBunenjinIntegration() {
            const resultsElement = document.getElementById('bunenjin-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 bunenjin哲学統合テスト実行中...</span>';
            
            try {
                const testInput = {
                    userInput: '人間関係で悩んでいます。相手の気持ちがわからず、どうすれば良いか迷っています。',
                    userProfile: { experienceLevel: '中級者' },
                    emotionalContext: { intensity: 0.6, primary: 'confusion' },
                    contextualAnalysis: { confidence: 0.8 }
                };
                
                const result = await orchestrator.executeIntegratedTransformation(testInput);
                
                // bunenjin統合要素の確認
                const bunenjinIntegration = result.bunenjinIntegration || result.integratedContent?.bunenjinWisdom;
                const multipleViews = bunenjinIntegration?.multipleViews;
                const dividedPerformance = bunenjinIntegration?.dividedPerformance;
                const tripleOSIntegration = bunenjinIntegration?.tripleOSIntegration;
                
                resultsElement.innerHTML = `
                    <span class="success">✅ bunenjin哲学統合テスト完了</span><br><br>
                    <span class="info">📊 哲学統合確認:</span><br>
                    <span class="${bunenjinIntegration ? 'success' : 'error'}">bunenjin統合: ${bunenjinIntegration ? '✅ 実装' : '❌ 未実装'}</span><br>
                    <span class="${multipleViews ? 'success' : 'error'}">複数視点: ${multipleViews ? '✅ 実装' : '❌ 未実装'}</span><br>
                    <span class="${dividedPerformance ? 'success' : 'error'}">分かれた演技: ${dividedPerformance ? '✅ 実装' : '❌ 未実装'}</span><br>
                    <span class="${tripleOSIntegration ? 'success' : 'error'}">Triple OS統合: ${tripleOSIntegration ? '✅ 実装' : '❌ 未実装'}</span><br><br>
                    
                    <span class="info">🧘 哲学要素詳細:</span><br>
                    <span class="info">視点数: ${multipleViews?.perspectives?.length || 0}</span><br>
                    <span class="info">矛盾数: ${dividedPerformance?.paradoxes?.length || 0}</span><br>
                    <span class="info">OSモード数: ${tripleOSIntegration ? Object.keys(tripleOSIntegration).length : 0}</span><br><br>
                    
                    <span class="info">🎯 哲学統合評価:</span><br>
                    <span class="${bunenjinIntegration && multipleViews && tripleOSIntegration ? 'success' : 'warning'}">統合度: ${bunenjinIntegration && multipleViews && tripleOSIntegration ? '✅ 完全統合' : '⚠️ 部分統合'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ bunenjin統合テストエラー: ${error.message}</span>`;
            }
        }

        // 複数視点テスト
        async function testMultipleViews() {
            const resultsElement = document.getElementById('bunenjin-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 複数視点テスト実行中...</span>';
            
            try {
                const testInput = {
                    userInput: '仕事と家庭の両立で悩んでいます',
                    userProfile: { experienceLevel: '上級者' },
                    emotionalContext: { intensity: 0.7, primary: 'stress' },
                    contextualAnalysis: { confidence: 0.9 }
                };
                
                const result = await orchestrator.executeIntegratedTransformation(testInput);
                
                const bunenjinIntegration = result.bunenjinIntegration || result.integratedContent?.bunenjinWisdom;
                const multipleViews = bunenjinIntegration?.multipleViews;
                const perspectives = multipleViews?.perspectives || [];
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 複数視点テスト完了</span><br><br>
                    <span class="info">📊 視点分析結果:</span><br>
                    <span class="info">検出された視点数: ${perspectives.length}</span><br>
                    <span class="${perspectives.length >= 2 ? 'success' : 'warning'}">最小要件: ${perspectives.length >= 2 ? '✅ 満たす (2視点以上)' : '❌ 不足'}</span><br><br>
                    
                    <span class="info">🔍 視点詳細:</span><br>
                    ${perspectives.map((p, i) => 
                        `<span class="success">${i + 1}. ${p.name || p.perspectiveName || `視点${i + 1}`}: ${p.insight || p.source || '洞察あり'}</span>`
                    ).join('<br>') || '<span class="warning">視点情報なし</span>'}<br><br>
                    
                    <span class="info">🎯 複数視点評価:</span><br>
                    <span class="${perspectives.length >= 3 ? 'success' : 'warning'}">視点の豊富さ: ${perspectives.length >= 3 ? '✅ 豊富' : '⚠️ 標準'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ 複数視点テストエラー: ${error.message}</span>`;
            }
        }

        // 矛盾許容テスト
        async function testParadoxHandling() {
            const resultsElement = document.getElementById('bunenjin-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 矛盾許容テスト実行中...</span>';
            
            try {
                const testInput = {
                    userInput: '変化したいのに変化が怖い、安定を求めるのに退屈も感じる',
                    userProfile: { experienceLevel: '上級者' },
                    emotionalContext: { intensity: 0.8, primary: 'conflict' },
                    contextualAnalysis: { confidence: 0.7 }
                };
                
                const result = await orchestrator.executeIntegratedTransformation(testInput);
                
                const bunenjinIntegration = result.bunenjinIntegration || result.integratedContent?.bunenjinWisdom;
                const dividedPerformance = bunenjinIntegration?.dividedPerformance;
                const paradoxes = dividedPerformance?.paradoxes || [];
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 矛盾許容テスト完了</span><br><br>
                    <span class="info">📊 矛盾処理結果:</span><br>
                    <span class="info">検出された矛盾数: ${paradoxes.length}</span><br>
                    <span class="${paradoxes.length > 0 ? 'success' : 'warning'}">矛盾認識: ${paradoxes.length > 0 ? '✅ 適切' : '⚠️ 不十分'}</span><br><br>
                    
                    <span class="info">🤔 矛盾内容:</span><br>
                    ${paradoxes.map((p, i) => 
                        `<span class="info">${i + 1}. ${p}</span>`
                    ).join('<br>') || '<span class="warning">矛盾情報なし</span>'}<br><br>
                    
                    <span class="info">🧘 分かれた演技:</span><br>
                    <span class="info">コンセプト: ${dividedPerformance?.concept || '未定義'}</span><br>
                    <span class="info">実践方法: ${dividedPerformance?.instruction || '未定義'}</span><br><br>
                    
                    <span class="info">🎯 矛盾許容評価:</span><br>
                    <span class="${paradoxes.length >= 2 ? 'success' : 'warning'}">許容能力: ${paradoxes.length >= 2 ? '✅ 高い' : '⚠️ 標準'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ 矛盾許容テストエラー: ${error.message}</span>`;
            }
        }

        // Triple OS統合テスト
        async function testTripleOSIntegration() {
            const resultsElement = document.getElementById('bunenjin-results');
            
            if (!orchestrator) {
                resultsElement.innerHTML = '<span class="error">❌ システムが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 Triple OS統合テスト実行中...</span>';
            
            try {
                const testInput = {
                    userInput: 'リスクを取って新しいことに挑戦したいが、安全性も確保したい',
                    userProfile: { experienceLevel: '上級者' },
                    emotionalContext: { intensity: 0.6, primary: 'ambivalence' },
                    contextualAnalysis: { confidence: 0.8 }
                };
                
                const result = await orchestrator.executeIntegratedTransformation(testInput);
                
                const bunenjinIntegration = result.bunenjinIntegration || result.integratedContent?.bunenjinWisdom;
                const tripleOSIntegration = bunenjinIntegration?.tripleOSIntegration;
                
                const osTypes = ['engineOS', 'interfaceOS', 'safeModeOS'];
                const availableOS = osTypes.filter(os => tripleOSIntegration?.[os]);
                
                resultsElement.innerHTML = `
                    <span class="success">✅ Triple OS統合テスト完了</span><br><br>
                    <span class="info">📊 OS統合結果:</span><br>
                    <span class="info">実装されたOS数: ${availableOS.length}/3</span><br>
                    <span class="${availableOS.length === 3 ? 'success' : 'warning'}">完全性: ${availableOS.length === 3 ? '✅ 完全' : '⚠️ 部分的'}</span><br><br>
                    
                    <span class="info">🖥️ OS別詳細:</span><br>
                    ${osTypes.map(os => {
                        const osData = tripleOSIntegration?.[os];
                        return `<span class="${osData ? 'success' : 'error'}">${os}: ${osData ? '✅ 実装' : '❌ 未実装'}</span><br>
                                ${osData ? `  焦点: ${osData.focus || 'N/A'}<br>  指導: ${osData.guidance?.[0] || 'N/A'}` : ''}`;
                    }).join('<br>')}<br><br>
                    
                    <span class="info">🎯 Triple OS評価:</span><br>
                    <span class="${availableOS.length >= 2 ? 'success' : 'warning'}">OS連携: ${availableOS.length >= 2 ? '✅ 良好' : '⚠️ 要改善'}</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ Triple OSテストエラー: ${error.message}</span>`;
            }
        }

        // 包括的テスト実行
        async function runComprehensiveTests() {
            const resultsElement = document.getElementById('comprehensive-results');
            
            if (!testSuite) {
                resultsElement.innerHTML = '<span class="error">❌ テストスイートが初期化されていません</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 包括的統合テスト実行中... (約30秒)</span>';
            
            try {
                const testReport = await testSuite.runComprehensiveTests();
                
                resultsElement.innerHTML = `
                    <span class="success">✅ 包括的統合テスト完了</span><br><br>
                    <span class="info">📊 総合結果:</span><br>
                    <span class="info">総合評価: <span class="${testReport.summary.overallResult === 'excellent' ? 'success' : testReport.summary.overallResult === 'good' ? 'success' : 'warning'}">${testReport.summary.overallResult}</span></span><br>
                    <span class="info">総テスト数: ${testReport.summary.totalTests}</span><br>
                    <span class="success">成功: ${testReport.summary.passedTests}</span><br>
                    <span class="error">失敗: ${testReport.summary.failedTests}</span><br>
                    <span class="success">成功率: ${testReport.summary.successRate}</span><br>
                    <span class="info">実行時間: ${testReport.summary.duration}</span><br><br>
                    
                    <span class="info">🎯 品質メトリクス:</span><br>
                    <span class="info">テストカバレッジ: ${testReport.qualityMetrics.testCoverage}%</span><br>
                    <span class="info">パフォーマンス: ${testReport.qualityMetrics.performanceGrade}</span><br>
                    <span class="info">精度スコア: ${testReport.qualityMetrics.accuracyScore}%</span><br>
                    <span class="info">信頼性スコア: ${testReport.qualityMetrics.reliabilityScore}%</span><br><br>
                    
                    <span class="info">🧘 bunenjin準拠:</span><br>
                    <span class="info">哲学準拠レベル: ${testReport.bunenjinCompliance.compliance}</span><br>
                    <span class="info">準拠スコア: ${testReport.bunenjinCompliance.score}%</span><br>
                    <span class="${testReport.bunenjinCompliance.areas.multipleViews ? 'success' : 'warning'}">複数視点: ${testReport.bunenjinCompliance.areas.multipleViews ? '✅' : '❌'}</span><br>
                    <span class="${testReport.bunenjinCompliance.areas.paradoxAcceptance ? 'success' : 'warning'}">矛盾許容: ${testReport.bunenjinCompliance.areas.paradoxAcceptance ? '✅' : '❌'}</span><br>
                    <span class="${testReport.bunenjinCompliance.areas.tripleOSIntegration ? 'success' : 'warning'}">Triple OS: ${testReport.bunenjinCompliance.areas.tripleOSIntegration ? '✅' : '❌'}</span><br><br>
                    
                    <span class="info">📋 推奨事項:</span><br>
                    ${testReport.recommendations.map(r => `<span class="info">- ${r}</span>`).join('<br>')}
                `;
                
                // グローバルテスト結果を保存
                testResults = testReport;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ 包括的テストエラー: ${error.message}</span>`;
            }
        }

        // テストレポート生成
        async function generateTestReport() {
            const resultsElement = document.getElementById('comprehensive-results');
            
            if (!testResults || Object.keys(testResults).length === 0) {
                resultsElement.innerHTML = '<span class="warning">⚠️ 先に包括的テストを実行してください</span>';
                return;
            }
            
            resultsElement.innerHTML = '<span class="info">🔄 詳細レポート生成中...</span>';
            
            try {
                const reportData = {
                    timestamp: new Date().toISOString(),
                    testResults: testResults,
                    systemInfo: orchestrator ? {
                        version: orchestrator.version,
                        philosophy: orchestrator.philosophy,
                        systemHealth: orchestrator.systemHealth,
                        performanceMetrics: orchestrator.performanceMetrics
                    } : null
                };
                
                // JSONレポートをダウンロード可能にする
                const jsonReport = JSON.stringify(reportData, null, 2);
                const blob = new Blob([jsonReport], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `haqei-integration-test-report-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                resultsElement.innerHTML = `
                    <span class="success">✅ テストレポート生成完了</span><br><br>
                    <span class="info">📄 レポート内容:</span><br>
                    <span class="info">- 包括的テスト結果詳細</span><br>
                    <span class="info">- システム性能メトリクス</span><br>
                    <span class="info">- bunenjin哲学準拠評価</span><br>
                    <span class="info">- 改善推奨事項</span><br>
                    <span class="info">- システム診断情報</span><br><br>
                    <span class="success">📁 ファイルがダウンロードされました</span>
                `;
                
            } catch (error) {
                resultsElement.innerHTML = `<span class="error">❌ レポート生成エラー: ${error.message}</span>`;
            }
        }

        // 結果クリア
        function clearResults() {
            const resultElements = [
                'system-status', 'integration-results', 'performance-results', 
                'error-handling-results', 'bunenjin-results', 'comprehensive-results'
            ];
            
            resultElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.innerHTML = `${id.replace('-', ' ')}結果がここに表示されます...`;
                }
            });
            
            // メトリクスリセット
            updateMetric('response-time', '--', 0);
            updateMetric('success-rate', '--', 0);
            updateMetric('cache-hit-rate', '--', 0);
            updateMetric('memory-usage', '--', 0);
        }

        // ヘルパー関数群
        function updateMetric(metricId, value, progressPercent) {
            const valueElement = document.getElementById(metricId);
            const progressElement = document.getElementById(metricId + '-progress');
            
            if (valueElement) valueElement.textContent = value;
            if (progressElement) progressElement.style.width = progressPercent + '%';
        }

        function estimateMemoryUsage() {
            // 簡易的なメモリ使用量推定
            const cacheSize = orchestrator?.integratedCache?.size || 0;
            const objectCount = orchestrator ? Object.keys(orchestrator.components).length : 0;
            return cacheSize * 0.01 + objectCount * 0.1; // MB単位
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ページ読み込み時の初期化
        window.addEventListener('load', function() {
            console.log('🌟 HAQEI統合システムテストページ読み込み完了');
            console.log('📋 利用可能なテスト機能:');
            console.log('  - システム初期化・健全性確認');
            console.log('  - 統合機能精度テスト');
            console.log('  - パフォーマンス・速度テスト');
            console.log('  - エラー処理・フォールバック機能テスト');
            console.log('  - bunenjin哲学統合テスト');
            console.log('  - 包括的統合テスト');
            
            // システム初期化の推奨
            setTimeout(() => {
                if (!orchestrator) {
                    document.getElementById('system-status').innerHTML = 
                        '<span class="warning">⚠️ まず「システム初期化」ボタンをクリックしてください</span>';
                }
            }, 1000);
        });
    </script>
</body>
</html>