<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>I Ching Future Simulator Enhanced - é«˜ç²¾åº¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ†æç‰ˆ</title>
  
  <!-- å¤–éƒ¨CSS -->
  <link rel="stylesheet" href="./css/nav-styles.css">
  <link rel="stylesheet" href="./css/darkmode.css">
  
  <style>
    /* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .simulator-container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 10px;
      font-size: 28px;
    }
    
    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
      font-size: 14px;
    }
    
    /* ç²¾åº¦ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
    .accuracy-indicator {
      background: linear-gradient(90deg, #10B981 0%, #3B82F6 100%);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      text-align: center;
      margin-bottom: 20px;
      font-weight: bold;
    }
    
    /* å…¥åŠ›ã‚¨ãƒªã‚¢ */
    .input-section {
      margin-bottom: 30px;
    }
    
    textarea {
      width: 100%;
      padding: 15px;
      border: 2px solid #e5e7eb;
      border-radius: 10px;
      font-size: 16px;
      resize: vertical;
      min-height: 100px;
    }
    
    button {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s;
      margin-top: 10px;
    }
    
    button:hover {
      transform: translateY(-2px);
    }
    
    /* çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ */
    .results-section {
      display: none;
    }
    
    .scenario-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    .scenario-card {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 15px;
      padding: 20px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    
    .scenario-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }
    
    .pattern-badge {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .hex-info {
      background: #f3f4f6;
      padding: 8px;
      border-radius: 8px;
      margin: 5px 0;
      font-size: 14px;
    }
    
    .keyword-tag {
      display: inline-block;
      background: #fef3c7;
      color: #92400e;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      margin: 2px;
    }
    
    .category-label {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 11px;
      margin-left: 5px;
    }
    
    .category-preparation { background: #dbeafe; color: #1e40af; }
    .category-cooperation { background: #dcfce7; color: #166534; }
    .category-growth { background: #fef3c7; color: #92400e; }
    .category-leadership { background: #fce7f3; color: #9f1239; }
    .category-difficulty { background: #fee2e2; color: #991b1b; }
    .category-stability { background: #e0e7ff; color: #3730a3; }
    .category-reflection { background: #f3e8ff; color: #6b21a8; }
    .category-transformation { background: #ffedd5; color: #9a3412; }
    
    /* ãƒ‡ãƒãƒƒã‚°æƒ…å ± */
    .debug-info {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 10px;
      margin-top: 20px;
      font-size: 12px;
      color: #6b7280;
    }
  </style>
</head>
<body>
  <div class="simulator-container">
    <h1>ğŸ”® I Ching Future Simulator Enhanced</h1>
    <p class="subtitle">é«˜ç²¾åº¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ†æã‚·ã‚¹ãƒ†ãƒ  v2.0</p>
    
    <div class="accuracy-indicator">
      ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ†é¡ç²¾åº¦: 70%+ (é »å‡ºä¸Šä½100å¯¾å¿œ)
    </div>
    
    <div class="input-section">
      <textarea id="userInput" placeholder="ã‚ãªãŸã®ç¾åœ¨ã®çŠ¶æ³ã‚„æ‚©ã¿ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
      <button onclick="generateEnhancedScenarios()">8ã¤ã®æœªæ¥ã‚’è¦‹ã‚‹</button>
    </div>
    
    <div id="results" class="results-section">
      <h2>ã‚ãªãŸã®8ã¤ã®å¯èƒ½ãªæœªæ¥</h2>
      <div id="scenarioGrid" class="scenario-grid"></div>
    </div>
    
    <div id="debugInfo" class="debug-info" style="display: none;"></div>
  </div>
  
  <!-- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿ -->
  <script src="./assets/H384H64database.js"></script>
  <script src="./js/EnhancedKeywordAnalyzer.js"></script>
  
  <script>
    // æ‹¡å¼µã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    const analyzer = new EnhancedKeywordAnalyzer();
    
    // æ‹¡å¼µç‰ˆã‚·ãƒŠãƒªã‚ªç”Ÿæˆé–¢æ•°
    function generateEnhancedScenarios() {
      const userInput = document.getElementById('userInput').value;
      if (!userInput) {
        alert('çŠ¶æ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
        return;
      }
      
      // å…¥åŠ›åˆ†æ
      const analysis = analyzeUserInput(userInput);
      
      // åˆæœŸå¦ãƒ»çˆ»ã®é¸å®š
      const { hex: initialHex, line: initialLine } = selectInitialHexLine(analysis);
      
      // 8ãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆ
      const patterns = ['JJJ', 'JJH', 'JHJ', 'JHH', 'HJJ', 'HJH', 'HHJ', 'HHH'];
      const scenarios = [];
      
      patterns.forEach((pattern, index) => {
        const scenario = generateScenarioWithEnhancedAnalysis(
          initialHex, 
          initialLine, 
          pattern, 
          analysis,
          index + 1
        );
        scenarios.push(scenario);
      });
      
      // çµæœè¡¨ç¤º
      displayEnhancedScenarios(scenarios);
      
      // ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤º
      showDebugInfo(analysis, scenarios);
    }
    
    // æ‹¡å¼µç‰ˆã‚·ãƒŠãƒªã‚ªç”Ÿæˆï¼ˆé«˜ç²¾åº¦ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ†æä½¿ç”¨ï¼‰
    function generateScenarioWithEnhancedAnalysis(hex, line, pattern, analysis, scenarioNum) {
      let currentHex = hex;
      let currentLine = line;
      const path = [];
      
      // 3ãƒ•ã‚§ãƒ¼ã‚ºã®é¸æŠã‚’å®Ÿè¡Œ
      for (let phase = 0; phase < 3; phase++) {
        const choice = pattern[phase];
        const currentData = getH384Entry(currentHex, currentLine);
        const currentKeyword = currentData?.['ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰']?.[0] || 'ä¸æ˜';
        
        path.push({
          phase: phase + 1,
          hex: currentHex,
          line: currentLine,
          hexName: currentData?.['å¦å'] || 'ä¸æ˜',
          lineName: getLineName(currentLine),
          keyword: currentKeyword,
          category: analyzer.analyzeKeyword(currentKeyword),
          choice: choice
        });
        
        if (choice === 'J') {
          // é€²çˆ»: åŒã˜å¦å†…ã§çˆ»ãŒé€²ã‚€
          currentLine = currentLine < 6 ? currentLine + 1 : 1;
        } else {
          // å¤‰çˆ»: ç•°ãªã‚‹å¦ã¸å¤‰åŒ–
          currentHex = ((currentHex - 1 + currentLine * 7) % 64) + 1;
        }
      }
      
      // æœ€çµ‚åˆ°é”ç‚¹
      const finalData = getH384Entry(currentHex, currentLine);
      const finalKeyword = finalData?.['ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰']?.[0] || 'ä¸æ˜';
      
      path.push({
        phase: 'final',
        hex: currentHex,
        line: currentLine,
        hexName: finalData?.['å¦å'] || 'ä¸æ˜',
        lineName: getLineName(currentLine),
        keyword: finalKeyword,
        category: analyzer.analyzeKeyword(finalKeyword)
      });
      
      // ã‚·ãƒŠãƒªã‚ªèª¬æ˜ç”Ÿæˆ
      const description = generateEnhancedDescription(path, pattern);
      
      return {
        number: scenarioNum,
        pattern: pattern,
        path: path,
        description: description,
        finalOutcome: finalData?.['ç¾ä»£è§£é‡ˆã®è¦ç´„'] || 'ä¸æ˜',
        accuracyScore: calculatePathAccuracy(path)
      };
    }
    
    // æ‹¡å¼µç‰ˆèª¬æ˜æ–‡ç”Ÿæˆ
    function generateEnhancedDescription(path, pattern) {
      let description = '';
      
      for (let i = 0; i < path.length - 1; i++) {
        const current = path[i];
        const next = path[i + 1];
        
        if (current.choice === 'J') {
          // é€²çˆ»ã®èª¬æ˜ï¼ˆæ‹¡å¼µç‰ˆï¼‰
          const connection = analyzer.getThematicConnection(
            current.category,
            next.category,
            current.keyword,
            next.keyword
          );
          description += `ç¬¬${current.phase}æ®µéš: ${connection}\n`;
        } else if (current.choice === 'H') {
          // å¤‰çˆ»ã®èª¬æ˜ï¼ˆæ‹¡å¼µç‰ˆï¼‰
          const shift = analyzer.getThematicShift(
            current.category,
            next.category,
            current.keyword,
            next.keyword
          );
          description += `ç¬¬${current.phase}æ®µéš: ${shift}\n`;
        }
      }
      
      return description;
    }
    
    // ãƒ‘ã‚¹ã®ç²¾åº¦ã‚¹ã‚³ã‚¢è¨ˆç®—
    function calculatePathAccuracy(path) {
      let classifiedCount = 0;
      let totalCount = 0;
      
      path.forEach(step => {
        if (step.keyword && step.keyword !== 'ä¸æ˜') {
          totalCount++;
          if (step.category !== 'other') {
            classifiedCount++;
          }
        }
      });
      
      return totalCount > 0 ? (classifiedCount / totalCount * 100).toFixed(0) : 0;
    }
    
    // çµæœè¡¨ç¤ºï¼ˆæ‹¡å¼µç‰ˆï¼‰
    function displayEnhancedScenarios(scenarios) {
      const grid = document.getElementById('scenarioGrid');
      grid.innerHTML = '';
      
      scenarios.forEach(scenario => {
        const card = document.createElement('div');
        card.className = 'scenario-card';
        
        card.innerHTML = `
          <span class="pattern-badge">${scenario.pattern} (ç²¾åº¦: ${scenario.accuracyScore}%)</span>
          <h3>ã‚·ãƒŠãƒªã‚ª ${scenario.number}</h3>
          ${scenario.path.map(step => {
            if (step.phase === 'final') {
              return `
                <div class="hex-info" style="background: #fef3c7;">
                  <strong>æœ€çµ‚åˆ°é”:</strong> ${step.hexName}ãƒ»${step.lineName}
                  <br><span class="keyword-tag">${step.keyword}</span>
                  <span class="category-label category-${step.category}">${analyzer.getCategoryLabel(step.category)}</span>
                </div>
              `;
            } else {
              return `
                <div class="hex-info">
                  ç¬¬${step.phase}æ®µéš: ${step.hexName}ãƒ»${step.lineName}
                  <br><span class="keyword-tag">${step.keyword}</span>
                  <span class="category-label category-${step.category}">${analyzer.getCategoryLabel(step.category)}</span>
                  ${step.choice === 'J' ? 'â†’ é€²çˆ»' : 'â‡’ å¤‰çˆ»'}
                </div>
              `;
            }
          }).join('')}
          <p style="margin-top: 10px; font-size: 13px; color: #666;">
            ${scenario.description.substring(0, 150)}...
          </p>
        `;
        
        grid.appendChild(card);
      });
      
      document.getElementById('results').style.display = 'block';
    }
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤º
    function showDebugInfo(analysis, scenarios) {
      const stats = analyzer.getAccuracyStats(H384_DATA);
      const debugDiv = document.getElementById('debugInfo');
      
      debugDiv.innerHTML = `
        <strong>ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆ:</strong><br>
        ç·ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ•°: ${stats.total}<br>
        åˆ†é¡æˆåŠŸ: ${stats.classified} (${stats.classificationRate}%)<br>
        <br>
        <strong>ã‚«ãƒ†ã‚´ãƒªåˆ¥åˆ†é¡æ•°:</strong><br>
        ${Object.entries(stats.categoryCount).map(([cat, count]) => 
          `${analyzer.getCategoryLabel(cat)}: ${count}`
        ).join(', ')}
      `;
      
      debugDiv.style.display = 'block';
    }
    
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function analyzeUserInput(input) {
      return {
        hasWork: input.includes('ä»•äº‹') || input.includes('æ¥­å‹™'),
        hasRelationship: input.includes('æ‹æ„›') || input.includes('é–¢ä¿‚'),
        hasConflict: input.includes('å¯¾ç«‹') || input.includes('äº‰ã„'),
        emotion: input.includes('ä¸å®‰') || input.includes('å¿ƒé…') ? 'negative' : 'neutral'
      };
    }
    
    function selectInitialHexLine(analysis) {
      if (analysis.hasWork && !analysis.hasConflict) {
        return { hex: 11, line: 1 }; // åœ°å¤©æ³°ãƒ»åˆä¹
      }
      if (analysis.hasRelationship) {
        return { hex: 31, line: 1 }; // æ²¢å±±å’¸ãƒ»åˆå…­
      }
      return { hex: 3, line: 1 }; // æ°´é›·å±¯ãƒ»åˆä¹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
    }
    
    function getH384Entry(hex, line) {
      const index = (hex - 1) * 6 + line - 1;
      return H384_DATA[index];
    }
    
    function getLineName(line) {
      const names = ['åˆ', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'ä¸Š'];
      return names[line - 1] || 'ä¸æ˜';
    }
  </script>
</body>
</html>