# 修正版設計書 - 既存コンポーネント統合

作成日: 2025年08月05日  
作成者: HAQEI System Architect  
プロジェクト: Future Simulator 既存コンポーネント統合  
バージョン: 2.0

## 1. 統合アーキテクチャ

### 1.1 修正前（現状）
```
future_simulator.html
    ↓
AuthenticIChingEngine.identifyCurrentSituation()
    ↓ （キーワードマッチングのみ）
固定データ表示
```

### 1.2 修正後（統合）
```
future_simulator.html
    ↓
┌─────────────────────────────────────────┐
│  既存コンポーネント統合フロー            │
├─────────────────────────────────────────┤
│  1. SituationalContextEngine            │
│     └─ analyzeSituationalContext()      │
│           ↓                             │
│  2. HexagramMappingEngine               │
│     └─ mapSituationToHexagram()        │
│           ↓                             │
│  3. Authentic8ScenariosSystem           │
│     └─ generate8TransformationPatterns()│
└─────────────────────────────────────────┘
    ↓
動的結果表示
```

## 2. 統合実装設計

### 2.1 AuthenticIChingEngine修正
```javascript
class AuthenticIChingEngine {
  constructor() {
    // 既存のコンストラクタ
    this.h384Data = window.H384_DATA || [];
    
    // 統合用エンジンの追加
    this.situationalEngine = null;
    this.hexagramEngine = null;
  }

  // 修正版メソッド
  async identifyCurrentSituation(inputText) {
    console.log("🔄 統合版現在状況特定開始");
    
    try {
      // 1. 既存エンジンの初期化（遅延初期化）
      if (!this.situationalEngine) {
        this.situationalEngine = new SituationalContextEngine();
      }
      if (!this.hexagramEngine) {
        this.hexagramEngine = new HexagramMappingEngine();
        await this.hexagramEngine.initialize();
      }
      
      // 2. テキスト分析（既存機能活用）
      const situationData = await this.situationalEngine.analyzeSituationalContext(inputText);
      console.log("📊 状況分析完了:", situationData);
      
      // 3. 易経変換（既存機能活用）
      const hexagramResult = await this.hexagramEngine.mapSituationToHexagram(situationData);
      console.log("🔮 易経変換完了:", hexagramResult);
      
      // 4. 統合結果の構築
      return this.buildIntegratedResult(hexagramResult, situationData);
      
    } catch (error) {
      console.error("❌ 統合処理エラー:", error);
      return this.getFallbackResult();
    }
  }

  buildIntegratedResult(hexagramResult, situationData) {
    return {
      卦番号: hexagramResult.primaryHexagram.id,
      卦名: hexagramResult.primaryHexagram.name,
      爻: hexagramResult.selectedLine.yao || '初九',
      爻位置: hexagramResult.selectedLine.position || 1,
      信頼度: hexagramResult.confidence || 0.8,
      状況分析: situationData,
      易経解釈: hexagramResult.interpretation,
      変卦: hexagramResult.changingHexagram
    };
  }
}
```

### 2.2 future_simulator.html修正
```javascript
class ProgressiveLoader {
  // 既存のコンストラクタとメソッド...

  async displayResults(inputText) {
    console.log('🌟 統合版分析システム開始');
    
    try {
      // 1. エンジン初期化（必要時のみ）
      await this.initializeEngines();
      
      // 2. 統合分析実行
      const analysisResult = await this.performIntegratedAnalysis(inputText);
      
      // 3. 表示更新
      await this.updateAllDisplays(analysisResult);
      
      // 4. チャート更新
      this.updateCharts(analysisResult);
      
      console.log('✅ 統合分析完了');
      
    } catch (error) {
      console.error('❌ 統合分析エラー:', error);
      this.displayFallbackResults(inputText);
    }
  }

  async initializeEngines() {
    // AuthenticIChingEngineは既存のまま使用
    if (!this.authenticEngine) {
      this.authenticEngine = new AuthenticIChingEngine();
    }
    
    // 8シナリオシステムも既存利用
    if (!this.authentic8ScenariosSystem) {
      const container = document.getElementById('scenariosContainer') || this.createScenariosContainer();
      this.authentic8ScenariosSystem = new Authentic8ScenariosSystem(container, this.authenticEngine);
    }
  }

  async performIntegratedAnalysis(inputText) {
    // AuthenticIChingEngineの修正版メソッドを呼び出し
    const currentSituation = await this.authenticEngine.identifyCurrentSituation(inputText);
    
    // 8シナリオ生成
    const scenarios = this.authentic8ScenariosSystem.generate8TransformationPatterns(
      currentSituation.卦番号,
      currentSituation.爻位置,
      currentSituation
    );
    
    return {
      currentSituation,
      scenarios,
      choices: this.generateAuthenticChoices(currentSituation)
    };
  }

  async updateAllDisplays(analysisResult) {
    const { currentSituation, scenarios, choices } = analysisResult;
    
    // 1. 現在地表示
    await this.updateCurrentPositionDisplay(currentSituation);
    
    // 2. 選択肢表示
    this.updateChoicesDisplay(choices);
    
    // 3. 8シナリオ表示
    this.authentic8ScenariosSystem.displayScenarios(scenarios);
  }

  updateCurrentPositionDisplay(situation) {
    // 既存のCurrentPositionDisplayを使用
    if (!this.currentPositionDisplay) {
      const container = document.getElementById('currentPositionContainer') || this.createCurrentPositionContainer();
      this.currentPositionDisplay = new CurrentPositionDisplay(container, this.authenticEngine);
    }
    
    this.currentPositionDisplay.updatePosition(situation);
  }

  updateChoicesDisplay(choices) {
    // 既存のDOM更新
    const choice1 = document.getElementById('choice1');
    const choice2 = document.getElementById('choice2');
    
    if (choice1 && choices.pathA) {
      choice1.querySelector('h3').textContent = choices.pathA.title;
      choice1.querySelector('p').textContent = choices.pathA.description;
    }
    
    if (choice2 && choices.pathB) {
      choice2.querySelector('h3').textContent = choices.pathB.title;
      choice2.querySelector('p').textContent = choices.pathB.description;
    }
  }

  updateCharts(analysisResult) {
    const { currentSituation } = analysisResult;
    
    // チャート用データの生成
    const chartData = {
      卦番号: currentSituation.卦番号,
      卦名: currentSituation.卦名,
      爻: currentSituation.爻,
      基本スコア: currentSituation.状況分析?.situationScore?.difficulty || 50,
      ポテンシャル: currentSituation.状況分析?.situationScore?.changeNecessity || 50,
      安定性: 100 - (currentSituation.状況分析?.situationScore?.urgency || 50),
      リスク: -(currentSituation.状況分析?.situationScore?.complexity || 50),
      変動性: currentSituation.状況分析?.temporalDynamics?.changeVelocity || 50,
      総合評価: Math.round(currentSituation.信頼度 * 100)
    };
    
    // 既存のチャート関数を呼び出し
    if (typeof renderCurrentStateBarChart === 'function') {
      renderCurrentStateBarChart(chartData);
    }
  }
}
```

## 3. データインターフェース

### 3.1 SituationalContextEngine → HexagramMappingEngine
```javascript
// SituationalContextEngineの出力
{
  primarySituation: {
    type: "challenge",
    intensity: 0.8,
    description: "..."
  },
  emotionalProfile: {
    valence: -0.3,
    arousal: 0.7,
    dominantEmotion: "anxiety"
  },
  temporalDynamics: {
    stage: "transition",
    changeVelocity: 0.6
  },
  contextualFactors: {...},
  confidence: 0.85
}

// HexagramMappingEngineが期待する入力
// （既存のインターフェースに準拠）
```

### 3.2 HexagramMappingEngine → Authentic8ScenariosSystem
```javascript
// HexagramMappingEngineの出力
{
  primaryHexagram: {
    id: 12,
    name: "否",
    upperTrigram: "天",
    lowerTrigram: "地"
  },
  selectedLine: {
    position: 3,
    yao: "九三",
    text: "包羞"
  },
  changingHexagram: {
    id: 33,
    name: "遯"
  },
  confidence: 0.87
}
```

## 4. エラーハンドリング

### 4.1 エラーパターンと対処
```javascript
try {
  // 統合処理
} catch (error) {
  if (error.name === 'SituationalAnalysisError') {
    // 基本的な分析にフォールバック
    return this.performBasicAnalysis(inputText);
  } else if (error.name === 'HexagramMappingError') {
    // デフォルトの第12卦を使用
    return this.getDefaultHexagramResult();
  } else {
    // 完全なフォールバック
    return this.getFallbackResult();
  }
}
```

## 5. パフォーマンス考慮

### 5.1 初期化の最適化
- エンジンの遅延初期化
- 必要時のみインスタンス生成

### 5.2 非同期処理
- Promise.allによる並列処理検討
- プログレッシブレンダリング維持

## 6. テスト計画

### 6.1 単体テスト
- AuthenticIChingEngine.identifyCurrentSituation()の動作確認
- 各エンジン間のデータ受け渡し確認

### 6.2 統合テスト
- エンドツーエンドフロー確認
- 様々な入力パターンでの検証

## 7. 移行リスク

### 7.1 後方互換性
- 既存のインターフェース維持
- 段階的な移行アプローチ

### 7.2 データ整合性
- エンジン間のデータ形式確認
- 必要に応じたアダプター実装

## 8. 承認

本設計書は、既存コンポーネントの統合による実装方針として承認されました。

**次のステップ**: 統合実装の開始