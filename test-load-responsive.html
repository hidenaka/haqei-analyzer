<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAQEI Load & Responsive Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .header h1 {
            color: #0984e3;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-section {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .test-section h3 {
            color: #0984e3;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .test-button {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(116, 185, 255, 0.3);
        }

        .test-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .test-result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }

        .success { background: #d4edda; border-left: 4px solid #28a745; }
        .warning { background: #fff3cd; border-left: 4px solid #ffc107; }
        .error { background: #f8d7da; border-left: 4px solid #dc3545; }

        .load-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .load-bar {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .load-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            width: 0%;
            transition: width 0.3s ease;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #0984e3;
        }

        .metric-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 5px;
        }

        .device-test {
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            background: white;
        }

        .device-test.active {
            border-color: #74b9ff;
            background: #f0f8ff;
        }

        .responsive-frame {
            border: 2px solid #ccc;
            border-radius: 8px;
            margin: 10px 0;
            overflow: hidden;
            resize: both;
            min-width: 320px;
            min-height: 200px;
        }

        .stress-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .stress-input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 80px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-idle { background: #6c757d; }
        .status-running { background: #ffc107; animation: pulse 1s infinite; }
        .status-success { background: #28a745; }
        .status-warning { background: #ffc107; }
        .status-error { background: #dc3545; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .realtime-chart {
            height: 200px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin: 15px 0;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .test-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stress-controls {
                flex-direction: column;
                align-items: stretch;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .metric-value {
                font-size: 1.4em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ HAQEI è² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆ</h1>
            <p>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ»å®‰å®šæ€§ãƒ»ãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œã®ç·åˆãƒ†ã‚¹ãƒˆ</p>
        </div>

        <div class="test-grid">
            <!-- è² è·ãƒ†ã‚¹ãƒˆ -->
            <div class="test-section">
                <h3>
                    <span class="status-indicator status-idle" id="loadStatus"></span>
                    ğŸ”¥ è² è·ãƒ†ã‚¹ãƒˆ
                </h3>
                <p>ã‚·ã‚¹ãƒ†ãƒ ã®å‡¦ç†èƒ½åŠ›ã¨å®‰å®šæ€§ã‚’æ¤œè¨¼</p>
                
                <div class="stress-controls">
                    <label>åŒæ™‚å®Ÿè¡Œæ•°:</label>
                    <input type="number" class="stress-input" id="concurrentCount" value="10" min="1" max="100">
                    
                    <label>å®Ÿè¡Œå›æ•°:</label>
                    <input type="number" class="stress-input" id="iterationCount" value="50" min="1" max="1000">
                    
                    <label>é–“éš”(ms):</label>
                    <input type="number" class="stress-input" id="intervalMs" value="100" min="0" max="5000">
                </div>

                <div class="load-meter">
                    <span>è² è·:</span>
                    <div class="load-bar">
                        <div class="load-fill" id="loadProgress"></div>
                    </div>
                    <span id="loadPercentage">0%</span>
                </div>

                <button class="test-button" onclick="runLoadTest()">è² è·ãƒ†ã‚¹ãƒˆé–‹å§‹</button>
                <button class="test-button" onclick="stopLoadTest()">åœæ­¢</button>
                
                <div class="test-result" id="loadResult"></div>
            </div>

            <!-- ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆ -->
            <div class="test-section">
                <h3>
                    <span class="status-indicator status-idle" id="memoryStatus"></span>
                    ğŸ§  ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆ
                </h3>
                <p>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã¨ãƒªãƒ¼ã‚¯æ¤œå‡º</p>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="heapUsed">0</div>
                        <div class="metric-label">ä½¿ç”¨ä¸­ (MB)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="heapTotal">0</div>
                        <div class="metric-label">ç·è¨ˆ (MB)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="heapLimit">0</div>
                        <div class="metric-label">åˆ¶é™ (MB)</div>
                    </div>
                </div>

                <button class="test-button" onclick="runMemoryTest()">ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆé–‹å§‹</button>
                <button class="test-button" onclick="forceGC()" title="ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ">GCå®Ÿè¡Œ</button>
                
                <div class="realtime-chart" id="memoryChart">
                    <canvas id="memoryCanvas" width="100" height="180"></canvas>
                </div>
                
                <div class="test-result" id="memoryResult"></div>
            </div>

            <!-- ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆ -->
            <div class="test-section">
                <h3>
                    <span class="status-indicator status-idle" id="responsiveStatus"></span>
                    ğŸ“± ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆ
                </h3>
                <p>ãƒ‡ãƒã‚¤ã‚¹åˆ¥å‹•ä½œç¢ºèª</p>

                <div class="device-test" id="desktopTest">
                    <strong>ğŸ–¥ï¸ ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ— (1920x1080)</strong>
                    <button class="test-button" onclick="testDevice('desktop', 1920, 1080)">ãƒ†ã‚¹ãƒˆ</button>
                    <div id="desktopResult" class="test-result"></div>
                </div>

                <div class="device-test" id="tabletTest">
                    <strong>ğŸ“± ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ (768x1024)</strong>
                    <button class="test-button" onclick="testDevice('tablet', 768, 1024)">ãƒ†ã‚¹ãƒˆ</button>
                    <div id="tabletResult" class="test-result"></div>
                </div>

                <div class="device-test" id="mobileTest">
                    <strong>ğŸ“± ãƒ¢ãƒã‚¤ãƒ« (375x667)</strong>
                    <button class="test-button" onclick="testDevice('mobile', 375, 667)">ãƒ†ã‚¹ãƒˆ</button>
                    <div id="mobileResult" class="test-result"></div>
                </div>

                <button class="test-button" onclick="runAllResponsiveTests()">å…¨ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆ</button>
            </div>

            <!-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦– -->
            <div class="test-section">
                <h3>
                    <span class="status-indicator status-idle" id="performanceStatus"></span>
                    ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
                </h3>
                <p>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¿½è·¡</p>

                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="avgResponseTime">0</div>
                        <div class="metric-label">å¹³å‡å¿œç­”æ™‚é–“ (ms)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="successRate">100</div>
                        <div class="metric-label">æˆåŠŸç‡ (%)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="errorCount">0</div>
                        <div class="metric-label">ã‚¨ãƒ©ãƒ¼æ•°</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="throughput">0</div>
                        <div class="metric-label">ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ (/s)</div>
                    </div>
                </div>

                <button class="test-button" onclick="startPerformanceMonitoring()">ç›£è¦–é–‹å§‹</button>
                <button class="test-button" onclick="stopPerformanceMonitoring()">ç›£è¦–åœæ­¢</button>
                
                <div class="realtime-chart" id="performanceChart">
                    <canvas id="performanceCanvas" width="100" height="180"></canvas>
                </div>
            </div>
        </div>

        <!-- ç·åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ -->
        <div class="test-section">
            <h3>ğŸš€ åŒ…æ‹¬çš„è² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆ</h3>
            <button class="test-button" onclick="runAllTests()" style="background: linear-gradient(135deg, #e17055, #d63031); font-size: 16px; padding: 15px 25px;">
                å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            </button>
            <button class="test-button" onclick="generatePerformanceReport()">ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</button>
        </div>
    </div>

    <!-- ä¾å­˜é–¢ä¿‚ã®èª­ã¿è¾¼ã¿ -->
    <script src="assets/H384H64database.js"></script>
    <script src="js/pages/future-simulator/IntegratedAnalysisEngine.js"></script>
    <script src="js/pages/future-simulator/MetaphorGenerationEngine.js"></script>
    <script src="js/pages/future-simulator/DynamicKeywordGenerator.js"></script>

    <script>
        // è² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
        class LoadResponsiveTestController {
            constructor() {
                this.testResults = new Map();
                this.loadTestRunning = false;
                this.performanceMonitoring = false;
                this.memoryHistory = [];
                this.performanceHistory = [];
                this.analysisEngine = null;
                this.chartContexts = {};
                
                this.initializeCharts();
            }

            initializeCharts() {
                // ãƒ¡ãƒ¢ãƒªãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
                const memoryCanvas = document.getElementById('memoryCanvas');
                if (memoryCanvas) {
                    this.chartContexts.memory = memoryCanvas.getContext('2d');
                    this.resizeCanvas(memoryCanvas);
                }

                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
                const performanceCanvas = document.getElementById('performanceCanvas');
                if (performanceCanvas) {
                    this.chartContexts.performance = performanceCanvas.getContext('2d');
                    this.resizeCanvas(performanceCanvas);
                }

                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
                window.addEventListener('resize', () => {
                    if (memoryCanvas) this.resizeCanvas(memoryCanvas);
                    if (performanceCanvas) this.resizeCanvas(performanceCanvas);
                });
            }

            resizeCanvas(canvas) {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth - 20;
                canvas.height = 180;
            }

            async initialize() {
                try {
                    console.log('âš¡ è² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–');
                    
                    // åˆ†æã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–
                    this.analysisEngine = new IntegratedAnalysisEngine(window.tokenizer);
                    if (this.analysisEngine.initializeAsync) {
                        await this.analysisEngine.initializeAsync();
                    }

                    // ãƒ¡ãƒ¢ãƒªç›£è¦–é–‹å§‹
                    this.startMemoryMonitoring();
                    
                    console.log('âœ… è² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆæº–å‚™å®Œäº†');
                } catch (error) {
                    console.error('âŒ ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            updateStatus(testType, status) {
                const statusElement = document.getElementById(`${testType}Status`);
                if (statusElement) {
                    statusElement.className = `status-indicator status-${status}`;
                }
            }

            displayResult(testType, result, success = true) {
                const resultElement = document.getElementById(`${testType}Result`);
                if (resultElement) {
                    resultElement.className = `test-result ${success ? 'success' : 'error'}`;
                    resultElement.textContent = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
                }
                
                this.testResults.set(testType, { 
                    success, 
                    result, 
                    timestamp: Date.now() 
                });
            }

            // è² è·ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            async runLoadTest() {
                if (this.loadTestRunning) return;
                
                this.loadTestRunning = true;
                this.updateStatus('load', 'running');
                
                const concurrentCount = parseInt(document.getElementById('concurrentCount').value);
                const iterationCount = parseInt(document.getElementById('iterationCount').value);
                const intervalMs = parseInt(document.getElementById('intervalMs').value);
                
                console.log(`ğŸ”¥ è² è·ãƒ†ã‚¹ãƒˆé–‹å§‹: ${concurrentCount}ä¸¦åˆ— x ${iterationCount}å›`);
                
                const loadResults = {
                    startTime: Date.now(),
                    totalRequests: 0,
                    successfulRequests: 0,
                    failedRequests: 0,
                    responseTimes: [],
                    errors: [],
                    peakMemory: 0,
                    avgResponseTime: 0,
                    throughput: 0
                };

                try {
                    const testInputs = [
                        'è² è·ãƒ†ã‚¹ãƒˆå…¥åŠ›1: äººé–“é–¢ä¿‚ã§æ‚©ã‚“ã§ã„ã¾ã™',
                        'è² è·ãƒ†ã‚¹ãƒˆå…¥åŠ›2: å°†æ¥ã¸ã®ä¸å®‰ãŒã‚ã‚Šã¾ã™',
                        'è² è·ãƒ†ã‚¹ãƒˆå…¥åŠ›3: ä»•äº‹ã§ã‚¹ãƒˆãƒ¬ã‚¹ã‚’æ„Ÿã˜ã¦ã„ã¾ã™',
                        'è² è·ãƒ†ã‚¹ãƒˆå…¥åŠ›4: è‡ªåˆ†ã®æ€§æ ¼ã«ã¤ã„ã¦è€ƒãˆã¦ã„ã¾ã™',
                        'è² è·ãƒ†ã‚¹ãƒˆå…¥åŠ›5: æ‹æ„›ã§è¿·ã„ãŒã‚ã‚Šã¾ã™'
                    ];

                    for (let iteration = 0; iteration < iterationCount && this.loadTestRunning; iteration++) {
                        const promises = [];
                        
                        // ä¸¦åˆ—å®Ÿè¡Œ
                        for (let concurrent = 0; concurrent < concurrentCount; concurrent++) {
                            const testInput = testInputs[concurrent % testInputs.length];
                            const promise = this.executeLoadTestRequest(testInput, loadResults);
                            promises.push(promise);
                        }

                        await Promise.allSettled(promises);
                        
                        // é€²æ—æ›´æ–°
                        const progress = ((iteration + 1) / iterationCount) * 100;
                        document.getElementById('loadProgress').style.width = `${progress}%`;
                        document.getElementById('loadPercentage').textContent = `${Math.round(progress)}%`;

                        // ãƒ¡ãƒ¢ãƒªç›£è¦–
                        if (performance.memory) {
                            const currentMemory = performance.memory.usedJSHeapSize / 1024 / 1024;
                            if (currentMemory > loadResults.peakMemory) {
                                loadResults.peakMemory = currentMemory;
                            }
                        }

                        // é–“éš”åˆ¶å¾¡
                        if (intervalMs > 0 && iteration < iterationCount - 1) {
                            await new Promise(resolve => setTimeout(resolve, intervalMs));
                        }
                    }

                    loadResults.endTime = Date.now();
                    loadResults.totalDuration = loadResults.endTime - loadResults.startTime;
                    loadResults.avgResponseTime = loadResults.responseTimes.length > 0 
                        ? loadResults.responseTimes.reduce((a, b) => a + b, 0) / loadResults.responseTimes.length 
                        : 0;
                    loadResults.throughput = loadResults.totalDuration > 0 
                        ? (loadResults.successfulRequests / (loadResults.totalDuration / 1000)).toFixed(2)
                        : 0;

                    const successRate = loadResults.totalRequests > 0 
                        ? (loadResults.successfulRequests / loadResults.totalRequests * 100).toFixed(1)
                        : 0;

                    const isSuccess = loadResults.avgResponseTime < 2000 && successRate >= 95;

                    const report = `è² è·ãƒ†ã‚¹ãƒˆçµæœ:
ç·å®Ÿè¡Œæ™‚é–“: ${(loadResults.totalDuration / 1000).toFixed(2)}ç§’
ç·ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°: ${loadResults.totalRequests}
æˆåŠŸ: ${loadResults.successfulRequests}
å¤±æ•—: ${loadResults.failedRequests}
æˆåŠŸç‡: ${successRate}%
å¹³å‡å¿œç­”æ™‚é–“: ${loadResults.avgResponseTime.toFixed(2)}ms
æœ€å¤§å¿œç­”æ™‚é–“: ${Math.max(...loadResults.responseTimes, 0).toFixed(2)}ms
æœ€å°å¿œç­”æ™‚é–“: ${Math.min(...loadResults.responseTimes, Infinity).toFixed(2)}ms
ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: ${loadResults.throughput} req/sec
ãƒ”ãƒ¼ã‚¯ãƒ¡ãƒ¢ãƒª: ${loadResults.peakMemory.toFixed(2)}MB

æ€§èƒ½è©•ä¾¡: ${isSuccess ? 'âœ… åˆæ ¼' : 'âŒ æ”¹å–„å¿…è¦'}
${loadResults.errors.length > 0 ? `
ã‚¨ãƒ©ãƒ¼è©³ç´°:
${loadResults.errors.slice(0, 5).map(e => `- ${e}`).join('\n')}
${loadResults.errors.length > 5 ? `... ä»–${loadResults.errors.length - 5}ä»¶` : ''}` : ''}`;

                    this.updateStatus('load', isSuccess ? 'success' : 'warning');
                    this.displayResult('load', report, isSuccess);

                } catch (error) {
                    console.error('è² è·ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('load', 'error');
                    this.displayResult('load', `è² è·ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, false);
                } finally {
                    this.loadTestRunning = false;
                    document.getElementById('loadProgress').style.width = '0%';
                    document.getElementById('loadPercentage').textContent = '0%';
                }
            }

            async executeLoadTestRequest(testInput, loadResults) {
                const startTime = performance.now();
                
                try {
                    loadResults.totalRequests++;
                    
                    const result = await this.analysisEngine.performSevenStageAnalysis(
                        testInput, 
                        'load_test', 
                        null
                    );
                    
                    const responseTime = performance.now() - startTime;
                    loadResults.responseTimes.push(responseTime);
                    
                    if (result && result.finalResult && result.finalResult.confidence > 0.3) {
                        loadResults.successfulRequests++;
                    } else {
                        loadResults.failedRequests++;
                        loadResults.errors.push(`ä½ä¿¡é ¼åº¦: ${result?.finalResult?.confidence || 0}`);
                    }
                    
                } catch (error) {
                    const responseTime = performance.now() - startTime;
                    loadResults.responseTimes.push(responseTime);
                    loadResults.failedRequests++;
                    loadResults.errors.push(error.message);
                }
            }

            stopLoadTest() {
                this.loadTestRunning = false;
                this.updateStatus('load', 'idle');
                console.log('ğŸ›‘ è² è·ãƒ†ã‚¹ãƒˆåœæ­¢');
            }

            // ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            async runMemoryTest() {
                this.updateStatus('memory', 'running');
                console.log('ğŸ§  ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆé–‹å§‹');

                try {
                    const memoryResults = {
                        initialMemory: 0,
                        peakMemory: 0,
                        finalMemory: 0,
                        memoryGrowth: 0,
                        leakDetected: false,
                        allocations: 0
                    };

                    // åˆæœŸãƒ¡ãƒ¢ãƒªæ¸¬å®š
                    if (performance.memory) {
                        memoryResults.initialMemory = performance.memory.usedJSHeapSize / 1024 / 1024;
                    }

                    // ãƒ¡ãƒ¢ãƒªè² è·ãƒ†ã‚¹ãƒˆ
                    const largeData = [];
                    for (let i = 0; i < 100; i++) {
                        // å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
                        const data = await this.analysisEngine.performSevenStageAnalysis(
                            `ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆ${i}: ${'å¤§é‡ã®ãƒ‡ãƒ¼ã‚¿ '.repeat(100)}`,
                            'memory_test',
                            null
                        );
                        
                        largeData.push(data);
                        memoryResults.allocations++;

                        // ãƒ¡ãƒ¢ãƒªç›£è¦–
                        if (performance.memory) {
                            const currentMemory = performance.memory.usedJSHeapSize / 1024 / 1024;
                            if (currentMemory > memoryResults.peakMemory) {
                                memoryResults.peakMemory = currentMemory;
                            }
                        }

                        // é€²æ—æ›´æ–°
                        if (i % 10 === 0) {
                            this.updateMemoryDisplay();
                        }
                    }

                    // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
                    if (window.gc) {
                        window.gc();
                    }

                    // æœ€çµ‚ãƒ¡ãƒ¢ãƒªæ¸¬å®š
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    if (performance.memory) {
                        memoryResults.finalMemory = performance.memory.usedJSHeapSize / 1024 / 1024;
                    }

                    memoryResults.memoryGrowth = memoryResults.finalMemory - memoryResults.initialMemory;
                    memoryResults.leakDetected = memoryResults.memoryGrowth > 50; // 50MBä»¥ä¸Šã®å¢—åŠ ã¯ãƒªãƒ¼ã‚¯ç–‘ã„

                    const isSuccess = !memoryResults.leakDetected && memoryResults.memoryGrowth < 100;

                    const report = `ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆçµæœ:
åˆæœŸãƒ¡ãƒ¢ãƒª: ${memoryResults.initialMemory.toFixed(2)}MB
ãƒ”ãƒ¼ã‚¯ãƒ¡ãƒ¢ãƒª: ${memoryResults.peakMemory.toFixed(2)}MB
æœ€çµ‚ãƒ¡ãƒ¢ãƒª: ${memoryResults.finalMemory.toFixed(2)}MB
ãƒ¡ãƒ¢ãƒªå¢—åŠ : ${memoryResults.memoryGrowth.toFixed(2)}MB
ãƒªãƒ¼ã‚¯æ¤œå‡º: ${memoryResults.leakDetected ? 'âŒ ç–‘ã„ã‚ã‚Š' : 'âœ… ãªã—'}
å‰²ã‚Šå½“ã¦å›æ•°: ${memoryResults.allocations}

è©•ä¾¡: ${isSuccess ? 'âœ… æ­£å¸¸' : 'âš ï¸ è¦æ”¹å–„'}`;

                    this.updateStatus('memory', isSuccess ? 'success' : 'warning');
                    this.displayResult('memory', report, isSuccess);

                } catch (error) {
                    console.error('ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('memory', 'error');
                    this.displayResult('memory', `ãƒ¡ãƒ¢ãƒªãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, false);
                }
            }

            forceGC() {
                if (window.gc) {
                    window.gc();
                    console.log('ğŸ—‘ï¸ ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ');
                } else {
                    console.warn('âš ï¸ ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³APIåˆ©ç”¨ä¸å¯');
                }
                this.updateMemoryDisplay();
            }

            startMemoryMonitoring() {
                setInterval(() => {
                    this.updateMemoryDisplay();
                    this.updateMemoryChart();
                }, 1000);
            }

            updateMemoryDisplay() {
                if (performance.memory) {
                    const memory = performance.memory;
                    document.getElementById('heapUsed').textContent = (memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    document.getElementById('heapTotal').textContent = (memory.totalJSHeapSize / 1024 / 1024).toFixed(1);
                    document.getElementById('heapLimit').textContent = (memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1);
                }
            }

            updateMemoryChart() {
                if (!this.chartContexts.memory || !performance.memory) return;

                const ctx = this.chartContexts.memory;
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;

                // å±¥æ­´ã«è¿½åŠ 
                const memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;
                this.memoryHistory.push(memoryUsage);
                if (this.memoryHistory.length > width / 2) {
                    this.memoryHistory.shift();
                }

                // ãƒãƒ£ãƒ¼ãƒˆã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, width, height);

                if (this.memoryHistory.length < 2) return;

                // ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
                const maxMemory = Math.max(...this.memoryHistory);
                const minMemory = Math.min(...this.memoryHistory);
                const range = maxMemory - minMemory || 1;

                // ã‚°ãƒªãƒƒãƒ‰æç”»
                ctx.strokeStyle = '#e9ecef';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = (height / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒ©ã‚¤ãƒ³æç”»
                ctx.strokeStyle = '#74b9ff';
                ctx.lineWidth = 2;
                ctx.beginPath();

                this.memoryHistory.forEach((memory, index) => {
                    const x = (index / (this.memoryHistory.length - 1)) * width;
                    const y = height - ((memory - minMemory) / range) * height;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // ç¾åœ¨å€¤è¡¨ç¤º
                ctx.fillStyle = '#0984e3';
                ctx.font = '12px Arial';
                ctx.fillText(`${memoryUsage.toFixed(1)}MB`, width - 60, 20);
            }

            // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆ
            async testDevice(deviceType, width, height) {
                this.updateStatus('responsive', 'running');
                console.log(`ğŸ“± ${deviceType}ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹: ${width}x${height}`);

                // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ‡ãƒã‚¤ã‚¹è¡¨ç¤º
                document.querySelectorAll('.device-test').forEach(test => test.classList.remove('active'));
                document.getElementById(`${deviceType}Test`).classList.add('active');

                try {
                    const deviceResults = {
                        deviceType: deviceType,
                        width: width,
                        height: height,
                        viewportSupported: true,
                        elementsVisible: true,
                        responsiveLayout: true,
                        touchSupport: false,
                        performanceScore: 0
                    };

                    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¯¾å¿œãƒã‚§ãƒƒã‚¯
                    const metaViewport = document.querySelector('meta[name="viewport"]');
                    deviceResults.viewportSupported = !!metaViewport;

                    // ã‚¿ãƒƒãƒã‚µãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
                    deviceResults.touchSupport = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

                    // ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
                    const originalWidth = window.innerWidth;
                    const originalHeight = window.innerHeight;

                    // CSS ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¯ã‚¨ãƒªãƒã‚§ãƒƒã‚¯
                    const mediaQueries = {
                        mobile: window.matchMedia('(max-width: 480px)').matches,
                        tablet: window.matchMedia('(max-width: 768px)').matches,
                        desktop: window.matchMedia('(min-width: 769px)').matches
                    };

                    deviceResults.mediaQuerySupport = mediaQueries;

                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
                    const startTime = performance.now();
                    const result = await this.analysisEngine.performSevenStageAnalysis(
                        `${deviceType}ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆ: ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œç¢ºèª`,
                        'responsive_test',
                        null
                    );
                    const responseTime = performance.now() - startTime;

                    deviceResults.performanceScore = responseTime < 1000 ? 100 : Math.max(0, 100 - (responseTime - 1000) / 10);

                    // è¦ç´ è¡¨ç¤ºç¢ºèª
                    const importantElements = [
                        '.container',
                        '.header',
                        '.test-section',
                        '.test-button'
                    ];

                    deviceResults.visibleElements = 0;
                    importantElements.forEach(selector => {
                        const element = document.querySelector(selector);
                        if (element && element.offsetWidth > 0 && element.offsetHeight > 0) {
                            deviceResults.visibleElements++;
                        }
                    });

                    deviceResults.elementsVisible = deviceResults.visibleElements === importantElements.length;

                    const isSuccess = deviceResults.viewportSupported && 
                                    deviceResults.elementsVisible && 
                                    deviceResults.performanceScore > 70;

                    const report = `${deviceType}ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆçµæœ:
ç”»é¢ã‚µã‚¤ã‚º: ${width}x${height}
ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¯¾å¿œ: ${deviceResults.viewportSupported ? 'âœ…' : 'âŒ'}
è¦ç´ è¡¨ç¤º: ${deviceResults.visibleElements}/${importantElements.length} ${deviceResults.elementsVisible ? 'âœ…' : 'âŒ'}
ã‚¿ãƒƒãƒã‚µãƒãƒ¼ãƒˆ: ${deviceResults.touchSupport ? 'âœ…' : 'âŒ'}
ãƒ¡ãƒ‡ã‚£ã‚¢ã‚¯ã‚¨ãƒª: Mobile:${mediaQueries.mobile} Tablet:${mediaQueries.tablet} Desktop:${mediaQueries.desktop}
å¿œç­”æ™‚é–“: ${responseTime.toFixed(2)}ms
ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚¹ã‚³ã‚¢: ${deviceResults.performanceScore.toFixed(1)}/100

è©•ä¾¡: ${isSuccess ? 'âœ… åˆæ ¼' : 'âŒ æ”¹å–„å¿…è¦'}`;

                    this.updateStatus('responsive', isSuccess ? 'success' : 'warning');
                    this.displayResult(`${deviceType}`, report, isSuccess);

                } catch (error) {
                    console.error(`${deviceType}ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:`, error);
                    this.displayResult(`${deviceType}`, `${deviceType}ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, false);
                } finally {
                    document.getElementById(`${deviceType}Test`).classList.remove('active');
                }
            }

            async runAllResponsiveTests() {
                console.log('ğŸ“± å…¨ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹');
                await this.testDevice('desktop', 1920, 1080);
                await this.testDevice('tablet', 768, 1024);
                await this.testDevice('mobile', 375, 667);
                this.updateStatus('responsive', 'success');
                console.log('âœ… å…¨ãƒ‡ãƒã‚¤ã‚¹ãƒ†ã‚¹ãƒˆå®Œäº†');
            }

            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
            startPerformanceMonitoring() {
                if (this.performanceMonitoring) return;
                
                this.performanceMonitoring = true;
                this.updateStatus('performance', 'running');
                console.log('ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–é–‹å§‹');

                this.performanceInterval = setInterval(() => {
                    this.updatePerformanceMetrics();
                    this.updatePerformanceChart();
                }, 1000);
            }

            stopPerformanceMonitoring() {
                this.performanceMonitoring = false;
                this.updateStatus('performance', 'idle');
                console.log('ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–åœæ­¢');

                if (this.performanceInterval) {
                    clearInterval(this.performanceInterval);
                }
            }

            updatePerformanceMetrics() {
                // ãƒ€ãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯å®Ÿéš›ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’åé›†ï¼‰
                const currentTime = Date.now();
                const metrics = {
                    responseTime: Math.random() * 1000 + 200,
                    successRate: 95 + Math.random() * 5,
                    errorCount: Math.floor(Math.random() * 3),
                    throughput: 10 + Math.random() * 20
                };

                // å±¥æ­´ã«è¿½åŠ 
                this.performanceHistory.push({
                    timestamp: currentTime,
                    ...metrics
                });

                if (this.performanceHistory.length > 60) {
                    this.performanceHistory.shift();
                }

                // å¹³å‡å€¤è¨ˆç®—
                const recent = this.performanceHistory.slice(-10);
                const avgResponseTime = recent.reduce((sum, m) => sum + m.responseTime, 0) / recent.length;
                const avgSuccessRate = recent.reduce((sum, m) => sum + m.successRate, 0) / recent.length;
                const totalErrors = recent.reduce((sum, m) => sum + m.errorCount, 0);
                const avgThroughput = recent.reduce((sum, m) => sum + m.throughput, 0) / recent.length;

                // UIæ›´æ–°
                document.getElementById('avgResponseTime').textContent = avgResponseTime.toFixed(0);
                document.getElementById('successRate').textContent = avgSuccessRate.toFixed(1);
                document.getElementById('errorCount').textContent = totalErrors;
                document.getElementById('throughput').textContent = avgThroughput.toFixed(1);
            }

            updatePerformanceChart() {
                if (!this.chartContexts.performance || this.performanceHistory.length < 2) return;

                const ctx = this.chartContexts.performance;
                const canvas = ctx.canvas;
                const width = canvas.width;
                const height = canvas.height;

                // ãƒãƒ£ãƒ¼ãƒˆã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, width, height);

                // ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
                const responseTimes = this.performanceHistory.map(h => h.responseTime);
                const maxResponseTime = Math.max(...responseTimes);
                const minResponseTime = Math.min(...responseTimes);
                const range = maxResponseTime - minResponseTime || 1;

                // ã‚°ãƒªãƒƒãƒ‰æç”»
                ctx.strokeStyle = '#e9ecef';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 5; i++) {
                    const y = (height / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // å¿œç­”æ™‚é–“ãƒ©ã‚¤ãƒ³æç”»
                ctx.strokeStyle = '#74b9ff';
                ctx.lineWidth = 2;
                ctx.beginPath();

                this.performanceHistory.forEach((metric, index) => {
                    const x = (index / (this.performanceHistory.length - 1)) * width;
                    const y = height - ((metric.responseTime - minResponseTime) / range) * height;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // ç¾åœ¨å€¤è¡¨ç¤º
                ctx.fillStyle = '#0984e3';
                ctx.font = '12px Arial';
                const currentResponseTime = responseTimes[responseTimes.length - 1];
                ctx.fillText(`${currentResponseTime.toFixed(0)}ms`, width - 60, 20);
            }

            // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            async runAllTests() {
                console.log('ğŸš€ åŒ…æ‹¬çš„è² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆé–‹å§‹');
                
                try {
                    await this.initialize();
                    
                    // ä¸¦è¡Œã—ã¦ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
                    await Promise.all([
                        this.runMemoryTest(),
                        this.runAllResponsiveTests()
                    ]);
                    
                    // è² è·ãƒ†ã‚¹ãƒˆã¯æœ€å¾Œã«å®Ÿè¡Œ
                    await this.runLoadTest();
                    
                    console.log('âœ… å…¨ãƒ†ã‚¹ãƒˆå®Œäº†');
                    
                } catch (error) {
                    console.error('âŒ å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
            generatePerformanceReport() {
                const timestamp = new Date().toISOString();
                const totalTests = this.testResults.size;
                const successfulTests = Array.from(this.testResults.values()).filter(r => r.success).length;

                const report = {
                    timestamp: timestamp,
                    summary: {
                        totalTests: totalTests,
                        successfulTests: successfulTests,
                        failedTests: totalTests - successfulTests,
                        successRate: totalTests > 0 ? (successfulTests / totalTests) * 100 : 0
                    },
                    testResults: Object.fromEntries(this.testResults),
                    performanceMetrics: {
                        memoryHistory: this.memoryHistory.slice(-100), // æœ€æ–°100ä»¶
                        performanceHistory: this.performanceHistory.slice(-100),
                        currentMemory: performance.memory ? {
                            used: performance.memory.usedJSHeapSize / 1024 / 1024,
                            total: performance.memory.totalJSHeapSize / 1024 / 1024,
                            limit: performance.memory.jsHeapSizeLimit / 1024 / 1024
                        } : null
                    },
                    environment: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        platform: navigator.platform,
                        screenSize: `${screen.width}x${screen.height}`,
                        viewportSize: `${window.innerWidth}x${window.innerHeight}`,
                        devicePixelRatio: window.devicePixelRatio,
                        connectionType: navigator.connection ? navigator.connection.effectiveType : 'unknown',
                        memorySupport: !!performance.memory,
                        touchSupport: 'ontouchstart' in window
                    },
                    recommendations: this.generatePerformanceRecommendations()
                };

                // ãƒ¬ãƒãƒ¼ãƒˆã‚’JSONã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `haqei-performance-report-${timestamp.replace(/[:.]/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸ', report);
            }

            generatePerformanceRecommendations() {
                const recommendations = [];
                
                // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯
                if (performance.memory && performance.memory.usedJSHeapSize > 50 * 1024 * 1024) {
                    recommendations.push('ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ã„ã§ã™ã€‚ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®æœ€é©åŒ–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚');
                }
                
                // å¿œç­”æ™‚é–“ãƒã‚§ãƒƒã‚¯
                const avgResponseTime = this.performanceHistory.length > 0 
                    ? this.performanceHistory.reduce((sum, h) => sum + h.responseTime, 0) / this.performanceHistory.length 
                    : 0;
                
                if (avgResponseTime > 1000) {
                    recommendations.push('å¿œç­”æ™‚é–“ãŒé…ã„ã§ã™ã€‚ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æœ€é©åŒ–ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚');
                }
                
                // ãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œãƒã‚§ãƒƒã‚¯
                const mobileTest = this.testResults.get('mobile');
                if (mobileTest && !mobileTest.success) {
                    recommendations.push('ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œã«å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’æ”¹å–„ã—ã¦ãã ã•ã„ã€‚');
                }
                
                if (recommendations.length === 0) {
                    recommendations.push('ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯è‰¯å¥½ã§ã™ã€‚ç¾åœ¨ã®æœ€é©åŒ–ãƒ¬ãƒ™ãƒ«ã‚’ç¶­æŒã—ã¦ãã ã•ã„ã€‚');
                }
                
                return recommendations;
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
        const loadTestController = new LoadResponsiveTestController();

        // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–¢æ•°
        async function runLoadTest() {
            await loadTestController.initialize();
            await loadTestController.runLoadTest();
        }

        function stopLoadTest() {
            loadTestController.stopLoadTest();
        }

        async function runMemoryTest() {
            await loadTestController.initialize();
            await loadTestController.runMemoryTest();
        }

        function forceGC() {
            loadTestController.forceGC();
        }

        async function testDevice(deviceType, width, height) {
            await loadTestController.initialize();
            await loadTestController.testDevice(deviceType, width, height);
        }

        async function runAllResponsiveTests() {
            await loadTestController.initialize();
            await loadTestController.runAllResponsiveTests();
        }

        function startPerformanceMonitoring() {
            loadTestController.startPerformanceMonitoring();
        }

        function stopPerformanceMonitoring() {
            loadTestController.stopPerformanceMonitoring();
        }

        async function runAllTests() {
            await loadTestController.runAllTests();
        }

        function generatePerformanceReport() {
            loadTestController.generatePerformanceReport();
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('âš¡ HAQEIè² è·ãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            await loadTestController.initialize();
        });
    </script>
</body>
</html>