# テキスト分析易経統合システム設計書

作成日: 2025年08月05日  
作成者: HAQEI System Architect  
プロジェクト: Future Simulator テキスト分析易経統合  
バージョン: 1.0

## 1. システムアーキテクチャ

### 1.1 全体構成
```
┌─────────────────────────────────────────────────────────┐
│                   future_simulator.html                   │
├─────────────────────────────────────────────────────────┤
│                    UI Layer (View)                       │
│  ├─ Input Section (textarea)                            │
│  ├─ Results Section                                     │
│  │  ├─ Current Position Display                         │
│  │  ├─ Choice Cards                                     │
│  │  └─ 8 Scenarios Grid                                │
│  └─ Charts (Chart.js)                                   │
├─────────────────────────────────────────────────────────┤
│              Integration Layer (Controller)              │
│  ├─ TextAnalysisOrchestrator                           │
│  ├─ IChingTransformationCoordinator                    │
│  └─ ScenarioGenerationManager                          │
├─────────────────────────────────────────────────────────┤
│                 Engine Layer (Model)                     │
│  ├─ SituationalContextEngine (既存)                    │
│  ├─ HexagramMappingEngine (既存)                       │
│  ├─ AuthenticIChingEngine (既存)                       │
│  └─ Authentic8ScenariosSystem (既存)                   │
├─────────────────────────────────────────────────────────┤
│                    Data Layer                            │
│  └─ H384_DATABASE (386 entries)                         │
└─────────────────────────────────────────────────────────┘
```

### 1.2 処理フロー設計
```
1. ユーザー入力受付
     ↓
2. TextAnalysisOrchestrator
   ├─ 形態素解析
   ├─ 感情分析
   ├─ キーワード抽出
   └─ 状況パターン認識
     ↓
3. IChingTransformationCoordinator
   ├─ 状況データ→易経概念マッピング
   ├─ 64卦スコアリング
   ├─ 最適卦選択
   └─ 変爻特定
     ↓
4. ScenarioGenerationManager
   ├─ 8変化パターン適用
   ├─ 各シナリオ詳細生成
   └─ グレード評価
     ↓
5. UI更新・表示
```

## 2. コンポーネント設計

### 2.1 TextAnalysisOrchestrator
```javascript
class TextAnalysisOrchestrator {
  constructor() {
    this.contextEngine = new SituationalContextEngine();
    this.keywordExpander = window.keywordExpander;
  }

  async analyzeText(inputText) {
    // Step 1: 基本分析
    const basicAnalysis = await this.performBasicAnalysis(inputText);
    
    // Step 2: 感情分析
    const emotionalAnalysis = this.analyzeEmotions(inputText);
    
    // Step 3: 状況パターン認識
    const situationPattern = this.recognizeSituationPattern(basicAnalysis, emotionalAnalysis);
    
    // Step 4: 構造化データ生成
    return this.generateStructuredData(situationPattern);
  }

  performBasicAnalysis(text) {
    // キーワード抽出
    // 文脈理解
    // 時間軸分析
  }

  analyzeEmotions(text) {
    // ポジティブ/ネガティブ/中立判定
    // 感情強度スコア
    // 支配的感情の特定
  }

  recognizeSituationPattern(basic, emotional) {
    // 困難度スコア計算
    // 変化必要性評価
    // 内的/外的要因分類
  }

  generateStructuredData(pattern) {
    return {
      keywords: [],
      emotionalState: {},
      situationScore: {},
      timeAxis: {},
      changeNecessity: 0,
      difficultyLevel: 0
    };
  }
}
```

### 2.2 IChingTransformationCoordinator
```javascript
class IChingTransformationCoordinator {
  constructor() {
    this.hexagramEngine = new HexagramMappingEngine();
    this.iChingEngine = new AuthenticIChingEngine();
  }

  async transformToIChing(structuredData) {
    // Step 1: 概念マッピング
    const conceptMapping = this.mapToIChingConcepts(structuredData);
    
    // Step 2: 64卦スコアリング
    const hexagramScores = await this.scoreAllHexagrams(conceptMapping);
    
    // Step 3: 最適卦選択
    const primaryHexagram = this.selectOptimalHexagram(hexagramScores);
    
    // Step 4: 変爻特定
    const changingLine = this.identifyChangingLine(structuredData, primaryHexagram);
    
    return {
      卦番号: primaryHexagram.number,
      卦名: primaryHexagram.name,
      爻: changingLine.position,
      信頼度: this.calculateConfidence(hexagramScores, primaryHexagram)
    };
  }

  mapToIChingConcepts(data) {
    // 感情→五行マッピング
    // 状況→八卦マッピング
    // 変化性→陰陽バランス
  }

  async scoreAllHexagrams(concepts) {
    const scores = [];
    for (let i = 1; i <= 64; i++) {
      const score = await this.calculateHexagramScore(i, concepts);
      scores.push({ number: i, score });
    }
    return scores.sort((a, b) => b.score - a.score);
  }

  calculateHexagramScore(hexagramNumber, concepts) {
    // 上卦・下卦の意味との適合度
    // キーワードマッチング
    // 状況パターンとの相関
  }

  identifyChangingLine(data, hexagram) {
    // 変化の焦点を特定
    // 6爻から最適な爻を選択
    // 動爻の判定
  }
}
```

### 2.3 ScenarioGenerationManager
```javascript
class ScenarioGenerationManager {
  constructor() {
    this.scenariosSystem = new Authentic8ScenariosSystem();
    this.iChingEngine = new AuthenticIChingEngine();
  }

  async generateScenarios(iChingResult, originalData) {
    // Step 1: 8変化パターン生成
    const patterns = this.scenariosSystem.generate8TransformationPatterns(
      iChingResult.卦番号,
      this.parseLinePosition(iChingResult.爻),
      iChingResult
    );
    
    // Step 2: 各シナリオの詳細化
    const detailedScenarios = await this.elaborateScenarios(patterns, originalData);
    
    // Step 3: グレード評価
    const gradedScenarios = this.gradeScenarios(detailedScenarios);
    
    // Step 4: 並び替えと最適化
    return this.optimizeScenarioOrder(gradedScenarios);
  }

  elaborateScenarios(patterns, data) {
    return patterns.map(pattern => ({
      ...pattern,
      具体的展開: this.generateConcreteScenario(pattern, data),
      推奨行動: this.generateRecommendations(pattern, data),
      成功確率: this.calculateSuccessProbability(pattern, data),
      HaQei視点: this.integrateBunenjinPerspective(pattern)
    }));
  }

  gradeScenarios(scenarios) {
    // S〜H級のグレード付け
    // 評価基準：実現可能性、望ましさ、リスク
  }
}
```

## 3. データ設計

### 3.1 入力データ構造
```javascript
{
  inputText: string,           // ユーザーの生の言葉
  timestamp: Date,            // 入力時刻
  sessionId: string          // セッションID
}
```

### 3.2 中間データ構造
```javascript
// 構造化状況データ
{
  keywords: {
    primary: string[],        // 主要キーワード
    secondary: string[],      // 副次キーワード
    emotional: string[]       // 感情関連キーワード
  },
  emotionalState: {
    valence: number,         // -1.0 〜 1.0 (ネガティブ〜ポジティブ)
    arousal: number,         // 0.0 〜 1.0 (低覚醒〜高覚醒)
    dominantEmotion: string  // 支配的感情
  },
  situationScore: {
    difficulty: number,      // 0-100
    changeNecessity: number, // 0-100
    urgency: number,        // 0-100
    complexity: number      // 0-100
  },
  factors: {
    internal: string[],      // 内的要因
    external: string[]       // 外的要因
  }
}

// 易経変換結果
{
  卦番号: number,             // 1-64
  卦名: string,              // 卦の名前
  上卦: { symbol: string, meaning: string },
  下卦: { symbol: string, meaning: string },
  爻: string,                // 初九、六二等
  爻位置: number,            // 1-6
  爻辞: string,              // 爻辞全文
  信頼度: number,            // 0.0-1.0
  変卦: {
    番号: number,
    名前: string
  }
}
```

### 3.3 出力データ構造
```javascript
{
  currentPosition: {
    hexagram: object,        // 現在の卦情報
    line: object,           // 爻情報
    interpretation: string   // 解釈
  },
  choices: {
    pathA: object,          // 爻辞に従う道
    pathB: object           // 爻辞に逆らう道
  },
  scenarios: [              // 8つのシナリオ
    {
      id: string,
      pattern: string,      // 変化パターン名
      hexagram: object,     // 変化後の卦
      grade: string,        // S〜H
      description: string,  // 詳細説明
      probability: number,  // 成功確率
      advice: string,       // アドバイス
      HaQei: object     // 分人視点
    }
  ]
}
```

## 4. インターフェース設計

### 4.1 内部API
```javascript
// テキスト分析API
async function analyzeUserInput(text) {
  const orchestrator = new TextAnalysisOrchestrator();
  return await orchestrator.analyzeText(text);
}

// 易経変換API
async function transformToIChing(structuredData) {
  const coordinator = new IChingTransformationCoordinator();
  return await coordinator.transformToIChing(structuredData);
}

// シナリオ生成API
async function generateDynamicScenarios(iChingResult, originalData) {
  const manager = new ScenarioGenerationManager();
  return await manager.generateScenarios(iChingResult, originalData);
}
```

### 4.2 UI更新インターフェース
```javascript
// 現在地表示更新
function updateCurrentPosition(position) {
  const display = new CurrentPositionDisplay(container, engine);
  display.updatePosition(position);
}

// 選択肢表示更新
function updateChoices(choices) {
  const choiceSystem = new AuthenticChoiceSystem(container, engine);
  choiceSystem.displayChoices(choices);
}

// 8シナリオ表示更新
function updateScenarios(scenarios) {
  const scenarioSystem = new Authentic8ScenariosSystem(container, engine);
  scenarioSystem.displayScenarios(scenarios);
}
```

## 5. エラーハンドリング設計

### 5.1 エラーパターン
1. **入力エラー**: 空入力、文字数超過
2. **分析エラー**: テキスト分析失敗
3. **変換エラー**: 易経マッピング失敗
4. **生成エラー**: シナリオ生成失敗

### 5.2 フォールバック戦略
```javascript
try {
  // 正常処理
} catch (error) {
  if (error.type === 'ANALYSIS_ERROR') {
    // 基本的な第12卦を使用
    return getDefaultHexagram();
  } else if (error.type === 'GENERATION_ERROR') {
    // 事前定義された8シナリオを使用
    return getPredefinedScenarios();
  }
  // その他のエラーはユーザーに通知
  showErrorMessage(error);
}
```

## 6. パフォーマンス最適化

### 6.1 非同期処理
- テキスト分析と易経変換を並列実行
- プログレッシブレンダリング
- Web Workerの活用検討

### 6.2 キャッシュ戦略
- 易経データのメモリキャッシュ
- 分析結果の一時保存
- SessionStorageの活用

## 7. セキュリティ設計

### 7.1 入力検証
- XSS対策（HTMLエスケープ）
- 文字数制限（2000文字）
- 不適切な内容のフィルタリング

### 7.2 データ保護
- 個人情報を含まない設計
- ローカル処理完結
- 外部送信なし

## 8. テスト設計

### 8.1 単体テスト
- 各コンポーネントの独立テスト
- エッジケースの網羅

### 8.2 統合テスト
- エンドツーエンドのフロー検証
- パフォーマンステスト
- ブラウザ互換性テスト

## 9. 移行計画

### 9.1 段階的移行
1. Phase 1: テキスト分析エンジン実装
2. Phase 2: 易経変換機能統合
3. Phase 3: 動的シナリオ生成
4. Phase 4: UI統合と最適化

### 9.2 既存機能の保持
- 現在のUI構造を維持
- Chart.js連携の継続
- データエクスポート機能の保持

## 10. 承認

本設計書は、テキスト分析易経統合システムの実装指針として承認されました。

**次のステップ**: タスク表の作成と実装開始