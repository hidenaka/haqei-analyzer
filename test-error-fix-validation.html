<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAQEI Future Simulator - Error Fix Validation Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            color: white;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .test-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .test-result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }
        .success {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
        }
        .error {
            background: rgba(244, 67, 54, 0.2);
            border-left: 4px solid #f44336;
        }
        .warning {
            background: rgba(255, 193, 7, 0.2);
            border-left: 4px solid #FFC107;
        }
        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .scenario-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .scenario-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ -->
    <script src="assets/H384H64database.js"></script>
    
    <div class="test-container">
        <h1>ğŸ”§ HAQEI Future Simulator - Error Fix Validation Test</h1>
        <p>ã‚·ãƒŠãƒªã‚ª5,7,8ã®"undefined"è¡¨ç¤ºã‚¨ãƒ©ãƒ¼ä¿®æ­£ã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</p>
        
        <div class="test-section">
            <h2>ğŸ“Š é€²æ—çŠ¶æ³</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">æº–å‚™ä¸­...</div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ¯ å€‹åˆ¥ãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testFallbackFunctions()">ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testScenarios578()">ã‚·ãƒŠãƒªã‚ª5,7,8ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testAllScenarios()">å…¨8ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testDataIntegrity()">ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆ</button>
            <div id="testResults" class="test-result"></div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ­ ã‚·ãƒŠãƒªã‚ªåˆ¥çµæœ</h2>
            <div class="scenario-grid" id="scenarioGrid">
                <!-- ã‚·ãƒŠãƒªã‚ªã‚«ãƒ¼ãƒ‰ãŒå‹•çš„ã«ç”Ÿæˆã•ã‚Œã‚‹ -->
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ” è©³ç´°ãƒ­ã‚°</h2>
            <div id="detailLog" class="test-result" style="max-height: 400px; overflow-y: auto; background: rgba(0, 0, 0, 0.3);"></div>
        </div>
    </div>

    <script>
        // ãƒ†ã‚¹ãƒˆç”¨ã®å¿…è¦ãªé–¢æ•°ã‚’ã‚³ãƒ”ãƒ¼ï¼ˆfuture_simulator.htmlã‹ã‚‰ï¼‰
        
        // é‡è¦ï¼ä¿®æ­£ã•ã‚ŒãŸé–¢æ•°ç¾¤ã‚’å«ã‚ã‚‹
        const findLineDataByNum = (hexNum, lineNum) => {
            if (!window.H384_DATA || !Array.isArray(window.H384_DATA)) {
                console.error('âŒ H384_DATAãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
                return null;
            }
            
            const result = window.H384_DATA.find(
                (line) => line.å¦ç•ªå· === hexNum && line.çˆ»æ•°å€¤ === lineNum
            );
            
            if (!result) {
                console.warn(`âš ï¸ å¦${hexNum}çˆ»${lineNum}ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                return createFallbackLineData(hexNum, lineNum, 0, "test");
            }
            
            return result;
        };
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ä»˜ãã®å¦ãƒ‡ãƒ¼ã‚¿æ¤œç´¢é–¢æ•°
        const findHexDataWithFallback = (hexNum) => {
            const hexData = window.H64_DATA || H64_DATA;
            
            if (!hexData) {
                console.error('âŒ H64_DATAãŒå­˜åœ¨ã—ã¾ã›ã‚“ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ');
                return createFallbackHexData(hexNum);
            }
            
            const result = hexData.find((hex) => hex.å¦ç•ªå· === hexNum);
            
            if (result) {
                return result;
            } else {
                console.warn(`âš ï¸ å¦${hexNum}ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ`);
                return createFallbackHexData(hexNum);
            }
        };
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨å¦ãƒ‡ãƒ¼ã‚¿ä½œæˆé–¢æ•°
        const createFallbackHexData = (hexNum) => {
            const hexNames = {
                1: 'ä¹¾ç‚ºå¤©', 2: 'å¤ç‚ºåœ°', 3: 'æ°´é›·å±¯', 4: 'å±±æ°´è’™', 5: 'æ°´å¤©éœ€', 6: 'å¤©æ°´è¨Ÿ', 7: 'åœ°æ°´å¸«', 8: 'æ°´åœ°æ¯”',
                9: 'é¢¨å¤©å°ç•œ', 10: 'å¤©æ¾¤å±¥', 11: 'åœ°å¤©æ³°', 12: 'å¤©åœ°å¦', 13: 'å¤©ç«åŒäºº', 14: 'ç«å¤©å¤§æœ‰', 15: 'åœ°å±±è¬™', 16: 'é›·åœ°è±«',
                17: 'æ¾¤é›·éš¨', 18: 'å±±é¢¨è ±', 19: 'åœ°æ¾¤è‡¨', 20: 'é¢¨åœ°è¦³', 21: 'ç«é›·å™¬å—‘', 22: 'å±±ç«è³', 23: 'å±±åœ°å‰¥', 24: 'åœ°é›·å¾©',
                25: 'å¤©é›·æ— å¦„', 26: 'å±±å¤©å¤§ç•œ', 27: 'å±±é›·é ¤', 28: 'æ¾¤é¢¨å¤§é', 29: 'åç‚ºæ°´', 30: 'é›¢ç‚ºç«', 31: 'æ¾¤å±±å’¸', 32: 'é›·é¢¨æ’',
                33: 'å¤©å±±é¯', 34: 'é›·å¤©å¤§å£®', 35: 'ç«åœ°æ™‹', 36: 'åœ°ç«æ˜å¤·', 37: 'é¢¨ç«å®¶äºº', 38: 'ç«æ¾¤ç½', 39: 'æ°´å±±è¹‡', 40: 'é›·æ°´è§£',
                41: 'å±±æ¾¤æ', 42: 'é¢¨é›·ç›Š', 43: 'æ¾¤å¤©å¤¬', 44: 'å¤©é¢¨å§¤', 45: 'æ¾¤åœ°èƒ', 46: 'åœ°é¢¨å‡', 47: 'æ¾¤æ°´å›°', 48: 'æ°´é¢¨äº•',
                49: 'æ¾¤ç«é©', 50: 'ç«é¢¨é¼', 51: 'éœ‡ç‚ºé›·', 52: 'è‰®ç‚ºå±±', 53: 'é¢¨å±±æ¼¸', 54: 'é›·æ¾¤å¸°å¦¹', 55: 'é›·ç«è±', 56: 'ç«å±±æ—…',
                57: 'å·½ç‚ºé¢¨', 58: 'å…Œç‚ºæ¾¤', 59: 'é¢¨æ°´æ¸™', 60: 'æ°´æ¾¤ç¯€', 61: 'é¢¨æ¾¤ä¸­å­š', 62: 'é›·å±±å°é', 63: 'æ°´ç«æ—¢æ¸ˆ', 64: 'ç«æ°´æœªæ¸ˆ'
            };

            const hexName = hexNames[hexNum] || `å¦${hexNum}`;
            const lineChanges = calculateLineChangeManually(hexNum);
            
            return {
                å¦ç•ªå·: hexNum,
                åå‰: hexName,
                åˆçˆ»å¤‰: lineChanges.åˆçˆ»å¤‰,
                äºŒçˆ»å¤‰: lineChanges.äºŒçˆ»å¤‰,
                ä¸‰çˆ»å¤‰: lineChanges.ä¸‰çˆ»å¤‰,
                å››çˆ»å¤‰: lineChanges.å››çˆ»å¤‰,
                äº”çˆ»å¤‰: lineChanges.äº”çˆ»å¤‰,
                ä¸Šçˆ»å¤‰: lineChanges.ä¸Šçˆ»å¤‰,
                __fallback: true
            };
        };
        
        // çˆ»å¤‰ã®æ‰‹å‹•è¨ˆç®—é–¢æ•°
        const calculateLineChangeManually = (hexNum) => {
            const hexToBinary = {
                1: '111111', 2: '000000', 3: '010001', 4: '100010', 5: '010111', 6: '111010', 7: '000010', 8: '010000',
                9: '110111', 10: '111011', 11: '000111', 12: '111000', 13: '111101', 14: '101111', 15: '000100', 16: '001000',
                17: '011001', 18: '100110', 19: '000011', 20: '110000', 21: '101001', 22: '100101', 23: '100000', 24: '000001',
                25: '111001', 26: '100111', 27: '100001', 28: '011110', 29: '010010', 30: '101101', 31: '011100', 32: '001110',
                33: '111100', 34: '001111', 35: '101000', 36: '000101', 37: '110101', 38: '101011', 39: '010100', 40: '001010',
                41: '100011', 42: '110001', 43: '011111', 44: '111110', 45: '011000', 46: '000110', 47: '011010', 48: '010110',
                49: '011101', 50: '101110', 51: '001001', 52: '100100', 53: '110100', 54: '001011', 55: '001101', 56: '101100',
                57: '110110', 58: '011011', 59: '110010', 60: '010011', 61: '110011', 62: '001100', 63: '010101', 64: '101010'
            };

            const binaryToHex = {};
            Object.keys(hexToBinary).forEach(key => {
                binaryToHex[hexToBinary[key]] = parseInt(key);
            });

            const currentBinary = hexToBinary[hexNum];
            if (!currentBinary) {
                return { åˆçˆ»å¤‰: hexNum, äºŒçˆ»å¤‰: hexNum, ä¸‰çˆ»å¤‰: hexNum, å››çˆ»å¤‰: hexNum, äº”çˆ»å¤‰: hexNum, ä¸Šçˆ»å¤‰: hexNum };
            }

            const calculateChange = (binary, position) => {
                const binaryArray = binary.split('');
                binaryArray[position] = binaryArray[position] === '1' ? '0' : '1';
                const newBinary = binaryArray.join('');
                return binaryToHex[newBinary] || hexNum;
            };

            return {
                åˆçˆ»å¤‰: calculateChange(currentBinary, 0),
                äºŒçˆ»å¤‰: calculateChange(currentBinary, 1),
                ä¸‰çˆ»å¤‰: calculateChange(currentBinary, 2),
                å››çˆ»å¤‰: calculateChange(currentBinary, 3),
                äº”çˆ»å¤‰: calculateChange(currentBinary, 4),
                ä¸Šçˆ»å¤‰: calculateChange(currentBinary, 5)
            };
        };
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨çˆ»ãƒ‡ãƒ¼ã‚¿ä½œæˆé–¢æ•°
        const createFallbackLineData = (hexNum, lineNum, step, choice) => {
            const hexNames = {
                1: 'ä¹¾ç‚ºå¤©', 2: 'å¤ç‚ºåœ°', 3: 'æ°´é›·å±¯', 4: 'å±±æ°´è’™', 5: 'æ°´å¤©éœ€', 6: 'å¤©æ°´è¨Ÿ', 7: 'åœ°æ°´å¸«', 8: 'æ°´åœ°æ¯”',
                9: 'é¢¨å¤©å°ç•œ', 10: 'å¤©æ¾¤å±¥', 11: 'åœ°å¤©æ³°', 12: 'å¤©åœ°å¦', 13: 'å¤©ç«åŒäºº', 14: 'ç«å¤©å¤§æœ‰', 15: 'åœ°å±±è¬™', 16: 'é›·åœ°è±«',
                17: 'æ¾¤é›·éš¨', 18: 'å±±é¢¨è ±', 19: 'åœ°æ¾¤è‡¨', 20: 'é¢¨åœ°è¦³', 21: 'ç«é›·å™¬å—‘', 22: 'å±±ç«è³', 23: 'å±±åœ°å‰¥', 24: 'åœ°é›·å¾©',
                25: 'å¤©é›·æ— å¦„', 26: 'å±±å¤©å¤§ç•œ', 27: 'å±±é›·é ¤', 28: 'æ¾¤é¢¨å¤§é', 29: 'åç‚ºæ°´', 30: 'é›¢ç‚ºç«', 31: 'æ¾¤å±±å’¸', 32: 'é›·é¢¨æ’',
                33: 'å¤©å±±é¯', 34: 'é›·å¤©å¤§å£®', 35: 'ç«åœ°æ™‹', 36: 'åœ°ç«æ˜å¤·', 37: 'é¢¨ç«å®¶äºº', 38: 'ç«æ¾¤ç½', 39: 'æ°´å±±è¹‡', 40: 'é›·æ°´è§£',
                41: 'å±±æ¾¤æ', 42: 'é¢¨é›·ç›Š', 43: 'æ¾¤å¤©å¤¬', 44: 'å¤©é¢¨å§¤', 45: 'æ¾¤åœ°èƒ', 46: 'åœ°é¢¨å‡', 47: 'æ¾¤æ°´å›°', 48: 'æ°´é¢¨äº•',
                49: 'æ¾¤ç«é©', 50: 'ç«é¢¨é¼', 51: 'éœ‡ç‚ºé›·', 52: 'è‰®ç‚ºå±±', 53: 'é¢¨å±±æ¼¸', 54: 'é›·æ¾¤å¸°å¦¹', 55: 'é›·ç«è±', 56: 'ç«å±±æ—…',
                57: 'å·½ç‚ºé¢¨', 58: 'å…Œç‚ºæ¾¤', 59: 'é¢¨æ°´æ¸™', 60: 'æ°´æ¾¤ç¯€', 61: 'é¢¨æ¾¤ä¸­å­š', 62: 'é›·å±±å°é', 63: 'æ°´ç«æ—¢æ¸ˆ', 64: 'ç«æ°´æœªæ¸ˆ'
            };

            const hexName = hexNames[hexNum] || `ERROR_å¦${hexNum}`;
            const lineNames = ["åˆ", "äºŒ", "ä¸‰", "å››", "äº”", "ä¸Š"];
            const lineName = lineNames[lineNum - 1] || `ERROR_çˆ»${lineNum}`;
            
            const baseScore = Math.max(25, Math.min(75, 50 + ((hexNum + lineNum) % 25)));
            const riskScore = Math.max(-75, Math.min(-25, -50 + ((hexNum + lineNum) % 25)));
            
            return {
                å¦ç•ªå·: hexNum,
                å¦å: hexName,
                çˆ»: lineName,  
                çˆ»æ•°å€¤: lineNum,
                step: step,
                choice: choice,
                ç¾ä»£è§£é‡ˆã®è¦ç´„: `${hexName}ã®${lineName}çˆ»ã®çŠ¶æ³ã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã®ãŸã‚è©³ç´°æƒ…å ±ã¯é™å®šçš„ã§ã™ãŒã€åŸºæœ¬çš„ãªæŒ‡é‡ã‚’æä¾›ã—ã¾ã™ã€‚`,
                S1_åŸºæœ¬ã‚¹ã‚³ã‚¢: baseScore,
                S2_ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«: baseScore + 5,
                S3_å®‰å®šæ€§ã‚¹ã‚³ã‚¢: baseScore - 5,
                S4_ãƒªã‚¹ã‚¯: riskScore,
                S5_ä¸»ä½“æ€§æ¨å¥¨ã‚¹ã‚¿ãƒ³ã‚¹: (hexNum + lineNum) % 2 === 0 ? 'å—å‹•' : 'èƒ½å‹•',
                S6_å¤‰å‹•æ€§ã‚¹ã‚³ã‚¢: 40 + ((hexNum + lineNum) % 20),
                S7_ç·åˆè©•ä¾¡ã‚¹ã‚³ã‚¢: Math.round((baseScore + (baseScore + 5) + (baseScore - 5)) / 3),
                __fallback: true
            };
        };
        
        // ãƒ†ã‚¹ãƒˆç”¨ã®ç°¡æ˜“ãƒ‘ã‚¹ç”Ÿæˆé–¢æ•°
        function generateTestPaths(startHex, startLine) {
            const paths = [];
            const startData = findLineDataByNum(startHex, startLine);
            
            // 8ã¤ã®ã‚·ãƒŠãƒªã‚ªãƒ‘ã‚¹ã‚’ç”Ÿæˆ
            for (let i = 0; i < 8; i++) {
                const path = [];
                const isChangePath = i >= 4;
                
                // ã‚¹ãƒ†ãƒƒãƒ—0: ç¾åœ¨åœ°
                path.push({
                    ...startData,
                    choice: isChangePath ? "change" : "stagnate"
                });
                
                // ã‚¹ãƒ†ãƒƒãƒ—1-3: ç°¡æ˜“ç”Ÿæˆ
                for (let step = 1; step <= 3; step++) {
                    const nextLine = ((startLine + step - 1) % 6) + 1;
                    const stepData = findLineDataByNum(startHex, nextLine);
                    
                    if (stepData) {
                        path.push({
                            ...stepData,
                            step: step,
                            choice: isChangePath ? "change" : "stagnate",
                            çˆ»æ•°å€¤: nextLine
                        });
                    } else {
                        path.push(createFallbackLineData(startHex, nextLine, step, isChangePath ? "change" : "stagnate"));
                    }
                }
                
                paths.push(path);
            }
            
            return paths;
        }
        
        // ãƒ†ã‚¹ãƒˆçµæœã®è¡¨ç¤º
        function displayTestResult(message, type = 'success') {
            const resultDiv = document.getElementById('testResults');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            
            resultDiv.textContent += logEntry;
            resultDiv.className = `test-result ${type}`;
            
            // è©³ç´°ãƒ­ã‚°ã«ã‚‚è¿½åŠ 
            const detailLog = document.getElementById('detailLog');
            detailLog.textContent += logEntry;
            detailLog.scrollTop = detailLog.scrollHeight;
        }
        
        // é€²æ—æ›´æ–°
        function updateProgress(percentage, text) {
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = text;
        }
        
        // ã‚·ãƒŠãƒªã‚ªã‚«ãƒ¼ãƒ‰æ›´æ–°
        function updateScenarioCard(scenarioId, status, result) {
            let card = document.getElementById(`scenario-${scenarioId}`);
            if (!card) {
                const grid = document.getElementById('scenarioGrid');
                card = document.createElement('div');
                card.id = `scenario-${scenarioId}`;
                card.className = 'scenario-card';
                card.innerHTML = `
                    <div class="scenario-title">ã‚·ãƒŠãƒªã‚ª ${scenarioId}</div>
                    <div id="scenario-${scenarioId}-status">æº–å‚™ä¸­...</div>
                    <div id="scenario-${scenarioId}-result"></div>
                `;
                grid.appendChild(card);
            }
            
            document.getElementById(`scenario-${scenarioId}-status`).textContent = status;
            document.getElementById(`scenario-${scenarioId}-result`).textContent = result;
            
            // çŠ¶æ³ã«å¿œã˜ã¦ã‚«ãƒ¼ãƒ‰ã®è‰²ã‚’å¤‰æ›´
            if (status.includes('âœ…')) {
                card.style.borderColor = '#4CAF50';
                card.style.background = 'rgba(76, 175, 80, 0.1)';
            } else if (status.includes('âŒ')) {
                card.style.borderColor = '#f44336';
                card.style.background = 'rgba(244, 67, 54, 0.1)';
            } else if (status.includes('âš ï¸')) {
                card.style.borderColor = '#FFC107';
                card.style.background = 'rgba(255, 193, 7, 0.1)';
            }
        }
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
        async function testFallbackFunctions() {
            displayTestResult('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...');
            updateProgress(0, 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...');
            
            let passCount = 0;
            let totalTests = 4;
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: createFallbackHexData
                const hexData = createFallbackHexData(99); // å­˜åœ¨ã—ãªã„å¦ç•ªå·
                if (hexData && hexData.å¦ç•ªå· === 99 && hexData.__fallback) {
                    displayTestResult('âœ… createFallbackHexData: æˆåŠŸ');
                    passCount++;
                } else {
                    displayTestResult('âŒ createFallbackHexData: å¤±æ•—', 'error');
                }
                
                // ãƒ†ã‚¹ãƒˆ2: createFallbackLineData
                const lineData = createFallbackLineData(1, 1, 0, 'test');
                if (lineData && lineData.å¦ç•ªå· === 1 && lineData.çˆ»æ•°å€¤ === 1 && lineData.__fallback) {
                    displayTestResult('âœ… createFallbackLineData: æˆåŠŸ');
                    passCount++;
                } else {
                    displayTestResult('âŒ createFallbackLineData: å¤±æ•—', 'error');
                }
                
                // ãƒ†ã‚¹ãƒˆ3: calculateLineChangeManually
                const changes = calculateLineChangeManually(1);
                if (changes && changes.åˆçˆ»å¤‰ && changes.ä¸Šçˆ»å¤‰) {
                    displayTestResult('âœ… calculateLineChangeManually: æˆåŠŸ');
                    passCount++;
                } else {
                    displayTestResult('âŒ calculateLineChangeManually: å¤±æ•—', 'error');
                }
                
                // ãƒ†ã‚¹ãƒˆ4: findHexDataWithFallback
                const hexDataFallback = findHexDataWithFallback(999); // å­˜åœ¨ã—ãªã„å¦ç•ªå·
                if (hexDataFallback && hexDataFallback.__fallback) {
                    displayTestResult('âœ… findHexDataWithFallback: æˆåŠŸ');
                    passCount++;
                } else {
                    displayTestResult('âŒ findHexDataWithFallback: å¤±æ•—', 'error');
                }
                
                const successRate = (passCount / totalTests) * 100;
                updateProgress(25, `ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº† (${successRate}%)`);
                displayTestResult(`ğŸ¯ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†: ${passCount}/${totalTests} æˆåŠŸ (${successRate}%)`);
                
            } catch (error) {
                displayTestResult(`âŒ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateProgress(25, 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ');
            }
        }
        
        // ã‚·ãƒŠãƒªã‚ª5,7,8ã®å€‹åˆ¥ãƒ†ã‚¹ãƒˆ
        async function testScenarios578() {
            displayTestResult('ğŸ¯ ã‚·ãƒŠãƒªã‚ª5,7,8ã®å€‹åˆ¥ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...');
            updateProgress(25, 'ã‚·ãƒŠãƒªã‚ª5,7,8ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...');
            
            const problemScenarios = [5, 7, 8];
            let passCount = 0;
            
            for (const scenarioId of problemScenarios) {
                try {
                    updateScenarioCard(scenarioId, 'ğŸ”„ ãƒ†ã‚¹ãƒˆä¸­...', '');
                    
                    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆã‚·ãƒŠãƒªã‚ªã«å¿œã˜ã¦èª¿æ•´ï¼‰
                    const testHex = scenarioId * 8; // ãƒ†ã‚¹ãƒˆç”¨å¦ç•ªå·
                    const testLine = scenarioId % 6 + 1; // ãƒ†ã‚¹ãƒˆç”¨çˆ»ç•ªå·
                    
                    const paths = generateTestPaths(testHex, testLine);
                    
                    let hasUndefined = false;
                    let undefinedCount = 0;
                    
                    // å„ãƒ‘ã‚¹ã®undefinedãƒã‚§ãƒƒã‚¯
                    paths.forEach((path, pathIndex) => {
                        path.forEach((step, stepIndex) => {
                            Object.keys(step).forEach(key => {
                                if (step[key] === undefined) {
                                    hasUndefined = true;
                                    undefinedCount++;
                                    displayTestResult(`âš ï¸ ã‚·ãƒŠãƒªã‚ª${scenarioId} ãƒ‘ã‚¹${pathIndex} ã‚¹ãƒ†ãƒƒãƒ—${stepIndex} ${key}: undefined`, 'warning');
                                }
                            });
                        });
                    });
                    
                    if (!hasUndefined) {
                        updateScenarioCard(scenarioId, 'âœ… æˆåŠŸ', 'undefinedãªã—');
                        displayTestResult(`âœ… ã‚·ãƒŠãƒªã‚ª${scenarioId}: undefinedå•é¡Œè§£æ±ºæ¸ˆã¿`);
                        passCount++;
                    } else {
                        updateScenarioCard(scenarioId, 'âŒ å¤±æ•—', `undefined: ${undefinedCount}å€‹`);
                        displayTestResult(`âŒ ã‚·ãƒŠãƒªã‚ª${scenarioId}: ã¾ã undefinedãŒ${undefinedCount}å€‹å­˜åœ¨`, 'error');
                    }
                    
                } catch (error) {
                    updateScenarioCard(scenarioId, 'âŒ ã‚¨ãƒ©ãƒ¼', error.message);
                    displayTestResult(`âŒ ã‚·ãƒŠãƒªã‚ª${scenarioId}ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            const successRate = (passCount / problemScenarios.length) * 100;
            updateProgress(50, `ã‚·ãƒŠãƒªã‚ª5,7,8ãƒ†ã‚¹ãƒˆå®Œäº† (${successRate}%)`);
            displayTestResult(`ğŸ¯ ã‚·ãƒŠãƒªã‚ª5,7,8ãƒ†ã‚¹ãƒˆå®Œäº†: ${passCount}/${problemScenarios.length} æˆåŠŸ (${successRate}%)`);
        }
        
        // å…¨8ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ
        async function testAllScenarios() {
            displayTestResult('ğŸ­ å…¨8ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...');
            updateProgress(50, 'å…¨8ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...');
            
            let passCount = 0;
            const totalScenarios = 8;
            
            for (let scenarioId = 1; scenarioId <= totalScenarios; scenarioId++) {
                try {
                    updateScenarioCard(scenarioId, 'ğŸ”„ ãƒ†ã‚¹ãƒˆä¸­...', '');
                    
                    const testHex = scenarioId * 6; // ãƒ†ã‚¹ãƒˆç”¨å¦ç•ªå·
                    const testLine = scenarioId % 6 + 1; // ãƒ†ã‚¹ãƒˆç”¨çˆ»ç•ªå·
                    
                    const paths = generateTestPaths(testHex, testLine);
                    
                    let hasUndefined = false;
                    let undefinedCount = 0;
                    let hasValidMetaphor = false;
                    
                    // å„ãƒ‘ã‚¹ã®è©³ç´°ãƒã‚§ãƒƒã‚¯
                    paths.forEach((path, pathIndex) => {
                        path.forEach((step, stepIndex) => {
                            Object.keys(step).forEach(key => {
                                if (step[key] === undefined) {
                                    hasUndefined = true;
                                    undefinedCount++;
                                }
                            });
                            
                            // ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ï¼ˆç¾ä»£è§£é‡ˆã®è¦ç´„ï¼‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
                            if (step.ç¾ä»£è§£é‡ˆã®è¦ç´„ && step.ç¾ä»£è§£é‡ˆã®è¦ç´„ !== 'undefined') {
                                hasValidMetaphor = true;
                            }
                        });
                    });
                    
                    if (!hasUndefined && hasValidMetaphor) {
                        updateScenarioCard(scenarioId, 'âœ… æˆåŠŸ', 'ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼è¡¨ç¤ºæ­£å¸¸');
                        passCount++;
                    } else if (hasUndefined) {
                        updateScenarioCard(scenarioId, 'âŒ å¤±æ•—', `undefined: ${undefinedCount}å€‹`);
                    } else if (!hasValidMetaphor) {
                        updateScenarioCard(scenarioId, 'âš ï¸ è­¦å‘Š', 'ãƒ¡ã‚¿ãƒ•ã‚¡ãƒ¼ä¸å®Œå…¨');
                    }
                    
                } catch (error) {
                    updateScenarioCard(scenarioId, 'âŒ ã‚¨ãƒ©ãƒ¼', error.message);
                    displayTestResult(`âŒ ã‚·ãƒŠãƒªã‚ª${scenarioId}ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            const successRate = (passCount / totalScenarios) * 100;
            updateProgress(75, `å…¨8ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆå®Œäº† (${successRate}%)`);
            displayTestResult(`ğŸ­ å…¨8ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆå®Œäº†: ${passCount}/${totalScenarios} æˆåŠŸ (${successRate}%)`);
        }
        
        // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆ
        async function testDataIntegrity() {
            displayTestResult('ğŸ” ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹...');
            updateProgress(75, 'ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...');
            
            let passCount = 0;
            let totalTests = 3;
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: H384_DATAã®å­˜åœ¨ç¢ºèª
                if (window.H384_DATA && Array.isArray(window.H384_DATA) && window.H384_DATA.length > 0) {
                    displayTestResult(`âœ… H384_DATAç¢ºèª: ${window.H384_DATA.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿`);
                    passCount++;
                } else {
                    displayTestResult('âŒ H384_DATAãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                }
                
                // ãƒ†ã‚¹ãƒˆ2: H64_DATAã®å­˜åœ¨ç¢ºèª
                if ((window.H64_DATA && Array.isArray(window.H64_DATA)) || (typeof H64_DATA !== 'undefined' && Array.isArray(H64_DATA))) {
                    const dataSource = window.H64_DATA || H64_DATA;
                    displayTestResult(`âœ… H64_DATAç¢ºèª: ${dataSource.length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿`);
                    passCount++;
                } else {
                    displayTestResult('âŒ H64_DATAãŒæ­£å¸¸ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                }
                
                // ãƒ†ã‚¹ãƒˆ3: åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®ç¢ºèª
                const sampleData = findLineDataByNum(1, 1);
                if (sampleData && sampleData.å¦å && sampleData.ç¾ä»£è§£é‡ˆã®è¦ç´„) {
                    displayTestResult('âœ… ãƒ‡ãƒ¼ã‚¿æ§‹é€ ç¢ºèª: åŸºæœ¬ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå­˜åœ¨');
                    passCount++;
                } else {
                    displayTestResult('âš ï¸ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å•é¡ŒãŒã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™', 'warning');
                }
                
                const successRate = (passCount / totalTests) * 100;
                updateProgress(100, `ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆå®Œäº† (${successRate}%)`);
                displayTestResult(`ğŸ” ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆå®Œäº†: ${passCount}/${totalTests} æˆåŠŸ (${successRate}%)`);
                
            } catch (error) {
                displayTestResult(`âŒ ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                updateProgress(100, 'ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒ†ã‚¹ãƒˆã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ');
            }
        }
        
        // åˆæœŸåŒ–
        window.addEventListener('load', () => {
            displayTestResult('ğŸš€ Error Fix Validation Test ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
            updateProgress(0, 'æº–å‚™å®Œäº† - ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
            
            // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åŸºæœ¬ç¢ºèª
            if (window.H384_DATA) {
                displayTestResult(`ğŸ“Š H384_DATAèª­ã¿è¾¼ã¿ç¢ºèª: ${window.H384_DATA.length}ä»¶`);
            }
            if (window.H64_DATA || (typeof H64_DATA !== 'undefined')) {
                const dataSource = window.H64_DATA || H64_DATA;
                displayTestResult(`ğŸ“Š H64_DATAèª­ã¿è¾¼ã¿ç¢ºèª: ${dataSource.length}ä»¶`);
            }
        });
    </script>
</body>
</html>