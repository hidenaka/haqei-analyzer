<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>全パターン動的表現検証</title>
    <style>
        body { 
            font-family: monospace; 
            padding: 20px; 
            background: #1a1a1a; 
            color: #fff; 
        }
        .test-section { 
            margin: 30px 0; 
            padding: 20px; 
            border: 1px solid #444; 
            border-radius: 8px;
        }
        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover {
            opacity: 0.9;
        }
        .result-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        .pattern-card {
            padding: 15px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 5px;
            border-left: 4px solid #3b82f6;
        }
        .pattern-title {
            color: #60a5fa;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .expression-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 3px;
        }
        .category-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-left: 10px;
        }
        .synergy { background: #10b981; }
        .harmony { background: #3b82f6; }
        .tension { background: #f59e0b; }
        .conflict { background: #ef4444; }
        .statistics {
            padding: 20px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 8px;
            margin: 20px 0;
        }
        .stat-item {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
        }
        .unique-expressions {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin: 10px 0;
        }
        .expression-count {
            color: #fbbf24;
            font-weight: bold;
        }
        .warning {
            color: #ef4444;
            font-weight: bold;
        }
        .success {
            color: #10b981;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>🔍 全パターン動的表現検証システム</h1>
    <p>64×64×64 = 262,144通りの組み合わせから体系的にサンプリングして、動的表現の多様性を検証</p>

    <div class="test-section">
        <h2>📊 体系的検証</h2>
        <button onclick="verifySystematicPatterns()">🎯 主要パターン検証（100組）</button>
        <button onclick="verifyRandomPatterns(1000)">🎲 ランダム検証（1000組）</button>
        <button onclick="verifyEdgeCases()">⚡ エッジケース検証</button>
        <button onclick="verifyAllCategories()">📈 全カテゴリ網羅検証</button>
        
        <div id="systematic-result"></div>
    </div>

    <div class="test-section">
        <h2>📊 統計分析</h2>
        <div id="statistics"></div>
    </div>

    <div class="test-section">
        <h2>🔍 ユニーク表現リスト</h2>
        <div id="unique-expressions"></div>
    </div>

    <script src="./assets/H384H64database.js"></script>
    <script src="./js/core/TripleOSInteractionAnalyzer.js"></script>
    <script>
        let allExpressions = new Set();
        let categoryStats = { SYNERGY: 0, HARMONY: 0, TENSION: 0, CONFLICT: 0 };
        let patternTypes = new Map();
        
        function verifySystematicPatterns() {
            allExpressions.clear();
            categoryStats = { SYNERGY: 0, HARMONY: 0, TENSION: 0, CONFLICT: 0 };
            patternTypes.clear();
            
            const analyzer = new TripleOSInteractionAnalyzer();
            const patterns = [];
            
            // 1. 同一卦パターン (1-1-1, 2-2-2, ..., 64-64-64)
            for (let i = 1; i <= 5; i++) {
                patterns.push({ 
                    type: '同一卦', 
                    ids: [i, i, i],
                    description: `すべて同じ卦（${i}-${i}-${i}）`
                });
            }
            
            // 2. 綜卦関係パターン (補完関係)
            const zongguaPairs = [[1, 2], [3, 50], [11, 12], [13, 14], [31, 32]];
            zongguaPairs.forEach(([a, b]) => {
                patterns.push({ 
                    type: '綜卦関係', 
                    ids: [a, b, 29],
                    description: `綜卦関係を含む（${a}-${b}-29）`
                });
            });
            
            // 3. 錯卦関係パターン (対極関係、差が32)
            for (let i = 1; i <= 5; i++) {
                const opposite = i + 32 > 64 ? i - 32 : i + 32;
                patterns.push({ 
                    type: '錯卦関係', 
                    ids: [i, opposite, 30],
                    description: `錯卦関係を含む（${i}-${opposite}-30）`
                });
            }
            
            // 4. 隣接卦パターン (連続する卦)
            for (let i = 1; i <= 10; i++) {
                patterns.push({ 
                    type: '隣接卦', 
                    ids: [i, i+1, i+2],
                    description: `隣接する3卦（${i}-${i+1}-${i+2}）`
                });
            }
            
            // 5. 陰陽バランスパターン
            const yinYangPatterns = [
                [1, 2, 29],  // 純陽、純陰、水
                [30, 29, 52], // 火、水、山
                [51, 57, 58], // 震、巽、兌
            ];
            yinYangPatterns.forEach(ids => {
                patterns.push({ 
                    type: '陰陽バランス', 
                    ids,
                    description: `陰陽バランス（${ids.join('-')}）`
                });
            });
            
            // 6. ランダムパターン
            for (let i = 0; i < 20; i++) {
                const ids = [
                    Math.floor(Math.random() * 64) + 1,
                    Math.floor(Math.random() * 64) + 1,
                    Math.floor(Math.random() * 64) + 1
                ];
                patterns.push({ 
                    type: 'ランダム', 
                    ids,
                    description: `ランダム（${ids.join('-')}）`
                });
            }
            
            // 7. 特殊な組み合わせ
            const specialPatterns = [
                [1, 64, 32],  // 始まりと終わりと中間
                [63, 64, 1],  // 既済、未済、乾
                [3, 4, 5],    // 初期の困難シリーズ
                [61, 62, 63], // 終盤シリーズ
            ];
            specialPatterns.forEach(ids => {
                patterns.push({ 
                    type: '特殊', 
                    ids,
                    description: `特殊パターン（${ids.join('-')}）`
                });
            });
            
            // 分析実行
            let html = '<div class="result-grid">';
            
            patterns.forEach(pattern => {
                const result = analyzePattern(analyzer, pattern.ids);
                
                html += `
                    <div class="pattern-card">
                        <div class="pattern-title">${pattern.type}: ${pattern.description}</div>
                        ${result.expressions.map(exp => `
                            <div class="expression-item">
                                ${exp.pair}: ${exp.summary}
                                <span class="category-badge ${exp.category.toLowerCase()}">${exp.category}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                // 統計収集
                result.expressions.forEach(exp => {
                    allExpressions.add(exp.summary);
                    categoryStats[exp.category]++;
                });
                
                patternTypes.set(pattern.type, (patternTypes.get(pattern.type) || 0) + 1);
            });
            
            html += '</div>';
            document.getElementById('systematic-result').innerHTML = html;
            
            updateStatistics();
            updateUniqueExpressions();
        }
        
        function verifyRandomPatterns(count) {
            allExpressions.clear();
            categoryStats = { SYNERGY: 0, HARMONY: 0, TENSION: 0, CONFLICT: 0 };
            
            const analyzer = new TripleOSInteractionAnalyzer();
            const sampleSize = Math.min(count, 10000);
            
            for (let i = 0; i < sampleSize; i++) {
                const ids = [
                    Math.floor(Math.random() * 64) + 1,
                    Math.floor(Math.random() * 64) + 1,
                    Math.floor(Math.random() * 64) + 1
                ];
                
                const result = analyzePattern(analyzer, ids);
                result.expressions.forEach(exp => {
                    allExpressions.add(exp.summary);
                    categoryStats[exp.category]++;
                });
            }
            
            updateStatistics();
            updateUniqueExpressions();
            
            document.getElementById('systematic-result').innerHTML = `
                <div class="statistics">
                    <h3>${sampleSize}組のランダムサンプリング完了</h3>
                    <p>ユニーク表現数: <span class="expression-count">${allExpressions.size}</span></p>
                </div>
            `;
        }
        
        function verifyEdgeCases() {
            allExpressions.clear();
            categoryStats = { SYNERGY: 0, HARMONY: 0, TENSION: 0, CONFLICT: 0 };
            
            const analyzer = new TripleOSInteractionAnalyzer();
            const edgeCases = [
                // すべて同じ卦
                [1, 1, 1], [2, 2, 2], [64, 64, 64],
                // 最大差
                [1, 32, 64], [64, 32, 1],
                // 綜卦関係
                [1, 2, 3], [11, 12, 13],
                // 錯卦関係（差32）
                [1, 33, 2], [32, 64, 33],
                // 連続
                [1, 2, 3], [62, 63, 64],
                // 素数番号
                [2, 3, 5], [7, 11, 13], [17, 19, 23],
                // 2の累乗
                [2, 4, 8], [16, 32, 64],
            ];
            
            let html = '<div class="result-grid">';
            
            edgeCases.forEach(ids => {
                const result = analyzePattern(analyzer, ids);
                
                html += `
                    <div class="pattern-card">
                        <div class="pattern-title">エッジケース: ${ids.join('-')}</div>
                        ${result.expressions.map(exp => `
                            <div class="expression-item">
                                ${exp.pair}: ${exp.summary}
                                <span class="category-badge ${exp.category.toLowerCase()}">${exp.category}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                result.expressions.forEach(exp => {
                    allExpressions.add(exp.summary);
                    categoryStats[exp.category]++;
                });
            });
            
            html += '</div>';
            document.getElementById('systematic-result').innerHTML = html;
            
            updateStatistics();
            updateUniqueExpressions();
        }
        
        function verifyAllCategories() {
            const analyzer = new TripleOSInteractionAnalyzer();
            const categorySamples = {
                SYNERGY: [],
                HARMONY: [],
                TENSION: [],
                CONFLICT: []
            };
            
            // 各カテゴリのサンプルを収集
            let attempts = 0;
            const maxAttempts = 10000;
            
            while (attempts < maxAttempts && 
                   (categorySamples.SYNERGY.length < 10 || 
                    categorySamples.HARMONY.length < 10 || 
                    categorySamples.TENSION.length < 10 || 
                    categorySamples.CONFLICT.length < 10)) {
                
                const ids = [
                    Math.floor(Math.random() * 64) + 1,
                    Math.floor(Math.random() * 64) + 1,
                    Math.floor(Math.random() * 64) + 1
                ];
                
                const result = analyzePattern(analyzer, ids);
                
                result.expressions.forEach(exp => {
                    if (categorySamples[exp.category].length < 10) {
                        categorySamples[exp.category].push({
                            ids: ids,
                            expression: exp
                        });
                    }
                });
                
                attempts++;
            }
            
            // 結果表示
            let html = '<h3>カテゴリ別サンプル</h3>';
            
            Object.entries(categorySamples).forEach(([category, samples]) => {
                html += `<h4>${category} (${samples.length}サンプル)</h4>`;
                html += '<div class="unique-expressions">';
                samples.forEach(sample => {
                    html += `
                        <div class="expression-item">
                            <strong>${sample.ids.join('-')}:</strong> ${sample.expression.summary}
                        </div>
                    `;
                });
                html += '</div>';
            });
            
            document.getElementById('systematic-result').innerHTML = html;
        }
        
        function analyzePattern(analyzer, ids) {
            const [engineId, interfaceId, safeId] = ids;
            
            const engineOS = {
                hexagramId: engineId,
                name: `第${engineId}卦`,
                score: 0.5
            };
            
            const interfaceOS = {
                hexagramId: interfaceId,
                name: `第${interfaceId}卦`,
                score: 0.5
            };
            
            const safeModeOS = {
                hexagramId: safeId,
                name: `第${safeId}卦`,
                score: 0.5
            };
            
            const analysis = analyzer.analyze(engineOS, interfaceOS, safeModeOS);
            
            return {
                expressions: analysis.interactions.pair_insights
            };
        }
        
        function updateStatistics() {
            const total = Object.values(categoryStats).reduce((a, b) => a + b, 0);
            
            let html = `
                <h3>📊 検証統計</h3>
                <div class="stat-item">
                    <span>総ペア分析数:</span>
                    <span class="expression-count">${total}</span>
                </div>
                <div class="stat-item">
                    <span>ユニーク表現数:</span>
                    <span class="expression-count">${allExpressions.size}</span>
                </div>
                <div class="stat-item">
                    <span>表現の多様性率:</span>
                    <span class="${allExpressions.size / total > 0.3 ? 'success' : 'warning'}">
                        ${((allExpressions.size / total) * 100).toFixed(1)}%
                    </span>
                </div>
                <h4>カテゴリ分布</h4>
            `;
            
            Object.entries(categoryStats).forEach(([category, count]) => {
                const percentage = total > 0 ? (count / total * 100).toFixed(1) : 0;
                html += `
                    <div class="stat-item">
                        <span>${category}:</span>
                        <span>${count} (${percentage}%)</span>
                    </div>
                `;
            });
            
            // 警告チェック
            if (allExpressions.size < total * 0.2) {
                html += `
                    <div class="warning">
                        ⚠️ 警告: 表現の多様性が低い（20%未満）
                    </div>
                `;
            } else if (allExpressions.size >= total * 0.5) {
                html += `
                    <div class="success">
                        ✅ 優秀: 高い表現の多様性（50%以上）
                    </div>
                `;
            }
            
            document.getElementById('statistics').innerHTML = html;
        }
        
        function updateUniqueExpressions() {
            const expressions = Array.from(allExpressions);
            expressions.sort();
            
            let html = `
                <h3>ユニーク表現一覧（${expressions.length}種類）</h3>
                <div class="unique-expressions">
            `;
            
            expressions.forEach((exp, index) => {
                html += `<div>${index + 1}. ${exp}</div>`;
            });
            
            html += '</div>';
            
            document.getElementById('unique-expressions').innerHTML = html;
        }
    </script>
</body>
</html>