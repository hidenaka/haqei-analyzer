class Matrix{constructor(t){if(!Array.isArray(t))throw new Error("Matrix constructor requires array data");this.data=t,this.rows=t.length,this.cols=t[0]?t[0].length:0}static zeros(t,r){const s=[];for(let o=0;o<t;o++)s[o]=new Array(r).fill(0);return new Matrix(s)}static ones(t,r){const s=[];for(let o=0;o<t;o++)s[o]=new Array(r).fill(1);return new Matrix(s)}static eye(t){const r=[];for(let s=0;s<t;s++)r[s]=new Array(t).fill(0),r[s][s]=1;return new Matrix(r)}get(t,r){return this.data[t][r]}set(t,r,s){return this.data[t][r]=s,this}mmul(t){if(this.cols!==t.rows)throw new Error("Matrix dimensions do not match for multiplication");const r=Matrix.zeros(this.rows,t.cols);for(let s=0;s<this.rows;s++)for(let o=0;o<t.cols;o++){let i=0;for(let r=0;r<this.cols;r++)i+=this.data[s][r]*t.data[r][o];r.data[s][o]=i}return r}add(t){if(this.rows!==t.rows||this.cols!==t.cols)throw new Error("Matrix dimensions do not match for addition");const r=Matrix.zeros(this.rows,this.cols);for(let s=0;s<this.rows;s++)for(let o=0;o<this.cols;o++)r.data[s][o]=this.data[s][o]+t.data[s][o];return r}subtract(t){if(this.rows!==t.rows||this.cols!==t.cols)throw new Error("Matrix dimensions do not match for subtraction");const r=Matrix.zeros(this.rows,this.cols);for(let s=0;s<this.rows;s++)for(let o=0;o<this.cols;o++)r.data[s][o]=this.data[s][o]-t.data[s][o];return r}transpose(){const t=Matrix.zeros(this.cols,this.rows);for(let r=0;r<this.rows;r++)for(let s=0;s<this.cols;s++)t.data[s][r]=this.data[r][s];return t}toArray(){return this.data}}"undefined"!=typeof module&&module.exports?module.exports={Matrix:Matrix}:"undefined"!=typeof window&&(window.Matrix=Matrix,window.ML={Matrix:Matrix}),console.log("âœ… ml-matrix minimal implementation loaded successfully");