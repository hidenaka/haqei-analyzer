// Minimal ml-matrix implementation for HAQEI Future Simulator
class Matrix {
  constructor(data) {
    if (Array.isArray(data)) {
      this.data = data;
      this.rows = data.length;
      this.cols = data[0] ? data[0].length : 0;
    } else {
      throw new Error('Matrix constructor requires array data');
    }
  }
  
  static zeros(rows, cols) {
    const data = [];
    for (let i = 0; i < rows; i++) {
      data[i] = new Array(cols).fill(0);
    }
    return new Matrix(data);
  }
  
  static ones(rows, cols) {
    const data = [];
    for (let i = 0; i < rows; i++) {
      data[i] = new Array(cols).fill(1);
    }
    return new Matrix(data);
  }
  
  static eye(size) {
    const data = [];
    for (let i = 0; i < size; i++) {
      data[i] = new Array(size).fill(0);
      data[i][i] = 1;
    }
    return new Matrix(data);
  }
  
  get(row, col) {
    return this.data[row][col];
  }
  
  set(row, col, value) {
    this.data[row][col] = value;
    return this;
  }
  
  mmul(other) {
    if (this.cols !== other.rows) {
      throw new Error('Matrix dimensions do not match for multiplication');
    }
    
    const result = Matrix.zeros(this.rows, other.cols);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < other.cols; j++) {
        let sum = 0;
        for (let k = 0; k < this.cols; k++) {
          sum += this.data[i][k] * other.data[k][j];
        }
        result.data[i][j] = sum;
      }
    }
    return result;
  }
  
  add(other) {
    if (this.rows !== other.rows || this.cols !== other.cols) {
      throw new Error('Matrix dimensions do not match for addition');
    }
    
    const result = Matrix.zeros(this.rows, this.cols);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        result.data[i][j] = this.data[i][j] + other.data[i][j];
      }
    }
    return result;
  }
  
  subtract(other) {
    if (this.rows !== other.rows || this.cols !== other.cols) {
      throw new Error('Matrix dimensions do not match for subtraction');
    }
    
    const result = Matrix.zeros(this.rows, this.cols);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        result.data[i][j] = this.data[i][j] - other.data[i][j];
      }
    }
    return result;
  }
  
  transpose() {
    const result = Matrix.zeros(this.cols, this.rows);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.cols; j++) {
        result.data[j][i] = this.data[i][j];
      }
    }
    return result;
  }
  
  toArray() {
    return this.data;
  }
}

// Export for CommonJS and Browser environments
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { Matrix };
} else if (typeof window !== 'undefined') {
  window.Matrix = Matrix;
  window.ML = { Matrix };
}

console.log('âœ… ml-matrix minimal implementation loaded successfully');