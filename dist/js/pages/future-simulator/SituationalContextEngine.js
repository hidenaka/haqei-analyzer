/**
 * Situational Context Engine - HaQei Philosophy Implementation
 * Triple OS Architecture: Context Layer Component
 * 
 * Áä∂Ê≥Å„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç®„É≥„Ç∏„É≥
 * - Áí∞Â¢ÉÁöÑÊñáËÑàÁêÜËß£
 * - HaQeiÂì≤Â≠¶„Å´„Çà„ÇãÁä∂Ê≥ÅË™çË≠ò
 * - ÂãïÁöÑÊñáËÑàÈÅ©Âøú„Ç∑„Çπ„ÉÜ„É†
 */

console.log('üé≠ SituationalContextEngine Loading...');

window.SituationalContextEngine = {
  // Triple OS ArchitectureÊ∫ñÊã†„ÅÆÂàùÊúüÂåñ
  init() {
    console.log('üîß SituationalContextEngine initializing...');
    this.setupTripleOS();
    this.initializeContextFrameworks();
    this.loadSituationalMappings();
    console.log('‚úÖ SituationalContextEngine initialized successfully');
  },

  // Triple OS Architecture „Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
  setupTripleOS() {
    // Engine OS (Core Context Logic)
    this.engineOS = {
      name: 'Situational Context Engine OS',
      version: '1.0.0',
      philosophy: 'haqei-situational',
      
      async analyzeSituationalContext(input, previousContext = {}) {
        try {
          const situationRecognition = this.recognizeSituation(input);
          const contextMapping = await this.mapSituationalContext(situationRecognition, previousContext);
          const environmentalFactors = this.analyzeEnvironmentalFactors(input, contextMapping);
          const stakeholderAnalysis = this.analyzeStakeholders(input, contextMapping);
          const dynamicFactors = this.analyzeDynamicFactors(input, contextMapping);
          const adaptationStrategies = this.generateAdaptationStrategies(contextMapping, dynamicFactors);
          
          return {
            input: input,
            situation: situationRecognition,
            context: contextMapping,
            environmental: environmentalFactors,
            stakeholders: stakeholderAnalysis,
            dynamics: dynamicFactors,
            adaptations: adaptationStrategies,
            metadata: {
              contextComplexity: this.calculateContextComplexity(contextMapping),
              adaptationPotential: this.calculateAdaptationPotential(adaptationStrategies),
              situationalStability: this.assessSituationalStability(dynamicFactors),
              philosophy: 'haqei-situational'
            }
          };
          
        } catch (error) {
          console.warn('‚ö†Ô∏è Situational context analysis error:', error);
          return this.createFallbackContext(input);
        }
      },
      
      recognizeSituation(input) {
        const situationTypes = this.identifySituationTypes(input);
        const urgencyLevel = this.assessUrgencyLevel(input);
        const complexity = this.assessSituationComplexity(input);
        const scope = this.determineSituationScope(input);
        const nature = this.analyzeSituationNature(input);
        
        return {
          types: situationTypes,
          urgency: urgencyLevel,
          complexity: complexity,
          scope: scope,
          nature: nature,
          primaryType: this.determinePrimarySituationType(situationTypes),
          confidence: this.calculateRecognitionConfidence(situationTypes)
        };
      },
      
      identifySituationTypes(input) {
        const situationPatterns = {
          decision: /Ê±∫„ÇÅ„Çã|ÈÅ∏„Å∂|Âà§Êñ≠|Ê±∫Êñ≠|ÊñπÈáù|ÈÅ∏Êäû/,
          problem: /ÂïèÈ°å|Âõ∞Èõ£|Ë™≤È°å|„Éà„É©„Éñ„É´|ÊÇ©„Åø|ÈöúÂÆ≥/,
          opportunity: /„ÉÅ„É£„É≥„Çπ|Ê©ü‰ºö|ÂèØËÉΩÊÄß|Â•ΩÊ©ü|„Çø„Ç§„Éü„É≥„Ç∞/,
          relationship: /‰∫∫ÈñìÈñ¢‰øÇ|Âèã‰∫∫|ÂÆ∂Êóè|ÂêåÂÉö|„ÉÅ„Éº„É†|„Éë„Éº„Éà„Éä„Éº/,
          career: /‰ªï‰∫ã|Ëª¢ËÅ∑|ÊòáÈÄ≤|„Ç≠„É£„É™„Ç¢|ËÅ∑Ê•≠|‰ºöÁ§æ/,
          health: /ÂÅ•Â∫∑|‰ΩìË™ø|ÁóÖÊ∞ó|Ê≤ªÁôÇ|ÂåªÁôÇ|„Ç±„Ç¢/,
          learning: /Â≠¶Áøí|ÂãâÂº∑|ÊïôËÇ≤|„Çπ„Ç≠„É´|Áü•Ë≠ò|ÊàêÈï∑/,
          finance: /„ÅäÈáë|ÈáëËûç|ÊäïË≥á|ÂèéÂÖ•|ÊîØÂá∫|ÁµåÊ∏à/,
          creative: /Ââµ‰Ωú|Ëä∏Ë°ì|„Éá„Ç∂„Ç§„É≥|„Ç¢„Ç§„Éá„Ç¢|Ë°®Áèæ|„ÇØ„É™„Ç®„Ç§„ÉÜ„Ç£„Éñ/,
          communication: /„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥|‰ºöË©±|‰ºùÈÅî|Áõ∏Ë´á|ÂØæË©±/,
          conflict: /ÂØæÁ´ã|‰∫â„ÅÑ|Ë°ùÁ™Å|Á∑äÂºµ|Êë©Êì¶|ÂØæÊäó/,
          change: /Â§âÂåñ|Â§âÊõ¥|Ëª¢Êèõ|ÁßªË°å|ÊîπÈù©|Èù©Êñ∞/
        };
        
        const detectedTypes = [];
        Object.entries(situationPatterns).forEach(([type, pattern]) => {
          if (pattern.test(input)) {
            detectedTypes.push({
              type: type,
              confidence: this.calculatePatternConfidence(pattern, input),
              relevance: this.assessTypeRelevance(type, input)
            });
          }
        });
        
        return detectedTypes.sort((a, b) => b.confidence - a.confidence);
      },
      
      assessUrgencyLevel(input) {
        const urgencyIndicators = {
          high: /Á∑äÊÄ•|ÊÄ•„Åé|„Åô„Åê„Å´|‰ªä„Åô„Åê|Ëá≥ÊÄ•|Âç±Èô∫|„ÇØ„É™„ÉÜ„Ç£„Ç´„É´/,
          medium: /Êó©„ÇÅ|Ëøë„ÅÑ„ÅÜ„Å°|„Åù„Çç„Åù„Çç|„Å™„Çã„Åπ„Åè|„Åß„Åç„Çå„Å∞/,
          low: /„ÅÑ„Å§„Åã|Â∞ÜÊù•|ÊôÇÈñì„Åå„ÅÇ„Çã„Å®„Åç|‰ΩôË£ï„Åå„ÅÇ„Çã„Å®„Åç/
        };
        
        for (const [level, pattern] of Object.entries(urgencyIndicators)) {
          if (pattern.test(input)) {
            return {
              level: level,
              confidence: this.calculatePatternConfidence(pattern, input),
              indicators: this.extractUrgencyIndicators(input, pattern)
            };
          }
        }
        
        return {
          level: 'medium',
          confidence: 0.5,
          indicators: []
        };
      },
      
      assessSituationComplexity(input) {
        let complexity = 0.5; // Âü∫Ê∫ñÂÄ§
        
        // Ë™ûÂΩô„ÅÆÂ§öÊßòÊÄß
        const uniqueWords = new Set(input.split(/\s+/)).size;
        const totalWords = input.split(/\s+/).length;
        const vocabulary = uniqueWords / totalWords;
        complexity += vocabulary * 0.3;
        
        // Ë§áÊï∞„ÅÆ„Éâ„É°„Ç§„É≥„ÅÆË®ÄÂèä
        const domains = this.identifyDomains(input);
        complexity += domains.length * 0.1;
        
        // Èñ¢‰øÇËÄÖ„ÅÆÂ§ö„Åï
        const stakeholders = this.identifyStakeholders(input);
        complexity += stakeholders.length * 0.05;
        
        // ÊôÇÈñìÁöÑË§áÈõë„Åï
        const timeframes = this.identifyTimeframes(input);
        complexity += timeframes.length * 0.1;
        
        return Math.min(complexity, 1.0);
      },
      
      determineSituationScope(input) {
        const scopeIndicators = {
          personal: /Ëá™ÂàÜ|ÁßÅ|ÂÄã‰∫∫ÁöÑ|„Éó„É©„Ç§„Éô„Éº„Éà|‰∏Ä‰∫∫„Åß/,
          interpersonal: /Áõ∏Êâã|„Éë„Éº„Éà„Éä„Éº|Âèã‰∫∫|ÂÆ∂Êóè|ÊÅã‰∫∫/,
          group: /„ÉÅ„Éº„É†|„Ç∞„É´„Éº„Éó|‰ª≤Èñì|„Åø„Çì„Å™|ÈõÜÂõ£/,
          organizational: /‰ºöÁ§æ|ÁµÑÁπî|ÈÉ®ÁΩ≤|ËÅ∑Â†¥|‰ºÅÊ•≠/,
          societal: /Á§æ‰ºö|Âú∞Âüü|„Ç≥„Éü„É•„Éã„ÉÜ„Ç£|‰∏ñÈñì|ÂÖ¨ÂÖ±/,
          global: /‰∏ñÁïå|„Ç∞„É≠„Éº„Éê„É´|ÂõΩÈöõ|ÂÖ®‰Ωì|ÊôÆÈÅç/
        };
        
        const detectedScopes = [];
        Object.entries(scopeIndicators).forEach(([scope, pattern]) => {
          if (pattern.test(input)) {
            detectedScopes.push({
              scope: scope,
              strength: this.calculatePatternStrength(pattern, input)
            });
          }
        });
        
        return detectedScopes.length > 0 ? detectedScopes : [{ scope: 'personal', strength: 0.5 }];
      },
      
      analyzeSituationNature(input) {
        const naturePatterns = {
          analytical: /ÂàÜÊûê|Ê§úË®é|Ë™øÊüª|Á†îÁ©∂|„Éá„Éº„Çø|ÊÉÖÂ†±/,
          creative: /ÂâµÈÄ†|„Ç¢„Ç§„Éá„Ç¢|Áô∫ÊÉ≥|„Ç§„Éé„Éô„Éº„Ç∑„Éß„É≥|„Éá„Ç∂„Ç§„É≥/,
          emotional: /ÊÑüÊÉÖ|Ê∞óÊåÅ„Å°|ÂøÉ|ÊÑõ|‰∏çÂÆâ|Âñú„Å≥|ÊÇ≤„Åó„Åø/,
          practical: /ÂÆüË∑µ|ÂÆüË°å|Ë°åÂãï|ÂÆüÈöõ|ÂÖ∑‰ΩìÁöÑ|ÁèæÂÆü/,
          strategic: /Êà¶Áï•|Ë®àÁîª|ÊñπÈáù|Èï∑Êúü|ÁõÆÊ®ô|„Éì„Ç∏„Éß„É≥/,
          tactical: /Êà¶Ë°ì|ÊâãÊ≥ï|ÊñπÊ≥ï|Áü≠Êúü|Âç≥Âäπ|„ÉÜ„ÇØ„Éã„ÉÉ„ÇØ/,
          philosophical: /Âì≤Â≠¶|‰æ°ÂÄ§Ë¶≥|‰ø°Âøµ|‰∫∫Áîü|ÊÑèÂë≥|Êú¨Ë≥™/
        };
        
        const detectedNatures = [];
        Object.entries(naturePatterns).forEach(([nature, pattern]) => {
          if (pattern.test(input)) {
            detectedNatures.push({
              nature: nature,
              strength: this.calculatePatternStrength(pattern, input),
              relevance: this.assessNatureRelevance(nature, input)
            });
          }
        });
        
        return detectedNatures.sort((a, b) => b.strength - a.strength);
      },
      
      async mapSituationalContext(situationRecognition, previousContext) {
        const baseContext = {
          situation: situationRecognition,
          previous: previousContext,
          timestamp: new Date().toISOString()
        };
        
        // Áä∂Ê≥ÅÁâπÂåñ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Éû„ÉÉ„Éî„É≥„Ç∞
        const contextMap = await this.createSituationalContextMap(situationRecognition);
        
        // Á∂ôÁ∂öÊÄß„Å®„ÅÆ„É™„É≥„ÇØ
        const continuity = this.analyzeContinuity(baseContext, previousContext);
        
        // ÊñáËÑàÁöÑÂà∂Á¥Ñ
        const constraints = this.identifyContextualConstraints(situationRecognition);
        
        // Ê©ü‰ºö„Å®ÂèØËÉΩÊÄß
        const opportunities = this.identifyContextualOpportunities(situationRecognition);
        
        return {
          base: baseContext,
          map: contextMap,
          continuity: continuity,
          constraints: constraints,
          opportunities: opportunities,
          coherence: this.calculateContextualCoherence(contextMap, continuity)
        };
      },
      
      analyzeEnvironmentalFactors(input, contextMapping) {
        const factors = {
          physical: this.analyzePhysicalEnvironment(input),
          social: this.analyzeSocialEnvironment(input),
          cultural: this.analyzeCulturalEnvironment(input),
          economic: this.analyzeEconomicEnvironment(input),
          technological: this.analyzeTechnologicalEnvironment(input),
          temporal: this.analyzeTemporalEnvironment(input)
        };
        
        const interactions = this.analyzeFactorInteractions(factors);
        const influences = this.assessEnvironmentalInfluences(factors, contextMapping);
        
        return {
          factors: factors,
          interactions: interactions,
          influences: influences,
          dominantFactors: this.identifyDominantFactors(factors),
          stability: this.assessEnvironmentalStability(factors)
        };
      },
      
      analyzeStakeholders(input, contextMapping) {
        const stakeholders = this.identifyStakeholders(input);
        const roles = this.analyzeStakeholderRoles(stakeholders, contextMapping);
        const relationships = this.mapStakeholderRelationships(stakeholders, input);
        const influences = this.assessStakeholderInfluences(stakeholders, contextMapping);
        const dynamics = this.analyzeStakeholderDynamics(stakeholders, relationships);
        
        return {
          stakeholders: stakeholders,
          roles: roles,
          relationships: relationships,
          influences: influences,
          dynamics: dynamics,
          keyStakeholders: this.identifyKeyStakeholders(stakeholders, influences),
          alignment: this.assessStakeholderAlignment(stakeholders, relationships)
        };
      },
      
      analyzeDynamicFactors(input, contextMapping) {
        const trends = this.identifyTrends(input, contextMapping);
        const pressures = this.identifyPressures(input, contextMapping);
        const changes = this.identifyChanges(input, contextMapping);
        const momentum = this.assessMomentum(input, contextMapping);
        const volatility = this.assessVolatility(trends, pressures, changes);
        
        return {
          trends: trends,
          pressures: pressures,
          changes: changes,
          momentum: momentum,
          volatility: volatility,
          predictability: this.assessPredictability(trends, volatility),
          adaptationRequired: this.assessAdaptationRequirement(changes, volatility)
        };
      },
      
      generateAdaptationStrategies(contextMapping, dynamicFactors) {
        const strategies = [];
        
        // Â§âÂåñÂØæÂøúÊà¶Áï•
        if (dynamicFactors.volatility > 0.6) {
          strategies.push(...this.generateVolatilityStrategies(dynamicFactors));
        }
        
        // ÂÆâÂÆöÊÄßÁ∂≠ÊåÅÊà¶Áï•
        if (dynamicFactors.volatility < 0.4) {
          strategies.push(...this.generateStabilityStrategies(dynamicFactors));
        }
        
        // Ê©ü‰ºöÊ¥ªÁî®Êà¶Áï•
        if (contextMapping.opportunities.length > 0) {
          strategies.push(...this.generateOpportunityStrategies(contextMapping.opportunities));
        }
        
        // Âà∂Á¥ÑÂØæÂá¶Êà¶Áï•
        if (contextMapping.constraints.length > 0) {
          strategies.push(...this.generateConstraintStrategies(contextMapping.constraints));
        }
        
        // HaQeiÂì≤Â≠¶ÁöÑÁµ±ÂêàÊà¶Áï•
        strategies.push(...this.generateHaQeiIntegrationStrategies(contextMapping, dynamicFactors));
        
        return this.prioritizeStrategies(strategies);
      }
    };

    // Interface OS (Context Presentation Layer)
    this.interfaceOS = {
      name: 'Situational Context Interface OS',
      
      formatContextResult(result) {
        return {
          overview: this.createContextOverview(result),
          situation: this.formatSituation(result.situation),
          context: this.formatContext(result.context),
          environmental: this.formatEnvironmentalFactors(result.environmental),
          stakeholders: this.formatStakeholders(result.stakeholders),
          dynamics: this.formatDynamics(result.dynamics),
          adaptations: this.formatAdaptations(result.adaptations),
          insights: this.generateContextualInsights(result),
          visualizations: this.generateVisualizationSpecs(result),
          philosophy: result.metadata.philosophy
        };
      },
      
      createContextOverview(result) {
        return {
          title: 'HaQeiÁä∂Ê≥Å„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÂàÜÊûê',
          summary: {
            situationType: result.situation.primaryType,
            urgency: result.situation.urgency.level,
            complexity: this.formatComplexity(result.situation.complexity),
            scope: result.situation.scope[0]?.scope || 'unknown'
          },
          keyInsights: this.extractKeyInsights(result),
          urgentActions: this.extractUrgentActions(result.adaptations),
          contextualTheme: this.deriveContextualTheme(result)
        };
      },
      
      formatSituation(situation) {
        return {
          primary: this.formatSituationType(situation.primaryType),
          types: situation.types.map(type => ({
            name: this.formatSituationType(type.type),
            confidence: this.formatPercentage(type.confidence),
            relevance: this.formatPercentage(type.relevance)
          })),
          urgency: {
            level: this.formatUrgencyLevel(situation.urgency.level),
            indicators: situation.urgency.indicators
          },
          complexity: this.formatComplexity(situation.complexity),
          scope: situation.scope.map(s => ({
            name: this.formatScopeType(s.scope),
            strength: this.formatPercentage(s.strength)
          })),
          nature: situation.nature.map(n => ({
            name: this.formatNatureType(n.nature),
            strength: this.formatPercentage(n.strength)
          }))
        };
      }
    };

    // Safe Mode OS (Fallback Layer)
    this.safeMode = {
      name: 'Situational Context Safe Mode OS',
      active: false,
      
      activate() {
        console.log('üõ°Ô∏è SituationalContextEngine Safe Mode activated');
        this.active = true;
        
        return {
          basicContextAnalysis: true,
          advancedFeatures: false,
          philosophy: 'haqei-safe'
        };
      },
      
      performBasicSituationalAnalysis(input) {
        const basicSituation = {
          type: this.identifyBasicSituationType(input),
          urgency: this.assessBasicUrgency(input),
          complexity: this.estimateBasicComplexity(input),
          scope: 'personal'
        };
        
        return {
          input: input,
          situation: basicSituation,
          insights: [`Âü∫Êú¨ÁöÑ„Å™Áä∂Ê≥ÅÂàÜÊûê: ${basicSituation.type}„Å®„Åó„Å¶Ë™çË≠ò`],
          metadata: {
            contextComplexity: basicSituation.complexity,
            adaptationPotential: 0.5,
            situationalStability: 0.5,
            philosophy: 'haqei-safe'
          }
        };
      }
    };
  },

  // ÂàùÊúüÂåñ„É°„ÇΩ„ÉÉ„ÉâÁæ§
  initializeContextFrameworks() {
    this.contextFrameworks = {
      situationType: this.createSituationTypeFramework(),
      urgency: this.createUrgencyFramework(),
      scope: this.createScopeFramework(),
      nature: this.createNatureFramework(),
      adaptation: this.createAdaptationFramework()
    };
  },

  createSituationTypeFramework() {
    return {
      categories: [
        'decision', 'problem', 'opportunity', 'relationship',
        'career', 'health', 'learning', 'finance',
        'creative', 'communication', 'conflict', 'change'
      ],
      hierarchies: {
        'problem': ['technical', 'interpersonal', 'strategic'],
        'decision': ['binary', 'multiple', 'strategic'],
        'opportunity': ['immediate', 'strategic', 'creative']
      }
    };
  },

  loadSituationalMappings() {
    this.situationalMappings = {
      contexts: this.loadContextMappings(),
      adaptations: this.loadAdaptationMappings(),
      strategies: this.loadStrategyMappings()
    };
  },

  // ÂàÜÊûê„É°„ÇΩ„ÉÉ„ÉâÁæ§
  identifyStakeholders(input) {
    const stakeholderPatterns = [
      /ÁßÅ|Ëá™ÂàÜ|ÂÄã‰∫∫/,
      /ÂÆ∂Êóè|‰∏°Ë¶™|ÂÖÑÂºü|ÂßâÂ¶π|Â≠ê‰æõ/,
      /Âèã‰∫∫|ÂèãÈÅî|‰ª≤Èñì|Áü•‰∫∫/,
      /ÊÅã‰∫∫|„Éë„Éº„Éà„Éä„Éº|ÈÖçÂÅ∂ËÄÖ/,
      /‰∏äÂè∏|ÈÉ®‰∏ã|ÂêåÂÉö|„ÉÅ„Éº„É†/,
      /È°ßÂÆ¢|„ÇØ„É©„Ç§„Ç¢„É≥„Éà|„ÅäÂÆ¢Êßò/,
      /Â∞ÇÈñÄÂÆ∂|ÂåªËÄÖ|ÂºÅË≠∑Â£´|„Ç≥„É≥„Çµ„É´„Çø„É≥„Éà/
    ];
    
    const stakeholders = [];
    stakeholderPatterns.forEach((pattern, index) => {
      if (pattern.test(input)) {
        stakeholders.push({
          type: this.getStakeholderType(index),
          relevance: this.calculateStakeholderRelevance(input, pattern)
        });
      }
    });
    
    return stakeholders;
  },

  getStakeholderType(index) {
    const types = [
      'self', 'family', 'friends', 'partner',
      'colleagues', 'clients', 'experts'
    ];
    return types[index] || 'unknown';
  },

  calculatePatternConfidence(pattern, input) {
    const matches = input.match(pattern);
    if (!matches) return 0;
    
    const matchCount = matches.length;
    const inputLength = input.length;
    const confidence = Math.min(matchCount / (inputLength / 100), 1.0);
    
    return confidence;
  },

  calculatePatternStrength(pattern, input) {
    const confidence = this.calculatePatternConfidence(pattern, input);
    const contextualRelevance = this.assessContextualRelevance(pattern, input);
    
    return (confidence + contextualRelevance) / 2;
  },

  assessContextualRelevance(pattern, input) {
    // „Éë„Çø„Éº„É≥„ÅåÊñáËÑàÁöÑ„Å´„Å©„ÅÆÁ®ãÂ∫¶Èñ¢ÈÄ£ÊÄß„Åå„ÅÇ„Çã„Åã„ÇíË©ï‰æ°
    const surroundingContext = this.extractSurroundingContext(pattern, input);
    const semanticRelevance = this.calculateSemanticRelevance(surroundingContext);
    
    return semanticRelevance;
  },

  generateHaQeiIntegrationStrategies(contextMapping, dynamicFactors) {
    const strategies = [];
    
    // Ë™øÂíåÊà¶Áï•ÔºàHaQei PhilosophyÔºâ
    strategies.push({
      type: 'harmony',
      description: 'Áä∂Ê≥Å„ÅÆÁï∞„Å™„ÇãË¶ÅÁ¥†Èñì„ÅÆË™øÂíå„ÇíÂõ≥„Çã',
      actions: ['ÂØæÁ´ãË¶ÅÁ¥†„ÅÆÁµ±Âêà', 'Áï∞„Å™„ÇãË¶ñÁÇπ„ÅÆÂèóÂÆπ', '„Éê„É©„É≥„Çπ„ÅÆÊ®°Á¥¢'],
      priority: 'high',
      philosophy: 'haqei-harmony'
    });
    
    // Â§âÂÆπÊà¶Áï•ÔºàHaQei PhilosophyÔºâ
    strategies.push({
      type: 'transformation',
      description: 'Áä∂Ê≥Å„ÇíÈÄö„Åò„ÅüÊàêÈï∑„Å®Â§âÂÆπ„Çí‰øÉÈÄ≤',
      actions: ['Â≠¶ÁøíÊ©ü‰ºö„ÅÆÊ¥ªÁî®', 'Ë¶ñÈáé„ÅÆÊã°Âºµ', '‰æ°ÂÄ§Ë¶≥„ÅÆÊ∑±Âåñ'],
      priority: 'medium',
      philosophy: 'haqei-transformation'
    });
    
    // Áµ±ÂêàÊà¶Áï•ÔºàHaQei PhilosophyÔºâ
    strategies.push({
      type: 'integration',
      description: 'ÂàÜÊï£„Åó„ÅüË¶ÅÁ¥†„ÅÆÁµ±ÂêàÁöÑÁêÜËß£',
      actions: ['ÂÖ®‰ΩìÂÉè„ÅÆÊääÊè°', 'Èñ¢ÈÄ£ÊÄß„ÅÆÁô∫Ë¶ã', 'Êú¨Ë≥™„ÅÆÊ¥ûÂØü'],
      priority: 'medium',
      philosophy: 'haqei-integration'
    });
    
    return strategies;
  },

  // ÂÖ¨ÈñãAPI
  async analyzeSituationalContext(input, previousContext = {}) {
    if (!this.engineOS) {
      await this.init();
    }
    
    try {
      if (this.safeMode.active) {
        return this.safeMode.performBasicSituationalAnalysis(input);
      }
      
      const result = await this.engineOS.analyzeSituationalContext(input, previousContext);
      return this.interfaceOS.formatContextResult(result);
      
    } catch (error) {
      console.error('‚ùå Situational context analysis failed:', error);
      this.safeMode.activate();
      return this.safeMode.performBasicSituationalAnalysis(input);
    }
  },

  getContextCapabilities() {
    const capabilities = ['basic_situation_recognition', 'urgency_assessment'];
    
    if (this.contextFrameworks) {
      capabilities.push('advanced_situation_analysis', 'stakeholder_analysis', 'environmental_analysis');
    }
    
    if (this.situationalMappings) {
      capabilities.push('adaptation_strategies', 'haqei_integration', 'context_synthesis');
    }
    
    if (!this.safeMode.active) {
      capabilities.push('dynamic_adaptation', 'complex_context_mapping', 'philosophical_integration');
    }
    
    return capabilities;
  }
};

// Ëá™ÂãïÂàùÊúüÂåñ
document.addEventListener('DOMContentLoaded', () => {
  window.SituationalContextEngine.init();
});

console.log('‚úÖ SituationalContextEngine loaded successfully with HaQei Philosophy');