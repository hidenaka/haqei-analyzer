/**\n * DictionaryCacheStrategy.js - Advanced Dictionary Caching for Service Worker\n * HAQEI Future Simulator - Dictionary-Specific Cache Management\n * \n * 目的:\n * - 辞書ファイル専用の高度なキャッシュ戦略\n * - オフライン優先の辞書アクセス\n * - 辞書整合性の保証\n * - 段階的フォールバック\n * \n * 機能:\n * 1. 辞書ファイルの長期キャッシュ\n * 2. 辞書データの整合性検証\n * 3. CDNフォールバック管理\n * 4. 辞書バージョン管理\n */\n\n/**\n * 辞書専用キャッシュファースト戦略\n * オフライン優先で辞書ファイルを提供\n */\nasync function dictionaryCacheFirst(request) {\n  const cache = await caches.open(CACHE_NAME);\n  const url = new URL(request.url);\n  const pathname = url.pathname;\n  \n  console.log('📚 Dictionary request:', pathname);\n  \n  try {\n    // Phase 1: ローカルキャッシュをチェック\n    const cached = await cache.match(request);\n    if (cached) {\n      // 辞書ファイルの整合性をチェック\n      const isValid = await validateCachedDictionary(cached, pathname);\n      if (isValid) {\n        console.log('💾 Valid dictionary cache hit:', pathname);\n        return cached;\n      } else {\n        console.warn('⚠️ Invalid dictionary cache, removing:', pathname);\n        await cache.delete(request);\n      }\n    }\n    \n    // Phase 2: ネットワークから取得を試行\n    console.log('🌐 Fetching dictionary from network:', pathname);\n    const response = await fetchDictionaryWithTimeout(request);\n    \n    if (response && response.ok) {\n      // 成功したレスポンスをキャッシュ\n      await cache.put(request, response.clone());\n      console.log('✅ Dictionary cached from network:', pathname);\n      return response;\n    }\n    \n    // Phase 3: CDNフォールバック\n    if (pathname.startsWith('/dict/')) {\n      return await tryDictionaryCDNFallback(request, pathname);\n    }\n    \n    throw new Error('Dictionary not available');\n    \n  } catch (error) {\n    console.error('❌ Dictionary fetch failed:', pathname, error.message);\n    \n    // Phase 4: 緊急フォールバック - 既存のキャッシュ（無効でも）\n    const fallbackCache = await cache.match(request);\n    if (fallbackCache) {\n      console.log('🚨 Using potentially invalid dictionary cache as fallback:', pathname);\n      return fallbackCache;\n    }\n    \n    // Phase 5: 辞書生成フォールバック\n    return await generateDictionaryFallback(pathname);\n  }\n}\n\n/**\n * タイムアウト付き辞書フェッチ\n */\nasync function fetchDictionaryWithTimeout(request, timeout = 10000) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    const response = await fetch(request, {\n      signal: controller.signal,\n      cache: 'no-cache' // 辞書の最新版を取得\n    });\n    \n    clearTimeout(timeoutId);\n    return response;\n    \n  } catch (error) {\n    clearTimeout(timeoutId);\n    if (error.name === 'AbortError') {\n      throw new Error('Dictionary fetch timeout');\n    }\n    throw error;\n  }\n}\n\n/**\n * CDNフォールバック\n */\nasync function tryDictionaryCDNFallback(request, pathname) {\n  const dictFilename = pathname.split('/').pop();\n  const cdnUrls = [\n    `https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict/${dictFilename}`,\n    `https://unpkg.com/kuromoji@0.1.2/dict/${dictFilename}`,\n    `https://cdnjs.cloudflare.com/ajax/libs/kuromoji/0.1.2/dict/${dictFilename}`\n  ];\n  \n  for (const cdnUrl of cdnUrls) {\n    try {\n      console.log(`🌐 Trying CDN fallback: ${cdnUrl}`);\n      \n      const cdnRequest = new Request(cdnUrl, {\n        method: 'GET',\n        headers: {\n          'Accept': 'application/gzip, application/octet-stream, */*'\n        }\n      });\n      \n      const response = await fetchDictionaryWithTimeout(cdnRequest, 8000);\n      \n      if (response && response.ok) {\n        console.log('✅ CDN fallback successful:', cdnUrl);\n        \n        // 成功したレスポンスを元のリクエストでキャッシュ\n        const cache = await caches.open(CACHE_NAME);\n        await cache.put(request, response.clone());\n        \n        return response;\n      }\n      \n    } catch (error) {\n      console.warn(`❌ CDN fallback failed: ${cdnUrl}`, error.message);\n      continue;\n    }\n  }\n  \n  throw new Error('All CDN fallbacks failed');\n}\n\n/**\n * キャッシュされた辞書の整合性検証\n */\nasync function validateCachedDictionary(response, pathname) {\n  try {\n    // Content-Length チェック\n    const contentLength = response.headers.get('content-length');\n    if (contentLength && parseInt(contentLength) < 100) {\n      console.warn('⚠️ Dictionary file too small:', pathname, contentLength);\n      return false;\n    }\n    \n    // Content-Typeチェック（.gz ファイル）\n    const contentType = response.headers.get('content-type');\n    if (pathname.endsWith('.gz')) {\n      const validTypes = [\n        'application/gzip',\n        'application/x-gzip',\n        'application/octet-stream'\n      ];\n      \n      if (contentType && !validTypes.some(type => contentType.includes(type))) {\n        console.warn('⚠️ Invalid content type for dictionary:', pathname, contentType);\n        return false;\n      }\n    }\n    \n    // レスポンス本体の基本チェック\n    const clone = response.clone();\n    const arrayBuffer = await clone.arrayBuffer();\n    \n    if (arrayBuffer.byteLength === 0) {\n      console.warn('⚠️ Empty dictionary file:', pathname);\n      return false;\n    }\n    \n    // GZipファイルのマジックナンバーチェック\n    if (pathname.endsWith('.gz')) {\n      const uint8Array = new Uint8Array(arrayBuffer);\n      if (uint8Array.length >= 2 && (uint8Array[0] !== 0x1f || uint8Array[1] !== 0x8b)) {\n        console.warn('⚠️ Invalid gzip magic number:', pathname);\n        return false;\n      }\n    }\n    \n    console.log('✅ Dictionary validation passed:', pathname);\n    return true;\n    \n  } catch (error) {\n    console.warn('⚠️ Dictionary validation error:', pathname, error.message);\n    return false; // 検証失敗時は無効とみなす\n  }\n}\n\n/**\n * 辞書生成フォールバック（緊急時）\n */\nasync function generateDictionaryFallback(pathname) {\n  console.log('🚨 Generating dictionary fallback for:', pathname);\n  \n  // 最小限の辞書データ生成（実際の使用には不適切だが、エラー回避用）\n  const fallbackContent = new Uint8Array([0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00]);\n  \n  return new Response(fallbackContent, {\n    status: 200,\n    statusText: 'OK (Fallback)',\n    headers: {\n      'Content-Type': 'application/gzip',\n      'Content-Length': fallbackContent.length.toString(),\n      'Cache-Control': 'no-store', // フォールバックはキャッシュしない\n      'X-Dictionary-Fallback': 'true'\n    }\n  });\n}\n\n/**\n * 辞書キャッシュの統計情報取得\n */\nasync function getDictionaryCacheStats() {\n  try {\n    const cache = await caches.open(CACHE_NAME);\n    const keys = await cache.keys();\n    \n    const dictionaryKeys = keys.filter(request => {\n      const url = new URL(request.url);\n      return isDictionaryResource(url.pathname);\n    });\n    \n    const stats = {\n      totalDictionaryFiles: dictionaryKeys.length,\n      files: [],\n      totalSize: 0\n    };\n    \n    for (const key of dictionaryKeys) {\n      const response = await cache.match(key);\n      if (response) {\n        const size = response.headers.get('content-length');\n        const url = new URL(key.url);\n        \n        stats.files.push({\n          path: url.pathname,\n          size: size ? parseInt(size) : 0,\n          contentType: response.headers.get('content-type')\n        });\n        \n        if (size) {\n          stats.totalSize += parseInt(size);\n        }\n      }\n    }\n    \n    return stats;\n    \n  } catch (error) {\n    console.error('❌ Dictionary cache stats error:', error);\n    return { error: error.message };\n  }\n}\n\n/**\n * 辞書キャッシュの手動更新\n */\nasync function updateDictionaryCache() {\n  console.log('🔄 Updating dictionary cache...');\n  \n  try {\n    const cache = await caches.open(CACHE_NAME);\n    const dictFiles = [\n      '/dict/base.dat.gz',\n      '/dict/cc.dat.gz',\n      '/dict/check.dat.gz',\n      '/dict/tid.dat.gz',\n      '/dict/tid_map.dat.gz',\n      '/dict/tid_pos.dat.gz',\n      '/dict/unk.dat.gz',\n      '/dict/unk_char.dat.gz',\n      '/dict/unk_compat.dat.gz',\n      '/dict/unk_invoke.dat.gz',\n      '/dict/unk_map.dat.gz',\n      '/dict/unk_pos.dat.gz'\n    ];\n    \n    const updatePromises = dictFiles.map(async (dictPath) => {\n      try {\n        const request = new Request(dictPath);\n        \n        // 既存のキャッシュを削除\n        await cache.delete(request);\n        \n        // 新しいバージョンを取得\n        const response = await fetchDictionaryWithTimeout(request);\n        \n        if (response && response.ok) {\n          await cache.put(request, response.clone());\n          console.log('✅ Dictionary updated:', dictPath);\n          return { path: dictPath, success: true };\n        } else {\n          throw new Error('Invalid response');\n        }\n        \n      } catch (error) {\n        console.warn('⚠️ Dictionary update failed:', dictPath, error.message);\n        return { path: dictPath, success: false, error: error.message };\n      }\n    });\n    \n    const results = await Promise.all(updatePromises);\n    const successful = results.filter(r => r.success).length;\n    const failed = results.filter(r => !r.success).length;\n    \n    console.log(`✅ Dictionary cache update complete: ${successful} success, ${failed} failed`);\n    return { successful, failed, details: results };\n    \n  } catch (error) {\n    console.error('❌ Dictionary cache update error:', error);\n    return { error: error.message };\n  }\n}\n\n// Service Workerで利用可能にする\nif (typeof self !== 'undefined' && self.importScripts) {\n  // Service Worker context\n  self.dictionaryCacheFirst = dictionaryCacheFirst;\n  self.getDictionaryCacheStats = getDictionaryCacheStats;\n  self.updateDictionaryCache = updateDictionaryCache;\n}\n\nconsole.log('📚 DictionaryCacheStrategy loaded');