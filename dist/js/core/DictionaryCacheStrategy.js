/**\n * DictionaryCacheStrategy.js - Advanced Dictionary Caching for Service Worker\n * HAQEI Future Simulator - Dictionary-Specific Cache Management\n * \n * ç›®çš„:\n * - è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«å°‚ç”¨ã®é«˜åº¦ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥\n * - ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å„ªå…ˆã®è¾æ›¸ã‚¢ã‚¯ã‚»ã‚¹\n * - è¾æ›¸æ•´åˆæ€§ã®ä¿è¨¼\n * - æ®µéšçš„ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯\n * \n * æ©Ÿèƒ½:\n * 1. è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®é•·æœŸã‚­ãƒ£ãƒƒã‚·ãƒ¥\n * 2. è¾æ›¸ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§æ¤œè¨¼\n * 3. CDNãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç®¡ç†\n * 4. è¾æ›¸ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†\n */\n\n/**\n * è¾æ›¸å°‚ç”¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆæˆ¦ç•¥\n * ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å„ªå…ˆã§è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›\n */\nasync function dictionaryCacheFirst(request) {\n  const cache = await caches.open(CACHE_NAME);\n  const url = new URL(request.url);\n  const pathname = url.pathname;\n  \n  console.log('ğŸ“š Dictionary request:', pathname);\n  \n  try {\n    // Phase 1: ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒã‚§ãƒƒã‚¯\n    const cached = await cache.match(request);\n    if (cached) {\n      // è¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®æ•´åˆæ€§ã‚’ãƒã‚§ãƒƒã‚¯\n      const isValid = await validateCachedDictionary(cached, pathname);\n      if (isValid) {\n        console.log('ğŸ’¾ Valid dictionary cache hit:', pathname);\n        return cached;\n      } else {\n        console.warn('âš ï¸ Invalid dictionary cache, removing:', pathname);\n        await cache.delete(request);\n      }\n    }\n    \n    // Phase 2: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰å–å¾—ã‚’è©¦è¡Œ\n    console.log('ğŸŒ Fetching dictionary from network:', pathname);\n    const response = await fetchDictionaryWithTimeout(request);\n    \n    if (response && response.ok) {\n      // æˆåŠŸã—ãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥\n      await cache.put(request, response.clone());\n      console.log('âœ… Dictionary cached from network:', pathname);\n      return response;\n    }\n    \n    // Phase 3: CDNãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯\n    if (pathname.startsWith('/dict/')) {\n      return await tryDictionaryCDNFallback(request, pathname);\n    }\n    \n    throw new Error('Dictionary not available');\n    \n  } catch (error) {\n    console.error('âŒ Dictionary fetch failed:', pathname, error.message);\n    \n    // Phase 4: ç·Šæ€¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ - æ—¢å­˜ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆç„¡åŠ¹ã§ã‚‚ï¼‰\n    const fallbackCache = await cache.match(request);\n    if (fallbackCache) {\n      console.log('ğŸš¨ Using potentially invalid dictionary cache as fallback:', pathname);\n      return fallbackCache;\n    }\n    \n    // Phase 5: è¾æ›¸ç”Ÿæˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯\n    return await generateDictionaryFallback(pathname);\n  }\n}\n\n/**\n * ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãè¾æ›¸ãƒ•ã‚§ãƒƒãƒ\n */\nasync function fetchDictionaryWithTimeout(request, timeout = 10000) {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n  \n  try {\n    const response = await fetch(request, {\n      signal: controller.signal,\n      cache: 'no-cache' // è¾æ›¸ã®æœ€æ–°ç‰ˆã‚’å–å¾—\n    });\n    \n    clearTimeout(timeoutId);\n    return response;\n    \n  } catch (error) {\n    clearTimeout(timeoutId);\n    if (error.name === 'AbortError') {\n      throw new Error('Dictionary fetch timeout');\n    }\n    throw error;\n  }\n}\n\n/**\n * CDNãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯\n */\nasync function tryDictionaryCDNFallback(request, pathname) {\n  const dictFilename = pathname.split('/').pop();\n  const cdnUrls = [\n    `https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict/${dictFilename}`,\n    `https://unpkg.com/kuromoji@0.1.2/dict/${dictFilename}`,\n    `https://cdnjs.cloudflare.com/ajax/libs/kuromoji/0.1.2/dict/${dictFilename}`\n  ];\n  \n  for (const cdnUrl of cdnUrls) {\n    try {\n      console.log(`ğŸŒ Trying CDN fallback: ${cdnUrl}`);\n      \n      const cdnRequest = new Request(cdnUrl, {\n        method: 'GET',\n        headers: {\n          'Accept': 'application/gzip, application/octet-stream, */*'\n        }\n      });\n      \n      const response = await fetchDictionaryWithTimeout(cdnRequest, 8000);\n      \n      if (response && response.ok) {\n        console.log('âœ… CDN fallback successful:', cdnUrl);\n        \n        // æˆåŠŸã—ãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å…ƒã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥\n        const cache = await caches.open(CACHE_NAME);\n        await cache.put(request, response.clone());\n        \n        return response;\n      }\n      \n    } catch (error) {\n      console.warn(`âŒ CDN fallback failed: ${cdnUrl}`, error.message);\n      continue;\n    }\n  }\n  \n  throw new Error('All CDN fallbacks failed');\n}\n\n/**\n * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸè¾æ›¸ã®æ•´åˆæ€§æ¤œè¨¼\n */\nasync function validateCachedDictionary(response, pathname) {\n  try {\n    // Content-Length ãƒã‚§ãƒƒã‚¯\n    const contentLength = response.headers.get('content-length');\n    if (contentLength && parseInt(contentLength) < 100) {\n      console.warn('âš ï¸ Dictionary file too small:', pathname, contentLength);\n      return false;\n    }\n    \n    // Content-Typeãƒã‚§ãƒƒã‚¯ï¼ˆ.gz ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰\n    const contentType = response.headers.get('content-type');\n    if (pathname.endsWith('.gz')) {\n      const validTypes = [\n        'application/gzip',\n        'application/x-gzip',\n        'application/octet-stream'\n      ];\n      \n      if (contentType && !validTypes.some(type => contentType.includes(type))) {\n        console.warn('âš ï¸ Invalid content type for dictionary:', pathname, contentType);\n        return false;\n      }\n    }\n    \n    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹æœ¬ä½“ã®åŸºæœ¬ãƒã‚§ãƒƒã‚¯\n    const clone = response.clone();\n    const arrayBuffer = await clone.arrayBuffer();\n    \n    if (arrayBuffer.byteLength === 0) {\n      console.warn('âš ï¸ Empty dictionary file:', pathname);\n      return false;\n    }\n    \n    // GZipãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚¸ãƒƒã‚¯ãƒŠãƒ³ãƒãƒ¼ãƒã‚§ãƒƒã‚¯\n    if (pathname.endsWith('.gz')) {\n      const uint8Array = new Uint8Array(arrayBuffer);\n      if (uint8Array.length >= 2 && (uint8Array[0] !== 0x1f || uint8Array[1] !== 0x8b)) {\n        console.warn('âš ï¸ Invalid gzip magic number:', pathname);\n        return false;\n      }\n    }\n    \n    console.log('âœ… Dictionary validation passed:', pathname);\n    return true;\n    \n  } catch (error) {\n    console.warn('âš ï¸ Dictionary validation error:', pathname, error.message);\n    return false; // æ¤œè¨¼å¤±æ•—æ™‚ã¯ç„¡åŠ¹ã¨ã¿ãªã™\n  }\n}\n\n/**\n * è¾æ›¸ç”Ÿæˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆç·Šæ€¥æ™‚ï¼‰\n */\nasync function generateDictionaryFallback(pathname) {\n  console.log('ğŸš¨ Generating dictionary fallback for:', pathname);\n  \n  // æœ€å°é™ã®è¾æ›¸ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆå®Ÿéš›ã®ä½¿ç”¨ã«ã¯ä¸é©åˆ‡ã ãŒã€ã‚¨ãƒ©ãƒ¼å›é¿ç”¨ï¼‰\n  const fallbackContent = new Uint8Array([0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00]);\n  \n  return new Response(fallbackContent, {\n    status: 200,\n    statusText: 'OK (Fallback)',\n    headers: {\n      'Content-Type': 'application/gzip',\n      'Content-Length': fallbackContent.length.toString(),\n      'Cache-Control': 'no-store', // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„\n      'X-Dictionary-Fallback': 'true'\n    }\n  });\n}\n\n/**\n * è¾æ›¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®çµ±è¨ˆæƒ…å ±å–å¾—\n */\nasync function getDictionaryCacheStats() {\n  try {\n    const cache = await caches.open(CACHE_NAME);\n    const keys = await cache.keys();\n    \n    const dictionaryKeys = keys.filter(request => {\n      const url = new URL(request.url);\n      return isDictionaryResource(url.pathname);\n    });\n    \n    const stats = {\n      totalDictionaryFiles: dictionaryKeys.length,\n      files: [],\n      totalSize: 0\n    };\n    \n    for (const key of dictionaryKeys) {\n      const response = await cache.match(key);\n      if (response) {\n        const size = response.headers.get('content-length');\n        const url = new URL(key.url);\n        \n        stats.files.push({\n          path: url.pathname,\n          size: size ? parseInt(size) : 0,\n          contentType: response.headers.get('content-type')\n        });\n        \n        if (size) {\n          stats.totalSize += parseInt(size);\n        }\n      }\n    }\n    \n    return stats;\n    \n  } catch (error) {\n    console.error('âŒ Dictionary cache stats error:', error);\n    return { error: error.message };\n  }\n}\n\n/**\n * è¾æ›¸ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æ‰‹å‹•æ›´æ–°\n */\nasync function updateDictionaryCache() {\n  console.log('ğŸ”„ Updating dictionary cache...');\n  \n  try {\n    const cache = await caches.open(CACHE_NAME);\n    const dictFiles = [\n      '/dict/base.dat.gz',\n      '/dict/cc.dat.gz',\n      '/dict/check.dat.gz',\n      '/dict/tid.dat.gz',\n      '/dict/tid_map.dat.gz',\n      '/dict/tid_pos.dat.gz',\n      '/dict/unk.dat.gz',\n      '/dict/unk_char.dat.gz',\n      '/dict/unk_compat.dat.gz',\n      '/dict/unk_invoke.dat.gz',\n      '/dict/unk_map.dat.gz',\n      '/dict/unk_pos.dat.gz'\n    ];\n    \n    const updatePromises = dictFiles.map(async (dictPath) => {\n      try {\n        const request = new Request(dictPath);\n        \n        // æ—¢å­˜ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤\n        await cache.delete(request);\n        \n        // æ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—\n        const response = await fetchDictionaryWithTimeout(request);\n        \n        if (response && response.ok) {\n          await cache.put(request, response.clone());\n          console.log('âœ… Dictionary updated:', dictPath);\n          return { path: dictPath, success: true };\n        } else {\n          throw new Error('Invalid response');\n        }\n        \n      } catch (error) {\n        console.warn('âš ï¸ Dictionary update failed:', dictPath, error.message);\n        return { path: dictPath, success: false, error: error.message };\n      }\n    });\n    \n    const results = await Promise.all(updatePromises);\n    const successful = results.filter(r => r.success).length;\n    const failed = results.filter(r => !r.success).length;\n    \n    console.log(`âœ… Dictionary cache update complete: ${successful} success, ${failed} failed`);\n    return { successful, failed, details: results };\n    \n  } catch (error) {\n    console.error('âŒ Dictionary cache update error:', error);\n    return { error: error.message };\n  }\n}\n\n// Service Workerã§åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹\nif (typeof self !== 'undefined' && self.importScripts) {\n  // Service Worker context\n  self.dictionaryCacheFirst = dictionaryCacheFirst;\n  self.getDictionaryCacheStats = getDictionaryCacheStats;\n  self.updateDictionaryCache = updateDictionaryCache;\n}\n\nconsole.log('ğŸ“š DictionaryCacheStrategy loaded');