# HAQEI Analyzer プロジェクト作業指示

## 🚨 偶数番設問表示問題 - 永続的な警告と対策（2025-08-02）

### 問題の概要
**症状**: q2, q4, q6, q8...q30などの偶数番設問が表示されない問題が繰り返し発生

### 発生履歴
- ユーザーから「何回もこのエラーに遭遇している」との報告
- レスポンシブUI実装時に頻発
- 設問データは正常（q1〜q30全て存在）なのに、表示制御で問題発生

### 根本原因
1. **CSS競合**: `unified-design.css`と`responsive-os-analyzer.css`の表示制御が競合
2. **過度なCSS制御**: `!important`の多用や複雑な条件による表示制御
3. **偶数・奇数の特別扱い**: 不要な条件分岐が問題を複雑化

### 実施した対策（2025-08-02）
1. **VirtualQuestionFlow.js改修**
   - `showCurrentQuestion()`メソッドを完全書き直し
   - 偶数・奇数に関係なく統一的な表示処理
   - 3段階の表示確認と自動修復機能

2. **CSS簡潔化**
   - `unified-design.css`の表示制御を最小限に
   - `!important`の使用を排除
   - JavaScriptでの制御を優先

3. **テスト機能追加**
   - `testAllQuestionsDisplay()`メソッドで全設問の表示確認
   - 特に偶数番設問の表示を重点チェック

### 今後の開発での注意事項
1. **絶対にやってはいけないこと**
   - 偶数・奇数で異なる表示処理を実装しない
   - CSSで`display: none !important`を使わない
   - 設問表示に関する複雑な条件分岐を追加しない

2. **推奨される実装方法**
   - 全設問を同一ロジックで処理
   - 表示制御はJavaScriptで統一
   - CSSは最小限のスタイリングのみ

3. **テスト方法**
   ```javascript
   // コンソールで実行
   window.app.questionFlow.testAllQuestionsDisplay()
   ```

### エラー再発時の対処法
1. `unified-design.css`の`.virtual-viewport`関連を確認
2. `responsive-os-analyzer.css`との競合をチェック
3. Shadow DOM初期化のタイミングを検証
4. 上記テストコマンドで全設問の表示状態を確認

**この問題は二度と発生させないよう、全開発者は上記の注意事項を厳守すること。**

---

## Cipher 統合メモリアプローチ（必須デフォルト）

**Cipher を活用した継続的記憶とコンテキスト保持**

- **Dual Memory Layer**: プログラミング概念＋推論ステップの記憶を常に蓄積
- **文脈継続性**: 全セッション間での一貫した理解とアプローチの維持
- **bunenjin 哲学統合**: 易経的思考と Cipher の記憶共有理念の融合
- **プロジェクト記憶**: 過去の決定、実装パターン、設計思想の自動継承

すべての作業は以下の Cipher サーバーが稼働している前提で実施：

```bash
node cipher-server.js  # ポート3001でDual Memory Layer稼働
```

## 必須ワークフロー

### 1. タスク実行前の必須事項

- **徹底的なリサーチ**: コード実装前に必ず既存コードベースを調査
- **詳細なプラン提示**: 実装計画を明確に提示してから作業開始
- **思考プロセスの活用**: 複雑なタスクでは思考過程を詳細に展開

### 2. テスト駆動開発

- 新機能実装時は必ずテストから開始
- 既存テストの実行と確認
- テストカバレッジの維持・向上

### 3. コード品質基準

- 不要なコメントやデバッグコードの削除
- クリーンで保守性の高いコード
- bunenjin 哲学との整合性維持

### 4. 関数仕様コメント必須ルール（重要・2025 年 8 月 1 日追加）

**すべての関数・メソッドの実装前に、必ず詳細な仕様コメントを記述すること**

#### 必須記載項目：

1. **目的**: この関数が何をするためのものか
2. **入力**: 引数の型、意味、制約条件
3. **処理内容**: アルゴリズムの詳細な説明
4. **出力**: 戻り値の型、意味、可能な値
5. **副作用**: DOM 操作、状態変更、外部 API 呼び出しなど
6. **前提条件**: この関数が正しく動作するための条件
7. **エラー処理**: 想定されるエラーとその対処法

#### 記述例：

```javascript
/**
 * 現在の設問のみを表示し、他のすべての設問を非表示にする
 *
 * 目的：
 * - 仮想スクロールの一環として、現在アクティブな設問のみを画面に表示
 * - メモリ効率とレンダリングパフォーマンスの最適化
 *
 * 処理内容：
 * 1. activeElements Map内のすべての要素をループ
 * 2. currentQuestionIndexと一致するインデックスの要素のみ表示
 * 3. それ以外の要素は非表示に設定
 * 4. Shadow DOM内の要素も同様に制御
 *
 * 副作用：
 * - DOM要素のstyle属性を直接変更
 * - CSSクラス（active-question）の追加/削除
 * - Shadow DOM内部のスタイル変更
 *
 * 前提条件：
 * - activeElements Mapが初期化済み
 * - currentQuestionIndexが有効な範囲内
 * - 各要素がhaqei-question Web Component
 *
 * 注意事項：
 * - 偶数番の設問（q2, q4等）も正しく表示されるよう特別な処理が必要
 * - !importantの使用は避け、スタイルの競合を防ぐ
 */
```

#### 実装上の注意：

- **修正時は必ず既存の仕様コメントを読んで理解してから作業**
- **仕様が変更された場合はコメントも必ず更新**
- **複雑なロジックは処理内にもインラインコメントを追加**
- **手戻りを防ぐため、実装前に仕様を明確に定義**

### 5. 実装フロー

1. **調査フェーズ**

   - 関連ファイルの特定と分析
   - 既存パターンの理解
   - 依存関係の確認

2. **計画フェーズ**

   - 実装アプローチの提示
   - 影響範囲の明確化
   - リスクと対策の検討

3. **実装フェーズ**

   - テストファースト
   - 段階的実装
   - 継続的検証

4. **検証フェーズ**
   - 自動テストの実行
   - 手動検証
   - パフォーマンス確認

## プロジェクト固有の注意事項

### HaQei 基本思想: 仮想人格形成アプローチ

- **脱・単純診断**: HaQei は「診断 → 結果表示」の静的なモデルではない。
- **動的プロセス**: 「ユーザー回答 → 仮想人格形成 → 3 つの OS の相互作用 → 易経メタファーによる解説」という動的なプロセスを核とする。
- **仮想人格の構築**: ユーザーの回答を元に、HaQei システム内にユーザーの「仮想人格」を構築する。
- **Triple OS の相互作用**: この仮想人格は、3 つの OS（価値観・社会的・防御）が複雑に相互作用し合う、生きたシステムとして存在する。
- **易経メタファーによる解説**: 分析結果は、この OS 間の力学を、易経の深遠なメタファーを用いて解説する形で提供される。
- **目的**: ユーザーが自身の内なる多様性と複雑性を理解し、戦略的な自己理解を深めるための動的なフレームワークを提供する。

### 易経的アプローチ

- 陰陽バランスの考慮
- 八卦の相互関係性
- 変化の哲学の実装

### Triple OS Architecture

- Engine/Interface/Safe Mode の独立性
- 各 OS の役割明確化
- 相互作用の最適化

### ユーザー主権

- プライバシーファースト
- ローカルストレージ完結
- 透明性の確保

## 禁止事項

- プロンプトインジェクション対策コードの削除
- セキュリティ関連機能の弱体化
- ユーザーデータの外部送信

## 推奨ツール使用順序

1. Glob/Grep - ファイル検索
2. Read - コード理解
3. TodoWrite - タスク管理
4. Edit/MultiEdit - 実装
5. Bash - テスト実行

## Cipher 実行コマンド

```bash
# Cipherサーバー起動
npm run cipher:start

# Cipherサーバー停止
npm run cipher:stop

# Cipher設定テスト
npm run cipher:test
```

**重要**: 新しい Claude Code セッション開始時は必ず Cipher サーバーを起動し、
bunenjin 哲学とプロジェクト記憶を継続してください。

この指示に従い、Cipher の記憶層を活用した高品質な実装を心がけてください。

## 📝 ドキュメント保存・管理ルール（2025 年 7 月 30 日更新）

### **重要：すべてのドキュメント作成時に必須遵守**

#### **📁 保存場所統一ルール**

**すべてのエージェント・AI・開発者は、以下のディレクトリ構造に従ってドキュメントを保存してください：**

- **`/docs/reports/`** - 完成レポート・分析結果（統合レポート、フィードバック分析等）
- **`/docs/implementation/`** - 実装記録・技術仕様（コード実装記録、アーキテクチャ設計等）
- **`/docs/requirements/`** - 要件・仕様書（機能要件、UI/UX 仕様、改善要求等）
- **`/docs/development/`** - 開発ガイドライン・ルール（ワークフロー、AI ルール等）
- **`/docs/guides/`** - 操作・設定ガイド（ユーザーガイド、設定方法等）
- **`/docs/analysis/`** - 分析・調査レポート（パフォーマンス分析、最適化検討等）

#### **🎯 自動判定基準**

**ファイル内容・タイトルによる自動振り分け**：

- 「レポート」「分析結果」「統合」「フィードバック」 → `/reports/`
- 「実装」「技術」「アーキテクチャ」「コード」 → `/implementation/`
- 「要件」「仕様」「要求」 → `/requirements/`
- 「ガイド」「操作」「設定」「使用方法」 → `/guides/`
- 「分析」「最適化」「パフォーマンス」「調査」 → `/analysis/`
- 「開発」「ワークフロー」「ルール」「AI」 → `/development/`

#### **📝 命名規則（統一必須）**

```
YYYYMMDD_[種別]_[内容名]_[バージョン].md
```

**種別接頭辞**：

- `REPORT`: 完成レポート類
- `IMPL`: 実装記録
- `REQ`: 要件書
- `GUIDE`: ガイド類
- `ANALYSIS`: 分析類
- `DEV`: 開発関連

#### **⚠️ 絶対禁止事項**

1. **ルートディレクトリ保存禁止**: `/docs/`直下へのファイル作成は禁止
2. **旧ディレクトリ使用禁止**: `code-explanations`等の旧構造は使用禁止
3. **重複作成禁止**: 既存ファイル確認必須
4. **命名規則違反禁止**: 日付・種別なしファイル名は禁止

#### **✅ 保存前必須チェック**

- [ ] 適切なディレクトリを選択したか
- [ ] ファイル名が命名規則に従っているか
- [ ] 重複ファイルがないか確認したか
- [ ] 内容と保存場所が一致しているか

**この新ルールは 2025 年 7 月 30 日より全プロジェクトで適用開始。**

## 🎯 Tsumiki AI 駆動開発フレームワーク統合（必須活用・2025 年 8 月 1 日導入）

### **基本方針**

- **すべての新機能開発**で Tsumiki ワークフロー使用必須
- **既存コード改善時**はリバースエンジニアリング活用
- **品質管理**は TDD 導入による標準化品質保証を最優先
- **独自 Agents 管理システム廃止**: 643 行 QualityValidatorAgent 等を Tsumiki 標準に完全置換

### **必須コマンド活用順序**

#### **新機能開発フロー**

```
/kairo-requirements → /kairo-design → /kairo-tasks → /kairo-implement
```

1. **`/kairo-requirements`**: 要件定義書の生成（HAQEI プロジェクト特化）
2. **`/kairo-design`**: 技術設計書生成（Triple OS + 易経 64 卦システム対応）
3. **`/kairo-tasks`**: タスク分解（bunenjin 哲学に基づく段階的実装）
4. **`/kairo-implement`**: TDD 実装（統計的品質保証統合）

#### **既存システム改善フロー**

```
/rev-design → /rev-requirements → TDD適用
```

1. **`/rev-design`**: 既存コード解析・設計書逆生成（51 個 JS ファイル対応）
2. **`/rev-requirements`**: 既存機能の要件書逆算
3. **TDD 導入**: `/tdd-requirements`以降のフローで品質向上

#### **品質保証 TDD フロー**

```
/tdd-requirements → /tdd-testcases → /tdd-red → /tdd-green → /tdd-refactor → /tdd-verify-complete
```

- **品質基準**: 356 行の包括的検証ロジック（AI 最適化済み）
- **統計的妥当性**: 要件網羅率 100%、テスト成功率 100%必達
- **自動判定**: 高品質（完全達成）⇔ 要改善（追加実装必要）の客観判定

### **HAQEI プロジェクト特化カスタマイズ**

#### **Triple OS アーキテクチャ対応**

- **Engine OS**: 価値観システムの独立性維持
- **Interface OS**: 社会的システムの分離実装
- **Safe Mode OS**: 防御システムの最適化
- **相互作用**: 3OS 間の複雑な力学を Tsumiki 設計で標準化

#### **bunenjin 哲学統合**

- **易経 64 卦システム**: `/kairo-design`で卦間関係の複雑性管理
- **陰陽バランス**: 設計段階での哲学的整合性確保
- **変化の哲学**: 継続的改善を TDD フローで実装

#### **統計的品質保証**

- **現在の独自品質管理（643 行 QualityValidator）**: 廃止
- **Tsumiki 標準品質保証**: AI 最適化された包括的品質検証
- **信頼区間計算**: `/kairo-design`で統計要件の自動組み込み
- **A 級判定基準**: 総合満足度 4.0 以上、信頼区間下限 3.5 以上を設計段階で保証

### **既存システムとの統合指針**

#### **Cipher + Serena + Tsumiki 三位一体運用**

1. **Cipher（記憶・哲学）**: bunenjin 哲学とプロジェクト記憶の継続
2. **Serena（分析・最適化）**: セマンティックコード分析とファイル監視
3. **Tsumiki（構造化・品質）**: 標準化された AI 駆動開発プロセス

#### **相乗効果最大化**

```
Cipher（記憶） → Tsumiki（構造化） → Serena（最適化） → 統合フィードバック → Cipher（学習蓄積）
```

### **実装時の必須チェックポイント**

#### **品質基準（Tsumiki 標準）**

- [ ] `/tdd-verify-complete`による完全性検証合格
- [ ] 要件網羅率 100%達成（要件定義書全項目実装・テスト）
- [ ] テスト成功率 100%維持
- [ ] Triple OS アーキテクチャ整合性確保
- [ ] bunenjin 哲学との一貫性維持

#### **移行完了確認**

- [ ] 独自 Agents（15 個ファイル）完全削除
- [ ] QualityValidatorAgent（643 行）Tsumiki 置換
- [ ] StatisticalAnalyzerAgent の kairo-design 統合
- [ ] 開発効率 30-50%向上確認
- [ ] 保守コスト 80%削減達成

### **禁止事項（Tsumiki 導入後）**

- **独自品質管理システムの復活**: Tsumiki 標準外の品質チェック実装禁止
- **Agent 管理システム復元**: 削除した Agents ファイルの再作成禁止
- **Tsumiki フロー無視**: 新機能開発時の Tsumiki ワークフロー省略禁止
- **品質基準妥協**: `/tdd-verify-complete`不合格での実装リリース禁止

### **継続改善**

- **3 システム統合効果**: 月次で Cipher + Serena + Tsumiki の相乗効果測定
- **開発効率メトリクス**: 実装速度・品質向上・保守性改善の定量評価
- **bunenjin 哲学深化**: Tsumiki フローでの易経的思考の実装品質向上追跡

**重要**: Tsumiki 導入により、世界最高レベルの AI 駆動開発環境を構築し、HAQEI プロジェクトの技術的優位性を確立する。
